/**
  ******************************************************************************
  * @file    Libraries/Device/Phoenix/source/tx_phe_system.c
  * @author  HUGE-IC Application Team
  * @version V1.0.2
  * @date    04-08-2019
  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
  *          This file contains the system clock configuration for Phoenix devices,
  *          and is generated by the clock configuration tool.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
  *
  *
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "include.h"

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
volatile u32 SysTickCnt;
static volatile uint32_t sys_ie_enable_counter = 0;
static volatile bool sys_critical_ie_disabled = false;
static volatile uint32_t sys_param_address = (LL_EF_SECTOR_NUMBERS-APP_PARAM_SECTORS-1)*LL_EF_SECTOR_SIZE;

__IO uint32_t SYS_CLK = SYS_CLK_VAL;

#ifdef EFLASH2SRAM
    u8 sram_vector_table[0x180] __attribute__((section("SRAM_VECTOR_TAB")));
#endif

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/** @addtogroup CMSIS
  * @{
  */

/** @addtogroup Phoenix_system
  * @{
  */

/** @defgroup Phoenix_System_Private_Functions
  * @{
  */

/**
  * @brief  system_critical_section_enter function
  * @retval None
  */
void system_critical_section_enter(void)
{
    bool interrupts_disabled = (bool)__get_PRIMASK();

    __disable_irq();

    if(!sys_ie_enable_counter) {
        sys_critical_ie_disabled = interrupts_disabled;
    }

    sys_ie_enable_counter++;
}

/**
  * @brief  system_critical_section_exit function
  * @retval None
  */
void system_critical_section_exit(void)
{
    if(sys_ie_enable_counter) {
        sys_ie_enable_counter--;
        if( !sys_ie_enable_counter && !sys_critical_ie_disabled) {
            __enable_irq();
        }
    }
}


/**
  * @brief  Use the CPU precision delay function
  * @param  n :
  * @retval None
  * @note   for M0    : period_count = 8+4n
  *         for M3/M4 : period_count = 8+3n
  */
#if defined(__CC_ARM)                /* KEIL Compiler */
__attribute__((noinline)) static __asm void __delay_asm(u32 n)
{
L1
    SUBS R0, R0, #1;
    BCS L1;
    BX LR;
}
#elif defined(__GNUC__)              /* GCC Compiler */
#elif defined (__ICCARM__)           /* IAR Compiler */
__attribute__((noinline)) static void __delay_asm(u32 n)
{
    asm(
        "L1:                \n"
        "   SUBS R0, R0, #1 \n"
        "   BCS L1          \n"
        "   BX LR             "
        );
}
#endif

/**
  * @brief  Use the CPU to delay approximately us
  * @param  n : the number of us to delay
  * @retval None
  * @note   only work for SYS_CLK
  */
void delay_us(u32 n)
{
    u64 sys_clk = ll_cc_sys_clk_get();
    
    if(n) {
        __delay_asm((sys_clk * n / 1000000) / 3);
    }
}

/**
  * @brief  Use the CPU to delay approximately ms
  * @param  n : the number of ms to delay
  * @retval None
  */
void delay_ms(u32 n)
{
    u64 sys_clk = ll_cc_sys_clk_get();

    if(n) {
        __delay_asm((sys_clk * n / 1000) / 3);
    }
}

/**
  * @brief  EFLASH initialization function
  * @param  None
  * @retval None
  */
void sys_eflash_init(void)
{
    /*  initialization structure variable           */
    TYPE_LL_EFLASH_INIT init;
    memset(&init, 0x0, sizeof(TYPE_LL_EFLASH_INIT));

    /* The initialization function is mainly to reset the module. */
    ll_eflash_init(EFLASH, &init);
}

/**
  * @brief  EFLASH Configuration function
  * @param  None
  * @retval None
  */
void sys_eflash_config(void)
{
    TYPE_LL_EFLASH_CFG eflash_cfg;

    /* Initialize the relevant variables  */
    memset(&eflash_cfg, 0x0, sizeof(eflash_cfg));

    eflash_cfg.cache_en             = false;
    eflash_cfg.pgclk_src_sel        = LL_EF_PG_CLK_HXOSC;
    eflash_cfg.clk                  = SYS_CLK;
    eflash_cfg.cmd_cache_en         = false;
    eflash_cfg.prefetch_en          = false;
    eflash_cfg.data_endian_lit_en   = true;
    eflash_cfg.read_directly_en     = false;

    ll_eflash_config(EFLASH, &eflash_cfg);
}


/**
  * @brief  The initialization of the module is performed when the system is initialized.
  * @param  None
  * @retval None
  */
void sys_module_init(void)
{
#if !GPIOB_INIT_LOCK
    SYSCTRL_REG_OPT(
        /* GPIOB0 ~ GPIOB11 are the common outputs of the modules SPWM, SVPWM, ADTIMER and EPWM,
         * so they need to be set to the input high-impedance state during initialization
         * and set the system key to GPIO KEY.
         */
        GPIOB->DIR &= ~0xFFF;
        SYSCTRL->PWM_KEY = GPIO_KEY_C | GPIO_KEY_B | GPIO_KEY_A;
    );
#endif
}

/**
  * @brief  The initialization of the cpu is performed when the system is initialized.
  * @param  None
  * @retval None
  */
void sys_cpu_init(void)
{
    /* clear all irq pending 
    for(u32 i=0; i<=AVDTMR1_CC_IRQn; i++) {
        NVIC_ClearPendingIRQ((IRQn_Type)i);
    }
    */
    
    /* reset all peripheral */
    SYSCTRL_REG_OPT(
        SYSCTRL->SYS_CON1 = 0x0;
        SYSCTRL->SYS_CON2 = 0xFF;
        for(__IO int icnt = 1000; icnt > 0; icnt--);
        SYSCTRL->SYS_CON1 = 0x1F;
        SYSCTRL->SYS_CON2 = 0xFFFFFFFF;
    );

}

/**
  * @brief  The initialization of the peripheral is performed when the system is initialized.
  * @param  None
  * @retval None
  */
void sys_peripheral_init(void)
{
    sys_eflash_init();

    sys_eflash_config();
}


/**
  * @brief  Setup the microcontroller system
  *         Initialize the Embedded Flash Interface, the PLL and update the
  *         SYS_CLK variable.
  * @retval None
  * @note   This function should be used only after reset.
  */
void system_init(void)
{
    sys_peripheral_init();
    
    sys_cpu_init();

#if FPGA_EN
    SYS_CLK = SYS_CLK_VAL;
#else
    TYPE_LL_CC_DIV_CFG cfg;

    /* set SYSPLL */
    ll_cc_syspll_set(SYS_CLK_MAX, LL_CC_RST_PLLCLK_SRC_HXOSC);
    /* set SYSCLK source */
    ll_cc_sysclk_select(LL_CC_RST_SYSCLK_SRC_SYSPLL_DIV);
    /* set ADCPLL */
    ll_cc_adcpll_set(__EPWM_FADC_ADPLL_MAX, LL_CC_RST_PLLCLK_SRC_HXOSC);
    
    /* APB0 = APB1 = SYS_CLK */
    cfg.sys_clk_div  = 0;
    cfg.apb0_clk_div = 0;
    cfg.apb1_clk_div = 0;
    ll_cc_clk_div_config(&cfg);
#endif

    sys_peripheral_init();

    /* The initialization of the module is performed when the system is initialized. */
    sys_module_init();

    /* recover vip param from last fault state */
    recover_fault_state();

    /* Configure the system interrupt vector table address. */
#ifdef EFLASH2SRAM
    memcpy((void*)sram_vector_table, (void*)__vector_handlers, sizeof(sram_vector_table));
    SCB->VTOR = (u32)sram_vector_table;
#else
    SCB->VTOR = (u32)__vector_handlers;
#endif
}

/**
  * @brief  is_systick_expired.
  * @param  offset_ticks: current sys tick
  * @param  Texpire: offset ticks
  * @retval return true or fault
  */
u32 is_systick_expired(s32 offset_ticks, s32 Texpire)
{
    return ((u32)(SysTickCnt+(u32)(0x100000000-offset_ticks)) >= Texpire);
}

/**
  * @brief  get_system_tick.
  * @retval return the count of current systick
  */
u32 get_system_tick(void)
{
    return SysTickCnt;
}

/**
  * @brief  system_tick_init.
  * @retval return true or fault
  */
u32 system_tick_init(void)
{
    ///1ms tick init
    SysTickCnt = 0;
    SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
    if(SysTick_Config(SYS_CLK/1000)) {
        return 0;
    }
    return 1;
}

/**
  * @brief  sys_update_firmware_handle
  * @param  cmd    : FIRMWARE_UPDATE_CMD
  * @param  addr   : address , base 0.
  * @param  len    : length in unit 4Byte
  * @param  p_data : data buffer
  * @retval 1(success), 0(failed)
  */
bool sys_update_firmware_handle(FIRMWARE_UPDATE_CMD cmd, u32 *p_data, u32 addr, u32 len)
{
    static u32 firmware_update_addr = APP_CODE_SIZE;
    static u32 firmware_update_sectors = APP_CODE_SIZE/LL_EF_SECTOR_SIZE;
    u16 *p_data_sector_id = (u16 *)p_data;
    bool ret_val = true;
    u32 temp;
    
    switch (cmd) {
        case FIRMWARE_UPDATE_CMD_ERASE_APP:
            temp = firmware_update_sectors;
            for(u32 i=firmware_update_sectors; i; i--) {
                ll_eflash_erase_sector(EFLASH, temp++);
            }
            break;
        case FIRMWARE_UPDATE_CMD_ERASE_SECTORS:
            for(u32 i=len; i; i--) {
                temp = *p_data_sector_id++;
                if(temp <= firmware_update_sectors) {
                    ll_eflash_erase_sector(EFLASH, temp+firmware_update_sectors);
                } else {
                    ret_val = false;
                    break;
                }
            }
            break;
        case FIRMWARE_UPDATE_CMD_PROGRAM:
            if((addr + len*4) > APP_CODE_SIZE) {
                ret_val = false;
            } else {
                temp = firmware_update_addr + addr;
                for(u32 i=len; i; i--) {
                    ll_eflash_prog_word(EFLASH, temp, *p_data++);
                    temp += 4;
                }
            }
            break;
        case FIRMWARE_UPDATE_CMD_VERIFY:
            if((addr + len*4) > APP_CODE_SIZE) {
                ret_val =  false;
            } else {
                temp = firmware_update_addr + addr;
                for(u32 i=len; i; i--) {
                    if(LL_EFLASH_DATA(temp) != *p_data++) {
                        ret_val = false;
                        break;
                    }
                    temp += 4;
                }
            } 
            break;
        case FIRMWARE_UPDATE_CMD_REGISTER:
            ll_eflash_prog_word(EFLASH, APP_CODE_SIZE-4, 0);
            break;
        case FIRMWARE_UPDATE_CMD_REBOOT:
            __NVIC_SystemReset();
            break;
        default:
            break;
    }

    return ret_val;
}

/**
  * @brief  save vip param to eflash
  * @param  p_data: param buffer
  * @param  len   : length in unit 4Byte
  * @retval 1(success), 0(failed)
  * @note : User can save vip param at here, restore vip param at next power-up or reset
  */
bool sys_save_data_to_eflash(u32 *p_data, u32 len)
{
    u32 max_search = APP_PARAM_SECTORS*LL_EF_SECTOR_SIZE/4/len;
    u32 param_sector_size = (len * 4 + LL_EF_SECTOR_SIZE-1)/ LL_EF_SECTOR_SIZE;
    u32 param_addr_last = sys_param_address;
    
    if(!max_search) {
        return false;
    }

save_start:
    
    max_search--;
    
    u32 new_sector_index = (sys_param_address + (len)*4 + 4)/LL_EF_SECTOR_SIZE;
    u32 cur_sector_index = (sys_param_address)/LL_EF_SECTOR_SIZE;
    
    if((new_sector_index+param_sector_size) >= (LL_EF_SECTOR_NUMBERS-1)) {
        new_sector_index = LL_EF_SECTOR_NUMBERS-1-APP_PARAM_SECTORS;
        sys_param_address = new_sector_index * LL_EF_SECTOR_SIZE;
    }
    if(cur_sector_index != new_sector_index) {
        for(u32 loop=param_sector_size; loop; loop--) {
            ll_eflash_erase_sector(EFLASH, new_sector_index++);
            ll_eflash_wait_busy(EFLASH);
        }
    }

    /* save param */
    u32 eflash_checksum = 0;
    u32 eflash_prog_data;
    u32 eflash_prog_addr = sys_param_address;
    u32 *p_data_temp = p_data;
    for(u32 loop=len; loop; loop--) {
        eflash_prog_data = *p_data_temp++;
        ll_eflash_prog_word(EFLASH, eflash_prog_addr, eflash_prog_data);
        eflash_prog_addr += 4;
        eflash_checksum += eflash_prog_data;
    }
    
    ll_eflash_prog_word(EFLASH, eflash_prog_addr, eflash_checksum);
    ll_eflash_wait_busy(EFLASH);
    eflash_prog_addr += 4;

    /* verify param */
    eflash_checksum = 0;
    eflash_prog_addr = sys_param_address;
    for(u32 loop=len; loop; loop--) {
        eflash_checksum += LL_EFLASH_DATA(eflash_prog_addr);
        eflash_prog_addr += 4;
    }

    sys_param_address += (len+1) * 4;

    if(eflash_checksum != LL_EFLASH_DATA(eflash_prog_addr)) {
        if(max_search) {
            goto save_start;
        }
    }

    /* give up last param */
    ll_eflash_prog_word(EFLASH, param_addr_last-4, 0x0);
    ll_eflash_prog_word(EFLASH, param_addr_last-8, 0x0);
    ll_eflash_wait_busy(EFLASH);
    return true;
}

/**
  * @brief  recover vip param from eflash
  * @param  p_data: param buffer
  * @param  len   : length in unit 4Byte
  * @retval 1(success), 0(failed)
  * @note : if the last param is wrong, we will found the latest ok-param instead
  */
bool sys_recover_data_from_eflash(u32 *p_data, u32 len)
{
    u32 eflash_prog_data;
    u32 eflash_prog_addr;
    u32 eflash_checksum;
    u32 eflash_checkblank_value;
    bool is_param_ok = false;
    u32 param_ok_addr;
    u32 max_search=APP_PARAM_SECTORS*LL_EF_SECTOR_SIZE/4/len;

    sys_param_address = (LL_EF_SECTOR_NUMBERS-APP_PARAM_SECTORS-1)*LL_EF_SECTOR_SIZE;
    
    /* check param location */
    for(; max_search; max_search--) {
        eflash_checksum = 0;
        eflash_checkblank_value = 0xFFFFFFFF;
        eflash_prog_addr = sys_param_address;
        for(u32 loop=len; loop; loop--) {
            eflash_prog_data = LL_EFLASH_DATA(eflash_prog_addr);
            eflash_checksum += eflash_prog_data;
            eflash_checkblank_value &= eflash_prog_data;
            eflash_prog_addr += 4;
        }
        
        if(eflash_checksum == LL_EFLASH_DATA(eflash_prog_addr)) {
            is_param_ok = true;
            param_ok_addr = sys_param_address;
        } 

        if(0xFFFFFFFF == eflash_checkblank_value) {
            break;
        } else {
            sys_param_address = eflash_prog_addr + 4;
        }
    }
    
    if(0 == max_search) {
        sys_param_address = (LL_EF_SECTOR_NUMBERS-APP_PARAM_SECTORS-1)*LL_EF_SECTOR_SIZE;
    }

    /* fill param buffer */
    if(is_param_ok) {
        /* addr adjust */
        if(sys_param_address <= param_ok_addr){
            sys_param_address = param_ok_addr + len*4 + 4;
        }
        for(u32 loop=len; loop; loop--) {
            *p_data++ = LL_EFLASH_DATA(param_ok_addr);
            param_ok_addr += 4;
        }
    }

    return is_param_ok;
}

/**
  * @brief  save vip param , User can override this function
  * @retval None
  * @note : User can save vip param at here, restore vip param at next power-up or reset
  */
__WEAK void sys_fault_save_context(void)
{
    /* add code here to save vip param to eflash/spi_flash/eeprom...ect */

#if 0    
    /* eflash param save */
    if(!sys_save_data_to_eflash(test_param, TEST_PARAM_LEN_4BYTE)) {
        printf("param save failed\r\n");
    } else {
        printf("param save ok\r\n");
    }
#endif
}

/**
  * @brief  recover vip param, User can override this function
  * @retval None
  * @note : restore vip param at next power-up or reset
  */
__WEAK void sys_fault_recover_context(void)
{
    /* add code here to read & verify vip param from eflash/spi_flash/eeprom...ect */
#if 0
    /* eflash param recover */
    if(!sys_recover_data_to_eflash(test_param, TEST_PARAM_LEN_4BYTE)) {
        printf("param recover failed\r\n");
    } else {
        printf("param recover ok\r\n");
    }
#endif
}

/**
  * @brief  recover_fault_state : recover vip param
  * @retval None
  * @note : restore vip param at next power-up or reset
  */
void recover_fault_state(void)
{
    sys_fault_recover_context();
}

/**
  * @brief  dump_fault_state : save vip param & printf cpu fault state
  * @retval None
  * @note : User can save vip param at here, restore vip param at next power-up or reset
  */
void dump_fault_state(void)
{
    sys_fault_save_context();

    /* dump cpu fault state */
#if DEBUG_LEVEL
#define SCB_SHPR_PRIORITY_Msk 0xF0
#define SCB_SHPR_PRIORITY_Pos 4

#define SCB_UFSR_DIVBYZERO_Pos 9
#define SCB_UFSR_DIVBYZERO_Msk (1UL << SCB_UFSR_DIVBYZERO_Pos)
#define SCB_UFSR_UNALIGNED_Pos 8
#define SCB_UFSR_UNALIGNED_Msk (1UL << SCB_UFSR_UNALIGNED_Pos)
#define SCB_UFSR_NOCP_Pos 3
#define SCB_UFSR_NOCP_Msk (1UL << SCB_UFSR_NOCP_Pos)
#define SCB_UFSR_INVPC_Pos 2
#define SCB_UFSR_INVPC_Msk (1UL << SCB_UFSR_INVPC_Pos)
#define SCB_UFSR_INVSTATE_Pos 1
#define SCB_UFSR_INVSTATE_Msk (1UL << SCB_UFSR_INVSTATE_Pos)
#define SCB_UFSR_UNDEFINSTR_Pos 0
#define SCB_UFSR_UNDEFINSTR_Msk (1UL << SCB_UFSR_UNDEFINSTR_Pos)

    uint32_t icsr  = SCB->ICSR;
    uint32_t shcsr = SCB->SHCSR;
    uint16_t ufsr  = (SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) >> SCB_CFSR_USGFAULTSR_Pos;

    printf("^_^''\r\n");
    printf("ICSR:\r\n");
    printf("\t there %s interrupt pending\r\n", (icsr & SCB_ICSR_ISRPENDING_Msk) ? "is" : "isn't");
    printf("\t pending exception number:%u\r\n", (icsr & SCB_ICSR_VECTPENDING_Msk) >> SCB_ICSR_VECTPENDING_Pos);
    printf("\t active exception number:%u\r\n", (icsr & SCB_ICSR_VECTACTIVE_Msk) >> SCB_ICSR_VECTACTIVE_Pos);

    printf("SHPRx:\r\n");
    printf("\t Mem Manage:%hhd\r\n", (SCB->SHP[0] & SCB_SHPR_PRIORITY_Msk) >> SCB_SHPR_PRIORITY_Pos);
    printf("\t Bus Fault:%hhd\r\n", (SCB->SHP[1] & SCB_SHPR_PRIORITY_Msk) >> SCB_SHPR_PRIORITY_Pos);
    printf("\t Usage Fault:%hhd\r\n", (SCB->SHP[2] & SCB_SHPR_PRIORITY_Msk) >> SCB_SHPR_PRIORITY_Pos);
    printf("\t SVC:%hhd\r\n", (SCB->SHP[7] & SCB_SHPR_PRIORITY_Msk) >> SCB_SHPR_PRIORITY_Pos);
    printf("\t Debug Monitor:%hhd\r\n", (SCB->SHP[8] & SCB_SHPR_PRIORITY_Msk) >> SCB_SHPR_PRIORITY_Pos);
    printf("\t PendSV:%hhd\r\n", (SCB->SHP[10] & SCB_SHPR_PRIORITY_Msk) >> SCB_SHPR_PRIORITY_Pos);
    printf("\t SysTick:%hhd\r\n", (SCB->SHP[11] & SCB_SHPR_PRIORITY_Msk) >> SCB_SHPR_PRIORITY_Pos);

    printf("SHCSR:\r\n");
    printf("\t Usage Fault enable:%u\r\n", (shcsr & SCB_SHCSR_USGFAULTENA_Msk) >> SCB_SHCSR_USGFAULTENA_Pos);
    printf("\t Bus Fault enable:%u\r\n", (shcsr & SCB_SHCSR_BUSFAULTENA_Msk) >> SCB_SHCSR_BUSFAULTENA_Pos);
    printf("\t Mem Fault enable:%u\r\n", (shcsr & SCB_SHCSR_MEMFAULTENA_Msk) >> SCB_SHCSR_MEMFAULTENA_Pos);
    printf("\r\n");
    printf("\t SVCall pended:%u\r\n", (shcsr & SCB_SHCSR_SVCALLPENDED_Msk) >> SCB_SHCSR_SVCALLPENDED_Pos);
    printf("\t Bus Fault pended:%u\r\n", (shcsr & SCB_SHCSR_BUSFAULTPENDED_Msk) >> SCB_SHCSR_BUSFAULTPENDED_Pos);
    printf("\t Mem Fault pended:%u\r\n", (shcsr & SCB_SHCSR_MEMFAULTPENDED_Msk) >> SCB_SHCSR_MEMFAULTPENDED_Pos);
    printf("\t Usage Fault pended:%u\r\n", (shcsr & SCB_SHCSR_USGFAULTPENDED_Msk) >> SCB_SHCSR_USGFAULTPENDED_Pos);
    printf("\r\n");
    printf("\t SysTick active:%u\r\n", (shcsr & SCB_SHCSR_SYSTICKACT_Msk) >> SCB_SHCSR_SYSTICKACT_Pos);
    printf("\t PendSV active:%u\r\n", (shcsr & SCB_SHCSR_PENDSVACT_Msk) >> SCB_SHCSR_PENDSVACT_Pos);
    printf("\t Monitor active:%u\r\n", (shcsr & SCB_SHCSR_MONITORACT_Msk) >> SCB_SHCSR_MONITORACT_Pos);
    printf("\t SVCall active:%u\r\n", (shcsr & SCB_SHCSR_SVCALLACT_Msk) >> SCB_SHCSR_SVCALLACT_Pos);
    printf("\t Usage Fault active:%u\r\n", (shcsr & SCB_SHCSR_USGFAULTACT_Msk) >> SCB_SHCSR_USGFAULTACT_Pos);
    printf("\t Bus Fault active:%u\r\n", (shcsr & SCB_SHCSR_BUSFAULTACT_Msk) >> SCB_SHCSR_BUSFAULTACT_Pos);
    printf("\t Mem Fault active:%u\r\n", (shcsr & SCB_SHCSR_MEMFAULTACT_Msk) >> SCB_SHCSR_MEMFAULTACT_Pos);

    printf("UFSR:\r\n");
    printf("\t Divide by zero: %d\r\n", (ufsr & SCB_UFSR_DIVBYZERO_Msk) >> SCB_UFSR_DIVBYZERO_Pos);
    printf("\t Unaligned access: %d\r\n", (ufsr & SCB_UFSR_UNALIGNED_Msk) >> SCB_UFSR_UNALIGNED_Pos);
    printf("\t No coprocessor: %d\r\n", (ufsr & SCB_UFSR_NOCP_Msk) >> SCB_UFSR_NOCP_Pos);
    printf("\t Invaild PC load: %d\r\n", (ufsr & SCB_UFSR_INVPC_Msk) >> SCB_UFSR_INVPC_Pos);
    printf("\t Invaild state(attempt to entry ARM state): %d\r\n", (ufsr & SCB_UFSR_INVSTATE_Msk) >> SCB_UFSR_INVSTATE_Pos);
    printf("\t Undefined instruction: %d\r\n", (ufsr & SCB_UFSR_UNDEFINSTR_Msk) >> SCB_UFSR_UNDEFINSTR_Pos);
    
    __asm("bkpt 0x00");
#endif
}

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
