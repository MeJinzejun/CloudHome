/**
  ******************************************************************************
  * @file    Libraries/Device/Phoenix/source/tx_phe_assert.c
  * @author  HUGE-IC Application Team
  * @version V1.0.0
  * @date    01-08-2018
  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
  *          This file contains the system clock configuration for Phoenix devices,
  *          and is generated by the clock configuration tool.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
  *
  *
  *
  ******************************************************************************
  */ 
  
/* Includes ------------------------------------------------------------------*/
#include "include.h"

#if USE_ASSERT

/* Private typedef -----------------------------------------------------------*/
/**
  * @brief The SRAM number, the SRAM start address, and the SRAM end address structure are asserted.
  */
typedef struct __assert_addr {
    TYPE_ENUM_ASSERT_SRAM addr_sram;
    u32                   start_addr;
    u32                   end_addr;
} TYPE_ADDERT_ADDR;

/* Private define ------------------------------------------------------------*/
/* Asserts the maximum threshold supported by the SRAM. */
#define SRAM_MAX_THRESHOLD              19

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/

/**
  * @brief Assert SRAM number, SRAM start address, SRAM end address constant table.
  */
static const TYPE_ADDERT_ADDR sram_addr_const[SRAM_MAX_THRESHOLD] = {
    {ASSERT_EFLASH,   SRAM_EFLASH_START_ADDR, SRAM_EFLASH_END_ADDR},
    {ASSERT_SRAM0,    SRAM0_START_ADDR,       SRAM0_END_ADDR},
    {ASSERT_SRAM10,   SRAM10_START_ADDR,      SRAM10_END_ADDR},
    {ASSERT_SRAM1,    SRAM1_START_ADDR,       SRAM1_END_ADDR},
    {ASSERT_SRAM2,    SRAM2_START_ADDR,       SRAM2_END_ADDR},
    {ASSERT_SRAM3,    SRAM3_START_ADDR,       SRAM3_END_ADDR},
    {ASSERT_SRAM4,    SRAM4_START_ADDR,       SRAM4_END_ADDR},
    {ASSERT_SRAM5,    SRAM5_START_ADDR,       SRAM5_END_ADDR},
    {ASSERT_SRAM6,    SRAM6_START_ADDR,       SRAM6_END_ADDR},
    {ASSERT_SRAM7,    SRAM7_START_ADDR,       SRAM7_END_ADDR},
    {ASSERT_SRAM8,    SRAM8_START_ADDR,       SRAM8_END_ADDR},
    {ASSERT_SRAM9,    SRAM9_START_ADDR,       SRAM9_END_ADDR},
    {ASSERT_SRAM11,   SRAM11_START_ADDR,      SRAM11_END_ADDR},
    {ASSERT_SRAM12,   SRAM12_START_ADDR,      SRAM12_END_ADDR},
    {ASSERT_SRAM13,   SRAM13_START_ADDR,      SRAM13_END_ADDR},
    {ASSERT_SRAM14,   SRAM14_START_ADDR,      SRAM14_END_ADDR},
    {ASSERT_SRAM15,   SRAM15_START_ADDR,      SRAM15_END_ADDR},
    {ASSERT_SRAM16,   SRAM16_START_ADDR,      SRAM16_END_ADDR},
    {ASSERT_SRAMEND,  SRAMEND_START_ADDR,     SRAMEND_END_ADDR},
};

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/** @addtogroup CMSIS
  * @{
  */
  
/** @addtogroup TX_ASSERT
  * @{
  */

/** @defgroup TX_ASSERT_Private_Functions 
  * @{
  */ 
  
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  p_file: pointer to the source file name
  * @param  line  : assert_param error line source number
  * @retval None
  */
__weak void tx_assert_false(u8 *p_file, u32 line)
{ 
    DBG_NOR("Wrong parameters value: file %s on line %d\r\n", p_file, line);
    while(1);
}

/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  start_adr   : The starting address of the parameter.
  * @param  len         : The length of the buffer, the minimum unit is calculated as 1 byte.
  * @param  sram_mask   : The SRAM threshold supported by the module.
  * @param  align_mask  : Threshold value for buffer address alignment.
  * @param  p_file      : pointer to the source file name
  * @param  line        : assert_param error line source number
  * @retval None
  */
__weak void tx_assert_address(u32  start_adr, 
                              u32  len, 
                              u32  sram_mask, 
                              u32  align_mask,
                              u8  *p_file, 
                              u32  line)
{
    u8  sta = 0;
    u8  end = 0;
    u8  temp = 0;
    u32 adr_sram = 0;
    u32 end_adr = 0;
    
    /* Detect the length value of the buffer. */
    if(len == 0) {
        DBG_NOR("Buffer len cannot be 0: file %s on line %d\r\n", p_file, line);
        return;
    }
    
    /* The end address of the buffer is calculated, but there is a 1byte difference between SRAM. */
    end_adr = start_adr + len - 1;
    
    /* Detect the alignment of the buffer address. */
    if(start_adr & align_mask) {
        DBG_NOR("The buffer address is aligned by %d byte.: file %s on line %d\r\n", 
                (align_mask + 1), p_file, line);
    }
    
    /* The detection input address is within the legal range of the SRAM. */
    if((start_adr < sram_addr_const[0].start_addr) || 
       (end_adr > sram_addr_const[SRAM_MAX_THRESHOLD - 2].end_addr)) {
        /* If the entered address exceeds the legal address of the SRAM, 
           check to see if it will exceed the legal address of EFLAH.     */
        if((start_adr < sram_addr_const[SRAM_MAX_THRESHOLD - 1].start_addr) || 
           (end_adr > sram_addr_const[SRAM_MAX_THRESHOLD - 1].end_addr)) {
                DBG_NOR("Invalid address: file %s on line %d\r\n", p_file, line);
                return;
           }
    }
    
    /* Polling finds the starting SRAM of the input address. */
    for(sta=0; sta<SRAM_MAX_THRESHOLD; sta++) {
        if(start_adr < sram_addr_const[sta].start_addr) {
            sta--;
            break;    
        }
    }

    /* Polling finds the end SRAM of the input address. */
    for(end = sta; end<SRAM_MAX_THRESHOLD; end++) {
        if(end_adr <= sram_addr_const[end].end_addr) {
            break;
        }
    }
    
    /* Assign a value to the SRAM where the input address is located. */
    for(temp=sta; temp<=end; temp++) {
        adr_sram |= sram_addr_const[temp].addr_sram;
    }
    
    /* Compares the SRAM where the input address is located to the legal SRAM address of the module. */
    if(adr_sram != (adr_sram & sram_mask)) {
        DBG_NOR("The SRAM address has no access: file %s on line %d\r\n", p_file, line);
    }
}

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */
  
#endif

/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
