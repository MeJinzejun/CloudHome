L 1 "..\..\..\..\User\Hardware\hw_lcd.c"
N#include "include.h"
L 1 "..\..\..\..\User\LL\include.h" 1
N/**
N  ******************************************************************************
N  * @file    User/LL/include.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   A generic header file containing various required header files
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __INCLUDE_H__
N#define __INCLUDE_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "config.h"
L 1 "..\..\..\..\User\LL\config.h" 1
N/**
N  ******************************************************************************
N  * @file    User/LL/config.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    14-11-2018
N  * @brief   project macro configuration.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CONFIG_H
N#define __CONFIG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/*******************************************************************************
N *                              Chip Configuration                             *
N *******************************************************************************/
N/*! define sdk target chip.
N */
N#define TXF6200
N//#define TXF5200
N
N/*! FPGA_EN 
N *  1 : FPGA plateform
N *  0 : chip plateform
N */
N#ifndef FPGA_EN
N#define FPGA_EN                                     0
N#endif
N
N/**
N  * @brief Adjust the value of External oscillator (HXOSC) used in your application.
N  *        This value is used by the CC_RST module to compute the system frequency
N  *        (when HXOSC is used as system clock source, directly or through the FPLL).  
N  */
N#if !defined  (HXOSC_CLK)
X#if !0L
N    #define HXOSC_CLK                               26000000UL  /*!< HXOSC Clock of the External oscillator in Hz */
N#endif /* HXOSC_CLK */
N
N/**
N  * @brief Internal High Speed oscillator (RC8M) value.
N  *        This value is used by the CC_RST module to compute the system frequency
N  *        (when RC8M is used as system clock source, directly or through the PLL). 
N  */
N#if !defined  (RC8M_CLK)
X#if !0L
N    #define RC8M_CLK                                8000000UL  /*!< RC8M Clock of the Internal oscillator in Hz */
N#endif /* RC8M_CLK */
N
N/**
N  * @brief Internal Low Speed oscillator (RC32K) value.
N  *        The real value may vary depending on the variations in voltage and temperature.
N  */
N#if !defined  (RC32K_CLK) 
X#if !0L 
N    #define RC32K_CLK                               32000U    /*!< RC32K Typical Value in Hz */
N#endif /* RC32K_CLK */
N
N#if FPGA_EN
X#if 0
S    #define SYS_CLK_VAL                             50000000UL
N#else
N    #define SYS_CLK_VAL                             82000000UL
N#endif
N
N/*! The ADC PLL of EPWM and FADC in the system clock is a common clock. Their clock 
N *  multiplier ratio is the same. If you want to set the EPWM clock to pll=180M, 
N *  the value is generally set to pll*2=360, 360 is also the default value.
N */
N#ifndef __EPWM_FADC_ADPLL_VAL
N#define __EPWM_FADC_ADPLL_VAL                       360000000UL
N#endif /* __EPWM_FADC_ADPLL_VAL */
N
N/*******************************************************************************
N *                            Function Configuration                           *
N *******************************************************************************/
N
N/*! Whether the GPIOB is used as a PWM pin during system initialization.
N */
N#define GPIOB_INIT_LOCK                             0
N
N
N
N/*******************************************************************************
N *                           Free-Modbus Configuration                         *
N *******************************************************************************/
N 
N/*! \brief Maximum number of Modbus functions codes the protocol stack
N *    should support.
N *
N * The maximum number of supported Modbus functions must be greater than
N * the sum of all enabled functions in this file and custom function
N * handlers. If set to small adding more functions will fail.
N */
N#define MB_FUNC_HANDLERS_MAX                        16
N
N/*! \brief Number of bytes which should be allocated for the <em>Report Slave ID
N *    </em>command.
N *
N * This number limits the maximum size of the additional segment in the
N * report slave id function. See eMBSetSlaveID(  ) for more information on
N * how to set this value. It is only used if MB_FUNC_OTHER_REP_SLAVEID_ENABLED
N * is set to <code>1</code>.
N */
N#define MB_FUNC_OTHER_REP_SLAVEID_BUF               32
N
N/*! \brief If the <em>Report Slave ID</em> function should be enabled. */
N#define MB_FUNC_OTHER_REP_SLAVEID_ENABLED           1
N
N/*! \brief If the <em>Read Input Registers</em> function should be enabled. */
N#define MB_FUNC_READ_INPUT_ENABLED                  0
N
N/*! \brief If the <em>Read Holding Registers</em> function should be enabled. */
N#define MB_FUNC_READ_HOLDING_ENABLED                0
N
N/*! \brief If the <em>Write Single Register</em> function should be enabled. */
N#define MB_FUNC_WRITE_HOLDING_ENABLED               0
N
N/*! \brief If the <em>Write Multiple registers</em> function should be enabled. */
N#define MB_FUNC_WRITE_MULTIPLE_HOLDING_ENABLED      0
N
N/*! \brief If the <em>Read Coils</em> function should be enabled. */
N#define MB_FUNC_READ_COILS_ENABLED                  0
N
N/*! \brief If the <em>Write Coils</em> function should be enabled. */
N#define MB_FUNC_WRITE_COIL_ENABLED                  0
N
N/*! \brief If the <em>Write Multiple Coils</em> function should be enabled. */
N#define MB_FUNC_WRITE_MULTIPLE_COILS_ENABLED        0
N
N/*! \brief If the <em>Read Discrete Inputs</em> function should be enabled. */
N#define MB_FUNC_READ_DISCRETE_INPUTS_ENABLED        0
N
N/*! \brief If the <em>Read/Write Multiple Registers</em> function should be enabled. */
N#define MB_FUNC_READWRITE_HOLDING_ENABLED           0
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CONFIG_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 28 "..\..\..\..\User\LL\include.h" 2
N#include "tx_phe.h"
L 1 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Device/Phoenix/include/tx_phe.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.1
N  * @date    03-26-2018
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File.
N  *          This file contains all the peripheral register's definitions, bits
N  *          definitions and memory mapping for Phoenix Connectivity line.
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripherals registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup PHOENIX
N  * @{
N  */
N
N#ifndef __PHOENIX_H
N#define __PHOENIX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "typedef.h"
L 1 "..\..\..\..\Libraries\Driver\include\typedef.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/typedef.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   Type definition
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup TYPEDEF
N  * @{
N  */
N
N#ifndef __TYPEDEF_H
N#define __TYPEDEF_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#include <stdint.h>
L 1 "D:\Tools\KIEIL\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 35 "..\..\..\..\Libraries\Driver\include\typedef.h" 2
N
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N#define BIT(a)                                  ((uint32_t)1<<(a))
N     
N#define BIT_64(a)                               ((uint64_t)1<<(a))
N
N#define SET_BIT(REG, BIT)                       ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)                     ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)                      ((REG) & (BIT))
N
N#define CLEAR_REG(REG)                          ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)                     ((REG) = (VAL))
N
N#define READ_REG(REG)                           ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)     WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N#define NONSENSE(x) ((void)(x))
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_types
N  * @{
N  */
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/* Standard Peripheral Library old types (maintained for legacy purpose) */
Ntypedef int64_t         s64;
Ntypedef int32_t         s32;
Ntypedef int16_t         s16;
Ntypedef int8_t          s8;
N
Ntypedef const int32_t   sc32;           /*!< Read Only */
Ntypedef const int16_t   sc16;           /*!< Read Only */
Ntypedef const int8_t    sc8;            /*!< Read Only */
N
Ntypedef __IO int32_t    vs32;
Xtypedef volatile int32_t    vs32;
Ntypedef __IO int16_t    vs16;
Xtypedef volatile int16_t    vs16;
Ntypedef __IO int8_t     vs8;
Xtypedef volatile int8_t     vs8;
N
Ntypedef __I int32_t     vsc32;          /*!< Read Only */
Xtypedef volatile const int32_t     vsc32;           
Ntypedef __I int16_t     vsc16;          /*!< Read Only */
Xtypedef volatile const int16_t     vsc16;           
Ntypedef __I int8_t      vsc8;           /*!< Read Only */
Xtypedef volatile const int8_t      vsc8;            
N
Ntypedef uint64_t        u64;
Ntypedef uint32_t        u32;
Ntypedef uint16_t        u16;
Ntypedef uint8_t         u8;
N
Ntypedef const uint32_t  uc32;           /*!< Read Only */
Ntypedef const uint16_t  uc16;           /*!< Read Only */
Ntypedef const uint8_t   uc8;            /*!< Read Only */
N
Ntypedef __IO uint32_t   vu32;
Xtypedef volatile uint32_t   vu32;
Ntypedef __IO uint16_t   vu16;
Xtypedef volatile uint16_t   vu16;
Ntypedef __IO uint8_t    vu8;
Xtypedef volatile uint8_t    vu8;
N
Ntypedef __I uint32_t    vuc32;          /*!< Read Only */
Xtypedef volatile const uint32_t    vuc32;           
Ntypedef __I uint16_t    vuc16;          /*!< Read Only */
Xtypedef volatile const uint16_t    vuc16;           
Ntypedef __I uint8_t     vuc8;           /*!< Read Only */
Xtypedef volatile const uint8_t     vuc8;            
N
Ntypedef enum {false = 0, true = 1, FALSE = 0, TRUE = 1} BOOL, bool;
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
Ntypedef enum {HIGH = 1, LOW = 0} Polarity;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __TYPEDEF_H */
N
N/**
N  * @}
N  */
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 43 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe.h" 2
N#include "config.h"
N
N
N#if defined(TXF6200)
X#if 1L
N#include "txf6200.h"
L 1 "..\..\..\..\Libraries\Device\Phoenix\include\txf6200.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Device/Phoenix/include/txf6200.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.1
N  * @date    08-04-2019
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File.
N  *          This file contains all the peripheral register's definitions, bits
N  *          definitions and memory mapping for TXF6200 Connectivity line.
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripherals registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup TXF6200
N  * @{
N  */
N
N#ifndef __TXF6200_H
N#define __TXF6200_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "typedef.h"
N     
N/* Macro Definitions */
N#if defined(__CC_ARM)                /* KEIL Compiler */
X#if 1L                 
N    #pragma anon_unions
N    #define WEAK            __attribute__ ((weak))
N    #define ALIAS(f)        __attribute__ ((weak, alias(#f)))
N    #define WEAK_ALIAS_FUNC(FUN, FUN_ALIAS) \
N                void FUN(void) __attribute__ ((weak, alias(#FUN_ALIAS)));
X    #define WEAK_ALIAS_FUNC(FUN, FUN_ALIAS)                 void FUN(void) __attribute__ ((weak, alias(#FUN_ALIAS)));
N    #define AT(n)           __attribute__((at(n)))
N    #define NO_INIT         __attribute__((zero_init))
N    #define USED            __attribute__((used))
N#elif defined(__GNUC__)              /* GCC Compiler */
S    #define WEAK            __attribute__ ((weak))
S    #define ALIAS(f)        __attribute__ ((weak, alias(#f)))
S    #define WEAK_ALIAS_FUNC(FUN, FUN_ALIAS) \
S                void FUN(void) __attribute__ ((weak, alias(#FUN_ALIAS)));
X    #define WEAK_ALIAS_FUNC(FUN, FUN_ALIAS)                 void FUN(void) __attribute__ ((weak, alias(#FUN_ALIAS)));
S    #define AT(n)           __attribute__((at(n)))
S    #define NO_INIT         __attribute__((zero_init))
S    #define USED            __attribute__((used))
S#elif defined (__ICCARM__)           /* IAR Compiler */
S    #define _WEAK_ALIAS_FUNC(FUN, FUN_ALIAS) weak __WEAK_ALIAS_FUNC(FUN, FUN_ALIAS)
S    #define __WEAK_ALIAS_FUNC(FUN, FUN_ALIAS) FUN=FUN_ALIAS
S    #define WEAK            _Pragma("weak")
S    #define ALIAS(f)        _Pragma(_STRINGIFY(weak f))
S    #define WEAK_ALIAS_FUNC(FUN, FUN_ALIAS) \
S                void FUN(void) _Pragma(_STRINGIFY(_WEAK_ALIAS_FUNC(FUN, FUN_ALIAS)));
X    #define WEAK_ALIAS_FUNC(FUN, FUN_ALIAS)                 void FUN(void) _Pragma(_STRINGIFY(_WEAK_ALIAS_FUNC(FUN, FUN_ALIAS)));
S    #define AT(n)           @(n)
S    #define NO_INIT         __no_init
S    #define USED            __root
N#endif
N
N/**
N  * @brief  set sysctal key valid & execute some code
N  * @param  expression : code to execute
N  * @retval None
N  */
N#define SYSCTRL_WRITE_ENABLE_KEY_VAL           (0x3fac87e4)
N#define SYSCTRL_WRITE_DISABLE_KEY_VAL          (0x0)
N  
N#define SYSCTRL_REG_OPT(expression)                   \
Ndo {                                                  \
N    uint8_t ie = !__get_PRIMASK();                    \
N    if(ie) __disable_irq();                           \
N    SYSCTRL->SYS_KEY = SYSCTRL_WRITE_ENABLE_KEY_VAL;  \
N    __ASM volatile ("nop");                           \
N    expression;                                       \
N    SYSCTRL->SYS_KEY = SYSCTRL_WRITE_DISABLE_KEY_VAL; \
N    if(ie) __enable_irq();                            \
N} while(0)
X#define SYSCTRL_REG_OPT(expression)                   do {                                                      uint8_t ie = !__get_PRIMASK();                        if(ie) __disable_irq();                               SYSCTRL->SYS_KEY = SYSCTRL_WRITE_ENABLE_KEY_VAL;      __ASM volatile ("nop");                               expression;                                           SYSCTRL->SYS_KEY = SYSCTRL_WRITE_DISABLE_KEY_VAL;     if(ie) __enable_irq();                            } while(0)
N
N/** 
N  * @brief  device defines  
N  */
N#define __CM3_REV                  0x0200U  /*!< Core Revision r2p0                           */
N#define __MPU_PRESENT              0U       /*!< Other  devices does not provide an MPU       */
N#define __NVIC_PRIO_BITS           3U       /*!<  uses 3 Bits for the Priority Levels         */
N#define __Vendor_SysTickConfig     0U       /*!< Set to 1 if different SysTick Config is used */
N     
N/** @addtogroup bitband
N  * @brief \@0x2000_0000 - 0x200F-FFFF
N            @0x4000_0000 - 0x400F-FFFF
N  * @{
N  */
N#define BITBAND_RAM(addr, bit) (*((uint32_t volatile*)(0x22000000u + (((uint32_t)&(addr) - (uint32_t)0x20000000u)<<5) + (((uint32_t)(bit))<<2))))
N#define BITBAND_REG(addr, bit) (*((uint32_t volatile*)(0x42000000u + (((uint32_t)&(addr) - (uint32_t)0x40000000u)<<5) + (((uint32_t)(bit))<<2))))
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */
N     
N/**
N * @brief TXF6200 Interrupt Number Definition, according to the selected device
N */
Ntypedef enum IRQn {
N/******  Cortex-M3 Processor Exceptions Numbers ***********************************************/
N    NonMaskableInt_IRQn         = -14,      /*!< 2 Non Maskable Interrupt                     */
N    MemoryManagement_IRQn       = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt      */
N    BusFault_IRQn               = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt              */
N    UsageFault_IRQn             = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt            */
N    SVCall_IRQn                 = -5,       /*!< 11 Cortex-M3 SV Call Interrupt               */
N    DebugMonitor_IRQn           = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt         */
N    PendSV_IRQn                 = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt               */
N    SysTick_IRQn                = -1,       /*!< 15 Cortex-M3 System Tick Interrupt           */
N
N/******  specific Interrupt Numbers ***********************************************************/
N    IIC0_IRQn                   =  0,
N    IIC1_IRQn                   =  1,
N    AVDTMR0_UP_IRQn             =  2,
N    USART0_IRQn                 =  3,
N    USART1_IRQn                 =  4,
N    USART2_IRQn                 =  5,
N    SPI0_IRQn                   =  6,
N    SPI1_IRQn                   =  7,
N    HCC_IRQn                    =  8,
N    GMAC_IRQn                   =  9,
N    QEI_IRQn                    = 10,
N    WDT_IRQn                    = 11,
N    FADC_IRQn                   = 12,
N    DMA0_IRQn                   = 13,
N    CAN_IRQn                    = 14,
N    GPIOA_IRQn                  = 15,
N    GPIOB_IRQn                  = 16,
N    GPIOC_IRQn                  = 17,
N    GPIOD_IRQn                  = 18,
N    AVDTMR0_CC_IRQn             = 19,
N    AVDTMR0_TRG_IRQn            = 20,
N    SVPWM_IRQn                  = 21,
N    TIM0_IRQn                   = 22,
N    TIM1_IRQn                   = 23,
N    TIM2_IRQn                   = 24,
N    TIM3_IRQn                   = 25,
N    AVDTMR0_BRK_IRQn            = 26,
N    SARADC_IRQn                 = 27,
N    RMS0_IRQn                   = 28,
N    RMS1_IRQn                   = 29,
N    RMS2_IRQn                   = 30,
N    SINCOS0_IRQn                = 31,
N    SINCOS1_IRQn                = 32,
N    MATRIX_MULT_IRQn            = 33,
N    IIR0_IRQn                   = 34,
N    IIR1_IRQn                   = 35,
N    IIR2_IRQn                   = 36,
N    FIR0_IRQn                   = 37,
N    FIR1_IRQn                   = 38,
N    FIR2_IRQn                   = 39,
N    SPWM_IRQn                   = 40,
N    FFT0_IRQn                   = 41,
N    FFT0_PREPROCESS_IRQn        = 42,
N    FFT1_IRQn                   = 43,
N    FFT1_PREPROCESS_IRQn        = 44,
N    FFT2_IRQn                   = 45,
N    FFT2_PREPROCESS_IRQn        = 46,
N    EPWM_IRQn                   = 47,
N    LVD_IRQn                    = 48,
N    DFTRANS0_IRQn               = 49,
N    DFTRANS1_IRQn               = 50,
N    DFTRANS2_IRQn               = 51,
N    CRC_DMA_IRQn                = 52,
N    ARCTAN0_IRQn                = 53,
N    ARCTAN1_IRQn                = 54,
N    ARCTAN2_IRQn                = 55,
N    DATADMA_IRQn                = 56,
N    WAKEPND_IRQn                = 57,
N    TIM4_IRQn                   = 58,
N    TIM5_IRQn                   = 59,
N    TIM6_IRQn                   = 60,
N    TIM7_IRQn                   = 61,
N    EVSYS_IRQn                  = 62,
N    AVDTMR1_BRK_IRQn            = 63,
N    AVDTMR1_UP_IRQn             = 64,
N    AVDTMR1_TRG_IRQn            = 65,
N    AVDTMR1_CC_IRQn             = 66,
N} IRQn_Type;
N
N/**
N  * @}
N  */
N#define ARM_MATH_CM3
N#include "core_cm3.h" 
L 1 "..\..\..\..\Libraries\CMSIS\Core\Include\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M3
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "..\..\..\..\Libraries\CMSIS\Core\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 0U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "..\..\..\..\Libraries\CMSIS\Core\Include\core_cm3.h" 2
N 
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM3_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) |                                     __CM3_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (3U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "..\..\..\..\Libraries\CMSIS\Core\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.0.2
N * @date     13. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * ARM Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\..\..\..\Libraries\CMSIS\Core\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (ARM compiler V5) header file
N * @version  V5.0.2
N * @date     13. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060750 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (0L && (__TARGET_ARCH_6S_M  == 1))   )
S  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (1L && (1  == 1))
N  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1U);
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#else
S  (void)fpscr;
S#endif
S}
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = (4 /*sizeof(v)*/ * 8) - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "..\..\..\..\Libraries\CMSIS\Core\Include\cmsis_compiler.h" 2
N
N
N/*
N * ARM Compiler 6 (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S
S  #include <cmsis_iar.h>
S
S  /* CMSIS compiler control architecture macros */
S  #if (__CORE__ == __ARM6M__) || (__CORE__ == __ARM6SM__)
S    #ifndef __ARM_ARCH_6M__
S      #define __ARM_ARCH_6M__                      1
S    #endif
S  #elif (__CORE__ == __ARM7M__)
S    #ifndef __ARM_ARCH_7M__
S      #define __ARM_ARCH_7M__                      1
S    #endif
S  #elif (__CORE__ == __ARM7EM__)
S    #ifndef __ARM_ARCH_7EM__
S      #define __ARM_ARCH_7EM__                     1
S    #endif
S  #endif
S
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __noreturn
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __root
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        __packed struct
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    __packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S
S  // Workaround for missing __CLZ intrinsic in
S  // various versions of the IAR compilers.
S  // __IAR_FEATURE_CLZ__ should be defined by
S  // the compiler that supports __CLZ internally.
S  #if (defined (__ARM_ARCH_6M__)) && (__ARM_ARCH_6M__ == 1) && (!defined (__IAR_FEATURE_CLZ__))
S    __STATIC_INLINE uint32_t __CLZ(uint32_t data)
S    {
S      if (data == 0u) { return 32u; }
S      
S      uint32_t count = 0;
S      uint32_t mask = 0x80000000;
S      
S      while ((data & mask) == 0)
S      {
S        count += 1u;
S        mask = mask >> 1u;
S      }
S      
S      return (count);
S    }
S  #endif
S
S
S/*
S * TI ARM Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 "..\..\..\..\Libraries\CMSIS\Core\Include\core_cm3.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200U
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
N    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
N    uint32_t _reserved1:8;               /*!< bit: 16..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
N    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
N#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
N#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if defined (__CM3_REV) && (__CM3_REV < 0x0201U)                   /* core r2p1 */
X#if 1L && (0x0200U < 0x0201U)                    
N#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB CFSR (MMFSR): MMARVALID Position */
N#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
N
N#define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB CFSR (MMFSR): MSTKERR Position */
N#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
N
N#define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
N#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
N
N#define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB CFSR (MMFSR): DACCVIOL Position */
N#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
N
N#define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB CFSR (MMFSR): IACCVIOL Position */
N#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
N
N/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
N#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
N
N#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
N#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
N
N#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
N#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
N
N#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
N#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
N
N#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
N#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
N
N#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
N#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
N
N/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
N#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
N
N#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
N#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
N
N#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
N#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
N
N#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
N#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
N
N#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
N#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
N
N#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
N#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N#if defined (__CM3_REV) && (__CM3_REV >= 0x200U)
X#if 1L && (0x0200U >= 0x200U)
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N#else
S        uint32_t RESERVED1[1U];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (0U == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
S  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
S  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
S  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (0U == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N  #define NVIC_GetActive              __NVIC_GetActive
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S   #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t __NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetActive(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 3U)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3U)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 3U)));
N  }
N  else
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3U)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3U)) ? (uint32_t)(3U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3U));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3U)) ? (uint32_t)(3U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3U));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void __NVIC_SystemReset(void)
Xstatic __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0U == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 3U) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != ((int32_t)0x5AA55AA5U))
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = ((int32_t)0x5AA55AA5U);        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == ((int32_t)0x5AA55AA5U))
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 206 "..\..\..\..\Libraries\Device\Phoenix\include\txf6200.h" 2
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */
N
N/**
N  * @brief IIC/SMBUS (IP) 
N  */
N
Ntypedef struct {
N    __IO uint32_t CON;
X    volatile uint32_t CON;
N    __IO uint32_t TAR;
X    volatile uint32_t TAR;
N    __IO uint32_t SAR;
X    volatile uint32_t SAR;
N    __IO uint32_t HS_MADDR;
X    volatile uint32_t HS_MADDR;
N    
N    __IO uint32_t DATA_CMD;
X    volatile uint32_t DATA_CMD;
N    __IO uint32_t SS_SCL_HCNT;
X    volatile uint32_t SS_SCL_HCNT;
N    __IO uint32_t SS_SCL_LCNT;
X    volatile uint32_t SS_SCL_LCNT;
N    __IO uint32_t FS_SCL_HCNT;
X    volatile uint32_t FS_SCL_HCNT;
N    
N    __IO uint32_t FS_SCL_LCNT;
X    volatile uint32_t FS_SCL_LCNT;
N    __IO uint32_t HS_SCL_HCNT;
X    volatile uint32_t HS_SCL_HCNT;
N    __IO uint32_t HS_SCL_LCNT;
X    volatile uint32_t HS_SCL_LCNT;
N    __IO uint32_t INTR_STAT;
X    volatile uint32_t INTR_STAT;
N    
N    __IO uint32_t INTR_MASK;
X    volatile uint32_t INTR_MASK;
N    __IO uint32_t RAW_INTR_STAT;
X    volatile uint32_t RAW_INTR_STAT;
N    __IO uint32_t RX_TL;
X    volatile uint32_t RX_TL;
N    __IO uint32_t TX_TL;
X    volatile uint32_t TX_TL;
N    
N    __IO uint32_t CLR_INTR;
X    volatile uint32_t CLR_INTR;
N    __IO uint32_t CLR_RX_UNDER;
X    volatile uint32_t CLR_RX_UNDER;
N    __IO uint32_t CLR_RX_OVER;
X    volatile uint32_t CLR_RX_OVER;
N    __IO uint32_t CLR_TX_OVER;
X    volatile uint32_t CLR_TX_OVER;
N    
N    __IO uint32_t CLR_RD_REQ;
X    volatile uint32_t CLR_RD_REQ;
N    __IO uint32_t CLR_TX_ABRT;
X    volatile uint32_t CLR_TX_ABRT;
N    __IO uint32_t CLR_RX_DONE;
X    volatile uint32_t CLR_RX_DONE;
N    __IO uint32_t CLR_ACTIVITY;
X    volatile uint32_t CLR_ACTIVITY;
N    
N    __IO uint32_t CLR_STOP_DET;
X    volatile uint32_t CLR_STOP_DET;
N    __IO uint32_t CLR_START_DET;
X    volatile uint32_t CLR_START_DET;
N    __IO uint32_t CLR_GEN_CALL;
X    volatile uint32_t CLR_GEN_CALL;
N    __IO uint32_t ENABLE;
X    volatile uint32_t ENABLE;
N    
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N    __IO uint32_t TXFLR;
X    volatile uint32_t TXFLR;
N    __IO uint32_t RXFLR;
X    volatile uint32_t RXFLR;
N    __IO uint32_t SDA_HOLD;
X    volatile uint32_t SDA_HOLD;
N    __IO uint32_t TX_ABRT_SOURCE;
X    volatile uint32_t TX_ABRT_SOURCE;
N    __IO uint32_t SLV_DATA_NACK_ONLY;
X    volatile uint32_t SLV_DATA_NACK_ONLY;
N    __IO uint32_t DMA_CR;
X    volatile uint32_t DMA_CR;
N    __IO uint32_t DMA_TDLR;
X    volatile uint32_t DMA_TDLR;
N    __IO uint32_t DMA_RDLR;
X    volatile uint32_t DMA_RDLR;
N    __IO uint32_t SDA_SETUP;
X    volatile uint32_t SDA_SETUP;
N    __IO uint32_t ACK_GENERAL_CALL;
X    volatile uint32_t ACK_GENERAL_CALL;
N    __IO uint32_t ENABLE_STATUS;
X    volatile uint32_t ENABLE_STATUS;
N    __IO uint32_t FS_SPKLEN;
X    volatile uint32_t FS_SPKLEN;
N    __IO uint32_t HS_SPKLEN;
X    volatile uint32_t HS_SPKLEN;
N    __IO uint32_t CLR_RESTART_DET;
X    volatile uint32_t CLR_RESTART_DET;
N    __IO uint32_t SCL_STUCK_AT_LOW_TIMEOUT;
X    volatile uint32_t SCL_STUCK_AT_LOW_TIMEOUT;
N    __IO uint32_t SDA_STUCK_AT_LOW_TIMEOUT;
X    volatile uint32_t SDA_STUCK_AT_LOW_TIMEOUT;
N    __IO uint32_t CLR_SCL_STUCK_DET;
X    volatile uint32_t CLR_SCL_STUCK_DET;
N    __IO uint32_t DEVICE_ID;
X    volatile uint32_t DEVICE_ID;
N    __IO uint32_t SMBUS_CLOCK_LOW_SEXT;
X    volatile uint32_t SMBUS_CLOCK_LOW_SEXT;
N    __IO uint32_t SMBUS_CLOCK_LOW_MEXT;
X    volatile uint32_t SMBUS_CLOCK_LOW_MEXT;
N    __IO uint32_t SMBUS_THIGH_MAX_IDLE_COUNT;
X    volatile uint32_t SMBUS_THIGH_MAX_IDLE_COUNT;
N    __IO uint32_t SMBUS_INTR_STAT;
X    volatile uint32_t SMBUS_INTR_STAT;
N    __IO uint32_t SMBUS_INTR_MASK;
X    volatile uint32_t SMBUS_INTR_MASK;
N    __IO uint32_t SMBUS_INTR_RAW_STATUS;
X    volatile uint32_t SMBUS_INTR_RAW_STATUS;
N    __IO uint32_t CLR_SMBUS_INTR;
X    volatile uint32_t CLR_SMBUS_INTR;
N    __IO uint32_t OPTIONAL_SAR;
X    volatile uint32_t OPTIONAL_SAR;
N    __IO uint32_t SMBUS_UDID_LSB;
X    volatile uint32_t SMBUS_UDID_LSB;
N} IIC_TypeDef;
N
N/**
N  * @brief USART(IP) 
N  */
Ntypedef struct {
N    union {
N        __IO uint32_t RBR;              /*!< USART Receive Buffer Register,                   RW, Address offset: 0x00 */ 
X        volatile uint32_t RBR;                
N        __IO uint32_t THR;              /*!< USART Transmit Holding Register,                 RW, Address offset: 0x00 */
X        volatile uint32_t THR;               
N        __IO uint32_t DLL;              /*!< USART Divisor Latch Low,                         RW, Address offset: 0x00 */
X        volatile uint32_t DLL;               
N    };
N    union {
N        __IO uint32_t IER;              /*!< USART Interrupt Enable Register,                 RW, Address offset: 0x04 */
X        volatile uint32_t IER;               
N        __IO uint32_t DLH;              /*!< USART Divisor Latch High,                        RW, Address offset: 0x04 */
X        volatile uint32_t DLH;               
N    };
N    union {
N        __IO uint32_t FCR;              /*!< USART FIFO Control Register,                     RW, Address offset: 0x08 */
X        volatile uint32_t FCR;               
N        __IO uint32_t IIR;              /*!< USART Interrupt Identity Register,               RW, Address offset: 0x08 */
X        volatile uint32_t IIR;               
N    };
N
N    __IO uint32_t LCR;                  /*!< USART Line Control Register,                     RW, Address offset: 0x0C */
X    volatile uint32_t LCR;                   
N
N    __IO uint32_t MCR;                  /*!< USART Modem Control Register,                    RW, Address offset: 0x10 */
X    volatile uint32_t MCR;                   
N    __IO uint32_t LSR;                  /*!< USART Line Status Register,                      RW, Address offset: 0x14 */
X    volatile uint32_t LSR;                   
N    __IO uint32_t MSR;                  /*!< USART Modem Status Register,                     RW, Address offset: 0x18 */
X    volatile uint32_t MSR;                   
N    __IO uint32_t SCR;                  /*!< USART Scratchpad Register,                       RW, Address offset: 0x1C */
X    volatile uint32_t SCR;                   
N
N    __IO uint32_t LPDLL;                /*!< USART Low Power Divisor Latch Low Register,      RW, Address offset: 0x20 */
X    volatile uint32_t LPDLL;                 
N    __IO uint32_t LPDLH;                /*!< USART Low Power Divisor Latch High Register,     RW, Address offset: 0x24 */
X    volatile uint32_t LPDLH;                 
N    __IO uint32_t FIFO[0x12];           /*!< USART Shadow Receive/Transmit FIFO Buf Register, RW, Address offset: 0x28 */
X    volatile uint32_t FIFO[0x12];            
N
N    __IO uint32_t FAR;                  /*!< USART FIFO Access Register,                      RW, Address offset: 0x70 */
X    volatile uint32_t FAR;                   
N    __IO uint32_t TFR;                  /*!< USART Transmit FIFO Read,                        RW, Address offset: 0x74 */
X    volatile uint32_t TFR;                   
N    __IO uint32_t RFW;                  /*!< USART Receive FIFO Write,                        RW, Address offset: 0x78 */
X    volatile uint32_t RFW;                   
N    __IO uint32_t USR;                  /*!< USART Status Register,                           RW, Address offset: 0x7C */
X    volatile uint32_t USR;                   
N
N    __IO uint32_t TFL;                  /*!< USART Transmit FIFO Level,                       RW, Address offset: 0x80 */
X    volatile uint32_t TFL;                   
N    __IO uint32_t RFL;                  /*!< USART Receive FIFO Level,                        RW, Address offset: 0x84 */
X    volatile uint32_t RFL;                   
N    __IO uint32_t SRR;                  /*!< USART Software Reset Register,                   RW, Address offset: 0x88 */
X    volatile uint32_t SRR;                   
N    __IO uint32_t SRTS;                 /*!< USART Shadow Request to Send,                    RW, Address offset: 0x8C */
X    volatile uint32_t SRTS;                  
N
N    __IO uint32_t SBCR;                 /*!< USART Shadow Break Control Register,             RW, Address offset: 0x90 */
X    volatile uint32_t SBCR;                  
N    __IO uint32_t SDMAM;                /*!< USART Shadow DMA Mode,                           RW, Address offset: 0x94 */
X    volatile uint32_t SDMAM;                 
N    __IO uint32_t SFE;                  /*!< USART Shadow FIFO Enable,                        RW, Address offset: 0x98 */
X    volatile uint32_t SFE;                   
N    __IO uint32_t SRT;                  /*!< USART Shadow RCVR Trigger,                       RW, Address offset: 0x9C */
X    volatile uint32_t SRT;                   
N
N    __IO uint32_t STET;                 /*!< USART Shadow TX Empty Trigger,                   RW, Address offset: 0xA0 */
X    volatile uint32_t STET;                  
N    __IO uint32_t HTX;                  /*!< USART Halt TX,                                   RW, Address offset: 0xA4 */
X    volatile uint32_t HTX;                   
N    __IO uint32_t DMASA;                /*!< USART DMA Software Acknowledge,                  RW, Address offset: 0xA8 */
X    volatile uint32_t DMASA;                 
N    __IO uint32_t TCR;                  /*!< USART Transceiver Control Register,              RW, Address offset: 0xAC */
X    volatile uint32_t TCR;                   
N
N    __IO uint32_t DE_EN;                /*!< USART Driver Output Enable Register,             RW, Address offset: 0xB0 */
X    volatile uint32_t DE_EN;                 
N    __IO uint32_t RE_EN;                /*!< USART Receiver Output Enable Register,           RW, Address offset: 0xB4 */
X    volatile uint32_t RE_EN;                 
N    __IO uint32_t DET;                  /*!< USART Driver Output Enable Timing Register,      RW, Address offset: 0xB8 */
X    volatile uint32_t DET;                   
N    __IO uint32_t TAT;                  /*!< USART TurnAround Timing Register,                RW, Address offset: 0xBC */
X    volatile uint32_t TAT;                   
N
N    __IO uint32_t DLF;                  /*!< USART Divisor Latch Fraction Register,           RW, Address offset: 0xC0 */
X    volatile uint32_t DLF;                   
N    __IO uint32_t RAR;                  /*!< USART Receive Address Register,                  RW, Address offset: 0xC4 */
X    volatile uint32_t RAR;                   
N    __IO uint32_t TAR;                  /*!< USART Transmit Address Register,                 RW, Address offset: 0xC8 */
X    volatile uint32_t TAR;                   
N    __IO uint32_t LCR_EXT;              /*!< USART Line Extended Control Register,            RW, Address offset: 0xCC */
X    volatile uint32_t LCR_EXT;               
N} USART_TypeDef;
N
N
N/**
N  * @brief SPI (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CFG;                  // 0x00
X    volatile uint32_t CFG;                  
N    __IO uint32_t CTL;                  // 0x04
X    volatile uint32_t CTL;                  
N    __IO uint32_t RX_BC;                // 0x08
X    volatile uint32_t RX_BC;                
N    __IO uint32_t STA;                  // 0x0C
X    volatile uint32_t STA;                  
N    __IO uint32_t WDATA;                // 0x10
X    volatile uint32_t WDATA;                
N    __IO uint32_t RDATA;                // 0x14
X    volatile uint32_t RDATA;                
N    __IO uint32_t DMA_TX_ADDR;          // 0x18
X    volatile uint32_t DMA_TX_ADDR;          
N    __IO uint32_t DMA_RX_ADDR;          // 0x1C
X    volatile uint32_t DMA_RX_ADDR;          
N    __IO uint32_t TX_BC;                // 0x20
X    volatile uint32_t TX_BC;                
N    __IO uint32_t TX_START;             // 0x24
X    volatile uint32_t TX_START;             
N    __IO uint32_t RX_START;             // 0x28
X    volatile uint32_t RX_START;             
N} SPI_TypeDef;
N
N/**
N  * @brief LVD (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CON;
X    volatile uint32_t CON;
N} LVD_TypeDef;
N
N/**
N  * @brief Controller Area Network (IP)
N  */
Ntypedef struct {
N    __IO uint32_t CANRBUF[0x12];        //0x00~0x47 Receive Buffer Registers
X    volatile uint32_t CANRBUF[0x12];        
N    __IO uint32_t CANTBUF[0x12];        //0x48~0x8f Transmit Buffer Registers
X    volatile uint32_t CANTBUF[0x12];        
N    __IO uint8_t  CFGSTA;               //0x90
X    volatile uint8_t  CFGSTA;               
N    __IO uint8_t  TCMD;                 //0x91
X    volatile uint8_t  TCMD;                 
N    __IO uint8_t  TCTRL;                //0x92
X    volatile uint8_t  TCTRL;                
N    __IO uint8_t  RCTRL;                //0x93
X    volatile uint8_t  RCTRL;                
N                  
N    __IO uint8_t  RTIE;                 //0x94
X    volatile uint8_t  RTIE;                 
N    __IO uint8_t  RTIF;                 //0x95
X    volatile uint8_t  RTIF;                 
N    __IO uint8_t  ERRINT;               //0x96
X    volatile uint8_t  ERRINT;               
N    __IO uint8_t  LIMIT;                //0x97
X    volatile uint8_t  LIMIT;                
N                  
N    __IO uint8_t  BITTIME0;             //0x98
X    volatile uint8_t  BITTIME0;             
N    __IO uint8_t  BITTIME1;             //0x99
X    volatile uint8_t  BITTIME1;             
N    __IO uint8_t  BITTIME2;             //0x9a
X    volatile uint8_t  BITTIME2;             
N    __IO uint8_t  reserved0;            //0x9b
X    volatile uint8_t  reserved0;            
N                  
N    __IO uint8_t  S_PRESC;              //0x9c
X    volatile uint8_t  S_PRESC;              
N    __IO uint8_t  F_PRESC;              //0x9d
X    volatile uint8_t  F_PRESC;              
N    __IO uint8_t  TDC;                  //0x9e
X    volatile uint8_t  TDC;                  
N    __IO uint8_t  reserved1;            //0x9f
X    volatile uint8_t  reserved1;            
N                  
N    __IO uint8_t  EALCAP;               //0xa0
X    volatile uint8_t  EALCAP;               
N    __IO uint8_t  reserved2;            //0xa1
X    volatile uint8_t  reserved2;            
N    __IO uint8_t  RECNT;                //0xa2
X    volatile uint8_t  RECNT;                
N    __IO uint8_t  TECNT;                //0xa3
X    volatile uint8_t  TECNT;                
N                  
N    __IO uint8_t  ACFCTRL;              //0xa4
X    volatile uint8_t  ACFCTRL;              
N    __IO uint8_t  reserved3;            //0xa5
X    volatile uint8_t  reserved3;            
N    __IO uint8_t  ACF_EN_0;             //0xa6
X    volatile uint8_t  ACF_EN_0;             
N    __IO uint8_t  ACF_EN_1;             //0xa7
X    volatile uint8_t  ACF_EN_1;             
N        
N    __IO uint32_t ACF;                  //0xa8
X    volatile uint32_t ACF;                  
N    
N    __IO uint32_t VER;
X    volatile uint32_t VER;
N} CAN_TypeDef;
N
N/**
N  * @brief event system(huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CH_ENA;               /*!< EVSYS channel enable register,               RW,  Address offset: 0x00 */
X    volatile uint32_t CH_ENA;                
N    __IO uint32_t CH_INT_ENA;           /*!< EVSYS interrupt enable register,             RW,  Address offset: 0x04 */
X    volatile uint32_t CH_INT_ENA;            
N    __IO uint32_t CH_CPU_KST;           /*!< EVSYS channel CPU kick start register,       RW,  Address offset: 0x08 */
X    volatile uint32_t CH_CPU_KST;            
N         uint32_t RESERVED0;            /*!< EVSYS reservered,                            RW,  Address offset: 0x0c */
N    __IO uint32_t CH_PND_CLR;           /*!< EVSYS channel pending clear register,        WO,  Address offset: 0x10 */
X    volatile uint32_t CH_PND_CLR;            
N    __IO uint32_t CH_CPU_PND;           /*!< EVSYS channel CPU pending register,          RO,  Address offset: 0x14 */
X    volatile uint32_t CH_CPU_PND;            
N    __IO uint32_t CH_HW_PND;            /*!< EVSYS channel hardware oending register,     RO,  Address offset: 0x18 */
X    volatile uint32_t CH_HW_PND;             
N    __IO uint32_t CH_MODE;              /*!< EVSYS channel mode select register,          RW,  Address offset: 0x1c */
X    volatile uint32_t CH_MODE;               
N    __IO uint32_t CH_SRC_CON0[16];      /*!< EVSYS source channel number register0,       RW,  Address offset: 0x20 */
X    volatile uint32_t CH_SRC_CON0[16];       
N    __IO uint32_t CH_SRC_CON1[16];      /*!< EVSYS source channel number register1,       RW,  Address offset: 0x60 */
X    volatile uint32_t CH_SRC_CON1[16];       
N    __IO uint32_t CH_DST_CON0[16];      /*!< EVSYS destination channel number register,   RW,  Address offset: 0xa0 */
X    volatile uint32_t CH_DST_CON0[16];       
N} EVSYS_TypeDef;
N
N/**
N  * @brief svpwm(huge-ic)
N  */
N
Ntypedef struct
N{
N    __IO uint32_t CON0;                 /*!< SVPWM control register0,                    R/W, Address offset: 0x00  */
X    volatile uint32_t CON0;                  
N    __IO uint32_t CON1;                 /*!< SVPWM control register1,                    RW,  Address offset: 0x04  */
X    volatile uint32_t CON1;                  
N    __IO uint32_t CON2;                 /*!< SVPWM control register2,                    RW,  Address offset: 0x08  */
X    volatile uint32_t CON2;                  
N    __IO uint32_t CON3;                 /*!< SVPWM control register3,                    RW,  Address offset: 0x0c  */
X    volatile uint32_t CON3;                  
N    __IO uint32_t CON4;                 /*!< SVPWM control register4,                    RW,  Address offset: 0x10  */
X    volatile uint32_t CON4;                  
N    __IO uint32_t CON5;                 /*!< SVPWM control register5,                    RW,  Address offset: 0x14  */
X    volatile uint32_t CON5;                  
N                                                                                                                  
N    __IO uint32_t REFA;                 /*!< SVPWM reference A register,                 RW,  Address offset: 0x18  */
X    volatile uint32_t REFA;                  
N    __IO uint32_t REFB;                 /*!< SVPWM reference B register,                 RW,  Address offset: 0x1c  */
X    volatile uint32_t REFB;                  
N    __IO uint32_t REFC;                 /*!< SVPWM reference C register,                 RW,  Address offset: 0x20  */
X    volatile uint32_t REFC;                  
N    __IO uint32_t STC0;                 /*!< SVPWM switching cycle register0,            RO,  Address offset: 0x24  */
X    volatile uint32_t STC0;                  
N    __IO uint32_t STC1;                 /*!< SVPWM switching cycle register1,            RO,  Address offset: 0x28  */
X    volatile uint32_t STC1;                  
N                                        
N    __IO uint32_t MATCH_CON;            /*!< SVPWM counter Matching Control Registers,   RW,  Address offset: 0x2c  */
X    volatile uint32_t MATCH_CON;             
N    __IO uint32_t ADC_CON;              /*!< SVPWM trigger ADC conversion Registers,     RW,  Address offset: 0x30  */
X    volatile uint32_t ADC_CON;               
N} SVPWM_TypeDef;
N
N
N/**
N  * @brief QEI (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t QEICON;
X    volatile uint32_t QEICON;
N    __IO uint32_t DFLTCON;
X    volatile uint32_t DFLTCON;
N    __IO uint32_t POSCNT;
X    volatile uint32_t POSCNT;
N    __IO uint32_t MAXCNT;
X    volatile uint32_t MAXCNT;
N    __IO uint32_t QEIE;
X    volatile uint32_t QEIE;
N    __IO uint32_t QEIFLAG;
X    volatile uint32_t QEIFLAG;
N    __IO uint32_t QEICLR;
X    volatile uint32_t QEICLR;
N    __IO uint32_t QEIO;
X    volatile uint32_t QEIO;
N    __IO uint32_t QEI_TIMER_PERIOD;
X    volatile uint32_t QEI_TIMER_PERIOD;
N    __IO uint32_t QEI_TIMER_CNT;
X    volatile uint32_t QEI_TIMER_CNT;
N    __IO uint32_t QEI_TIMER_CNT_LATCH;
X    volatile uint32_t QEI_TIMER_CNT_LATCH;
N    __IO uint32_t QEI_ROTATE_PERIOD;
X    volatile uint32_t QEI_ROTATE_PERIOD;
N    __IO uint32_t QEI_ROTATE_CNT;
X    volatile uint32_t QEI_ROTATE_CNT;
N    __IO uint32_t QEI_ROTATE_CNT_LATCH;
X    volatile uint32_t QEI_ROTATE_CNT_LATCH;
N    __IO uint32_t POSCNT_LATCH;
X    volatile uint32_t POSCNT_LATCH;
N} QEI_TypeDef;
N
N/**
N  * @brief WDT (IP)
N  */
Ntypedef struct {
N    __IO uint32_t WDT_CR;
X    volatile uint32_t WDT_CR;
N    __IO uint32_t WDT_TORR;
X    volatile uint32_t WDT_TORR;
N    __IO uint32_t WDT_CCVR;
X    volatile uint32_t WDT_CCVR;
N    __IO uint32_t WDT_CRR;
X    volatile uint32_t WDT_CRR;
N    __IO uint32_t WDT_STAT;
X    volatile uint32_t WDT_STAT;
N    __IO uint32_t WDT_EOI;
X    volatile uint32_t WDT_EOI;
N         uint32_t WDT_RSV[51];
N    __IO uint32_t WDT_COMP_PARAMS_5;
X    volatile uint32_t WDT_COMP_PARAMS_5;
N    __IO uint32_t WDT_COMP_PARAMS_4;
X    volatile uint32_t WDT_COMP_PARAMS_4;
N    __IO uint32_t WDT_COMP_PARAMS_3;
X    volatile uint32_t WDT_COMP_PARAMS_3;
N    __IO uint32_t WDT_COMP_PARAMS_2;
X    volatile uint32_t WDT_COMP_PARAMS_2;
N    __IO uint32_t WDT_COMP_PARAMS_1;
X    volatile uint32_t WDT_COMP_PARAMS_1;
N    __IO uint32_t WDT_COMP_VERSION;
X    volatile uint32_t WDT_COMP_VERSION;
N    __IO uint32_t WDT_COMP_TYPE;
X    volatile uint32_t WDT_COMP_TYPE;
N} WDT_TypeDef;
N
N/**
N  * @brief WDT1 (Huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CON;
X    volatile uint32_t CON;
N    __IO uint32_t KEY;    
X    volatile uint32_t KEY;    
N} WDT1_TypeDef;
N
N/**
N  * @brief RTC (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t RTCCON;
X    volatile uint32_t RTCCON;
N    __IO uint32_t RTCCPND;
X    volatile uint32_t RTCCPND;
N    __IO uint32_t RTCSECCNT;
X    volatile uint32_t RTCSECCNT;
N    __IO uint32_t RTCDATA;
X    volatile uint32_t RTCDATA;
N} RTC_TypeDef;
N
N/**
N  * @brief Normal TIMERs (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t TMR_CON;
X    volatile uint32_t TMR_CON;
N    __IO uint32_t TMR_PR;
X    volatile uint32_t TMR_PR;
N    __IO uint32_t TMR_CNT;
X    volatile uint32_t TMR_CNT;
N    __IO uint32_t TMR_PWM;
X    volatile uint32_t TMR_PWM;
N} TIMER_TypeDef;
N
N/**
N  * @brief Advanced-control timer (huge-ic) 
N  */
Ntypedef struct
N{   
N  __IO uint32_t CR1;                    /*!< TIM control register 1,                     RW, Address offset: 0x00 */
X  volatile uint32_t CR1;                     
N  __IO uint32_t CR2;                    /*!< TIM control register 2,                     RW, Address offset: 0x04 */
X  volatile uint32_t CR2;                     
N  __IO uint32_t SMCR;                   /*!< TIM slave Mode Control register,            RW, Address offset: 0x08 */
X  volatile uint32_t SMCR;                    
N  __IO uint32_t DIER;                   /*!< TIM DMA/interrupt enable register,          RW, Address offset: 0x0C */
X  volatile uint32_t DIER;                    
N  __IO uint32_t SR;                     /*!< TIM status register,                        RW, Address offset: 0x10 */
X  volatile uint32_t SR;                      
N  __IO uint32_t EGR;                    /*!< TIM event generation register,              RW, Address offset: 0x14 */
X  volatile uint32_t EGR;                     
N  __IO uint32_t CCMR1;                  /*!< TIM capture/compare mode register 1,        RW, Address offset: 0x18 */
X  volatile uint32_t CCMR1;                   
N  __IO uint32_t CCMR2;                  /*!< TIM capture/compare mode register 2,        RW, Address offset: 0x1C */
X  volatile uint32_t CCMR2;                   
N  __IO uint32_t CCER;                   /*!< TIM capture/compare enable register,        RW, Address offset: 0x20 */
X  volatile uint32_t CCER;                    
N  __IO uint32_t CNT;                    /*!< TIM counter register,                       RW, Address offset: 0x24 */
X  volatile uint32_t CNT;                     
N  __IO uint32_t PSC;                    /*!< TIM prescaler register,                     RW, Address offset: 0x28 */
X  volatile uint32_t PSC;                     
N  __IO uint32_t ARR;                    /*!< TIM auto-reload register,                   RW, Address offset: 0x2C */
X  volatile uint32_t ARR;                     
N  __IO uint32_t RCR;                    /*!< TIM repetition counter register,            RW, Address offset: 0x30 */
X  volatile uint32_t RCR;                     
N  __IO uint32_t CCR1;                   /*!< TIM capture/compare register 1,             RW, Address offset: 0x34 */    
X  volatile uint32_t CCR1;                        
N  __IO uint32_t CCR2;                   /*!< TIM capture/compare register 2,             RW, Address offset: 0x38 */    
X  volatile uint32_t CCR2;                        
N  __IO uint32_t CCR3;                   /*!< TIM capture/compare register 3,             RW, Address offset: 0x3C */
X  volatile uint32_t CCR3;                    
N  __IO uint32_t CCR4;                   /*!< TIM capture/compare register 4,             RW, Address offset: 0x40 */
X  volatile uint32_t CCR4;                    
N  __IO uint32_t BDTR;                   /*!< TIM break and dead-time register,           RW, Address offset: 0x44 */
X  volatile uint32_t BDTR;                    
N  __IO uint32_t DCR;                    /*!< TIM DMA control register,                   RW, Address offset: 0x48 */
X  volatile uint32_t DCR;                     
N  __IO uint32_t DMAR;                   /*!< TIM DMA address for full transfer register, RW, Address offset: 0x4C */
X  volatile uint32_t DMAR;                    
N  __IO uint32_t OR;                     /*!< TIM option register,                        RW, Address offset: 0x50 */
X  volatile uint32_t OR;                      
N  __IO uint32_t CCMR3;                  /*!< TIM capture/compare mode register 3         RW, Address offset: 0x54 */
X  volatile uint32_t CCMR3;                   
N  __IO uint32_t CCR5;                   /*!< TIM capture/compare register 5              RW, Address offset: 0x58 */
X  volatile uint32_t CCR5;                    
N  __IO uint32_t CCR6;                   /*!< TIM capture/compare register 6              RW, Address offset: 0x5C */
X  volatile uint32_t CCR6;                    
N  __IO uint32_t AF1;                    /*!< TIM alternate function option register 1    RW, Address offset: 0x60 */
X  volatile uint32_t AF1;                     
N  __IO uint32_t AF2;                    /*!< TIM alternate function option register 2    RW, Address offset: 0x64 */
X  volatile uint32_t AF2;                     
N    
N} ADVTMR_TypeDef;
N
N/**
N  * @brief HCC (huge-ic) 
N  */
Ntypedef struct {
N    __IO uint32_t HCC_STADR_FFT;
X    volatile uint32_t HCC_STADR_FFT;
N    __IO uint32_t HCC_STADR_PHS;
X    volatile uint32_t HCC_STADR_PHS;
N    __IO uint32_t HCC_STADR_RAG;
X    volatile uint32_t HCC_STADR_RAG;
N    __IO uint32_t HCC_CONTROL;
X    volatile uint32_t HCC_CONTROL;
N    __IO uint32_t HCC_RESULT;
X    volatile uint32_t HCC_RESULT;
N} HCC_TypeDef;
N
N/**
N  * @brief CRC (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CRC_CFG;              // 0x0c
X    volatile uint32_t CRC_CFG;              
N    __IO uint32_t CRC_INIT;             // 0x04
X    volatile uint32_t CRC_INIT;             
N    __IO uint32_t CRC_INV;              // 0x08
X    volatile uint32_t CRC_INV;              
N    __IO uint32_t CRC_POLY;             // 0x0c 
X    volatile uint32_t CRC_POLY;             
N    __IO uint32_t CRC_KST;              // 0x10
X    volatile uint32_t CRC_KST;              
N    __IO uint32_t CRC_STA;              // 0x14
X    volatile uint32_t CRC_STA;              
N         uint32_t RESERVED0;
N    __IO uint32_t DMA_ADDR;             // 0x1c
X    volatile uint32_t DMA_ADDR;             
N    __IO uint32_t DMA_LEN;              // 0x20
X    volatile uint32_t DMA_LEN;              
N    __IO uint32_t CRC_OUT;              // 0x24
X    volatile uint32_t CRC_OUT;              
N} CRC_TypeDef;
N
N/**
N  * @brief Frac PLL 0 (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t FPLL0_CON;
X    volatile uint32_t FPLL0_CON;
N    __IO uint32_t FPLL0_INT;
X    volatile uint32_t FPLL0_INT;
N    __IO uint32_t FPLL0_FRAC;
X    volatile uint32_t FPLL0_FRAC;
N    __IO uint32_t FPLL0_SSC;
X    volatile uint32_t FPLL0_SSC;
N} FPLL0_TypeDef;
N
N/**
N  * @brief Frac PLL 1 (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t FPLL1_CON;
X    volatile uint32_t FPLL1_CON;
N    __IO uint32_t FPLL1_INT;
X    volatile uint32_t FPLL1_INT;
N    __IO uint32_t FPLL1_FRAC;
X    volatile uint32_t FPLL1_FRAC;
N    __IO uint32_t FPLL1_SSC;
X    volatile uint32_t FPLL1_SSC;
N} FPLL1_TypeDef;
N
N/**
N  * @brief SYS_CTRL (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CLK_CON0;
X    volatile uint32_t CLK_CON0;
N    __IO uint32_t CLK_CON1;
X    volatile uint32_t CLK_CON1;
N    __IO uint32_t CLK_CON2;
X    volatile uint32_t CLK_CON2;
N    __IO uint32_t CLK_CON3;
X    volatile uint32_t CLK_CON3;
N    __IO uint32_t CLK_CON4;
X    volatile uint32_t CLK_CON4;
N    __IO uint32_t CLK_CON5;
X    volatile uint32_t CLK_CON5;
N    
N    __IO uint32_t SYS_CON0;
X    volatile uint32_t SYS_CON0;
N    __IO uint32_t SYS_CON1;
X    volatile uint32_t SYS_CON1;
N    __IO uint32_t SYS_CON2;
X    volatile uint32_t SYS_CON2;
N    __IO uint32_t SYS_CON3;
X    volatile uint32_t SYS_CON3;
N    __IO uint32_t SYS_CON4;
X    volatile uint32_t SYS_CON4;
N    __IO uint32_t SYS_CON5;
X    volatile uint32_t SYS_CON5;
N    __IO uint32_t SYS_CON6;
X    volatile uint32_t SYS_CON6;
N    __IO uint32_t SYS_CON7;
X    volatile uint32_t SYS_CON7;
N    __IO uint32_t SYS_CON8;
X    volatile uint32_t SYS_CON8;
N    
N    __IO uint32_t AIP_CON0;
X    volatile uint32_t AIP_CON0;
N    __IO uint32_t AIP_CON1;
X    volatile uint32_t AIP_CON1;
N    
N    __IO uint32_t IO_MAP;
X    volatile uint32_t IO_MAP;
N    __IO uint32_t IO_MAP1;
X    volatile uint32_t IO_MAP1;
N    
N    __IO uint32_t PMUREG0;
X    volatile uint32_t PMUREG0;
N    __IO uint32_t PMUREG4;
X    volatile uint32_t PMUREG4;
N    
N    __IO uint32_t PWM_KEY;
X    volatile uint32_t PWM_KEY;
N    __IO uint32_t SYS_KEY;
X    volatile uint32_t SYS_KEY;
N    
N    __IO uint32_t DMA_ERR0;
X    volatile uint32_t DMA_ERR0;
N    __IO uint32_t DMA_ERR1;
X    volatile uint32_t DMA_ERR1;
N    
N    __IO uint32_t HOSC_MNT;
X    volatile uint32_t HOSC_MNT;
N    __IO uint32_t WKUP_CON0;
X    volatile uint32_t WKUP_CON0;
N    __IO uint32_t LP_CON0;
X    volatile uint32_t LP_CON0;
N    __IO uint32_t MBIST_CON0;
X    volatile uint32_t MBIST_CON0;
N    __IO uint32_t MBIST_MISR;
X    volatile uint32_t MBIST_MISR;
N    __IO uint32_t SPWM_SOFTRESET;       //SYSCTRL->SYS_KEY = 0x4c5de9b3
X    volatile uint32_t SPWM_SOFTRESET;       
N    __IO uint32_t CHIP_ID;
X    volatile uint32_t CHIP_ID;
N    __IO uint32_t MODE_REG;
X    volatile uint32_t MODE_REG;
N} SYSCTRL_TypeDef;
N
N/**
N  * @brief eFlash controller (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CTRLR0;               /*!< EFLASH control register,                     RW,  Address offset: 0x00           */
X    volatile uint32_t CTRLR0;                
N    __IO uint32_t KST;                  /*!< EFLASH kick start register,                  RO,  Address offset: 0x04           */
X    volatile uint32_t KST;                   
N    __IO uint32_t DONE;                 /*!< EFLASH finish flag register,                 RO,  Address offset: 0x08           */
X    volatile uint32_t DONE;                  
N    __IO uint32_t RESERVED0;            /*!< EFLASH reserved0,                            RO,  Address offset: 0x0c           */
X    volatile uint32_t RESERVED0;             
N    __IO uint32_t PROG_ADDR;            /*!< EFLASH program address register,             RW,  Address offset: 0x10           */
X    volatile uint32_t PROG_ADDR;             
N    __IO uint32_t PROG_BYTE;            /*!< EFLASH program byte register,                RW,  Address offset: 0x14           */
X    volatile uint32_t PROG_BYTE;             
N    __IO uint32_t PROG_DATA;            /*!< EFLASH program data register,                RW,  Address offset: 0x18           */
X    volatile uint32_t PROG_DATA;             
N         uint32_t RESERVED1;            /*!< EFLASH reserve1,                             RO,  Address offset: 0x1c           */
N    __IO uint32_t ERASE_CTRL;           /*!< EFLASH erase register,                       R/W, Address offset: 0x20           */
X    volatile uint32_t ERASE_CTRL;            
N         uint32_t RESERVED2[3];         /*!< EFLASH reserve2,                             RO,  Address offset: 0x24/0x28/0x2c */
N    __IO uint32_t TIME_REG0;            /*!< EFLASH time register0,                       RW,  Address offset: 0x30           */
X    volatile uint32_t TIME_REG0;             
N    __IO uint32_t TIME_REG1;            /*!< EFLASH time register1,                       RW,  Address offset: 0x34           */
X    volatile uint32_t TIME_REG1;             
N    __IO uint32_t TIME_REG2;            /*!< EFLASH time register2,                       RW,  Address offset: 0x38           */
X    volatile uint32_t TIME_REG2;             
N    __IO uint32_t TIME_REG3;            /*!< EFLASH time register3,                       RW,  Address offset: 0x3c           */
X    volatile uint32_t TIME_REG3;             
N         uint32_t RESERVED3[4];         /*!< EFLASH reserve5,                             RO,  Address offset: 0x40-0x4c      */
N    __IO uint32_t NVR_PASSWORD;         /*!< EFLASH NVR password register,                RW,  Address offset: 0x50           */
X    volatile uint32_t NVR_PASSWORD;          
N    __IO uint32_t MAIN_PASSWORD;        /*!< EFLASH MAIN password register,               RW,  Address offset: 0x54           */
X    volatile uint32_t MAIN_PASSWORD;         
N    __IO uint32_t CRC_DMA;              /*!< EFLASH CRC DMA register,                     RW,  Address offset: 0x58           */
X    volatile uint32_t CRC_DMA;               
N    __IO uint32_t CRC_OUT;              /*!< EFLASH CRC OUT register,                     RW,  Address offset: 0x5c           */
X    volatile uint32_t CRC_OUT;               
N         uint32_t RESERVED4[4];         /*!< EFLASH reserve9,                             RO,  Address offset: 0x60-0x6c      */
N    __IO uint32_t MODE_STA;             /*!< EFLASH mode status register,                 RO,  Address offset: 0x70           */
X    volatile uint32_t MODE_STA;              
N    __IO uint32_t PERMISSION0;          /*!< EFLASH NVR Hardware control permission,      RO,  Address offset: 0x74           */
X    volatile uint32_t PERMISSION0;           
N    __IO uint32_t PERMISSION1;          /*!< EFLASH MAIN Hardware control permission,     RO,  Address offset: 0x78           */
X    volatile uint32_t PERMISSION1;           
N} EFLASH_TypeDef;
N
N/**
N  * @brief GPIO controller (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t DR;                   /*!< GPIO port data register,                    RW,  Address offset: 0x00  */  
X    volatile uint32_t DR;                      
N    __IO uint32_t DIR;                  /*!< GPIO port direct register,                  RW,  Address offset: 0x04  */ 
X    volatile uint32_t DIR;                    
N    __IO uint32_t INTMASK;              /*!< GPIO port interrupt mask register,          RW,  Address offset: 0x08  */ 
X    volatile uint32_t INTMASK;                
N    __IO uint32_t PU0EN;                /*!< GPIO port pull up register,10K,             RW,  Address offset: 0x0C  */ 
X    volatile uint32_t PU0EN;                  
N         uint32_t RESERVED0;            /*!< GPIO port reserve0,                         RO,  Address offset: 0x10  */ 
N         uint32_t RESERVED1;            /*!< GPIO port reserve1,                         RO,  Address offset: 0x14  */        
N    __IO uint32_t PD0EN;                /*!< GPIO port pull down register,10K,           RW,  Address offset: 0x18  */ 
X    volatile uint32_t PD0EN;                  
N         uint32_t RESERVED2;            /*!< GPIO port reserve2,                         RO,  Address offset: 0x1C  */  
N         uint32_t RESERVED3;            /*!< GPIO port reserve3,                         RO,  Address offset: 0x20  */   
N    __IO uint32_t DS;                   /*!< GPIO port drive strong register,            RW,  Address offset: 0x24  */      
X    volatile uint32_t DS;                          
N    __IO uint32_t HY;                   /*!< GPIO port hardware register,                RW,  Address offset: 0x28  */  
X    volatile uint32_t HY;                      
N    __IO uint32_t OD;                   /*!< GPIO port open-drain register,              RW,  Address offset: 0x2c  */  
X    volatile uint32_t OD;                      
N    __IO uint32_t SR;                   /*!< GPIO port slow rate register,               RW,  Address offset: 0x30  */   
X    volatile uint32_t SR;                       
N    __IO uint32_t DIE;                  /*!< GPIO port digtial enable register,          RW,  Address offset: 0x34  */ 
X    volatile uint32_t DIE;                    
N    __IO uint32_t BSRS;                 /*!< GPIO port bit set/reset(H16/L16) register,  RW,  Address offset: 0x38  */ 
X    volatile uint32_t BSRS;                   
N} GPIO_TypeDef;
N
N/**
N  * @brief DMAC controller (IP)
N  */
Ntypedef struct {
N    __IO uint32_t SARL;
X    volatile uint32_t SARL;
N    __IO uint32_t SARH;
X    volatile uint32_t SARH;
N    __IO uint32_t DARL;
X    volatile uint32_t DARL;
N    __IO uint32_t DARH;
X    volatile uint32_t DARH;
N    __IO uint32_t FIFO0[2];             //LLPL,LLPH, NO USE
X    volatile uint32_t FIFO0[2];             
N    __IO uint32_t CTLL;
X    volatile uint32_t CTLL;
N    __IO uint32_t CTLH;
X    volatile uint32_t CTLH;
N    __IO uint32_t FIFO1[8];             //SSTATL,SSTATH,DSTATL,DSTATH,SSTATARL,SSTATARH,DSTATARL,DSTATARH
X    volatile uint32_t FIFO1[8];             
N    __IO uint32_t CFGL;
X    volatile uint32_t CFGL;
N    __IO uint32_t CFGH;
X    volatile uint32_t CFGH;
N    __IO uint32_t SGRL;
X    volatile uint32_t SGRL;
N    __IO uint32_t SGRH;
X    volatile uint32_t SGRH;
N    __IO uint32_t DSRL;
X    volatile uint32_t DSRL;
N    __IO uint32_t DSRH;
X    volatile uint32_t DSRH;
N} DMAC_CH_TypeDef;
N
N/**
N  * @brief DMAC
N  */
Ntypedef struct {
N    DMAC_CH_TypeDef CH0;
N    DMAC_CH_TypeDef CH1;
N    DMAC_CH_TypeDef CH2;
N    DMAC_CH_TypeDef CH3;
N    __IO uint32_t   FIFO0[22*4];
X    volatile uint32_t   FIFO0[22*4];
N    __IO uint32_t   RawTfrL;
X    volatile uint32_t   RawTfrL;
N    __IO uint32_t   RawTfrH;
X    volatile uint32_t   RawTfrH;
N    __IO uint32_t   RawBlockL;
X    volatile uint32_t   RawBlockL;
N    __IO uint32_t   RawBlockH;
X    volatile uint32_t   RawBlockH;
N    __IO uint32_t   RawSrcTranL;
X    volatile uint32_t   RawSrcTranL;
N    __IO uint32_t   RawSrcTranH;
X    volatile uint32_t   RawSrcTranH;
N    __IO uint32_t   RawDstTranL;
X    volatile uint32_t   RawDstTranL;
N    __IO uint32_t   RawDstTranH;
X    volatile uint32_t   RawDstTranH;
N    __IO uint32_t   RawErrL;
X    volatile uint32_t   RawErrL;
N    __IO uint32_t   RawErrH;
X    volatile uint32_t   RawErrH;
N    __IO uint32_t   FIFO1[5*2];
X    volatile uint32_t   FIFO1[5*2];
N    __IO uint32_t   MaskTfrL;
X    volatile uint32_t   MaskTfrL;
N    __IO uint32_t   MaskTfrH;
X    volatile uint32_t   MaskTfrH;
N    __IO uint32_t   MaskBlockL;
X    volatile uint32_t   MaskBlockL;
N    __IO uint32_t   MaskBlockH;
X    volatile uint32_t   MaskBlockH;
N    __IO uint32_t   MaskSrcTranL;
X    volatile uint32_t   MaskSrcTranL;
N    __IO uint32_t   MaskSrcTranH;
X    volatile uint32_t   MaskSrcTranH;
N    __IO uint32_t   MaskDstTranL;
X    volatile uint32_t   MaskDstTranL;
N    __IO uint32_t   MaskDstTranH;
X    volatile uint32_t   MaskDstTranH;
N    __IO uint32_t   MaskErrL;
X    volatile uint32_t   MaskErrL;
N    __IO uint32_t   MaskErrH;
X    volatile uint32_t   MaskErrH;
N    __IO uint32_t   ClearTfrL;
X    volatile uint32_t   ClearTfrL;
N    __IO uint32_t   ClearTfrH;
X    volatile uint32_t   ClearTfrH;
N    __IO uint32_t   ClearBlockL;
X    volatile uint32_t   ClearBlockL;
N    __IO uint32_t   ClearBlockH;
X    volatile uint32_t   ClearBlockH;
N    __IO uint32_t   ClearSrcTranL;
X    volatile uint32_t   ClearSrcTranL;
N    __IO uint32_t   ClearSrcTranH;
X    volatile uint32_t   ClearSrcTranH;
N    __IO uint32_t   ClearDstTranL;
X    volatile uint32_t   ClearDstTranL;
N    __IO uint32_t   ClearDstTranH;
X    volatile uint32_t   ClearDstTranH;
N    __IO uint32_t   ClearErrL;
X    volatile uint32_t   ClearErrL;
N    __IO uint32_t   ClearErrH;
X    volatile uint32_t   ClearErrH;
N    __IO uint32_t   FIFO2[2];
X    volatile uint32_t   FIFO2[2];
N    __IO uint32_t   ReqSrcRegL;
X    volatile uint32_t   ReqSrcRegL;
N    __IO uint32_t   ReqSrcRegH;
X    volatile uint32_t   ReqSrcRegH;
N    __IO uint32_t   ReqDstRegL;
X    volatile uint32_t   ReqDstRegL;
N    __IO uint32_t   ReqDstRegH;
X    volatile uint32_t   ReqDstRegH;
N    __IO uint32_t   SglReqSrcRegL;
X    volatile uint32_t   SglReqSrcRegL;
N    __IO uint32_t   SglReqSrcRegH;
X    volatile uint32_t   SglReqSrcRegH;
N    __IO uint32_t   SglReqDstRegL;
X    volatile uint32_t   SglReqDstRegL;
N    __IO uint32_t   SglReqDstRegH;
X    volatile uint32_t   SglReqDstRegH;
N    __IO uint32_t   LstSrcRegL;
X    volatile uint32_t   LstSrcRegL;
N    __IO uint32_t   LstSrcRegH;
X    volatile uint32_t   LstSrcRegH;
N    __IO uint32_t   LstDstRegL;
X    volatile uint32_t   LstDstRegL;
N    __IO uint32_t   LstDstRegH;
X    volatile uint32_t   LstDstRegH;
N    __IO uint32_t   DmaCfgRegL;
X    volatile uint32_t   DmaCfgRegL;
N    __IO uint32_t   DmaCfgRegH;
X    volatile uint32_t   DmaCfgRegH;
N    __IO uint32_t   ChEnRegL;
X    volatile uint32_t   ChEnRegL;
N    __IO uint32_t   ChEnRegH;
X    volatile uint32_t   ChEnRegH;
N    __IO uint32_t   FIFO3[2];
X    volatile uint32_t   FIFO3[2];
N    __IO uint32_t   DmaTestRegL;
X    volatile uint32_t   DmaTestRegL;
N    __IO uint32_t   DmaTestRegH;
X    volatile uint32_t   DmaTestRegH;
N} DMAC_TypeDef;
N
N/**
N  * @brief Ethernet GMAC controller (IP modify)
N  */
Ntypedef struct {
N    __IO uint32_t CSR0;
X    volatile uint32_t CSR0;
N         uint32_t RESERVED0;
N    __IO uint32_t CSR1;
X    volatile uint32_t CSR1;
N         uint32_t RESERVED1;
N    __IO uint32_t CSR2;
X    volatile uint32_t CSR2;
N         uint32_t RESERVED2;
N    __IO uint32_t CSR3;
X    volatile uint32_t CSR3;
N         uint32_t RESERVED3;
N    __IO uint32_t CSR4;
X    volatile uint32_t CSR4;
N         uint32_t RESERVED4;
N    __IO uint32_t CSR5;
X    volatile uint32_t CSR5;
N         uint32_t RESERVED5;
N    __IO uint32_t CSR6;
X    volatile uint32_t CSR6;
N         uint32_t RESERVED6;
N    __IO uint32_t CSR7;
X    volatile uint32_t CSR7;
N         uint32_t RESERVED7;
N    __IO uint32_t CSR8;
X    volatile uint32_t CSR8;
N         uint32_t RESERVED8;
N    __IO uint32_t CSR9;
X    volatile uint32_t CSR9;
N         uint32_t RESERVED9;
N    __IO uint32_t CSR10;
X    volatile uint32_t CSR10;
N         uint32_t RESERVED10;
N    __IO uint32_t CSR11;
X    volatile uint32_t CSR11;
N         uint32_t RESERVED11;
N} GMAC_TypeDef;
N
N/** 
N  * @brief sin&cos (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CON;
X    volatile uint32_t CON;
N    __IO uint32_t LEN;
X    volatile uint32_t LEN;
N    __IO uint32_t STEP;
X    volatile uint32_t STEP;
N    __IO uint32_t DATA_IN;
X    volatile uint32_t DATA_IN;
N    __IO uint32_t DATA_OUT;
X    volatile uint32_t DATA_OUT;
N    __IO uint32_t DATA_IN_ADR;
X    volatile uint32_t DATA_IN_ADR;
N    __IO uint32_t DATA_OUT_ADR;
X    volatile uint32_t DATA_OUT_ADR;
N         uint32_t RESERVED[9];
N} SINCOS_TypeDef;
N
N/**
N  * @brief RMS (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CON;
X    volatile uint32_t CON;
N    __IO uint32_t LEN;
X    volatile uint32_t LEN;
N    __IO uint32_t IN_FRAC_WIDTH;
X    volatile uint32_t IN_FRAC_WIDTH;
N    __IO uint32_t OUT_FRAC_WIDTH;
X    volatile uint32_t OUT_FRAC_WIDTH;
N    __IO uint32_t DATA_IN;
X    volatile uint32_t DATA_IN;
N    __IO uint32_t DATA_OUTL;
X    volatile uint32_t DATA_OUTL;
N    __IO uint32_t DATA_OUTH;
X    volatile uint32_t DATA_OUTH;
N    __IO uint32_t DATA_IN_ADR;
X    volatile uint32_t DATA_IN_ADR;
N    __IO uint32_t DATA_OUT_ADR;
X    volatile uint32_t DATA_OUT_ADR;
N         uint32_t RESERVED[7];
N} RMS_TypeDef;
N
N/**
N  * @brief MATRIX channel typedef (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t DATAIN_STADR0;
X    volatile uint32_t DATAIN_STADR0;
N    __IO uint32_t DATAIN_STADR1;
X    volatile uint32_t DATAIN_STADR1;
N    __IO uint32_t DATAIN_STADR2;
X    volatile uint32_t DATAIN_STADR2;
N    __IO uint32_t DATAOUT_STADR0;
X    volatile uint32_t DATAOUT_STADR0;
N    __IO uint32_t DATAOUT_STADR1;
X    volatile uint32_t DATAOUT_STADR1;
N    __IO uint32_t DATAOUT_STADR2;
X    volatile uint32_t DATAOUT_STADR2;
N    __IO uint32_t LEN;
X    volatile uint32_t LEN;
N    __IO uint32_t INDEX;
X    volatile uint32_t INDEX;
N    __IO uint32_t COEF_FRAC_WIDTH;
X    volatile uint32_t COEF_FRAC_WIDTH;
N    __IO uint32_t OUT_FRAC_WIDTH; 
X    volatile uint32_t OUT_FRAC_WIDTH; 
N} MATRIX_CH_TypeDef;
N
N/**
N  * @brief MATRIX (huge-ic)
N  */
Ntypedef struct {
N    MATRIX_CH_TypeDef CH[4];
N    __IO uint32_t     COEF[2][9];
X    volatile uint32_t     COEF[2][9];
N    __IO uint32_t     MATRIX_COEF_SEL;
X    volatile uint32_t     MATRIX_COEF_SEL;
N    __IO uint32_t     MATRIX_EN;
X    volatile uint32_t     MATRIX_EN;
N    __IO uint32_t     MATRIX_PEND;
X    volatile uint32_t     MATRIX_PEND;
N    __IO uint32_t     MATRIX_IE;
X    volatile uint32_t     MATRIX_IE;
N         uint32_t     RESERVED[18];
N} MATRIX_TypeDef;
N
N/**
N  * @brief SPWM (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t SPWM_CON;
X    volatile uint32_t SPWM_CON;
N    __IO uint32_t SPWM_PERIOD0;
X    volatile uint32_t SPWM_PERIOD0;
N    __IO uint32_t SPWM_DATAUSE0;
X    volatile uint32_t SPWM_DATAUSE0;
N    __IO uint32_t SPWM_DATABUF0;
X    volatile uint32_t SPWM_DATABUF0;
N    __IO uint32_t SPWM_DATAUSE1;
X    volatile uint32_t SPWM_DATAUSE1;
N    __IO uint32_t SPWM_DATABUF1;
X    volatile uint32_t SPWM_DATABUF1;
N    __IO uint32_t SPWM_DATAUSE2;
X    volatile uint32_t SPWM_DATAUSE2;
N    __IO uint32_t SPWM_DATABUF2;
X    volatile uint32_t SPWM_DATABUF2;
N    __IO uint32_t SPWM_FAULT_INFO;
X    volatile uint32_t SPWM_FAULT_INFO;
N    __IO uint32_t SPWM_FAULT_INVERT;
X    volatile uint32_t SPWM_FAULT_INVERT;
N    __IO uint32_t SPWM_PERIOD1;
X    volatile uint32_t SPWM_PERIOD1;
N    __IO uint32_t SPWM_MATCH;
X    volatile uint32_t SPWM_MATCH;
N    __IO uint32_t SPWM_ADCC;
X    volatile uint32_t SPWM_ADCC;
N    __IO uint32_t SPWM_CNT0;
X    volatile uint32_t SPWM_CNT0;
N    __IO uint32_t SPWM_CNT1;
X    volatile uint32_t SPWM_CNT1;
N    __IO uint32_t SPWM_CNT2;
X    volatile uint32_t SPWM_CNT2;
N} SPWM_TypeDef;
N
N
N/**
N  * @brief FFT (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t DMA_CON;
X    volatile uint32_t DMA_CON;
N    __IO uint32_t REAL_STADR;
X    volatile uint32_t REAL_STADR;
N    __IO uint32_t IMAG_STADR;
X    volatile uint32_t IMAG_STADR;
N    __IO uint32_t WINDOW_STADR;
X    volatile uint32_t WINDOW_STADR;
N    __IO uint32_t REALIMAG_OUT_STADR;
X    volatile uint32_t REALIMAG_OUT_STADR;
N    __IO uint32_t INDEX;
X    volatile uint32_t INDEX;
N    __IO uint32_t LEN;
X    volatile uint32_t LEN;
N    __IO uint32_t STADR;
X    volatile uint32_t STADR;
N    __IO uint32_t KS;
X    volatile uint32_t KS;
N    __IO uint32_t CTRL;
X    volatile uint32_t CTRL;
N    __IO uint32_t STAT; 
X    volatile uint32_t STAT; 
N    __IO uint32_t MAXIMUM; 
X    volatile uint32_t MAXIMUM; 
N         uint32_t RESERVED[4];
N} FFT_TypeDef;
N
N/**
N  * @brief DFT (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CON;
X    volatile uint32_t CON;
N    __IO uint32_t LEN;
X    volatile uint32_t LEN;
N    __IO uint32_t INDEX;
X    volatile uint32_t INDEX;
N    __IO uint32_t STEP;
X    volatile uint32_t STEP;
N    __IO uint32_t REAL_STADR;
X    volatile uint32_t REAL_STADR;
N    __IO uint32_t IMAG_STADR;
X    volatile uint32_t IMAG_STADR;
N    __IO uint32_t OUT;
X    volatile uint32_t OUT;
N    __IO uint32_t DMA_LEN;
X    volatile uint32_t DMA_LEN;
N    __IO uint32_t NORMALIZED_COEF;
X    volatile uint32_t NORMALIZED_COEF;
N    __IO uint32_t OUT_ADR;
X    volatile uint32_t OUT_ADR;
N         uint32_t RESERVED[6];
N} DFT_TypeDef;
N
N/**
N  * @brief ARCTAN (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CON;
X    volatile uint32_t CON;
N    __IO uint32_t DMA_LEN;
X    volatile uint32_t DMA_LEN;
N    __IO uint32_t DMA0_STADR;
X    volatile uint32_t DMA0_STADR;
N    __IO uint32_t DMA1_STADR;
X    volatile uint32_t DMA1_STADR;
N    __IO uint32_t DMA2_STADR;
X    volatile uint32_t DMA2_STADR;
N    __IO uint32_t IN;
X    volatile uint32_t IN;
N    __IO uint32_t OUT; 
X    volatile uint32_t OUT; 
N         uint32_t RESERVED[9];
N} ARCTAN_TypeDef;
N
N/**
N  * @brief DATADMA (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t CON;
X    volatile uint32_t CON;
N    __IO uint32_t SRC_BUF_STADR;
X    volatile uint32_t SRC_BUF_STADR;
N    __IO uint32_t SRC_BUF_LEN;
X    volatile uint32_t SRC_BUF_LEN;
N    __IO uint32_t SRC_DMA_ADR;
X    volatile uint32_t SRC_DMA_ADR;
N    __IO uint32_t DEST_DMA_ADR;
X    volatile uint32_t DEST_DMA_ADR;
N    __IO uint32_t DMA_LEN; 
X    volatile uint32_t DMA_LEN; 
N         uint32_t RESERVED[10];
N} DATADMA_TypeDef;
N
N/** 
N  * @brief saradc (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t SARADC_CON;
X    volatile uint32_t SARADC_CON;
N         uint32_t RESERVED[4];
N    __IO uint32_t SARADC_COM_ACFG;
X    volatile uint32_t SARADC_COM_ACFG;
N    __IO uint32_t SARADC_CON1;
X    volatile uint32_t SARADC_CON1;
N         uint32_t RESERVED0;
N    __IO uint32_t SARADC_CDIV_DMALEN[19];
X    volatile uint32_t SARADC_CDIV_DMALEN[19];
N         uint32_t RESERVED1;
N    __IO uint32_t SARADC_DMASTADDR[14];
X    volatile uint32_t SARADC_DMASTADDR[14];
N         uint32_t RESERVED2;
N         uint32_t RESERVED3;
N    __IO uint32_t SARADC_ACFG[19];
X    volatile uint32_t SARADC_ACFG[19];
N         uint32_t RESERVED4;
N    __IO  int16_t SARADC_DATA[19];
X    volatile  int16_t SARADC_DATA[19];
N         uint16_t RESERVED5;
N         uint32_t RESERVED6;
N         uint32_t RESERVED7;
N    __IO uint32_t DACCMP_CON[5];
X    volatile uint32_t DACCMP_CON[5];
N         uint32_t RESERVED8;
N
N    __IO uint32_t SARADC_QUANTIFY_CON[14];
X    volatile uint32_t SARADC_QUANTIFY_CON[14];
N         uint32_t RESERVED9[5];
N    __IO uint32_t SARADC_START_POINT[19];
X    volatile uint32_t SARADC_START_POINT[19];
N    __IO uint32_t SARADC_PENDING0;
X    volatile uint32_t SARADC_PENDING0;
N    __IO uint32_t SARADC_PENDING1;
X    volatile uint32_t SARADC_PENDING1;
N    __IO uint32_t SARADC_PENDING2;
X    volatile uint32_t SARADC_PENDING2;
N    __IO uint32_t SARADC_PENDING0_CLR;
X    volatile uint32_t SARADC_PENDING0_CLR;
N    __IO uint32_t SARADC_PENDING1_CLR;
X    volatile uint32_t SARADC_PENDING1_CLR;
N    __IO uint32_t SARADC_PENDING2_CLR;
X    volatile uint32_t SARADC_PENDING2_CLR;
N    __IO uint32_t SARADC_INT_CONTROL0;
X    volatile uint32_t SARADC_INT_CONTROL0;
N    __IO uint32_t SARADC_INT_CONTROL1;
X    volatile uint32_t SARADC_INT_CONTROL1;
N    __IO uint32_t SARADC_INT_CONTROL2;
X    volatile uint32_t SARADC_INT_CONTROL2;
N
N    __IO uint32_t DACCMP_DEBOUNCE[5];
X    volatile uint32_t DACCMP_DEBOUNCE[5];
N    __IO uint32_t DACCMP_DATA[5];
X    volatile uint32_t DACCMP_DATA[5];
N    __IO uint32_t SARADC_DMA_INDEX[14];
X    volatile uint32_t SARADC_DMA_INDEX[14];
N} ADC_TypeDef;
N
N/** 
N  * @brief iir (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t IIR_CH_ENA0;          // 0x00
X    volatile uint32_t IIR_CH_ENA0;          
N    __IO uint32_t IIR_CPU_KST0;         // 0x04
X    volatile uint32_t IIR_CPU_KST0;         
N    __IO uint32_t IIR_CFG_ADDR;         // 0x08
X    volatile uint32_t IIR_CFG_ADDR;         
N    __IO uint32_t IIR_INT_ENA0;         // 0x0c
X    volatile uint32_t IIR_INT_ENA0;         
N    __IO uint32_t IIR_HALF_PND0;        // 0x10
X    volatile uint32_t IIR_HALF_PND0;        
N    __IO uint32_t IIR_FULL_PND0;        // 0x14
X    volatile uint32_t IIR_FULL_PND0;        
N    __IO uint32_t IIR_FILT_PND0;        // 0x18
X    volatile uint32_t IIR_FILT_PND0;        
N    __IO uint32_t IIR_INT_SRCL0;        // 0x1c
X    volatile uint32_t IIR_INT_SRCL0;        
N    __IO uint32_t IIR_INT_SRCH0;        // 0x20
X    volatile uint32_t IIR_INT_SRCH0;        
N    __IO uint32_t IIR_DATA_OUT;         // 0x24
X    volatile uint32_t IIR_DATA_OUT;         
N    __IO uint32_t EVSYS_CH_ENA0;        // 0x28
X    volatile uint32_t EVSYS_CH_ENA0;        
N         uint32_t RESERVED0;            // 0x2c
N
N    __IO uint32_t IIR_CH_ENA1;          // 0x30
X    volatile uint32_t IIR_CH_ENA1;          
N    __IO uint32_t IIR_CPU_KST1;         // 0x34
X    volatile uint32_t IIR_CPU_KST1;         
N         uint32_t RESERVED07;           // 0x38
N    __IO uint32_t IIR_INT_ENA1;         // 0x3c
X    volatile uint32_t IIR_INT_ENA1;         
N    __IO uint32_t IIR_HALF_PND1;        // 0x40
X    volatile uint32_t IIR_HALF_PND1;        
N    __IO uint32_t IIR_FULL_PND1;        // 0x44
X    volatile uint32_t IIR_FULL_PND1;        
N    __IO uint32_t IIR_FILT_PND1;        // 0x48
X    volatile uint32_t IIR_FILT_PND1;        
N    __IO uint32_t IIR_INT_SRCL1;        // 0x4c
X    volatile uint32_t IIR_INT_SRCL1;        
N    __IO uint32_t IIR_INT_SRCH1;        // 0x50
X    volatile uint32_t IIR_INT_SRCH1;        
N         uint32_t RESERVED10;           // 0x54
N    __IO uint32_t EVSYS_CH_ENA1;        // 0x58
X    volatile uint32_t EVSYS_CH_ENA1;        
N         uint32_t RESERVED12;           // 0x5c
N} IIR_TypeDef;  
N
N
N/** 
N  * @brief fir (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t FIR_CH_ENA;           // 0x00
X    volatile uint32_t FIR_CH_ENA;           
N    __IO uint32_t FIR_CPU_KST;          // 0x04
X    volatile uint32_t FIR_CPU_KST;          
N    __IO uint32_t FIR_CFG_ADDR;         // 0x08
X    volatile uint32_t FIR_CFG_ADDR;         
N    __IO uint32_t FIR_INT_ENA;          // 0x0c
X    volatile uint32_t FIR_INT_ENA;          
N    __IO uint32_t FIR_HALF_PND;         // 0x10
X    volatile uint32_t FIR_HALF_PND;         
N    __IO uint32_t FIR_FULL_PND;         // 0x14
X    volatile uint32_t FIR_FULL_PND;         
N    __IO uint32_t FIR_FILT_PND;         // 0x18
X    volatile uint32_t FIR_FILT_PND;         
N    __IO uint32_t FIR_INT_SRCL;         // 0x1c
X    volatile uint32_t FIR_INT_SRCL;         
N    __IO uint32_t FIR_INT_SRCH;         // 0x20
X    volatile uint32_t FIR_INT_SRCH;         
N    __IO uint32_t FIR_DATA_OUT;         // 0x24
X    volatile uint32_t FIR_DATA_OUT;         
N    __IO uint32_t EVSYS_CH_ENA;         // 0x28
X    volatile uint32_t EVSYS_CH_ENA;         
N         uint32_t RESERVED02;           // 0x2c
N} FIR_TypeDef;  
N
N/** 
N  * @brief EPWM (huge-ic)
N  */
Ntypedef struct {
N     __IO uint32_t EPWM_TBCTL;          /*!< EPWM Time-Base Control Register,                            RW,  Address offset: 0x00  */
X     volatile uint32_t EPWM_TBCTL;           
N     __IO uint32_t EPWM_TBPRD;          /*!< EPWM Time-Base Period(Shadow Data) Register,                RW,  Address offset: 0x04  */
X     volatile uint32_t EPWM_TBPRD;           
N     __IO uint32_t EPWM_TBPHASE;        /*!< EPWM Phase Data Register,                                   RW,  Address offset: 0x08  */
X     volatile uint32_t EPWM_TBPHASE;         
N     __IO uint32_t EPWM_CMPCTL;         /*!< EPWM Counter-Compare Control Register,                      RW,  Address offset: 0x0C  */
X     volatile uint32_t EPWM_CMPCTL;          
N     __IO uint32_t EPWM_CMPA;           /*!< EPWM Counter-Compare A Register,                            RO,  Address offset: 0x10  */
X     volatile uint32_t EPWM_CMPA;            
N     __IO uint32_t EPWM_CMPB;           /*!< EPWM Counter-Compare B Register,                            RO,  Address offset: 0x14  */
X     volatile uint32_t EPWM_CMPB;            
N     __IO uint32_t EPWM_CMPC;           /*!< EPWM Counter-Compare C Register,                            RW,  Address offset: 0x18  */
X     volatile uint32_t EPWM_CMPC;            
N     __IO uint32_t EPWM_AQCTLAB;        /*!< EPWM Action-Qualifier Control Register for Output A and B,  RO,  Address offset: 0x1C  */
X     volatile uint32_t EPWM_AQCTLAB;         
N     __IO uint32_t EPWM_AQSFRC;         /*!< EPWM Action-Qualifier Software Force Register,              RO,  Address offset: 0x20  */
X     volatile uint32_t EPWM_AQSFRC;          
N     __IO uint32_t EPWM_AQCSFRC;        /*!< EPWM Action-Qualifier Continuous S/W Force Register Set,    RW,  Address offset: 0x24  */
X     volatile uint32_t EPWM_AQCSFRC;         
N     __IO uint32_t EPWM_DBCTL;          /*!< EPWM Dead-Band Generator Control Register,                  RW,  Address offset: 0x28  */
X     volatile uint32_t EPWM_DBCTL;           
N     __IO uint32_t EPWM_DBDELAY;        /*!< EPWM Dead-Band Generator Edge Delay Count Register          RW,  Address offset: 0x2c  */
X     volatile uint32_t EPWM_DBDELAY;         
N     __IO uint32_t EPWM_ETCTL;          /*!< EPWM Event-Trigger Control Register,                        RW,  Address offset: 0x30  */
X     volatile uint32_t EPWM_ETCTL;           
N     __IO uint32_t EPWM_ETFLAG;         /*!< EPWM Event-Trigger Flag Register,                           RW,  Address offset: 0x34  */
X     volatile uint32_t EPWM_ETFLAG;          
N     __IO uint32_t EPWM_DCCTL;          /*!< EPWM Digital Compare Control Register                       RW,  Address offset: 0x38  */
X     volatile uint32_t EPWM_DCCTL;           
N     __IO uint32_t EPWM_DCTRIPSEL;      /*!< EPWM Digital Compare Trip Select Register,                  RW,  Address offset: 0x24  */
X     volatile uint32_t EPWM_DCTRIPSEL;       
N     __IO uint32_t EPWM_DCCAP;          /*!< EPWM Digital Compare Capture Control Register,              RW,  Address offset: 0x28  */
X     volatile uint32_t EPWM_DCCAP;           
N     __IO uint32_t EPWM_BLANKOFFSET;    /*!< EPWM Blank Offset Data Register,                            RW,  Address offset: 0x2c  */
X     volatile uint32_t EPWM_BLANKOFFSET;     
N     __IO uint32_t EPWM_WINWIDTH;       /*!< EPWM Window Width Data Register,                            RW,  Address offset: 0x30  */
X     volatile uint32_t EPWM_WINWIDTH;        
N     __IO uint32_t EPWM_TZCTL;          /*!< EPWM Trip-Zone Control Register,                            RW,  Address offset: 0x34  */
X     volatile uint32_t EPWM_TZCTL;           
N     __IO uint32_t EPWM_TZFLAG;         /*!< EPWM Trip-Zone Flag Register,                               RW,  Address offset: 0x38  */
X     volatile uint32_t EPWM_TZFLAG;          
N} EPWM_CH_TypeDef;
N
Ntypedef struct {
N     EPWM_CH_TypeDef CH[7];             /*!< EPWM Channel0 To Channel6 Control Config Register           RW,  Address offset: 0x00  */
N     __IO uint32_t EPWM_TTCTL;          /*!< EPWM Control Config Register                                RW,  Address offset: 0x24C */
X     volatile uint32_t EPWM_TTCTL;           
N     __IO uint32_t EPWM_ADCSEL0;        /*!< EPWM Adc0 To Adc9 Select Register                           RW,  Address offset: 0x250 */
X     volatile uint32_t EPWM_ADCSEL0;         
N     __IO uint32_t EPWM_ADCSEL1;        /*!< EPWM Adca0 To Adc13 Select Register                         RW,  Address offset: 0x254 */
X     volatile uint32_t EPWM_ADCSEL1;         
N} EPWM_TypeDef;  
N
N/** 
N  * @brief fadc (huge-ic)
N  */
Ntypedef struct {
N    __IO uint32_t FADCCON0;             // 0x00
X    volatile uint32_t FADCCON0;             
N    __IO uint32_t FADCACSCON;           // 0x04
X    volatile uint32_t FADCACSCON;           
N    __IO uint32_t FADCACSDAT;           // 0x08
X    volatile uint32_t FADCACSDAT;           
N    __IO uint32_t FADCINT0;             // 0x0c
X    volatile uint32_t FADCINT0;             
N    __IO uint32_t FADCINT1;             // 0x10
X    volatile uint32_t FADCINT1;             
N    __IO uint32_t FADCSMPFLAG;          // 0x14
X    volatile uint32_t FADCSMPFLAG;          
N    __IO uint32_t FADCDMAFLAG0;         // 0x18
X    volatile uint32_t FADCDMAFLAG0;         
N    __IO uint32_t FADCDMAFLAG1;         // 0x1c
X    volatile uint32_t FADCDMAFLAG1;         
N    __IO uint32_t FADCDMAADDR[16];      // 0x20 ~ 0x5C
X    volatile uint32_t FADCDMAADDR[16];      
N    __IO uint32_t FADCDMALEN[16];       // 0x60 ~ 0x9c
X    volatile uint32_t FADCDMALEN[16];       
N    __IO uint32_t FADCPPROC0CON[16];    // 0xa0 ~ 0xdc
X    volatile uint32_t FADCPPROC0CON[16];    
N    __IO uint32_t FADCPPROC1CON[16];    // 0xe0 ~ 0x11c
X    volatile uint32_t FADCPPROC1CON[16];    
N    __IO  int16_t FADCRES[16];          // 0x120 ~ 0x13c
X    volatile  int16_t FADCRES[16];          
N} FADC_TypeDef;  
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N/*! FLASH base address in the alias region */
N#define FLASH_BASE              ((uint32_t)0x08000000)
N/*! SRAM base address in the alias region */
N#define SRAM_BASE               ((uint32_t)0x20000000)
N/*! Peripheral base address in the alias region */
N#define PERIPH_BASE             ((uint32_t)0x40000000)
N
N//--------------Peripheral memory map------------------//
N#define APB0_BASE               PERIPH_BASE
N#define APB1_BASE               (PERIPH_BASE + 0x10000)
N#define APB2_BASE               (PERIPH_BASE + 0x30000)
N
N//--------------APB0 bus peris map---------------------//
N#define IIC0_BASE               (APB0_BASE + 0x0000)
N#define IIC1_BASE               (APB0_BASE + 0x1000)
N#define USART0_BASE             (APB0_BASE + 0x3000)
N#define USART1_BASE             (APB0_BASE + 0x4000)
N#define USART2_BASE             (APB0_BASE + 0x5000)
N#define SPI0_BASE               (APB0_BASE + 0x6000)
N#define SPI1_BASE               (APB0_BASE + 0x7000)
N#define LVD_BASE                (APB0_BASE + 0x9000)
N#define ADVTMR0_BASE            (APB0_BASE + 0xA000)
N#define TIMER4_BASE             (APB0_BASE + 0xD000)
N#define TIMER5_BASE             (APB0_BASE + 0xD010)
N#define TIMER6_BASE             (APB0_BASE + 0xD020)
N#define TIMER7_BASE             (APB0_BASE + 0xD030)
N
N//--------------APB1 bus peris map---------------------//
N#define QEI_BASE                (APB1_BASE + 0x2000)
N#define WDT_BASE                (APB1_BASE + 0x3000)
N#define WDT1_BASE               (APB1_BASE + 0x4000)
N#define TIMER0_BASE             (APB1_BASE + 0x5000)
N#define TIMER1_BASE             (APB1_BASE + 0x5010)
N#define TIMER2_BASE             (APB1_BASE + 0x5020)
N#define TIMER3_BASE             (APB1_BASE + 0x5030)
N#define CRC_BASE                (APB1_BASE + 0x7000)
N#define FPLL0_BASE              (APB1_BASE + 0xC000)
N#define FPLL1_BASE              (APB1_BASE + 0xD000)
N
N//--------------APB2 bus peris map---------------------//
N#define HCC_BASE                (APB2_BASE + 0x0000)
N#define EFLASH_BASE             (APB2_BASE + 0x1000)
N#define PWRACE_BASE             (APB2_BASE + 0x5000)
N#define ADC_BASE                (APB2_BASE + 0x6000)
N#define FADC_BASE               (APB2_BASE + 0x7000)
N
N//--------------PWRACE Subsystem peris map-------------//
N#define SINCOS0_BASE            (PWRACE_BASE + 0x000)
N#define SINCOS1_BASE            (PWRACE_BASE + 0x040)
N#define RMS0_BASE               (PWRACE_BASE + 0x080)
N#define RMS1_BASE               (PWRACE_BASE + 0x0C0)
N#define RMS2_BASE               (PWRACE_BASE + 0x100)
N#define MATRIX_BASE             (PWRACE_BASE + 0x140)
N#define SPWM_BASE               (PWRACE_BASE + 0x280)
N#define FFT0_BASE               (PWRACE_BASE + 0x2C0)
N#define FFT1_BASE               (PWRACE_BASE + 0x300)
N#define FFT2_BASE               (PWRACE_BASE + 0x340)
N#define DFTRAN0_BASE            (PWRACE_BASE + 0x380)
N#define DFTRAN1_BASE            (PWRACE_BASE + 0x3C0)
N#define DFTRAN2_BASE            (PWRACE_BASE + 0x400)
N#define ARCTAN0_BASE            (PWRACE_BASE + 0x440)
N#define ARCTAN1_BASE            (PWRACE_BASE + 0x480)
N#define ARCTAN2_BASE            (PWRACE_BASE + 0x4C0)
N#define DATADMA_BASE            (PWRACE_BASE + 0x500)
N#define EVSYS_BASE              (APB2_BASE + 0x2000)
N#define SVPWM_BASE              (APB2_BASE + 0x3000)
N#define EPWM_BASE               (APB2_BASE + 0x8000)
N
N//--------------ADC Subsystem peris map----------------//
N#define SARADC_BASE             (ADC_BASE + 0x0000)
N#define IIR0_BASE               (ADC_BASE + 0x0300 + 0x0000)
N#define IIR1_BASE               (ADC_BASE + 0x0300 + 0x0060)
N#define IIR2_BASE               (ADC_BASE + 0x0300 + 0x00c0)
N#define FIR0_BASE               (ADC_BASE + 0x0300 + 0x0120)
N#define FIR1_BASE               (ADC_BASE + 0x0300 + 0x0150)
N#define FIR2_BASE               (ADC_BASE + 0x0300 + 0x0180)
N
N//--------------AHB0 bus peris map---------------------//
N#define AHB_BASE                (PERIPH_BASE + 0x20000)
N#define DMAC_BASE               (AHB_BASE + 0x0000)
N#define GMAC_BASE               (AHB_BASE + 0x1000)
N#define GPIOA_BASE              (AHB_BASE + 0x2000)
N#define GPIOB_BASE              (AHB_BASE + 0x4000)
N#define GPIOC_BASE              (AHB_BASE + 0x5000)
N#define GPIOD_BASE              (AHB_BASE + 0x7000)
N#define SYSCTRL_BASE            (AHB_BASE + 0x6000)
N#define CAN_BASE                (AHB_BASE + 0x9000)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_declaration
N  * @{
N  */
N#define IIC0                    ((IIC_TypeDef     *) IIC0_BASE)
N#define IIC1                    ((IIC_TypeDef     *) IIC1_BASE)
N#define USART0                  ((USART_TypeDef   *) USART0_BASE)
N#define USART1                  ((USART_TypeDef   *) USART1_BASE)
N#define USART2                  ((USART_TypeDef   *) USART2_BASE)
N#define SPI0                    ((SPI_TypeDef     *) SPI0_BASE)
N#define SPI1                    ((SPI_TypeDef     *) SPI1_BASE)
N#define LVD                     ((LVD_TypeDef     *) LVD_BASE)
N#define TIMER4                  ((TIMER_TypeDef   *) TIMER4_BASE)
N#define TIMER5                  ((TIMER_TypeDef   *) TIMER5_BASE)
N#define TIMER6                  ((TIMER_TypeDef   *) TIMER6_BASE)
N#define TIMER7                  ((TIMER_TypeDef   *) TIMER7_BASE)
N#define HCC                     ((HCC_TypeDef     *) HCC_BASE)
N
N#define CAN                     ((CAN_TypeDef     *) CAN_BASE)
N#define QEI                     ((QEI_TypeDef     *) QEI_BASE)
N#define WDT                     ((WDT_TypeDef     *) WDT_BASE)
N#define WDT1                    ((WDT1_TypeDef    *) WDT1_BASE)
N#define TIMER0                  ((TIMER_TypeDef   *) TIMER0_BASE)
N#define TIMER1                  ((TIMER_TypeDef   *) TIMER1_BASE)
N#define TIMER2                  ((TIMER_TypeDef   *) TIMER2_BASE)
N#define TIMER3                  ((TIMER_TypeDef   *) TIMER3_BASE)
N#define EFLASH                  ((EFLASH_TypeDef  *) EFLASH_BASE)
N#define CRC                     ((CRC_TypeDef     *) CRC_BASE)
N#define EVSYS                   ((EVSYS_TypeDef   *) EVSYS_BASE)
N#define SVPWM                   ((SVPWM_TypeDef   *) SVPWM_BASE)
N#define FPLL0                   ((FPLL0_TypeDef   *) FPLL0_BASE)
N#define FPLL1                   ((FPLL1_TypeDef   *) FPLL1_BASE)
N
N#define SINCOS0                 ((SINCOS_TypeDef  *) SINCOS0_BASE)
N#define SINCOS1                 ((SINCOS_TypeDef  *) SINCOS1_BASE)
N#define RMS0                    ((RMS_TypeDef     *) RMS0_BASE)
N#define RMS1                    ((RMS_TypeDef     *) RMS1_BASE)
N#define RMS2                    ((RMS_TypeDef     *) RMS2_BASE)
N#define MATRIX                  ((MATRIX_TypeDef  *) MATRIX_BASE)
N#define SPWM                    ((SPWM_TypeDef    *) SPWM_BASE)
N
N#define FFT0                    ((FFT_TypeDef     *) FFT0_BASE)
N#define FFT1                    ((FFT_TypeDef     *) FFT1_BASE)
N#define FFT2                    ((FFT_TypeDef     *) FFT2_BASE)
N#define FFT                     ((FFT_TypeDef     *) FFT0_BASE)
N
N#define DFTRAN0                 ((DFT_TypeDef     *) DFTRAN0_BASE)
N#define DFTRAN1                 ((DFT_TypeDef     *) DFTRAN1_BASE)
N#define DFTRAN2                 ((DFT_TypeDef     *) DFTRAN2_BASE)
N#define DFTRAN                  ((DFT_TypeDef     *) DFTRAN0_BASE)
N
N#define ARCTAN0                 ((ARCTAN_TypeDef  *) ARCTAN0_BASE)
N#define ARCTAN1                 ((ARCTAN_TypeDef  *) ARCTAN1_BASE)
N#define ARCTAN2                 ((ARCTAN_TypeDef  *) ARCTAN2_BASE)
N#define ARCTAN                  ((ARCTAN_TypeDef  *) ARCTAN0_BASE)
N
N#define DATADMA                 ((DATADMA_TypeDef *) DATADMA_BASE)
N
N#define ADC                     ((ADC_TypeDef     *) SARADC_BASE)
N#define IIR0                    ((IIR_TypeDef     *) IIR0_BASE)
N#define IIR1                    ((IIR_TypeDef     *) IIR1_BASE)
N#define IIR2                    ((IIR_TypeDef     *) IIR2_BASE)
N#define IIRX                    ((IIR_TypeDef     *) IIR0_BASE)
N#define FIR0                    ((FIR_TypeDef     *) FIR0_BASE)
N#define FIR1                    ((FIR_TypeDef     *) FIR1_BASE)
N#define FIR2                    ((FIR_TypeDef     *) FIR2_BASE)
N#define FIR                     ((FIR_TypeDef     *) FIR0_BASE)
N
N#define DMAC                    ((DMAC_TypeDef    *) DMAC_BASE)
N#define GMAC                    ((GMAC_TypeDef    *) GMAC_BASE)
N#define GPIOA                   ((GPIO_TypeDef    *) GPIOA_BASE)
N#define GPIOB                   ((GPIO_TypeDef    *) GPIOB_BASE)
N#define GPIOC                   ((GPIO_TypeDef    *) GPIOC_BASE)
N#define GPIOD                   ((GPIO_TypeDef    *) GPIOD_BASE)
N#define SYSCTRL                 ((SYSCTRL_TypeDef *) SYSCTRL_BASE)
N
N#define ADVTMR0                 ((ADVTMR_TypeDef  *) ADVTMR0_BASE)
N#define EPWM                    ((EPWM_TypeDef    *) EPWM_BASE)
N#define FADC                    ((FADC_TypeDef    *) FADC_BASE)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/*! special key define : A(PB0-3), B(PB4-7), C(PB8-11) */
N#define PWM_KEY_A               (0x51UL << 0)
N#define PWM_KEY_B               (0xA1UL << 8)
N#define PWM_KEY_C               (0x55UL << 16)
N#define SVPWM_KEY_A             (0x54UL << 0)
N#define SVPWM_KEY_B             (0xA4UL << 8)
N#define SVPWM_KEY_C             (0x58UL << 16)
N#define ADTTIM_KEY_A            (0x52UL << 0)
N#define ADTTIM_KEY_B            (0xA2UL << 8)
N#define ADTTIM_KEY_C            (0x56UL << 16)
N#define GPIO_KEY_A              (0x53UL << 0)
N#define GPIO_KEY_B              (0xA3UL << 8)
N#define GPIO_KEY_C              (0x57UL << 16)
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __TXF6200_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 48 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe.h" 2
N#elif  defined (TXF5200)
S#include "txf5200.h"
S#else
S#error "phoenix sdk target device error!!!"
N#endif
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __PHOENIX_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 29 "..\..\..\..\User\LL\include.h" 2
N#include "core_cm3.h"
L 1 "..\..\..\..\Libraries\CMSIS\Core\Include\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
S#define __CORE_CM3_H_GENERIC
S
S#include <stdint.h>
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/**
S  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
S  CMSIS violates the following MISRA-C:2004 rules:
S
S   \li Required Rule 8.5, object/function definition in header file.<br>
S     Function definitions in header files are used to allow 'inlining'.
S
S   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
S     Unions are used for effective representation of core registers.
S
S   \li Advisory Rule 19.7, Function-like macro defined.<br>
S     Function-like macros are used to allow more efficient code.
S */
S
S
S/*******************************************************************************
S *                 CMSIS definitions
S ******************************************************************************/
S/**
S  \ingroup Cortex_M3
S  @{
S */
S
S#include "cmsis_version.h"
S 
S/*  CMSIS CM3 definitions */
S#define __CM3_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
S#define __CM3_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
S#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) | \
S                                    __CM3_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) |                                     __CM3_CMSIS_VERSION_SUB           )   
S
S#define __CORTEX_M                (3U)                                   /*!< Cortex-M Core */
S
S/** __FPU_USED indicates whether an FPU is used or not.
S    This core does not support an FPU at all
S*/
S#define __FPU_USED       0U
S
S#if defined ( __CC_ARM )
S  #if defined __TARGET_FPU_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#endif
S
S#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
S#define __CORE_CM3_H_DEPENDANT
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* check device defines and use defaults */
S#if defined __CHECK_DEVICE_DEFINES
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200U
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
S#endif
S
S/* IO definitions (access restrictions to peripheral registers) */
S/**
S    \defgroup CMSIS_glob_defs CMSIS Global Defines
S
S    <strong>IO Type Qualifiers</strong> are used
S    \li to specify the access to peripheral variables.
S    \li for automatic generation of peripheral register debug information.
S*/
S#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
S#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions */
S#endif
S#define     __O     volatile             /*!< Defines 'write only' permissions */
S#define     __IO    volatile             /*!< Defines 'read / write' permissions */
S
S/* following defines should be used for structure members */
S#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
S#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
S#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
S
S/*@} end of group Cortex_M3 */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S  - Core Debug Register
S  - Core MPU Register
S ******************************************************************************/
S/**
S  \defgroup CMSIS_core_register Defines and Type Definitions
S  \brief Type definitions and defines for Cortex-M processor based devices.
S*/
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_CORE  Status and Control Registers
S  \brief      Core Register type definitions.
S  @{
S */
S
S/**
S  \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} APSR_Type;
S
S/* APSR Register Definitions */
S#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
S#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
S
S#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
S#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
S
S#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
S#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
S
S#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
S#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
S
S#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
S#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
S
S
S/**
S  \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} IPSR_Type;
S
S/* IPSR Register Definitions */
S#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
S#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
S    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
S    uint32_t _reserved1:8;               /*!< bit: 16..23  Reserved */
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
S    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} xPSR_Type;
S
S/* xPSR Register Definitions */
S#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
S#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
S
S#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
S#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
S
S#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
S#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
S
S#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
S#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
S
S#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
S#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
S
S#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
S#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
S
S#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
S#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
S
S#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
S#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
S
S#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
S#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
S    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} CONTROL_Type;
S
S/* CONTROL Register Definitions */
S#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
S#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
S
S#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
S#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
S
S/*@} end of group CMSIS_CORE */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
S  \brief      Type definitions for the NVIC Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
S        uint32_t RESERVED0[24U];
S  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
S        uint32_t RSERVED1[24U];
S  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
S        uint32_t RESERVED2[24U];
S  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
S        uint32_t RESERVED3[24U];
S  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
S        uint32_t RESERVED4[56U];
S  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
S        uint32_t RESERVED5[644U];
S  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
S}  NVIC_Type;
S
S/* Software Triggered Interrupt Register Definitions */
S#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
S#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
S
S/*@} end of group CMSIS_NVIC */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCB     System Control Block (SCB)
S  \brief    Type definitions for the System Control Block Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
S  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
S  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
S  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
S  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
S  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
S  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
S  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
S  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
S  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
S  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
S  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
S  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
S  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
S  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
S  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
S  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
S  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
S  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
S        uint32_t RESERVED0[5U];
S  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
S} SCB_Type;
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
S#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
S
S/* SCB Vector Table Offset Register Definitions */
S#if defined (__CM3_REV) && (__CM3_REV < 0x0201U)                   /* core r2p1 */
S#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
S#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
S
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
S#else
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
S#endif
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
S#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
S#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
S#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
S
S#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
S#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
S#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
S
S#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
S#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
S#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
S
S#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
S#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
S
S#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
S#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
S
S#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
S#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
S
S#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
S#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
S
S#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
S#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
S
S#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
S#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
S
S#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
S#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
S
S#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
S#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
S
S#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
S#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
S
S#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
S#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
S
S#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
S#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
S
S#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
S#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
S
S/* SCB Configurable Fault Status Register Definitions */
S#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
S#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
S
S#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
S#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
S
S#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
S#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
S
S/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
S#define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB CFSR (MMFSR): MMARVALID Position */
S#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
S
S#define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB CFSR (MMFSR): MSTKERR Position */
S#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
S
S#define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
S#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
S
S#define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB CFSR (MMFSR): DACCVIOL Position */
S#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
S
S#define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB CFSR (MMFSR): IACCVIOL Position */
S#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
S
S/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
S#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
S#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
S
S#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
S#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
S
S#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
S#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
S
S#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
S#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
S
S#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
S#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
S
S#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
S#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
S
S/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
S#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
S#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
S
S#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
S#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
S
S#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
S#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
S
S#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
S#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
S
S#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
S#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
S
S#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
S#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
S
S/* SCB Hard Fault Status Register Definitions */
S#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
S#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
S
S#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
S#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
S
S#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
S#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
S
S/* SCB Debug Fault Status Register Definitions */
S#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
S#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
S
S#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
S#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
S
S#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
S#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
S
S#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
S#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
S
S#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
S#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
S  \brief    Type definitions for the System Control and ID Register not in the SCB
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control and ID Register not in the SCB.
S */
Stypedef struct
S{
S        uint32_t RESERVED0[1U];
S  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
S#if defined (__CM3_REV) && (__CM3_REV >= 0x200U)
S  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
S#else
S        uint32_t RESERVED1[1U];
S#endif
S} SCnSCB_Type;
S
S/* Interrupt Controller Type Register Definitions */
S#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
S#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
S
S/* Auxiliary Control Register Definitions */
S
S#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
S#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
S
S#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
S#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
S
S#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
S#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
S
S/*@} end of group CMSIS_SCnotSCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
S  \brief    Type definitions for the System Timer Registers.
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
S  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
S  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
S  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
S */
Stypedef struct
S{
S  __OM  union
S  {
S    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
S    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
S    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
S  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
S        uint32_t RESERVED0[864U];
S  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
S        uint32_t RESERVED1[15U];
S  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
S        uint32_t RESERVED2[15U];
S  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
S        uint32_t RESERVED3[29U];
S  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
S  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
S  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
S        uint32_t RESERVED4[43U];
S  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
S  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
S        uint32_t RESERVED5[6U];
S  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
S  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
S  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
S  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
S  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
S  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
S  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
S  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
S  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
S  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
S  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
S  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
S} ITM_Type;
S
S/* ITM Trace Privilege Register Definitions */
S#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
S#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
S
S/* ITM Trace Control Register Definitions */
S#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
S#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
S
S#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
S#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
S
S#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
S#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
S
S#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
S#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
S
S#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
S#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
S
S#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
S#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
S
S#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
S#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
S
S#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
S#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
S
S#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
S#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
S
S/* ITM Integration Write Register Definitions */
S#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
S#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
S
S/* ITM Integration Read Register Definitions */
S#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
S#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
S
S/* ITM Integration Mode Control Register Definitions */
S#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
S#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
S
S/* ITM Lock Status Register Definitions */
S#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
S#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
S
S#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
S#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
S
S#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
S#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
S
S/*@}*/ /* end of group CMSIS_ITM */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
S  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
S  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
S  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
S  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
S  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
S  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
S  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
S  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
S  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
S  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
S  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
S        uint32_t RESERVED0[1U];
S  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
S  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
S  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
S        uint32_t RESERVED1[1U];
S  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
S  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
S  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
S        uint32_t RESERVED2[1U];
S  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
S  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
S  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
S} DWT_Type;
S
S/* DWT Control Register Definitions */
S#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
S#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
S
S#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
S#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
S
S#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
S#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
S
S#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
S#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
S
S#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
S#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
S
S#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
S#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
S
S#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
S#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
S
S#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
S#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
S
S#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
S#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
S
S#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
S#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
S
S#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
S#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
S
S#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
S#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
S
S#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
S#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
S
S#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
S#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
S
S#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
S#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
S
S#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
S#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
S
S#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
S#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
S
S#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
S#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
S
S/* DWT CPI Count Register Definitions */
S#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
S#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
S
S/* DWT Exception Overhead Count Register Definitions */
S#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
S#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
S
S/* DWT Sleep Count Register Definitions */
S#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
S#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
S
S/* DWT LSU Count Register Definitions */
S#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
S#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
S
S/* DWT Folded-instruction Count Register Definitions */
S#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
S#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
S
S/* DWT Comparator Mask Register Definitions */
S#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
S#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
S
S/* DWT Comparator Function Register Definitions */
S#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
S#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
S
S#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
S#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
S
S#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
S#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
S
S#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
S#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
S
S#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
S#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
S
S#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
S#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
S
S#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
S#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
S
S#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
S#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
S
S#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
S#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
S
S/*@}*/ /* end of group CMSIS_DWT */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
S  \brief    Type definitions for the Trace Port Interface (TPI)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Trace Port Interface Register (TPI).
S */
Stypedef struct
S{
S  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
S  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
S        uint32_t RESERVED0[2U];
S  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
S        uint32_t RESERVED1[55U];
S  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
S        uint32_t RESERVED2[131U];
S  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
S  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
S  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
S        uint32_t RESERVED3[759U];
S  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
S  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
S  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
S        uint32_t RESERVED4[1U];
S  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
S  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
S  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
S        uint32_t RESERVED5[39U];
S  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
S  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
S        uint32_t RESERVED7[8U];
S  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
S  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
S} TPI_Type;
S
S/* TPI Asynchronous Clock Prescaler Register Definitions */
S#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
S#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
S
S/* TPI Selected Pin Protocol Register Definitions */
S#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
S#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
S
S/* TPI Formatter and Flush Status Register Definitions */
S#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
S#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
S
S#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
S#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
S
S#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
S#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
S
S#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
S#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
S
S/* TPI Formatter and Flush Control Register Definitions */
S#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
S#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
S
S#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
S#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
S
S/* TPI TRIGGER Register Definitions */
S#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
S#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
S
S/* TPI Integration ETM Data Register Definitions (FIFO0) */
S#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
S#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
S
S#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
S#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
S
S#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
S#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
S
S#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
S#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
S
S#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
S#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
S
S#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
S#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
S
S#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
S#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
S
S/* TPI ITATBCTR2 Register Definitions */
S#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
S#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
S
S/* TPI Integration ITM Data Register Definitions (FIFO1) */
S#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
S#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
S
S#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
S#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
S
S#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
S#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
S
S#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
S#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
S
S#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
S#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
S
S#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
S#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
S
S#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
S#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
S
S/* TPI ITATBCTR0 Register Definitions */
S#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
S#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
S
S/* TPI Integration Mode Control Register Definitions */
S#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
S#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
S
S/* TPI DEVID Register Definitions */
S#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
S#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
S
S#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
S#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
S
S#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
S#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
S
S#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
S#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
S
S#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
S#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
S
S#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
S#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
S
S/* TPI DEVTYPE Register Definitions */
S#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
S#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
S
S#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
S#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
S
S/*@}*/ /* end of group CMSIS_TPI */
S
S
S#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
S  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
S  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
S  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
S#endif
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
S  \brief    Type definitions for the Core Debug Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Core Debug Register (CoreDebug).
S */
Stypedef struct
S{
S  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
S  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
S  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
S  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
S} CoreDebug_Type;
S
S/* Debug Halting Control and Status Register Definitions */
S#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
S#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
S
S#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
S#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
S
S#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
S#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
S
S#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
S#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
S
S#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
S#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
S
S#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
S#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
S
S#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
S#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
S
S#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
S#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
S
S#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
S#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
S
S#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
S#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
S
S#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
S#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
S
S#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
S#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
S
S/* Debug Core Register Selector Register Definitions */
S#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
S#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
S
S#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
S#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
S
S/* Debug Exception and Monitor Control Register Definitions */
S#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
S#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
S
S#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
S#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
S
S#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
S#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
S
S#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
S#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
S
S#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
S#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
S
S#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
S#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
S
S#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
S#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
S
S#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
S#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
S
S#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
S#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
S
S#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
S#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
S
S#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
S#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
S
S#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
S#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
S
S#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
S#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
S
S/*@} end of group CMSIS_CoreDebug */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_bitfield     Core register bit field macros
S  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
S  @{
S */
S
S/**
S  \brief   Mask and shift a bit field value for use in a register bit range.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
S  \return           Masked and shifted value.
S*/
S#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
S
S/**
S  \brief     Mask and shift a register value to extract a bit filed value.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
S  \return           Masked and shifted bit field value.
S*/
S#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
S
S/*@} end of group CMSIS_core_bitfield */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_base     Core Definitions
S  \brief      Definitions for base addresses, unions, and structures.
S  @{
S */
S
S/* Memory mapping of Core Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
S#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
S#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
S#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
S#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
S
S#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
S#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
S#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
S#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
S#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
S#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
S#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
S#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
S
S#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
S#endif
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Debug Functions
S  - Core Register Access Functions
S ******************************************************************************/
S/**
S  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
S  \brief    Functions that manage interrupts and exceptions via the NVIC.
S  @{
S */
S
S#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
S#else
S  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
S  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
S  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
S  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
S  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
S  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
S  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
S  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
S  #define NVIC_GetActive              __NVIC_GetActive
S  #define NVIC_SetPriority            __NVIC_SetPriority
S  #define NVIC_GetPriority            __NVIC_GetPriority
S  #define NVIC_SystemReset            __NVIC_SystemReset
S#endif /* CMSIS_NVIC_VIRTUAL */
S
S#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S   #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S#else
S  #define NVIC_SetVector              __NVIC_SetVector
S  #define NVIC_GetVector              __NVIC_GetVector
S#endif  /* (CMSIS_VECTAB_VIRTUAL) */
S
S#define NVIC_USER_IRQ_OFFSET          16
S
S
S
S/**
S  \brief   Set Priority Grouping
S  \details Sets the priority grouping field using the required unlock sequence.
S           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
S           Only values from 0..7 are used.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S  \param [in]      PriorityGroup  Priority grouping field.
S */
S__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
S{
S  uint32_t reg_value;
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
S
S  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
S  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
S  reg_value  =  (reg_value                                   |
S                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
S                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
S  SCB->AIRCR =  reg_value;
S}
S
S
S/**
S  \brief   Get Priority Grouping
S  \details Reads the priority grouping field from the NVIC Interrupt Controller.
S  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
S */
S__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
S{
S  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
S}
S
S
S/**
S  \brief   Enable Interrupt
S  \details Enables a device specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S  }
S}
S
S
S/**
S  \brief   Get Interrupt Enable status
S  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
S  \param [in]      IRQn  Device specific interrupt number.
S  \return             0  Interrupt is not enabled.
S  \return             1  Interrupt is enabled.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return((uint32_t)(((NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S  }
S  else
S  {
S    return(0U);
S  }
S}
S
S
S/**
S  \brief   Disable Interrupt
S  \details Disables a device specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S    __DSB();
S    __ISB();
S  }
S}
S
S
S/**
S  \brief   Get Pending Interrupt
S  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
S  \param [in]      IRQn  Device specific interrupt number.
S  \return             0  Interrupt status is not pending.
S  \return             1  Interrupt status is pending.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S  }
S  else
S  {
S    return(0U);
S  }
S}
S
S
S/**
S  \brief   Set Pending Interrupt
S  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S  }
S}
S
S
S/**
S  \brief   Clear Pending Interrupt
S  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S  }
S}
S
S
S/**
S  \brief   Get Active Interrupt
S  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
S  \param [in]      IRQn  Device specific interrupt number.
S  \return             0  Interrupt status is not active.
S  \return             1  Interrupt status is active.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S  }
S  else
S  {
S    return(0U);
S  }
S}
S
S
S/**
S  \brief   Set Interrupt Priority
S  \details Sets the priority of a device specific interrupt or a processor exception.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S  \param [in]      IRQn  Interrupt number.
S  \param [in]  priority  Priority to set.
S  \note    The priority cannot be set for every processor exception.
S */
S__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
S  }
S  else
S  {
S    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
S  }
S}
S
S
S/**
S  \brief   Get Interrupt Priority
S  \details Reads the priority of a device specific interrupt or a processor exception.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S  \param [in]   IRQn  Interrupt number.
S  \return             Interrupt Priority.
S                      Value is aligned automatically to the implemented priority bits of the microcontroller.
S */
S__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
S  }
S  else
S  {
S    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
S  }
S}
S
S
S/**
S  \brief   Encode Priority
S  \details Encodes the priority for an interrupt with the given priority group,
S           preemptive priority value, and subpriority value.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S  \param [in]     PriorityGroup  Used priority group.
S  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
S  \param [in]       SubPriority  Subpriority value (starting from 0).
S  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
S */
S__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
S  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
S
S  return (
S           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
S           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
S         );
S}
S
S
S/**
S  \brief   Decode Priority
S  \details Decodes an interrupt priority value with a given priority group to
S           preemptive priority value and subpriority value.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
S  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
S  \param [in]     PriorityGroup  Used priority group.
S  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
S  \param [out]     pSubPriority  Subpriority value (starting from 0).
S */
S__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
S  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
S
S  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
S  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
S}
S
S
S/**
S  \brief   Set Interrupt Vector
S  \details Sets an interrupt vector in SRAM based interrupt vector table.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S           VTOR must been relocated to SRAM before.
S  \param [in]   IRQn      Interrupt number
S  \param [in]   vector    Address of interrupt handler function
S */
S__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
S{
S  uint32_t *vectors = (uint32_t *)SCB->VTOR;
S  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
S}
S
S
S/**
S  \brief   Get Interrupt Vector
S  \details Reads an interrupt vector from interrupt vector table.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S  \param [in]   IRQn      Interrupt number.
S  \return                 Address of interrupt handler function
S */
S__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
S{
S  uint32_t *vectors = (uint32_t *)SCB->VTOR;
S  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
S}
S
S
S/**
S  \brief   System Reset
S  \details Initiates a system reset request to reset the MCU.
S */
S__STATIC_INLINE void __NVIC_SystemReset(void)
S{
S  __DSB();                                                          /* Ensure all outstanding memory accesses included
S                                                                       buffered write are completed before reset */
S  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
S                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
S                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
S  __DSB();                                                          /* Ensure completion of memory access */
S
S  for(;;)                                                           /* wait until reset */
S  {
S    __NOP();
S  }
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S/* ##########################  FPU functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_FpuFunctions FPU Functions
S  \brief    Function that provides FPU type.
S  @{
S */
S
S/**
S  \brief   get FPU type
S  \details returns the FPU type
S  \returns
S   - \b  0: No FPU
S   - \b  1: Single precision FPU
S   - \b  2: Double + Single precision FPU
S */
S__STATIC_INLINE uint32_t SCB_GetFPUType(void)
S{
S    return 0U;           /* No FPU */
S}
S
S
S/*@} end of CMSIS_Core_FpuFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
S  \brief    Functions that configure the System.
S  @{
S */
S
S#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
S
S/**
S  \brief   System Tick Configuration
S  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
S           Counter is in free running mode to generate periodic interrupts.
S  \param [in]  ticks  Number of ticks between two interrupts.
S  \return          0  Function succeeded.
S  \return          1  Function failed.
S  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S           must contain a vendor-specific implementation of this function.
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
S  {
S    return (1UL);                                                   /* Reload value impossible */
S  }
S
S  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
S  return (0UL);                                                     /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S/* ##################################### Debug In/Output function ########################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_core_DebugFunctions ITM Functions
S  \brief    Functions that access the ITM debug interface.
S  @{
S */
S
Sextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
S#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
S
S
S/**
S  \brief   ITM Send Character
S  \details Transmits a character via the ITM channel 0, and
S           \li Just returns when no debugger is connected that has booked the output.
S           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
S  \param [in]     ch  Character to transmit.
S  \returns            Character to transmit.
S */
S__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
S{
S  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
S      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
S  {
S    while (ITM->PORT[0U].u32 == 0UL)
S    {
S      __NOP();
S    }
S    ITM->PORT[0U].u8 = (uint8_t)ch;
S  }
S  return (ch);
S}
S
S
S/**
S  \brief   ITM Receive Character
S  \details Inputs a character via the external variable \ref ITM_RxBuffer.
S  \return             Received character.
S  \return         -1  No character pending.
S */
S__STATIC_INLINE int32_t ITM_ReceiveChar (void)
S{
S  int32_t ch = -1;                           /* no character available */
S
S  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
S  {
S    ch = ITM_RxBuffer;
S    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
S  }
S
S  return (ch);
S}
S
S
S/**
S  \brief   ITM Check Character
S  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
S  \return          0  No character available.
S  \return          1  Character available.
S */
S__STATIC_INLINE int32_t ITM_CheckChar (void)
S{
S
S  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
S  {
S    return (0);                              /* no character available */
S  }
S  else
S  {
S    return (1);                              /*    character available */
S  }
S}
S
S/*@} end of CMSIS_core_DebugFunctions */
S
S
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 30 "..\..\..\..\User\LL\include.h" 2
N#include "cmsis_compiler.h"
N//#include "cmsis_version.h"
N#include "tx_phe_system.h"
L 1 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe_system.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Device/Phoenix/include/tx_phe_system.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.1
N  * @date    03-08-2018
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File.
N  *          This file contains all the peripheral register's definitions, bits
N  *          definitions and memory mapping for Phoenix Connectivity line.
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripherals registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_SYSTEM_H
N#define __TX_PHE_SYSTEM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @defgroup   CONFIG_SETTING CONFIG_SETTING
N  * @brief Various configuration settings
N  * @{
N  */
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N#include "typedef.h"
N#include "tx_phe.h"
N
N/* Private define ------------------------------------------------------------*/
N/*! SDK version : v1.0.9
N */
N#define __SDK_VERSION                       0x010009UL
N     
N//#pragma import(__use_no_semihosting) 
N
N/*! system assert : check param valid
N */
N#define USE_ASSERT                         1
N
N/*! DEBUG_LEVEL : debug level select : [none | error | warning | all]
N */
N#define DEBUG_LEVEL                         DL_ALL
N
N/*! module debug macro : user can add self-defined module debug switch like this
N *  usage : change XXX to user module
N */
N#define XXX_DBG_EN                          1
N
N/*! APP_PARAM_ST_SECTOR : app vip param sector sections(bigger is better, Balanced wear)
N *  usage : the system API auto save param in this section
N */
N#define APP_PARAM_SECTORS                  20
N
N/*! SARADC config : force SARADC not use trim infomation 
N */
N#define __SARADC_TRIM_FORCE_OFF            0
N
N/*! FADC config : force FADC not use trim infomation 
N */
N#define __FADC_TRIM_FORCE_OFF              0
N
N/**
N  * @brief SYS_CLK define Max frequence value.
N  */
N#define SYS_CLK_MAX                                 82000000UL
N
N/**
N  * @brief __EPWM_FADC_ADPLL define Max frequence value.
N  */
N#define __EPWM_FADC_ADPLL_MAX                       360000000UL
N
N/*********************************************************************************/
N// system debug level : normal \ warning \ error \ none
N/*********************************************************************************/
N#define DL_NONE                             0
N#define DL_ERR                              1
N#define DL_WARNING                          2
N#define DL_ALL                              3
N
N#if (DL_NONE == DEBUG_LEVEL)
X#if (0 == 3)
S    #define DBG_ERR_EN                      0
S    #define DBG_WAR_EN                      0
S    #define DBG_NOR_EN                      0
S#elif (DL_ERR == DEBUG_LEVEL)
X#elif (1 == 3)
S    #define DBG_ERR_EN                      1
S    #define DBG_WAR_EN                      0
S    #define DBG_NOR_EN                      0
S#elif (DL_WARNING == DEBUG_LEVEL)
X#elif (2 == 3)
S    #define DBG_ERR_EN                      1
S    #define DBG_WAR_EN                      1
S    #define DBG_NOR_EN                      0
N#elif (DL_ALL == DEBUG_LEVEL)
X#elif (3 == 3)
N    #define DBG_ERR_EN                      1
N    #define DBG_WAR_EN                      1
N    #define DBG_NOR_EN                      1
N#endif
N
N/* Private macro -------------------------------------------------------------*/
N#if (DBG_ERR_EN)
X#if (1)
N    #define DBG_ERR(fmt, args...)           printf("[err]");       printf(fmt, ##args)
N    #define DBG_ERR_BUF(buf, len)           printf_array(buf, len)
N#else
S    #define DBG_ERR(...)
S    #define DBG_ERR_BUF(buf, len)
N#endif
N
N#if (DBG_WAR_EN)
X#if (1)
N    #define DBG_WAR(fmt, args...)           printf("[warning]");   printf(fmt, ##args)
N    #define DBG_WAR_BUF(buf, len)           printf_array(buf, len)
N#else
S    #define DBG_WAR(...)
S    #define DBG_WAR_BUF(buf, len)
N#endif
N
N#if (DBG_NOR_EN)
X#if (1)
N    #define DBG_NOR(fmt, args...)           printf(fmt, ##args)
N    #define DBG_NOR_BUF(buf, len)           printf_array(buf, len)
N#else
S    #define DBG_NOR(...)
S    #define DBG_NOR_BUF(buf, len)
N#endif
N
N/*********************************************************************************/
N// define each peripheral debug info
N/*********************************************************************************/
N#if (XXX_DBG_EN)
X#if (1)
N    #define XXX_DBG_NOR(fmt, args...)       DBG_NOR(fmt, ##args)
N    #define XXX_DBG_NOR_BUF(buf, len)       DBG_NOR_BUF(buf, len)
N#else
S    #define XXX_DBG_NOR(...)
S    #define XXX_DBG_NOR_BUF(buf, len)
N#endif
N
N
N/*********************************************************************************/
N/*    firmware update                                                            */
N/*********************************************************************************/
N/**
N  * @brief EFLASH firmware update cmd
N  */
Ntypedef enum {
N    /*! erase all app code
N     */    
N    FIRMWARE_UPDATE_CMD_ERASE_APP,
N    /*! erase special sectors in the buffer, use for "Incremental upgrade"
N     */    
N    FIRMWARE_UPDATE_CMD_ERASE_SECTORS,
N    /*! program buffer data to special addr
N     */    
N    FIRMWARE_UPDATE_CMD_PROGRAM,
N    /*! verify special addr data with buffer 
N     */    
N    FIRMWARE_UPDATE_CMD_VERIFY,
N    /*! when execute schedule : erase->program->verify is passed, 
N     *  use must kick cmd success to register new firmware.
N     */
N    FIRMWARE_UPDATE_CMD_REGISTER,
N    /*! reboot to execute new app code 
N     */    
N    FIRMWARE_UPDATE_CMD_REBOOT,
N} FIRMWARE_UPDATE_CMD;
N
N/** APP_CODE_SIZE
N  * this must same with scatter file & makecode.ini
N  */
N#define APP_CODE_SIZE                           (56 * 1024)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private variables ---------------------------------------------------------*/
Nextern void (* const __vector_handlers[])(void);
N     
Nextern volatile u32 SysTickCnt;
N
Nextern __IO uint32_t SYS_CLK;
Xextern volatile uint32_t SYS_CLK;
N
N/* Private function prototypes -----------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N
N/**
N  * @brief  system_critical_section_enter function
N  * @retval None
N  */
Nvoid system_critical_section_enter(void);
N
N/**
N  * @brief  system_critical_section_exit function
N  * @retval None
N  */
Nvoid system_critical_section_exit(void);
N
N/**
N  * @brief  Use the CPU to delay approximately us
N  * @param  n : the number of us to delay
N  * @retval None
N  */
Nvoid delay_us(u32 n);
N
N/**
N  * @brief  Use the CPU to delay approximately ms
N  * @param  n : the number of ms to delay
N  * @retval None
N  */
Nvoid delay_ms(u32 n);
N
N/**
N  * @brief  Setup the microcontroller system
N  *         Initialize the Embedded Flash Interface, the PLL and update the 
N  *         SYS_CLK variable.
N  * @retval None
N  * @note   This function should be used only after reset.
N  */
Nvoid system_init(void);
N
N/**
N  * @brief  is_systick_expired.
N  * @param  offset_ticks: current sys tick 
N  * @param  Texpire: offset ticks
N  * @retval return true or fault
N  */
Nu32 is_systick_expired(s32 offset_ticks, s32 Texpire);
N
N/**
N  * @brief  system_tick_init.
N  * @retval return true or fault
N  */
Nu32 system_tick_init(void);
N
N/**
N  * @brief  get_system_tick.
N  * @retval return the count of current systick
N  */
Nu32 get_system_tick(void);
N
N/**
N  * @brief  sys_update_firmware_handle
N  * @param  cmd    : FIRMWARE_UPDATE_CMD
N  * @param  addr   : address , base 0.
N  * @param  len    : length in unit 4Byte
N  * @param  p_data : data buffer
N  * @retval 1(success), 0(failed)
N  */
Nbool sys_update_firmware_handle(FIRMWARE_UPDATE_CMD cmd, u32 *p_data, u32 addr, u32 len);
N
N/**
N  * @brief  dump_fault_state : save vip param & printf cpu fault state
N  * @retval None
N  * @note : User can save vip param at here, restore vip param at next power-up or reset
N  */
Nvoid dump_fault_state(void);
N    
N/**
N  * @brief  recover_fault_state : recover vip param
N  * @retval None
N  * @note : restore vip param at next power-up or reset
N  */
Nvoid recover_fault_state(void);
N
N/**
N  * @brief  save vip param to eflash
N  * @param  p_data: param buffer
N  * @param  len   : length in unit 4Byte
N  * @retval 1(success), 0(failed)
N  * @note : User can save vip param at here, restore vip param at next power-up or reset
N  */
Nbool sys_save_data_to_eflash(u32 *p_data, u32 len);
N
N/**
N  * @brief  recover vip param from eflash
N  * @param  p_data: param buffer
N  * @param  len   : length in unit 4Byte
N  * @retval 1(success), 0(failed)
N  * @note : if the last param is wrong, we will found the latest ok-param instead
N  */
Nbool sys_recover_data_from_eflash(u32 *p_data, u32 len);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TX_PHE_SYSTEM_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 33 "..\..\..\..\User\LL\include.h" 2
N#include "tx_phe_assert.h"
L 1 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe_assert.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Device/Phoenix/include/tx_phe_assert.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
N  *          This file contains the system clock configuration for TX_PHE devices,
N  *          and is generated by the clock configuration tool.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_ASSERT_H
N#define __TX_PHE_ASSERT_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N    
N/** @addtogroup TX_PHE_ASSERT TX_PHE System
N  * @{
N  */
N     
N/** @addtogroup assert_interface_gr Assert 
N  * @ingroup  TX_PHE_ASSERT
N  * @{
N  */ 
N
N/** @defgroup ASSERT_Exported_Constants ASSERT Exported Constants
N  * @ingroup  assert_interface_gr
N  * @brief    ASSERT external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the low 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N    
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Includes ------------------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N
N#if defined(TXF6200)
X#if 1L
N#include "txf6200_assert.h"
L 1 "..\..\..\..\Libraries\Device\Phoenix\include\txf6200_assert.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Device/Phoenix/txf6200_assert.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
N  *          This file contains the system clock configuration for TXF6200 devices,
N  *          and is generated by the clock configuration tool.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TXF6200_ASSERT_H
N#define __TXF6200_ASSERT_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N    
N/** @addtogroup TXF6200_SYSTEM TXF6200 System
N  * @{
N  */
N     
N/** @addtogroup assert_interface_gr Assert 
N  * @ingroup  TXF6200_SYSTEM
N  * @{
N  */ 
N
N/** @defgroup ASSERT_Exported_Constants ASSERT Exported Constants
N  * @ingroup  assert_interface_gr
N  * @brief    ASSERT external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the low 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N    
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Includes ------------------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N    
N    
N/*! SRAM start address macro definition
N */
N#define SRAM_START_ADDR                     ((u32)0x20000000)
N/*! SRAM EFLASH start address macro definition
N */
N#define SRAM_EFLASH_ADDR                    ((u32)0x08000000)
N
N
N/*! SRAM size, 4KB space, maximum access unit 64bit.
N */
N#define SRAM_LEN_4KB_64b                    ((u32)0x8000)
N/*! SRAM size, 1KB space, maximum access unit 64bit.
N */
N#define SRAM_LEN_1KB_64b                    ((u32)0x2000)
N/*! SRAM size, 256B space, maximum access unit 64bit.
N */
N#define SRAM_LEN_256B_64b                   ((u32)0x800)
N/*! SRAM size, 128B space, maximum access unit 256bit.
N */
N#define SRAM_LEN_128B_128b                  ((u32)0x800)
N/*! EFLASH size, 32kB space, maximum access unit 32bit.
N */
N#define SRAM_LEN_EFLASH_32KB_32b            ((u32)0x20000)
N
N                                                    
N/*! Define the minimum unit value of the sram buffer: : 1 Byte 
N */
N#define SRAM_BUF_UINT_1BYTE                 (1UL)
N/*! Define the minimum unit value of the sram buffer: : 2 Byte 
N */
N#define SRAM_BUF_UINT_2BYTE                 (2UL)
N/*! Define the minimum unit value of the sram buffer: : 4 Byte 
N */
N#define SRAM_BUF_UINT_4BYTE                 (4UL)
N/*! Define the minimum unit value of the sram buffer: : 8 Byte 
N */
N#define SRAM_BUF_UINT_8BYTE                 (8UL)
N
N
N/*! Define the buffer address alignment mask in SRAM: 1 Byte. 
N */
N#define SRAM_BUF_ALIGNMEMT_1BYTE_MASK       (0UL)
N/*! Define the buffer address alignment mask in SRAM: 2 Byte. 
N */
N#define SRAM_BUF_ALIGNMEMT_1BYTE_MASK       (0UL)
N/*! Define the buffer address alignment mask in SRAM: 2 Byte. 
N */
N#define SRAM_BUF_ALIGNMEMT_2BYTE_MASK       (1UL)
N/*! Define the buffer address alignment mask in SRAM: 4 Byte. 
N */
N#define SRAM_BUF_ALIGNMEMT_4BYTE_MASK       (3UL)
N/*! Define the buffer address alignment mask in SRAM: 8 Byte. 
N */
N#define SRAM_BUF_ALIGNMEMT_8BYTE_MASK       (7UL)
N
N                                            
N/*! The start and end addresses of the space of SRAM0.
N */
N#define SRAM0_START_ADDR                    (SRAM_START_ADDR)
N#define SRAM0_END_ADDR                      (SRAM0_START_ADDR + SRAM_LEN_4KB_64b - 1)
N
N/*! The start and end addresses of the space of SRAM10.
N */
N#define SRAM10_START_ADDR                   (SRAM0_END_ADDR + 1)
N#define SRAM10_END_ADDR                     (SRAM10_START_ADDR + SRAM_LEN_4KB_64b - 1)
N
N/*! The start and end addresses of the space of SRAM1.
N */
N#define SRAM1_START_ADDR                    (SRAM10_END_ADDR + 1)
N#define SRAM1_END_ADDR                      (SRAM1_START_ADDR + SRAM_LEN_1KB_64b - 1)
N
N/*! The start and end addresses of the space of SRAM2.
N */
N#define SRAM2_START_ADDR                    (SRAM1_END_ADDR + 1)
N#define SRAM2_END_ADDR                      (SRAM2_START_ADDR + SRAM_LEN_1KB_64b - 1)
N
N/*! The start and end addresses of the space of SRAM3.
N */
N#define SRAM3_START_ADDR                    (SRAM2_END_ADDR + 1)
N#define SRAM3_END_ADDR                      (SRAM3_START_ADDR + SRAM_LEN_1KB_64b - 1)
N
N/*! The start and end addresses of the space of SRAM4.
N */
N#define SRAM4_START_ADDR                    (SRAM3_END_ADDR + 1)
N#define SRAM4_END_ADDR                      (SRAM4_START_ADDR + SRAM_LEN_256B_64b - 1)
N
N/*! The start and end addresses of the space of SRAM5.
N */
N#define SRAM5_START_ADDR                    (SRAM4_END_ADDR + 1)
N#define SRAM5_END_ADDR                      (SRAM5_START_ADDR + SRAM_LEN_256B_64b - 1)
N
N/*! The start and end addresses of the space of SRAM6.
N */
N#define SRAM6_START_ADDR                    (SRAM5_END_ADDR + 1)
N#define SRAM6_END_ADDR                      (SRAM6_START_ADDR + SRAM_LEN_256B_64b - 1)
N
N/*! The start and end addresses of the space of SRAM7.
N */
N#define SRAM7_START_ADDR                    (SRAM6_END_ADDR + 1)
N#define SRAM7_END_ADDR                      (SRAM7_START_ADDR + SRAM_LEN_256B_64b - 1)
N
N/*! The start and end addresses of the space of SRAM8.
N */
N#define SRAM8_START_ADDR                    (SRAM7_END_ADDR + 1)
N#define SRAM8_END_ADDR                      (SRAM8_START_ADDR + SRAM_LEN_256B_64b - 1)
N
N/*! The start and end addresses of the space of SRAM9.
N */
N#define SRAM9_START_ADDR                    (SRAM8_END_ADDR + 1)
N#define SRAM9_END_ADDR                      (SRAM9_START_ADDR + SRAM_LEN_256B_64b - 1)
N
N/*! The start and end addresses of the space of SRAM11.
N */
N#define SRAM11_START_ADDR                   (SRAM9_END_ADDR + 1)
N#define SRAM11_END_ADDR                     (SRAM11_START_ADDR + SRAM_LEN_128B_128b - 1)
N
N/*! The start and end addresses of the space of SRAM12.
N */
N#define SRAM12_START_ADDR                   (SRAM11_END_ADDR + 1)
N#define SRAM12_END_ADDR                     (SRAM12_START_ADDR + SRAM_LEN_128B_128b- 1)
N
N/*! The start and end addresses of the space of SRAM13.
N */
N#define SRAM13_START_ADDR                   (SRAM12_END_ADDR + 1)
N#define SRAM13_END_ADDR                     (SRAM13_START_ADDR + SRAM_LEN_128B_128b - 1)
N
N/*! The start and end addresses of the space of SRAM14.
N */
N#define SRAM14_START_ADDR                   (SRAM13_END_ADDR + 1)
N#define SRAM14_END_ADDR                     (SRAM14_START_ADDR + SRAM_LEN_128B_128b - 1)
N
N/*! The start and end addresses of the space of SRAM15.
N */
N#define SRAM15_START_ADDR                   (SRAM14_END_ADDR + 1)
N#define SRAM15_END_ADDR                     (SRAM15_START_ADDR + SRAM_LEN_128B_128b - 1)
N
N/*! The start and end addresses of the space of SRAM16.
N */
N#define SRAM16_START_ADDR                   (SRAM15_END_ADDR + 1)
N#define SRAM16_END_ADDR                     (SRAM16_START_ADDR + SRAM_LEN_128B_128b - 1)
N
N/*! The start and end addresses of the space of SRAM16.
N */
N#define SRAMEND_START_ADDR                  (SRAM16_END_ADDR + 1)
N#define SRAMEND_END_ADDR                    (SRAMEND_START_ADDR)
N
N/*! The start and end addresses of the space of eFLASH.
N */
N#define SRAM_EFLASH_START_ADDR              (SRAM_EFLASH_ADDR)
N#define SRAM_EFLASH_END_ADDR                (SRAM_EFLASH_START_ADDR + SRAM_LEN_EFLASH_32KB_32b - 1)
N
N/**
N  * @brief Enumerate the SRAM as a representation of the bit.
N  */
Ntypedef enum {                 
N    /*! SRAM0  is enumerated as BIT(0).
N     */
N    ASSERT_SRAM0  = BIT(0),
X    ASSERT_SRAM0  = ((uint32_t)1<<(0)),
N    /*! SRAM10 is enumerated as BIT(1).
N     */
N    ASSERT_SRAM10 = BIT(1),
X    ASSERT_SRAM10 = ((uint32_t)1<<(1)),
N    /*! SRAM1  is enumerated as BIT(2).
N     */
N    ASSERT_SRAM1  = BIT(2),
X    ASSERT_SRAM1  = ((uint32_t)1<<(2)),
N    /*! SRAM2  is enumerated as BIT(3).
N     */
N    ASSERT_SRAM2  = BIT(3),
X    ASSERT_SRAM2  = ((uint32_t)1<<(3)),
N    /*! SRAM3  is enumerated as BIT(4).
N     */
N    ASSERT_SRAM3  = BIT(4),
X    ASSERT_SRAM3  = ((uint32_t)1<<(4)),
N    /*! SRAM4  is enumerated as BIT(5).
N     */
N    ASSERT_SRAM4  = BIT(5),
X    ASSERT_SRAM4  = ((uint32_t)1<<(5)),
N    /*! SRAM5  is enumerated as BIT(6).
N     */
N    ASSERT_SRAM5  = BIT(6),
X    ASSERT_SRAM5  = ((uint32_t)1<<(6)),
N    /*! SRAM6  is enumerated as BIT(7).
N     */
N    ASSERT_SRAM6  = BIT(7),
X    ASSERT_SRAM6  = ((uint32_t)1<<(7)),
N    /*! SRAM7  is enumerated as BIT(8).
N     */
N    ASSERT_SRAM7  = BIT(8),
X    ASSERT_SRAM7  = ((uint32_t)1<<(8)),
N    /*! SRAM8  is enumerated as BIT(9).
N     */
N    ASSERT_SRAM8  = BIT(9),
X    ASSERT_SRAM8  = ((uint32_t)1<<(9)),
N    /*! SRAM9  is enumerated as BIT(10).
N     */
N    ASSERT_SRAM9  = BIT(10),
X    ASSERT_SRAM9  = ((uint32_t)1<<(10)),
N    /*! SRAM11 is enumerated as BIT(11).
N     */
N    ASSERT_SRAM11 = BIT(11),
X    ASSERT_SRAM11 = ((uint32_t)1<<(11)),
N    /*! SRAM12 is enumerated as BIT(12).
N     */
N    ASSERT_SRAM12 = BIT(12),
X    ASSERT_SRAM12 = ((uint32_t)1<<(12)),
N    /*! SRAM13 is enumerated as BIT(13).
N     */
N    ASSERT_SRAM13 = BIT(13),
X    ASSERT_SRAM13 = ((uint32_t)1<<(13)),
N    /*! SRAM14 is enumerated as BIT(14).
N    */
N    ASSERT_SRAM14 = BIT(14),
X    ASSERT_SRAM14 = ((uint32_t)1<<(14)),
N    /*! SRAM15 is enumerated as BIT(15).
N     */
N    ASSERT_SRAM15 = BIT(15),
X    ASSERT_SRAM15 = ((uint32_t)1<<(15)),
N    /*! SRAM16 is enumerated as BIT(16).
N     */
N    ASSERT_SRAM16 = BIT(16),
X    ASSERT_SRAM16 = ((uint32_t)1<<(16)),
N    /*! EFLASH is enumerated as BIT(17).
N     */
N    ASSERT_EFLASH = BIT(17),
X    ASSERT_EFLASH = ((uint32_t)1<<(17)),
N    /*! SRAM END is enumerated as BIT(18).
N     */
N    ASSERT_SRAMEND = BIT(18),
X    ASSERT_SRAMEND = ((uint32_t)1<<(18)),
N} TYPE_ENUM_ASSERT_SRAM;
N
N/*! GPDMA addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_GPDMA_MASK                    (ASSERT_SRAM0 | ASSERT_SRAM10 | ASSERT_SRAM1 | \
N                                            ASSERT_SRAM2 | ASSERT_SRAM3  | ASSERT_EFLASH)
X#define SRAM_GPDMA_MASK                    (ASSERT_SRAM0 | ASSERT_SRAM10 | ASSERT_SRAM1 |                                             ASSERT_SRAM2 | ASSERT_SRAM3  | ASSERT_EFLASH)
N
N/*! CRC DMA addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_CRC_DMA_MASK                   (ASSERT_SRAM0 | ASSERT_SRAM10)
N
N/*! GMAC TXFIFO addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_GMAC_TXFIFO_MASK               (ASSERT_SRAM2)
N/*! GMAC RXFIFO addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_GMAC_RXFIFO_MASK               (ASSERT_SRAM3)
N/*! GMAC DMA addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_GMAC_DMA_MASK                  (ASSERT_SRAM0 | ASSERT_SRAM10 | ASSERT_SRAM1)
N
N/*! SINCOS0 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_SINCOS0_MASK                   (ASSERT_SRAM0 | ASSERT_SRAM1 | ASSERT_SRAM2 | \
N                                             ASSERT_SRAM3)
X#define SRAM_SINCOS0_MASK                   (ASSERT_SRAM0 | ASSERT_SRAM1 | ASSERT_SRAM2 |                                              ASSERT_SRAM3)
N/*! SINCOS1 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_SINCOS1_MASK                   (ASSERT_SRAM0 | ASSERT_SRAM1 | ASSERT_SRAM2 | \
N                                             ASSERT_SRAM3)
X#define SRAM_SINCOS1_MASK                   (ASSERT_SRAM0 | ASSERT_SRAM1 | ASSERT_SRAM2 |                                              ASSERT_SRAM3)
N
N/*! RMS0 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_RMS0_MASK                      (ASSERT_SRAM0 | ASSERT_SRAM1 | ASSERT_SRAM2 | \
N                                             ASSERT_SRAM3)
X#define SRAM_RMS0_MASK                      (ASSERT_SRAM0 | ASSERT_SRAM1 | ASSERT_SRAM2 |                                              ASSERT_SRAM3)
N/*! RMS1 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_RMS1_MASK                      (ASSERT_SRAM0 | ASSERT_SRAM1 | ASSERT_SRAM2 | \
N                                             ASSERT_SRAM3)
X#define SRAM_RMS1_MASK                      (ASSERT_SRAM0 | ASSERT_SRAM1 | ASSERT_SRAM2 |                                              ASSERT_SRAM3)
N/*! RMS02 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_RMS2_MASK                      (ASSERT_SRAM0 | ASSERT_SRAM1 | ASSERT_SRAM2 | \
N                                             ASSERT_SRAM3)
X#define SRAM_RMS2_MASK                      (ASSERT_SRAM0 | ASSERT_SRAM1 | ASSERT_SRAM2 |                                              ASSERT_SRAM3)
N
N/*! MATRIX X addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_MATRIX_X_MASK                  (ASSERT_SRAM1)
N/*! MATRIX_Y addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_MATRIX_Y_MASK                  (ASSERT_SRAM2)
N/*! MATRIX_Z addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_MATRIX_Z_MASK                  (ASSERT_SRAM3)
N
N/*! HCC FFT addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_HC_FFT_MASK                    (ASSERT_SRAM0 | ASSERT_SRAM4 | ASSERT_SRAM5 | \
N                                             ASSERT_SRAM6 | ASSERT_SRAM7 | ASSERT_SRAM8 | \
N                                             ASSERT_SRAM9)
X#define SRAM_HC_FFT_MASK                    (ASSERT_SRAM0 | ASSERT_SRAM4 | ASSERT_SRAM5 |                                              ASSERT_SRAM6 | ASSERT_SRAM7 | ASSERT_SRAM8 |                                              ASSERT_SRAM9)
N/*! HCC PHASE addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_HC_PHS_MASK                    (ASSERT_SRAM0 | ASSERT_SRAM10)
N/*! HHC Rang addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_HC_RANG_MASK                   (ASSERT_SRAM0 | ASSERT_SRAM10)
N
N/*! FFT0 REAL addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT0_REAL_MASK                 (ASSERT_SRAM1)
N/*! FFT0 IMAG addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT0_IMAG_MASK                 (ASSERT_SRAM2)
N/*! FFT0 WINDOW addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT0_WINDOW_MASK               (ASSERT_SRAM0)
N/*! FFT0 REALIMAG addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT0_REALIMAG_MASK             (ASSERT_SRAM4 | ASSERT_SRAM5)
N/*! FFT0 RAM addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT0_RAM_MASK                  (ASSERT_SRAM4 | ASSERT_SRAM5)
N/*! FFT1 REAL addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT1_REAL_MASK                 (ASSERT_SRAM2)
N/*! FFT1 IMAG addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT1_IMAG_MASK                 (ASSERT_SRAM3)
N/*! FFT1 WINDOW addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT1_WINDOW_MASK               (ASSERT_SRAM0)
N/*! FFT1 REALIMAG addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT1_REALIMAG_MASK             (ASSERT_SRAM6 | ASSERT_SRAM7)
N/*! FFT1 RAM addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT1_RAM_MASK                  (ASSERT_SRAM6 | ASSERT_SRAM7)
N/*! FFT2 REAL addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT2_REAL_MASK                 (ASSERT_SRAM3)
N/*! FFT2 IMAG addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT2_IMAG_MASK                 (ASSERT_SRAM1)
N/*! FFT2 WINDOW addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT2_WINDOW_MASK               (ASSERT_SRAM0)
N/*! FFT2 REALIMAG addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT2_REALIMAG_MASK             (ASSERT_SRAM8 | ASSERT_SRAM9)
N/*! FFT2 RAM addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FFT2_RAM_MASK                  (ASSERT_SRAM8 | ASSERT_SRAM9)
N
N/*! ARC TRIANGLE 0 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_ARC_TRIANGLE_0_MASK            (ASSERT_SRAM1 | ASSERT_SRAM2 | ASSERT_SRAM3 | \
N                                             ASSERT_SRAM4 | ASSERT_SRAM5)
X#define SRAM_ARC_TRIANGLE_0_MASK            (ASSERT_SRAM1 | ASSERT_SRAM2 | ASSERT_SRAM3 |                                              ASSERT_SRAM4 | ASSERT_SRAM5)
N/*! ARC TRIANGLE 1 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_ARC_TRIANGLE_1_MASK            (ASSERT_SRAM1 | ASSERT_SRAM2 | ASSERT_SRAM3 | \
N                                             ASSERT_SRAM6 | ASSERT_SRAM7)
X#define SRAM_ARC_TRIANGLE_1_MASK            (ASSERT_SRAM1 | ASSERT_SRAM2 | ASSERT_SRAM3 |                                              ASSERT_SRAM6 | ASSERT_SRAM7)
N/*! ARC TRIANGLE 2 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_ARC_TRIANGLE_2_MASK            (ASSERT_SRAM1 | ASSERT_SRAM2 | ASSERT_SRAM3 | \
N                                             ASSERT_SRAM8 | ASSERT_SRAM9)
X#define SRAM_ARC_TRIANGLE_2_MASK            (ASSERT_SRAM1 | ASSERT_SRAM2 | ASSERT_SRAM3 |                                              ASSERT_SRAM8 | ASSERT_SRAM9)
N
N/*! DFT0 REAL addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_DFT0_REAL_MASK                 (ASSERT_SRAM1)
N/*! DFT0 IMAG addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_DFT0_IMAG_MASK                 (ASSERT_SRAM2)
N/*! DFT1 REAL addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_DFT1_REAL_MASK                 (ASSERT_SRAM2)
N/*! DFT1 IMAG addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_DFT1_IMAG_MASK                 (ASSERT_SRAM3)
N/*! DFT2 REAL addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_DFT2_REAL_MASK                 (ASSERT_SRAM3)
N/*! DFT2 IMAG addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_DFT2_IMAG_MASK                 (ASSERT_SRAM1)
N
N/*! DATADMA source addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_DATADMA_SRC_MASK               (ASSERT_SRAM0 | ASSERT_SRAM10 | ASSERT_SRAM1 | \
N                                             ASSERT_SRAM2 | ASSERT_SRAM3  | ASSERT_SRAM4 | \
N                                             ASSERT_SRAM5 | ASSERT_SRAM6  | ASSERT_SRAM7 | \
N                                             ASSERT_SRAM8 | ASSERT_SRAM9)
X#define SRAM_DATADMA_SRC_MASK               (ASSERT_SRAM0 | ASSERT_SRAM10 | ASSERT_SRAM1 |                                              ASSERT_SRAM2 | ASSERT_SRAM3  | ASSERT_SRAM4 |                                              ASSERT_SRAM5 | ASSERT_SRAM6  | ASSERT_SRAM7 |                                              ASSERT_SRAM8 | ASSERT_SRAM9)
N/*! DATADMA Destination addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM. 
N */
N#define SRAM_DATADMA_DST_MASK               (ASSERT_SRAM0 | ASSERT_SRAM10 | ASSERT_SRAM1 | \
N                                             ASSERT_SRAM2 | ASSERT_SRAM3  | ASSERT_SRAM4 | \
N                                             ASSERT_SRAM5 | ASSERT_SRAM6  | ASSERT_SRAM7 | \
N                                             ASSERT_SRAM8 | ASSERT_SRAM9)
X#define SRAM_DATADMA_DST_MASK               (ASSERT_SRAM0 | ASSERT_SRAM10 | ASSERT_SRAM1 |                                              ASSERT_SRAM2 | ASSERT_SRAM3  | ASSERT_SRAM4 |                                              ASSERT_SRAM5 | ASSERT_SRAM6  | ASSERT_SRAM7 |                                              ASSERT_SRAM8 | ASSERT_SRAM9)
N                                             
N/*! SARADC DMA addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_SARADC_DMA_MASK                (ASSERT_SRAM0 | ASSERT_SRAM10 | ASSERT_SRAM1 | \
N                                             ASSERT_SRAM2 | ASSERT_SRAM3)
X#define SRAM_SARADC_DMA_MASK                (ASSERT_SRAM0 | ASSERT_SRAM10 | ASSERT_SRAM1 |                                              ASSERT_SRAM2 | ASSERT_SRAM3)
N
N/*! IIR CONFIG0 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_IIR_CONFIG0_MASK               (ASSERT_SRAM11)
N/*! IIR CONFIG1 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_IIR_CONFIG1_MASK               (ASSERT_SRAM12)
N/*! IIR CONFIG2 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_IIR_CONFIG2_MASK               (ASSERT_SRAM13)
N/*! IIR COEF0 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_IIR_COEF0_MASK                 (ASSERT_SRAM14)
N/*! IIR COEF1 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_IIR_COEF1_MASK                 (ASSERT_SRAM15)
N/*! IIR COEF2 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM. 
N */
N#define SRAM_IIR_COEF2_MASK                 (ASSERT_SRAM16)
N/*! IIR DATA0 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_IIR_DATA0_MASK                 (ASSERT_SRAM1)
N/*! IIR DATA1 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_IIR_DATA1_MASK                 (ASSERT_SRAM2)
N/*! IIR DATA2 addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_IIR_DATA2_MASK                 (ASSERT_SRAM3)
N
N/*! FIR CONFIG addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FIR_CONFIG_MASK                (ASSERT_SRAM0)
N/*! FIR0 DATA addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FIR0_DATA_MASK                 (ASSERT_SRAM1)
N/*! FIR1 DATA addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FIR1_DATA_MASK                 (ASSERT_SRAM2)
N/*! FIR2 DATA addr supports access to the SRAM and defines its macro as TYPE_ENUM_ASSERT_SRAM.
N */
N#define SRAM_FIR2_DATA_MASK                 (ASSERT_SRAM3)
N
N
N/*! Define GPDMA module buffer address alignment mask.
N */
N#define SRAM_GPDMA_ALIGN_MASK               SRAM_BUF_ALIGNMEMT_1BYTE_MASK
N
N/*! Define CRC DMA module buffer address alignment mask.
N */
N#define SRAM_CRC_DMA_ALIGN_MASK             SRAM_BUF_ALIGNMEMT_4BYTE_MASK
N
N/*! Define GMAC TXFIFO module buffer address alignment mask.
N */
N#define SRAM_GMAC_TXFIFO_ALIGN_MASK         SRAM_BUF_ALIGNMEMT_4BYTE_MASK
N/*! Define GMAC RXFIFO module buffer address alignment mask.
N */
N#define SRAM_GMAC_RXFIFO_ALIGN_MASK         SRAM_BUF_ALIGNMEMT_4BYTE_MASK
N/*! Define GMAC DMA module buffer address alignment mask.
N */
N#define SRAM_GMAC_DMA_ALIGN_MASK            SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N
N/*! Define SINCOS0 module buffer address alignment mask.
N */
N#define SRAM_SINCOS0_ALIGN_MASK             SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define SINCOS1 module buffer address alignment mask.
N */
N#define SRAM_SINCOS1_ALIGN_MASK             SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N
N/*! Define RMS0 module buffer address alignment mask.
N */
N#define SRAM_RMS0_ALIGN_MASK                SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define RMS1 module buffer address alignment mask.
N */
N#define SRAM_RMS1_ALIGN_MASK                SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define RMS2 module buffer address alignment mask.
N */
N#define SRAM_RMS2_ALIGN_MASK                SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N
N/*! Define MATRIX X module buffer address alignment mask.
N */
N#define SRAM_MATRIX_X_ALIGN_MASK            SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define MATRIX_Y module buffer address alignment mask.
N */
N#define SRAM_MATRIX_Y_ALIGN_MASK            SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define MATRIX_Z module buffer address alignment mask.
N */
N#define SRAM_MATRIX_Z_ALIGN_MASK            SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N
N/*! Define HCC FFT module buffer address alignment mask.
N */
N#define SRAM_HC_FFT_ALIGN_MASK              SRAM_BUF_ALIGNMEMT_4BYTE_MASK
N/*! Define HCC PHASE module buffer address alignment mask.
N */
N#define SRAM_HC_PHS_ALIGN_MASK              SRAM_BUF_ALIGNMEMT_4BYTE_MASK
N/*! Define HHC Rang module buffer address alignment mask.
N */
N#define SRAM_HC_RANG_ALIGN_MASK             SRAM_BUF_ALIGNMEMT_4BYTE_MASK
N
N/*! Define FFT0 REAL module buffer address alignment mask. 
N */
N#define SRAM_FFT0_REAL_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FFT0 IMAG module buffer address alignment mask.
N */
N#define SRAM_FFT0_IMAG_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FFT0 WINDOW module buffer address alignment mask.
N */
N#define SRAM_FFT0_WINDOW_ALIGN_MASK         SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FFT0 REALIMAG module buffer address alignment mask.
N */
N#define SRAM_FFT0_REALIMAG_ALIGN_MASK       SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define FFT0 RAM module buffer address alignment mask.
N */
N#define SRAM_FFT0_RAM_ALIGN_MASK            SRAM_BUF_ALIGNMEMT_4BYTE_MASK
N/*! Define FFT1 REAL module buffer address alignment mask.
N */
N#define SRAM_FFT1_REAL_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FFT1 IMAG module buffer address alignment mask.
N */
N#define SRAM_FFT1_IMAG_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FFT1 WINDOW module buffer address alignment mask.
N */
N#define SRAM_FFT1_WINDOW_ALIGN_MASK         SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FFT1 REALIMAG module buffer address alignment mask.
N */
N#define SRAM_FFT1_REALIMAG_ALIGN_MASK       SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define FFT1 RAM module buffer address alignment mask.
N */
N#define SRAM_FFT1_RAM_ALIGN_MASK            SRAM_BUF_ALIGNMEMT_4BYTE_MASK
N/*! Define FFT2 REAL module buffer address alignment mask.
N */
N#define SRAM_FFT2_REAL_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FFT2 IMAG module buffer address alignment mask.
N */
N#define SRAM_FFT2_IMAG_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FFT2 WINDOW module buffer address alignment mask.
N */
N#define SRAM_FFT2_WINDOW_ALIGN_MASK         SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FFT2 REALIMAG module buffer address alignment mask.
N */
N#define SRAM_FFT2_REALIMAG_ALIGN_MASK       SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define FFT2 RAM module buffer address alignment mask.
N */
N#define SRAM_FFT2_RAM_ALIGN_MASK            SRAM_BUF_ALIGNMEMT_4BYTE_MASK
N
N/*! Define ARC TRIANGLE 0 module buffer address alignment mask.
N */
N#define SRAM_ARC_TRIANGLE_0_ALIGN_MASK      SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define ARC TRIANGLE 1 module buffer address alignment mask.
N */
N#define SRAM_ARC_TRIANGLE_1_ALIGN_MASK      SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define ARC TRIANGLE 2 module buffer address alignment mask.
N */
N#define SRAM_ARC_TRIANGLE_2_ALIGN_MASK      SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N
N/*! Define DFT0 REAL module buffer address alignment mask.
N */
N#define SRAM_DFT0_REAL_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define DFT0 IMAG module buffer address alignment mask.
N */
N#define SRAM_DFT0_IMAG_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define DFT0 output module buffer address alignment mask.
N */
N#define SRAM_DFT0_OUT_ALIGN_MASK            SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define DFT1 REAL module buffer address alignment mask.
N */
N#define SRAM_DFT1_REAL_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define DFT1 IMAG module buffer address alignment mask.
N */
N#define SRAM_DFT1_IMAG_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define DFT1 output module buffer address alignment mask.
N */
N#define SRAM_DFT1_OUT_ALIGN_MASK            SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define DFT2 REAL module buffer address alignment mask.
N */
N#define SRAM_DFT2_REAL_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define DFT2 IMAG module buffer address alignment mask.
N */
N#define SRAM_DFT2_IMAG_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define DFT2 output module buffer address alignment mask.
N */
N#define SRAM_DFT2_OUT_ALIGN_MASK            SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N
N/*! Define DATADMA source module buffer address alignment mask.
N */
N#define SRAM_DATADMA_SRC_ALIGN_MASK         SRAM_BUF_ALIGNMEMT_1BYTE_MASK
N/*! Define DATADMA Destination module buffer address alignment mask.
N */
N#define SRAM_DATADMA_DST_ALIGN_MASK         SRAM_BUF_ALIGNMEMT_1BYTE_MASK
N
N/*! Define SARADC DMA module buffer address alignment mask.
N */
N#define SRAM_SARADC_DMA_ALIGN_MASK          SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N
N/*! Define IIR CONFIG0 module buffer address alignment mask.
N */
N#define SRAM_IIR_CONFIG0_ALIGN_MASK         SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define IIR CONFIG1 module buffer address alignment mask.
N */
N#define SRAM_IIR_CONFIG1_ALIGN_MASK         SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define IIR CONFIG2 module buffer address alignment mask.
N */
N#define SRAM_IIR_CONFIG2_ALIGN_MASK         SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define IIR COEF0 module buffer address alignment mask.
N */
N#define SRAM_IIR_COEF0_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define IIR COEF1 module buffer address alignment mask.
N */
N#define SRAM_IIR_COEF1_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define IIR COEF2 module buffer address alignment mask.
N */
N#define SRAM_IIR_COEF2_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define IIR DATA0 module buffer address alignment mask.
N */
N#define SRAM_IIR_DATA0_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define IIR DATA1 module buffer address alignment mask.
N */
N#define SRAM_IIR_DATA1_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define IIR DATA2 module buffer address alignment mask.
N */
N#define SRAM_IIR_DATA2_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N
N/*! Define FIR CONFIG module buffer address alignment mask.
N */
N#define SRAM_FIR_CONFIG_ALIGN_MASK          SRAM_BUF_ALIGNMEMT_8BYTE_MASK
N/*! Define FIR0 DATA module buffer address alignment mask.
N */
N#define SRAM_FIR0_DATA_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FIR1 DATA module buffer address alignment mask.
N */
N#define SRAM_FIR1_DATA_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N/*! Define FIR2 DATA module buffer address alignment mask.
N */
N#define SRAM_FIR2_DATA_ALIGN_MASK           SRAM_BUF_ALIGNMEMT_2BYTE_MASK
N
N/**
N  * @}
N  */
N  
N/** @defgroup ASSERT_Data_Handle ASSERT Data Handle functions
N  * @ingroup  assert_interface_gr
N  * @brief    ASSERT Data Handle functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data Handle functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the ASSERT data 
N    Handle.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* __TXF6200_ASSERT_H */
N
N
N/************************ (C) COPYRIGHT TXMicroelectronics *****END OF FILE****/
L 64 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe_assert.h" 2
N#elif  defined (TXF5200)
S#include "txf5200_assert.h"
S#else
S#error "phoenix sdk target device error!!!"
N#endif
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup ASSERT_Data_Handle ASSERT Data Handle functions
N  * @ingroup  assert_interface_gr
N  * @brief    ASSERT Data Handle functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data Handle functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the ASSERT data 
N    Handle.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N#if USE_ASSERT
X#if 1
N
N/**
N  * @brief  Reports the name of the source file and the source line number
N  *         where the assert_param error has occurred.
N  * @param  p_file: pointer to the source file name
N  * @param  line  : assert_param error line source number
N  * @retval None
N  */
Nvoid tx_assert_false(u8 *p_file, u32 line);
N
N/**
N  * @brief  Reports the name of the source file and the source line number
N  *         where the assert_param error has occurred.
N  * @param  start_adr   : The starting address of the parameter.
N  * @param  len         : The length of the buffer, the minimum unit is calculated as 1 byte.
N  * @param  sram_mask   : The SRAM threshold supported by the module.
N  * @param  align_mask  : Threshold value for buffer address alignment.
N  * @param  p_file      : pointer to the source file name
N  * @param  line        : assert_param error line source number
N  * @retval None
N  */
Nvoid tx_assert_address(u32  start_adr, 
N                       u32  len, 
N                       u32  sram_mask, 
N                       u32  align_mask,
N                       u8  *p_file, 
N                       u32  line);
N
N/**
N  * @brief  Assert the effective value of the parameter
N  * @param  expr: Enter the expression that asserts the parameter.
N  * @retval None
N  */
N#define TX_ASSERT(expr)                           ((expr) ? (void)0U : tx_assert_false((uint8_t *)__FILE__, __LINE__))
N
N/**
N  * @brief  Reports the name of the source file and the source line number
N  *         where the assert_param error has occurred.
N  * @param  start_adr: The starting address of the parameter.
N  * @param  len: The length of the buffer, the minimum unit is calculated as 1 byte.
N  * @param  sram_mask: The SRAM threshold supported by the module.
N  * @param  align_mask: Threshold value for buffer address alignment.
N  * @retval None
N  */
N#define TX_ASSERT_ADDR(start_adr, len, sram_mask, align_mask)    tx_assert_address(start_adr, len, sram_mask, align_mask, \
N                                                                                   (uint8_t *)__FILE__, __LINE__)
X#define TX_ASSERT_ADDR(start_adr, len, sram_mask, align_mask)    tx_assert_address(start_adr, len, sram_mask, align_mask,                                                                                    (uint8_t *)__FILE__, __LINE__)
N
N#else
S
S/**
S  * @brief  Assert the effective value of the parameter
S  * @param  expr: Enter the expression that asserts the parameter.
S  * @retval None
S  */
S#define TX_ASSERT(expr)                                          ((void)0U)
S    
S/**
S  * @brief  Reports the name of the source file and the source line number
S  *         where the assert_param error has occurred.
S  * @param  start_adr: The starting address of the parameter.
S  * @param  len: The length of the buffer, the minimum unit is calculated as 1 byte.
S  * @param  sram_mask: The SRAM threshold supported by the module.
S  * @param  align_mask: Threshold value for buffer address alignment.
S  * @retval None
S  */
S#define TX_ASSERT_ADDR(start_adr, len, sram_mask, align_mask)    ((void)0U)
S
N#endif /* USE_ASSERT */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* __TX_PHE_ASSERT_H */
N
N
N/************************ (C) COPYRIGHT TXMicroelectronics *****END OF FILE****/
N
L 34 "..\..\..\..\User\LL\include.h" 2
N#include "tx_phe_ll_module.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_module.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   Header file collection of various modules
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_MODULE_H
N#define __TX_PHE_LL_MODULE_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N#include "tx_phe_misc.h"
L 1 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe_misc.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Device/Phoenix/include/tx_phe_misc.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the functions prototypes for the miscellaneous
N  *          firmware library functions (add-on to CMSIS functions).
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_HAL_MISC_H
N#define __TX_PHE_HAL_MISC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N#include "core_cm3.h"
L 1 "..\..\..\..\Libraries\CMSIS\Core\Include\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
S#define __CORE_CM3_H_GENERIC
S
S#include <stdint.h>
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/**
S  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
S  CMSIS violates the following MISRA-C:2004 rules:
S
S   \li Required Rule 8.5, object/function definition in header file.<br>
S     Function definitions in header files are used to allow 'inlining'.
S
S   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
S     Unions are used for effective representation of core registers.
S
S   \li Advisory Rule 19.7, Function-like macro defined.<br>
S     Function-like macros are used to allow more efficient code.
S */
S
S
S/*******************************************************************************
S *                 CMSIS definitions
S ******************************************************************************/
S/**
S  \ingroup Cortex_M3
S  @{
S */
S
S#include "cmsis_version.h"
S 
S/*  CMSIS CM3 definitions */
S#define __CM3_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
S#define __CM3_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
S#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) | \
S                                    __CM3_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) |                                     __CM3_CMSIS_VERSION_SUB           )   
S
S#define __CORTEX_M                (3U)                                   /*!< Cortex-M Core */
S
S/** __FPU_USED indicates whether an FPU is used or not.
S    This core does not support an FPU at all
S*/
S#define __FPU_USED       0U
S
S#if defined ( __CC_ARM )
S  #if defined __TARGET_FPU_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#endif
S
S#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
S#define __CORE_CM3_H_DEPENDANT
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* check device defines and use defaults */
S#if defined __CHECK_DEVICE_DEFINES
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200U
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
S#endif
S
S/* IO definitions (access restrictions to peripheral registers) */
S/**
S    \defgroup CMSIS_glob_defs CMSIS Global Defines
S
S    <strong>IO Type Qualifiers</strong> are used
S    \li to specify the access to peripheral variables.
S    \li for automatic generation of peripheral register debug information.
S*/
S#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
S#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions */
S#endif
S#define     __O     volatile             /*!< Defines 'write only' permissions */
S#define     __IO    volatile             /*!< Defines 'read / write' permissions */
S
S/* following defines should be used for structure members */
S#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
S#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
S#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
S
S/*@} end of group Cortex_M3 */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S  - Core Debug Register
S  - Core MPU Register
S ******************************************************************************/
S/**
S  \defgroup CMSIS_core_register Defines and Type Definitions
S  \brief Type definitions and defines for Cortex-M processor based devices.
S*/
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_CORE  Status and Control Registers
S  \brief      Core Register type definitions.
S  @{
S */
S
S/**
S  \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} APSR_Type;
S
S/* APSR Register Definitions */
S#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
S#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
S
S#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
S#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
S
S#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
S#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
S
S#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
S#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
S
S#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
S#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
S
S
S/**
S  \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} IPSR_Type;
S
S/* IPSR Register Definitions */
S#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
S#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
S    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
S    uint32_t _reserved1:8;               /*!< bit: 16..23  Reserved */
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
S    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} xPSR_Type;
S
S/* xPSR Register Definitions */
S#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
S#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
S
S#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
S#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
S
S#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
S#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
S
S#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
S#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
S
S#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
S#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
S
S#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
S#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
S
S#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
S#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
S
S#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
S#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
S
S#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
S#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
S    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} CONTROL_Type;
S
S/* CONTROL Register Definitions */
S#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
S#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
S
S#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
S#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
S
S/*@} end of group CMSIS_CORE */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
S  \brief      Type definitions for the NVIC Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
S        uint32_t RESERVED0[24U];
S  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
S        uint32_t RSERVED1[24U];
S  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
S        uint32_t RESERVED2[24U];
S  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
S        uint32_t RESERVED3[24U];
S  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
S        uint32_t RESERVED4[56U];
S  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
S        uint32_t RESERVED5[644U];
S  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
S}  NVIC_Type;
S
S/* Software Triggered Interrupt Register Definitions */
S#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
S#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
S
S/*@} end of group CMSIS_NVIC */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCB     System Control Block (SCB)
S  \brief    Type definitions for the System Control Block Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
S  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
S  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
S  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
S  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
S  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
S  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
S  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
S  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
S  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
S  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
S  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
S  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
S  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
S  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
S  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
S  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
S  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
S  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
S        uint32_t RESERVED0[5U];
S  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
S} SCB_Type;
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
S#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
S
S/* SCB Vector Table Offset Register Definitions */
S#if defined (__CM3_REV) && (__CM3_REV < 0x0201U)                   /* core r2p1 */
S#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
S#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
S
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
S#else
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
S#endif
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
S#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
S#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
S#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
S
S#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
S#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
S#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
S
S#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
S#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
S#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
S
S#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
S#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
S
S#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
S#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
S
S#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
S#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
S
S#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
S#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
S
S#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
S#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
S
S#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
S#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
S
S#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
S#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
S
S#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
S#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
S
S#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
S#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
S
S#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
S#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
S
S#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
S#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
S
S#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
S#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
S
S/* SCB Configurable Fault Status Register Definitions */
S#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
S#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
S
S#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
S#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
S
S#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
S#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
S
S/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
S#define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB CFSR (MMFSR): MMARVALID Position */
S#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
S
S#define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB CFSR (MMFSR): MSTKERR Position */
S#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
S
S#define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
S#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
S
S#define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB CFSR (MMFSR): DACCVIOL Position */
S#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
S
S#define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB CFSR (MMFSR): IACCVIOL Position */
S#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
S
S/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
S#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
S#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
S
S#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
S#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
S
S#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
S#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
S
S#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
S#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
S
S#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
S#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
S
S#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
S#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
S
S/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
S#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
S#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
S
S#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
S#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
S
S#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
S#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
S
S#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
S#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
S
S#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
S#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
S
S#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
S#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
S
S/* SCB Hard Fault Status Register Definitions */
S#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
S#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
S
S#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
S#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
S
S#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
S#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
S
S/* SCB Debug Fault Status Register Definitions */
S#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
S#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
S
S#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
S#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
S
S#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
S#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
S
S#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
S#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
S
S#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
S#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
S  \brief    Type definitions for the System Control and ID Register not in the SCB
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control and ID Register not in the SCB.
S */
Stypedef struct
S{
S        uint32_t RESERVED0[1U];
S  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
S#if defined (__CM3_REV) && (__CM3_REV >= 0x200U)
S  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
S#else
S        uint32_t RESERVED1[1U];
S#endif
S} SCnSCB_Type;
S
S/* Interrupt Controller Type Register Definitions */
S#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
S#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
S
S/* Auxiliary Control Register Definitions */
S
S#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
S#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
S
S#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
S#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
S
S#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
S#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
S
S/*@} end of group CMSIS_SCnotSCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
S  \brief    Type definitions for the System Timer Registers.
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
S  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
S  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
S  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
S */
Stypedef struct
S{
S  __OM  union
S  {
S    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
S    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
S    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
S  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
S        uint32_t RESERVED0[864U];
S  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
S        uint32_t RESERVED1[15U];
S  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
S        uint32_t RESERVED2[15U];
S  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
S        uint32_t RESERVED3[29U];
S  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
S  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
S  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
S        uint32_t RESERVED4[43U];
S  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
S  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
S        uint32_t RESERVED5[6U];
S  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
S  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
S  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
S  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
S  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
S  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
S  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
S  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
S  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
S  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
S  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
S  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
S} ITM_Type;
S
S/* ITM Trace Privilege Register Definitions */
S#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
S#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
S
S/* ITM Trace Control Register Definitions */
S#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
S#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
S
S#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
S#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
S
S#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
S#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
S
S#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
S#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
S
S#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
S#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
S
S#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
S#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
S
S#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
S#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
S
S#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
S#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
S
S#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
S#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
S
S/* ITM Integration Write Register Definitions */
S#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
S#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
S
S/* ITM Integration Read Register Definitions */
S#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
S#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
S
S/* ITM Integration Mode Control Register Definitions */
S#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
S#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
S
S/* ITM Lock Status Register Definitions */
S#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
S#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
S
S#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
S#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
S
S#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
S#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
S
S/*@}*/ /* end of group CMSIS_ITM */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
S  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
S  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
S  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
S  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
S  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
S  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
S  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
S  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
S  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
S  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
S  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
S        uint32_t RESERVED0[1U];
S  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
S  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
S  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
S        uint32_t RESERVED1[1U];
S  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
S  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
S  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
S        uint32_t RESERVED2[1U];
S  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
S  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
S  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
S} DWT_Type;
S
S/* DWT Control Register Definitions */
S#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
S#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
S
S#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
S#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
S
S#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
S#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
S
S#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
S#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
S
S#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
S#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
S
S#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
S#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
S
S#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
S#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
S
S#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
S#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
S
S#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
S#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
S
S#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
S#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
S
S#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
S#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
S
S#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
S#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
S
S#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
S#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
S
S#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
S#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
S
S#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
S#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
S
S#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
S#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
S
S#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
S#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
S
S#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
S#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
S
S/* DWT CPI Count Register Definitions */
S#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
S#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
S
S/* DWT Exception Overhead Count Register Definitions */
S#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
S#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
S
S/* DWT Sleep Count Register Definitions */
S#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
S#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
S
S/* DWT LSU Count Register Definitions */
S#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
S#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
S
S/* DWT Folded-instruction Count Register Definitions */
S#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
S#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
S
S/* DWT Comparator Mask Register Definitions */
S#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
S#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
S
S/* DWT Comparator Function Register Definitions */
S#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
S#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
S
S#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
S#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
S
S#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
S#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
S
S#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
S#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
S
S#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
S#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
S
S#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
S#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
S
S#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
S#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
S
S#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
S#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
S
S#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
S#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
S
S/*@}*/ /* end of group CMSIS_DWT */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
S  \brief    Type definitions for the Trace Port Interface (TPI)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Trace Port Interface Register (TPI).
S */
Stypedef struct
S{
S  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
S  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
S        uint32_t RESERVED0[2U];
S  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
S        uint32_t RESERVED1[55U];
S  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
S        uint32_t RESERVED2[131U];
S  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
S  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
S  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
S        uint32_t RESERVED3[759U];
S  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
S  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
S  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
S        uint32_t RESERVED4[1U];
S  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
S  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
S  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
S        uint32_t RESERVED5[39U];
S  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
S  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
S        uint32_t RESERVED7[8U];
S  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
S  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
S} TPI_Type;
S
S/* TPI Asynchronous Clock Prescaler Register Definitions */
S#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
S#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
S
S/* TPI Selected Pin Protocol Register Definitions */
S#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
S#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
S
S/* TPI Formatter and Flush Status Register Definitions */
S#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
S#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
S
S#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
S#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
S
S#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
S#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
S
S#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
S#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
S
S/* TPI Formatter and Flush Control Register Definitions */
S#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
S#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
S
S#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
S#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
S
S/* TPI TRIGGER Register Definitions */
S#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
S#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
S
S/* TPI Integration ETM Data Register Definitions (FIFO0) */
S#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
S#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
S
S#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
S#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
S
S#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
S#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
S
S#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
S#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
S
S#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
S#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
S
S#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
S#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
S
S#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
S#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
S
S/* TPI ITATBCTR2 Register Definitions */
S#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
S#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
S
S/* TPI Integration ITM Data Register Definitions (FIFO1) */
S#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
S#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
S
S#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
S#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
S
S#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
S#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
S
S#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
S#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
S
S#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
S#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
S
S#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
S#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
S
S#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
S#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
S
S/* TPI ITATBCTR0 Register Definitions */
S#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
S#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
S
S/* TPI Integration Mode Control Register Definitions */
S#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
S#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
S
S/* TPI DEVID Register Definitions */
S#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
S#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
S
S#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
S#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
S
S#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
S#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
S
S#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
S#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
S
S#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
S#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
S
S#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
S#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
S
S/* TPI DEVTYPE Register Definitions */
S#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
S#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
S
S#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
S#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
S
S/*@}*/ /* end of group CMSIS_TPI */
S
S
S#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
S  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
S  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
S  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
S#endif
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
S  \brief    Type definitions for the Core Debug Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Core Debug Register (CoreDebug).
S */
Stypedef struct
S{
S  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
S  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
S  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
S  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
S} CoreDebug_Type;
S
S/* Debug Halting Control and Status Register Definitions */
S#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
S#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
S
S#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
S#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
S
S#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
S#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
S
S#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
S#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
S
S#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
S#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
S
S#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
S#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
S
S#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
S#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
S
S#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
S#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
S
S#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
S#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
S
S#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
S#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
S
S#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
S#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
S
S#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
S#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
S
S/* Debug Core Register Selector Register Definitions */
S#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
S#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
S
S#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
S#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
S
S/* Debug Exception and Monitor Control Register Definitions */
S#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
S#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
S
S#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
S#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
S
S#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
S#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
S
S#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
S#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
S
S#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
S#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
S
S#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
S#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
S
S#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
S#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
S
S#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
S#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
S
S#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
S#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
S
S#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
S#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
S
S#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
S#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
S
S#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
S#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
S
S#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
S#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
S
S/*@} end of group CMSIS_CoreDebug */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_bitfield     Core register bit field macros
S  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
S  @{
S */
S
S/**
S  \brief   Mask and shift a bit field value for use in a register bit range.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
S  \return           Masked and shifted value.
S*/
S#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
S
S/**
S  \brief     Mask and shift a register value to extract a bit filed value.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
S  \return           Masked and shifted bit field value.
S*/
S#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
S
S/*@} end of group CMSIS_core_bitfield */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_base     Core Definitions
S  \brief      Definitions for base addresses, unions, and structures.
S  @{
S */
S
S/* Memory mapping of Core Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
S#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
S#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
S#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
S#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
S
S#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
S#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
S#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
S#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
S#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
S#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
S#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
S#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
S
S#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
S#endif
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Debug Functions
S  - Core Register Access Functions
S ******************************************************************************/
S/**
S  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
S  \brief    Functions that manage interrupts and exceptions via the NVIC.
S  @{
S */
S
S#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
S#else
S  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
S  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
S  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
S  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
S  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
S  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
S  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
S  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
S  #define NVIC_GetActive              __NVIC_GetActive
S  #define NVIC_SetPriority            __NVIC_SetPriority
S  #define NVIC_GetPriority            __NVIC_GetPriority
S  #define NVIC_SystemReset            __NVIC_SystemReset
S#endif /* CMSIS_NVIC_VIRTUAL */
S
S#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S   #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S#else
S  #define NVIC_SetVector              __NVIC_SetVector
S  #define NVIC_GetVector              __NVIC_GetVector
S#endif  /* (CMSIS_VECTAB_VIRTUAL) */
S
S#define NVIC_USER_IRQ_OFFSET          16
S
S
S
S/**
S  \brief   Set Priority Grouping
S  \details Sets the priority grouping field using the required unlock sequence.
S           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
S           Only values from 0..7 are used.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S  \param [in]      PriorityGroup  Priority grouping field.
S */
S__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
S{
S  uint32_t reg_value;
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
S
S  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
S  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
S  reg_value  =  (reg_value                                   |
S                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
S                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
S  SCB->AIRCR =  reg_value;
S}
S
S
S/**
S  \brief   Get Priority Grouping
S  \details Reads the priority grouping field from the NVIC Interrupt Controller.
S  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
S */
S__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
S{
S  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
S}
S
S
S/**
S  \brief   Enable Interrupt
S  \details Enables a device specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S  }
S}
S
S
S/**
S  \brief   Get Interrupt Enable status
S  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
S  \param [in]      IRQn  Device specific interrupt number.
S  \return             0  Interrupt is not enabled.
S  \return             1  Interrupt is enabled.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return((uint32_t)(((NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S  }
S  else
S  {
S    return(0U);
S  }
S}
S
S
S/**
S  \brief   Disable Interrupt
S  \details Disables a device specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S    __DSB();
S    __ISB();
S  }
S}
S
S
S/**
S  \brief   Get Pending Interrupt
S  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
S  \param [in]      IRQn  Device specific interrupt number.
S  \return             0  Interrupt status is not pending.
S  \return             1  Interrupt status is pending.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S  }
S  else
S  {
S    return(0U);
S  }
S}
S
S
S/**
S  \brief   Set Pending Interrupt
S  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S  }
S}
S
S
S/**
S  \brief   Clear Pending Interrupt
S  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S  }
S}
S
S
S/**
S  \brief   Get Active Interrupt
S  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
S  \param [in]      IRQn  Device specific interrupt number.
S  \return             0  Interrupt status is not active.
S  \return             1  Interrupt status is active.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S  }
S  else
S  {
S    return(0U);
S  }
S}
S
S
S/**
S  \brief   Set Interrupt Priority
S  \details Sets the priority of a device specific interrupt or a processor exception.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S  \param [in]      IRQn  Interrupt number.
S  \param [in]  priority  Priority to set.
S  \note    The priority cannot be set for every processor exception.
S */
S__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
S  }
S  else
S  {
S    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
S  }
S}
S
S
S/**
S  \brief   Get Interrupt Priority
S  \details Reads the priority of a device specific interrupt or a processor exception.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S  \param [in]   IRQn  Interrupt number.
S  \return             Interrupt Priority.
S                      Value is aligned automatically to the implemented priority bits of the microcontroller.
S */
S__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
S  }
S  else
S  {
S    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
S  }
S}
S
S
S/**
S  \brief   Encode Priority
S  \details Encodes the priority for an interrupt with the given priority group,
S           preemptive priority value, and subpriority value.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S  \param [in]     PriorityGroup  Used priority group.
S  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
S  \param [in]       SubPriority  Subpriority value (starting from 0).
S  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
S */
S__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
S  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
S
S  return (
S           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
S           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
S         );
S}
S
S
S/**
S  \brief   Decode Priority
S  \details Decodes an interrupt priority value with a given priority group to
S           preemptive priority value and subpriority value.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
S  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
S  \param [in]     PriorityGroup  Used priority group.
S  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
S  \param [out]     pSubPriority  Subpriority value (starting from 0).
S */
S__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
S  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
S
S  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
S  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
S}
S
S
S/**
S  \brief   Set Interrupt Vector
S  \details Sets an interrupt vector in SRAM based interrupt vector table.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S           VTOR must been relocated to SRAM before.
S  \param [in]   IRQn      Interrupt number
S  \param [in]   vector    Address of interrupt handler function
S */
S__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
S{
S  uint32_t *vectors = (uint32_t *)SCB->VTOR;
S  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
S}
S
S
S/**
S  \brief   Get Interrupt Vector
S  \details Reads an interrupt vector from interrupt vector table.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S  \param [in]   IRQn      Interrupt number.
S  \return                 Address of interrupt handler function
S */
S__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
S{
S  uint32_t *vectors = (uint32_t *)SCB->VTOR;
S  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
S}
S
S
S/**
S  \brief   System Reset
S  \details Initiates a system reset request to reset the MCU.
S */
S__STATIC_INLINE void __NVIC_SystemReset(void)
S{
S  __DSB();                                                          /* Ensure all outstanding memory accesses included
S                                                                       buffered write are completed before reset */
S  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
S                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
S                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
S  __DSB();                                                          /* Ensure completion of memory access */
S
S  for(;;)                                                           /* wait until reset */
S  {
S    __NOP();
S  }
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S/* ##########################  FPU functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_FpuFunctions FPU Functions
S  \brief    Function that provides FPU type.
S  @{
S */
S
S/**
S  \brief   get FPU type
S  \details returns the FPU type
S  \returns
S   - \b  0: No FPU
S   - \b  1: Single precision FPU
S   - \b  2: Double + Single precision FPU
S */
S__STATIC_INLINE uint32_t SCB_GetFPUType(void)
S{
S    return 0U;           /* No FPU */
S}
S
S
S/*@} end of CMSIS_Core_FpuFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
S  \brief    Functions that configure the System.
S  @{
S */
S
S#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
S
S/**
S  \brief   System Tick Configuration
S  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
S           Counter is in free running mode to generate periodic interrupts.
S  \param [in]  ticks  Number of ticks between two interrupts.
S  \return          0  Function succeeded.
S  \return          1  Function failed.
S  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S           must contain a vendor-specific implementation of this function.
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
S  {
S    return (1UL);                                                   /* Reload value impossible */
S  }
S
S  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
S  return (0UL);                                                     /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S/* ##################################### Debug In/Output function ########################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_core_DebugFunctions ITM Functions
S  \brief    Functions that access the ITM debug interface.
S  @{
S */
S
Sextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
S#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
S
S
S/**
S  \brief   ITM Send Character
S  \details Transmits a character via the ITM channel 0, and
S           \li Just returns when no debugger is connected that has booked the output.
S           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
S  \param [in]     ch  Character to transmit.
S  \returns            Character to transmit.
S */
S__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
S{
S  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
S      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
S  {
S    while (ITM->PORT[0U].u32 == 0UL)
S    {
S      __NOP();
S    }
S    ITM->PORT[0U].u8 = (uint8_t)ch;
S  }
S  return (ch);
S}
S
S
S/**
S  \brief   ITM Receive Character
S  \details Inputs a character via the external variable \ref ITM_RxBuffer.
S  \return             Received character.
S  \return         -1  No character pending.
S */
S__STATIC_INLINE int32_t ITM_ReceiveChar (void)
S{
S  int32_t ch = -1;                           /* no character available */
S
S  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
S  {
S    ch = ITM_RxBuffer;
S    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
S  }
S
S  return (ch);
S}
S
S
S/**
S  \brief   ITM Check Character
S  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
S  \return          0  No character available.
S  \return          1  Character available.
S */
S__STATIC_INLINE int32_t ITM_CheckChar (void)
S{
S
S  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
S  {
S    return (0);                              /* no character available */
S  }
S  else
S  {
S    return (1);                              /*    character available */
S  }
S}
S
S/*@} end of CMSIS_core_DebugFunctions */
S
S
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 30 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe_misc.h" 2
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup MISC
N  * @{
N  */
N
N/** @defgroup MISC_Exported_Types
N  * @{
N  */
N
N/** 
N  * @brief  NVIC Init Structure definition  
N  */
N
Ntypedef struct
N{
N  uint8_t NVIC_IRQChannel;                    /*!< Specifies the IRQ channel to be enabled or disabled.
N                                                   This parameter can be a value of @ref IRQn_Type 
N                                                   (For the complete HUGE-IC Devices IRQ Channels list, please
N                                                    refer to HUGE-IC.h file) */
N
N  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!< Specifies the pre-emption priority for the IRQ channel
N                                                   specified in NVIC_IRQChannel. This parameter can be a value
N                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */
N
N  uint8_t NVIC_IRQChannelSubPriority;         /*!< Specifies the subpriority level for the IRQ channel specified
N                                                   in NVIC_IRQChannel. This parameter can be a value
N                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */
N
N  FunctionalState NVIC_IRQChannelCmd;         /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel
N                                                   will be enabled or disabled. 
N                                                   This parameter can be set either to ENABLE or DISABLE */   
N} NVIC_InitTypeDef;
N 
N/**
N  * @}
N  */
N
N/** @defgroup NVIC_Priority_Table 
N  * @{
N  */
N
N/**
N@code  
N The table below gives the allowed values of the pre-emption priority and subpriority according
N to the Priority Grouping configuration performed by NVIC_PriorityGroupConfig function
N  ============================================================================================================================
N    NVIC_PriorityGroup   | NVIC_IRQChannelPreemptionPriority | NVIC_IRQChannelSubPriority  | Description
N  ============================================================================================================================
N   NVIC_PriorityGroup_0  |                0                  |            0-7              |   0 bits for pre-emption priority
N                         |                                   |                             |   3 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------
N   NVIC_PriorityGroup_1  |                0-1                |            0-3              |   1 bits for pre-emption priority
N                         |                                   |                             |   2 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------    
N   NVIC_PriorityGroup_2  |                0-3                |            0-1              |   2 bits for pre-emption priority
N                         |                                   |                             |   1 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------    
N   NVIC_PriorityGroup_3  |                0-7                |            0                |   3 bits for pre-emption priority
N                         |                                   |                             |   0 bits for subpriority
N  ============================================================================================================================
N@endcode
N*/
N
N/**
N  * @}
N  */
N
N/** @defgroup MISC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup Vector_Table_Base 
N  * @{
N  */
N
N#define NVIC_VectTab_RAM                      ((u32)0x20000000)
N#define NVIC_VectTab_FLASH                    ((u32)0x08000000)
N#define IS_NVIC_VECTTAB(VECTTAB)              (((VECTTAB) == NVIC_VectTab_RAM) ||   \
N                                              ((VECTTAB) == NVIC_VectTab_FLASH))
X#define IS_NVIC_VECTTAB(VECTTAB)              (((VECTTAB) == NVIC_VectTab_RAM) ||                                                 ((VECTTAB) == NVIC_VectTab_FLASH))
N/**
N  * @}
N  */
N
N/** @defgroup System_Low_Power 
N  * @{
N  */
N
N#define NVIC_LP_SEVONPEND                     ((uint8_t)0x10)
N#define NVIC_LP_SLEEPDEEP                     ((uint8_t)0x04)
N#define NVIC_LP_SLEEPONEXIT                   ((uint8_t)0x02)
N#define IS_NVIC_LP(LP)                        (((LP) == NVIC_LP_SEVONPEND) ||       \
N                                              ((LP) == NVIC_LP_SLEEPDEEP) ||        \
N                                              ((LP) == NVIC_LP_SLEEPONEXIT))
X#define IS_NVIC_LP(LP)                        (((LP) == NVIC_LP_SEVONPEND) ||                                                     ((LP) == NVIC_LP_SLEEPDEEP) ||                                                      ((LP) == NVIC_LP_SLEEPONEXIT))
N/**
N  * @}
N  */
N
N/** @defgroup Preemption_Priority_Group 
N  * @{
N  */
N/*! 0 bits for pre-emption priority 3 bits for subpriority
N */
N#define NVIC_PriorityGroup_0                   ((u32)0x700)
N/*! 1 bits for pre-emption priority 2 bits for subpriority
N */
N#define NVIC_PriorityGroup_1                   ((u32)0x600)
N/*! 2 bits for pre-emption priority 1 bits for subpriority
N */
N#define NVIC_PriorityGroup_2                   ((u32)0x500)
N/*! 3 bits for pre-emption priority 0 bits for subpriority
N */
N#define NVIC_PriorityGroup_3                   ((u32)0x400)
N
N
N#define IS_NVIC_PRIORITY_GROUP(GROUP)          (((GROUP) == NVIC_PriorityGroup_0) ||\
N                                               ((GROUP) == NVIC_PriorityGroup_1) || \
N                                               ((GROUP) == NVIC_PriorityGroup_2) || \
N                                               ((GROUP) == NVIC_PriorityGroup_3))
X#define IS_NVIC_PRIORITY_GROUP(GROUP)          (((GROUP) == NVIC_PriorityGroup_0) ||                                               ((GROUP) == NVIC_PriorityGroup_1) ||                                                ((GROUP) == NVIC_PriorityGroup_2) ||                                                ((GROUP) == NVIC_PriorityGroup_3))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)         ((PRIORITY) < 0x10)
N
N#define IS_NVIC_OFFSET(OFFSET)                 ((OFFSET) < 0x0007FFFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup SysTick_clock_source 
N  * @{
N  */
N
N#define SysTick_CLKSource_HCLK_Div8            ((u32)0xFFFFFFFB)
N#define SysTick_CLKSource_HCLK                 ((u32)0x00000004)
N#define IS_SYSTICK_CLK_SOURCE(SOURCE)          (((SOURCE) == SysTick_CLKSource_HCLK) || \
N                                               ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE)          (((SOURCE) == SysTick_CLKSource_HCLK) ||                                                ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup MISC_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup MISC_Exported_Functions
N  * @{
N  */
N
Nvoid NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup);
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_EnableIRQ(IRQn_Type IRQn);
Xvoid __NVIC_EnableIRQ(IRQn_Type IRQn);
Nvoid NVIC_DisableIRQ(IRQn_Type IRQn);
Xvoid __NVIC_DisableIRQ(IRQn_Type IRQn);
Nvoid NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset);
Nvoid NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);
Nvoid SysTick_CLKSourceConfig(u32 SysTick_CLKSource);
Nu32 SysTick_Config(u32 ticks);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // __TX_PHE_HAL_MISC_H
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2017 HUGE-IC *****END OF FILE****/
L 29 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_assert.h"
N#include "tx_phe_system.h"
N#include "tx_phe_debug.h"
L 1 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe_debug.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Device/Phoenix/include/tx_phe_debug.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the DEBUG LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_DEBUG_H
N#define __TX_PHE_LL_DEBUG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N#include "tx_phe_ll_usart.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_usart.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_usart.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.1
N  * @date    03-08-2018
N  * @brief   This file contains all the USART LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_USART_H
N#define __TX_PHE_LL_USART_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup usart_interface_gr USART Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N     
N/** @addtogroup USART_LL_Driver USART LL Driver
N  * @ingroup  usart_interface_gr
N  * @brief Mainly the driver part of the USART module, which includes \b USART \b Register 
N  * \b Constants, \b USART \b Exported \b Constants, \b USART \b Exported \b Struct, \b USART
N  * \b Data \b transfers \b functions, \b USART \b Initialization \b and \b USART \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N     
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N     
N/** @defgroup USART_LL_Register_Constants USART LL Register Constants
N  * @ingroup  USART_LL_Driver
N  * @brief    USART LL register constant table definition
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the USART 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the USART register, mainly for convenience. Understand the 
N    configuration of the USART.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/*! RX/TX FIFO depth 16 byte
N */
N#define FIFO_DEPTH_MASK                          (0xF)
N
N/***** RBR(Receive Buffer Register) *****/
N/*! Receive Buffer for 9 bit
N */
N#define LL_USARTX_RBR_RX_9BIT(n)                 (((n)&0x1FF) << 0)
N/*! Receive Buffer for 8 bit
N */
N#define LL_USARTX_RBR_RX_8BIT(n)                 (((n)&0xFF) << 0)
N
N
N/***** THR(Transmit Holding Register) *****/
N/*! Transmit Buffer for 9 bit
N */
N#define LL_USARTX_THR_TX_9BIT(n)                 (((n)&0x1FF) << 0)
N/*! Transmit Buffer for 8 bit
N */
N#define LL_USARTX_THR_TX_8BIT(n)                 (((n)&0xFF) << 0)
N
N
N/***** DLH(Divisor Latch High) *****/
N/*! Upper 8-bits of a 16-bit, Divisor Latch register that contains the baud 
N *  rate divisor for the USART
N */
N#define LL_USARTX_DLH(n)                         (((n)&0xFF) << 0)
N
N
N/***** DLL(Divisor Latch Low) *****/
N/*! Lower 8-bits of a 16-bit, Divisor Latch register that contains the baud 
N *  rate divisor for the USART     
N */
N#define LL_USARTX_DLL(n)                         (((n)&0xFF) << 0)
N
N
N/***** IER(Interrupt Enable Register) *****/
N/*! Programmable THRE Interrupt Mode Enable
N */
N#define LL_USARTX_IER_PTIME                      (1UL << 7)
N/*! Enable Modem Status Interrupt
N */
N#define LL_USARTX_IER_EDSSI                      (1UL << 3)
N/*! Enable Receiver Line Status Interrupt
N */
N#define LL_USARTX_IER_ELSI                       (1UL << 2)
N/*! Enable Transmit Holding Register Empty Interrupt
N */
N#define LL_USARTX_IER_ETBEI                      (1UL << 1)
N/*! Enable Received Data Available Interrupt
N */
N#define LL_USARTX_IER_ERBFI                      (1UL << 0)
N/*! Enable interrupt mask
N */
N#define LL_USARTX_IER_MASK(n)                    (((n)&0xFF) << 0)
N
N
N/***** IIR(Interrupt Identity Register) *****/
N/*! FIFOs Enabled(RO)
N */
N#define LL_USARTX_IIR_FIFOSE(n)                  (((n)&0x3) << 6)
N/*! Interrupt ID(RO)
N */
N#define LL_USARTX_IIR_IID(n)                     (((n)&0xF) << 0)
N
N
N/***** FCR(FIFO Control Register) *****/
N/*! Used to select the trigger level in the receiver FIFO at which the 
N *  Received Data Available Interrupt is generated.
N */
N#define LL_USARTX_FCR_RCVR(n)                    (((n)&0x3) << 6)
N/*! Used to select the trigger level in the Transmit FIFO at which the 
N *  Received Data Available Interrupt is generated
N */
N#define LL_USARTX_FCR_TET(n)                     (((n)&0x3) << 4)
N/*! DMA Mode
N */
N#define LL_USARTX_FCR_DMAM                       (1UL << 3)
N/*! This resets the control portion of the transmit FIFO and treats 
N *  the FIFO as empty
N */
N#define LL_USARTX_FCR_XFIFOR                     (1UL << 2)
N/*! This resets the control portion of the receive FIFO and treats 
N *  the FIFO as empty
N */
N#define LL_USARTX_FCR_RFIFOR                     (1UL << 1)
N/*! This enables/disables the transmit (XMIT) and receive (RCVR)FIFOs
N */
N#define LL_USARTX_FCR_FIFOE                      (1UL << 0)
N
N
N/***** LCR(Line Control Register) *****/
N/*! Divisor Latch Access Bit
N */
N#define LL_USARTX_LCR_DLAB                       (1UL << 7)
N/*! This is used to cause a break condition to be transmitted to the 
N *  receiving device
N */
N#define LL_USARTX_LCR_BC                         (1UL << 6)
N/*! Stick Parity
N */
N#define LL_USARTX_LCR_SP                         (1UL << 5)
N/*! Even Parity Select
N */
N#define LL_USARTX_LCR_EPS                        (1UL << 4)
N/*! Parity Enable
N */
N#define LL_USARTX_LCR_PEN                        (1UL << 3)
N
N/*! Parity Enable And Parity Select
N */
N#define LL_USARTX_LCR_PARITY(n)                  (((n)&0x3) << 3)
N/*! Number of stop bits
N */
N#define LL_USARTX_LCR_STOP                       (1UL << 2)
N/*! Data Length Select
N */
N#define LL_USARTX_LCR_DLS(n)                     (((n)&0x3) << 0)
N
N
N/***** MCR(Modem Control Register) *****/
N/*! SIR Mode Enable
N */
N#define LL_USARTX_MCR_SIRE                       (1UL << 6)
N/*! Auto Flow Control Enable
N */
N#define LL_USARTX_MCR_AFCE                       (1UL << 5)
N/*! Used to put the USART into a diagnostic mode for test purposes
N */
N#define LL_USARTX_MCR_LB                         (1UL << 4)
N/*! Used to directly control the user-designated Output2 (out2_n) output
N */
N#define LL_USARTX_MCR_OUT2                       (1UL << 3)
N/*! Used to directly control the user-designated Output1 (out1_n) output
N */
N#define LL_USARTX_MCR_OUT1                       (1UL << 2)
N/*! Used to directly control the Request to Send (rts_n) output
N */
N#define LL_USARTX_MCR_RTS                        (1UL << 1)
N/*! Used to directly control the Data Terminal Ready (dtr_n) output
N */
N#define LL_USARTX_MCR_DTR                        (1UL << 0)
N
N
N/***** LSR(Line Status Register) *****/
N/*! Address Received bit
N */
N#define LL_USARTX_LSR_ADDR_RCVD                  (1UL << 8)
N/*! Receiver FIFO Error bit
N */
N#define LL_USARTX_LSR_RFE                        (1UL << 7)
N/*! Transmitter Empty bit
N */
N#define LL_USARTX_LSR_TEMT                       (1UL << 6)
N/*! Transmit Holding Register Empty bit
N */
N#define LL_USARTX_LSR_THRE                       (1UL << 5)
N/*! Break Interrupt bit
N */
N#define LL_USARTX_LSR_BI                         (1UL << 4)
N/*! Framing Error bit
N */
N#define LL_USARTX_LSR_FE                         (1UL << 3)
N/*! Parity Error bit
N */
N#define LL_USARTX_LSR_PE                         (1UL << 2)
N/*! Overrun error bit
N */
N#define LL_USARTX_LSR_OE                         (1UL << 1)
N/*! Data Ready bit
N */
N#define LL_USARTX_LSR_DR                         (1UL << 0)
N
N
N/***** MSR(Modem Status Register) *****/
N/*! Used to indicate the current state of the modem control line dcd_n
N */
N#define LL_USARTX_MSR_DCD                        (1UL << 7)
N/*! Used to indicate the current state of the modem control line ri_n
N */
N#define LL_USARTX_MSR_RI                         (1UL << 6)
N/*! Used to indicate the current state of the modem control line dsr_n
N */
N#define LL_USARTX_MSR_DSR                        (1UL << 5)
N/*! Used to indicate the current state of the modem control line cts_n
N */
N#define LL_USARTX_MSR_CTS                        (1UL << 4)
N/*! Used to indicate that the modem control line dcd_n haschanged since 
N *  the last time the MSR was read
N */
N#define LL_USARTX_MSR_DDCD                       (1UL << 3)
N/*! Used to indicate that a change on the input ri_n has occurred since 
N *  the last time the MSR was read
N */
N#define LL_USARTX_MSR_TERI                       (1UL << 2)
N/*! sed to indicate that the modem control line dsr_n has changed since 
N *  the last time the MSR was read
N */
N#define LL_USARTX_MSR_DDSR                       (1UL << 1)
N/*! Used to indicate that the modem control line cts_n has changed since 
N *  the last time the MSR was read
N */
N#define LL_USARTX_MSR_DCTS                       (1UL << 0)
N
N
N/***** SCR(Scratchpad Register) *****/
N/*! This register is for programmers to use as a temporary storage space
N */
N#define LL_USARTX_SCR(n)                         (((n)&0xFF) << 0)
N
N
N/***** LPDLL(Low Power Divisor Latch Low Register) *****/
N/*! lower 8-bits of a 16-bit,It required for SIR Low Power (minimum pulse 
N *  width) detection at the receiver 
N */
N#define LL_USARTX_LPDLL(n)                       (((n)&0xFF) << 0)
N
N
N/***** LPDLL(Low Power Divisor Latch High Register) *****/
N/*! upper 8-bits of a 16-bit,It required for SIR Low Power (minimum pulse 
N *  width) detection at the receiver 
N */
N#define LL_USARTX_LPDLH(n)                       (((n)&0xFF) << 0)
N
N
N/***** SRBR(Shadow Receive Buffer Register) *****/
N/*! RX Buffer shadow register for the 9 BIT
N */
N#define LL_USARTX_SRBR_RX_9BIT(n)                (((n)&0x1FF) << 0)
N/*! RX Buffer shadow register for the 8 BIT
N */
N#define LL_USARTX_SRBR_RX_8BIT(n)                (((n)&0xFF) << 0)
N
N
N/***** STHR(Shadow Transmit Holding Register) *****/
N/*! TX Buffer shadow register for the 9 BIT
N */
N#define LL_USARTX_STHR_TX_9BIT(n)                (((n)&0x1FF) << 0)
N/*! TX Buffer shadow register for the 8 BIT
N */
N#define LL_USARTX_STHR_TX_8BIT(n)                (((n)&0xFF) << 0)
N
N
N/***** FAR(FIFO Access Register) *****/
N/*! This register is use to enable a FIFO access mode for testing
N */
N#define LL_USARTX_FAR                            (1UL << 0)
N
N
N/***** TFR(Transmit FIFO Read Register) *****/
N/*! Transmit FIFO Read
N */
N#define LL_USARTX_TFR                            (1UL << 0)
N
N
N/***** RFW(Receive FIFO Write) *****/
N/*! Receive FIFO Framing Error
N */
N#define LL_USARTX_RFW_RFFE                       (1UL << 9)
N/*! Receive FIFO Parity Error
N */
N#define LL_USARTX_RFW_RFPE                       (1UL << 8)
N/*! Receive FIFO Write Data
N */
N#define LL_USARTX_RFW_RFWD(n)                    (((n)&0xFF) << 0)
N
N
N/***** USR(USART Status Register) *****/
N/*! Receive FIFO Full
N */
N#define LL_USARTX_USR_RFF                        (1UL << 4)
N/*! Receive FIFO Not Empty
N */
N#define LL_USARTX_USR_RFNE                       (1UL << 3)
N/*! Transmit FIFO Empty
N */
N#define LL_USARTX_USR_TFE                        (1UL << 2)
N/*! Transmit FIFO Not Full
N */
N#define LL_USARTX_USR_TFNF                       (1UL << 1)
N/*! USART Busy
N */
N#define LL_USARTX_USR_BUSY                       (1UL << 0)
N
N
N/***** TFL(Transmit FIFO Level) *****/
N/*! Transmit FIFO Level
N */
N#define LL_USARTX_TFL(n)                         (((n)&FIFO_DEPTH_MASK) << 0)
N
N/***** RFL(Receive FIFO Level) *****/
N/*! Receive FIFO Level
N */
N#define LL_USARTX_RFL(n)                         (((n)&FIFO_DEPTH_MASK) << 0)
N
N
N/***** SRR(Software Reset Register) *****/
N/*! This is a shadow register for the XMIT FIFO Reset bit (FCR[2])
N */
N#define LL_USARTX_SRR_XFR                        (1UL << 2)
N/*! This is a shadow register for the RCVR FIFO Reset bit (FCR[1])
N */
N#define LL_USARTX_SRR_RFR                        (1UL << 1)
N/*! This asynchronously resets the DW_apb_usart and synchronously 
N *  removes the reset assertion
N */
N#define LL_USARTX_SRR_UR                         (1UL << 0)
N
N
N/***** SRTS(Shadow Request to Send) *****/
N/*! Shadow Request to Send
N */
N#define LL_USARTX_SRTS                           (1UL << 0)
N
N
N/***** SBCR(Shadow Break Control Register) *****/
N/*! Shadow Break Control Bit
N */
N#define LL_USARTX_SBCR                           (1UL << 0)
N
N
N/***** SDMAM(Shadow DMA Mode) *****/
N/*! This is a shadow register for the DMA mode bit (FCR[3])
N */
N#define LL_USARTX_SDMAM                          (1UL << 0)
N
N
N/***** SFE(Shadow FIFO Enable) *****/
N/*! This is a shadow register for the FIFO enable bit (FCR[0])
N */
N#define LL_USARTX_SFE                            (1UL << 0)
N
N
N/***** SRT(Shadow RCVR Trigger) *****/
N/*! This is a shadow register for the RCVR trigger bits (FCR[7:6])
N */
N#define LL_USARTX_SRT(n)                         (((n)&0x3) << 0)
N
N
N/***** STET(Shadow TX Empty Trigger) *****/
N/*! This is a shadow register for the TX empty trigger bits (FCR[5:4])
N */
N#define LL_USARTX_STET(n)                        (((n)&0x3) << 0)
N
N
N/***** HTX(Halt TX) *****/
N/*! This register is use to halt transmissions for testing
N */
N#define LL_USARTX_HTX                            (1UL << 0)
N
N
N/***** DMASA(DMA Software Acknowledge) *****/
N/*! This register is use to perform a DMA software acknowledge if a 
N *  transfer needs to be terminated due to an error condition
N */
N#define LL_USARTX_DMASA                          (1UL << 0)
N
N
N/***** TCR(Transceiver Control Register) *****/
N/*! Transfer Mode
N */
N#define LL_USARTX_TCR_XFER_MODE(n)               (((n)&0x3) << 3)
N/*! Driver Enable Polarity
N */
N#define LL_USARTX_TCR_DE_POL(n)                  (((n)&0x1) << 2)
N/*! Receiver Enable Polarity
N */
N#define LL_USARTX_TCR_RE_POL(n)                  (((n)&0x1) << 1)
N/*! RS485 Transfer Enable
N */
N#define LL_USARTX_TCR_RS485_EN                   (1UL << 0)
N
N
N/***** DE_EN(Driver Output Enable Register) *****/
N/*! Used to control assertion and de-assertion of 'de' signal.
N */
N#define LL_USARTX_DE_EN                          (1UL << 0)
N
N
N/***** RE_EN(Receiver Output Enable Register) *****/
N/*! Used to control assertion and de-assertion of 're' signal.
N */
N#define LL_USARTX_RE_EN                          (1UL << 0)
N
N
N/***** DET(Driver Output Enable Timing Register) *****/
N/*! Driver enable de-assertion time
N */
N#define LL_USARTX_DET_DEDAT(n)                   (((n)&0xFF) << 16)
N/*! Driver enable assertion time
N */
N#define LL_USARTX_DET_DEAT(n)                    (((n)&0xFF) << 0)
N
N
N/***** TAT(TurnAround Timing Register) *****/
N/*! Receiver Enable to Driver Enable TurnAround time
N */
N#define LL_USARTX_TAT_RE_TO_DE(n)                (((n)&0xFFFF) << 16)
N/*! Driver Enable to Receiver Enable TurnAround time
N */
N#define LL_USARTX_TAT_DE_TO_RE(n)                (((n)&0xFFFF) << 0)
N
N
N/***** DLF(Divisor Latch Fraction Register) *****/
N/*! Fractional part of divisor, The fractional value is added to integer 
N *  value set by DLH, DLL. Fractional value is determined by 
N *  (Divisor Fraction value)/(2^DLF_SIZE)
N */
N#define LL_USARTX_DLF_DE_TO_RE(n)                (((n)&0xF) << 0)
N
N
N/***** RAR(Receive Address Register) *****/
N/*! This is an address matching register during receive mode
N */
N#define LL_USARTX_RAR(n)                         (((n)&0xFF) << 0)
N
N
N/***** TAR(Transmit Address Register) *****/
N/*! This is an address matching register during transmit mode
N */
N#define LL_USARTX_TAR(n)                         (((n)&0xFF) << 0)
N
N
N/***** LCR_EXT(USART Status Register) *****/
N/*! Transmit mode control bit
N */
N#define LL_USARTX_LCR_TRANSMIT_MODE              (1UL << 3)
N/*! Send address control bit
N */
N#define LL_USARTX_LCR_SEND_ADDR                  (1UL << 2)
N/*! Address Match Mode
N */
N#define LL_USARTX_LCR_ADDR_MATCH                 (1UL << 1)
N/*! Extension for DLS
N */
N#define LL_USARTX_LCR_DLS_E                      (1UL << 0)
N
N
N/***** CPR(USART Status Register) *****/
N/*! Parameter FIFO_MODE
N */
N#define LL_USARTX_CPR_FIFO_MODE                  (((n)&0xFF) << 16)
N/*! Parameter DMA_EXTRA
N */
N#define LL_USARTX_CPR_DMA_EXTRA                  (1UL << 13)
N/*! Parameter ADD_ENCODED
N */
N#define LL_USARTX_CPR_ADD_ENCODED                (1UL << 12)
N/*! Parameter SHADOW
N */
N#define LL_USARTX_CPR_SHADOW                     (1UL << 11)
N/*! Parameter FIFO_STAT
N */
N#define LL_USARTX_CPR_FIFO_STAT                  (1UL << 10)
N/*! Parameter FIFO_ACCESS
N */
N#define LL_USARTX_CPR_FIFO_ACCESS                (1UL << 9)
N/*! Parameter NEW_FEAT
N */
N#define LL_USARTX_CPR_NEW_FEAT                   (1UL << 8)
N/*! Parameter SIR_LP_MODE
N */
N#define LL_USARTX_CPR_SIR_LP_MODE                (1UL << 7)
N/*! Parameter SIR_MODE
N */
N#define LL_USARTX_CPR_SIR_MODE                   (1UL << 6)
N/*! Parameter THRE_MODE
N */
N#define LL_USARTX_CPR_THRE_MODE                  (1UL << 5)
N/*! Parameter AFCE_MODE
N */
N#define LL_USARTX_CPR_AFCE_MODE                  (1UL << 4)
N/*! Parameter APB_DATA_WIDTH
N */
N#define LL_USARTX_CPR_APB_DATA_WIDTH             (((n)&0x3) << 0)
N
N
N/***** UCV(USART Component Version) *****/
N/*! ASCII value for each number in the version
N */
N#define LL_USARTX_UCV(n)                         (((n)&0xFFFFFFFF) << 0)
N
N
N/***** CTR(Component Type Register) *****/
N/*! This register contains the peripherals identification code
N */
N#define LL_USARTX_CTR(n)                         (((n)&0xFFFFFFFF) << 0)
N
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_Exported_Constants USART LL Exported Constants
N  * @ingroup  USART_LL_Driver
N  * @brief    USART LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N/***** DRIVER API *****/
N
N
N/***** LL API *****/
N
N/**
N  * @brief Enumeration constant for USART interrupt flag
N  */
Ntypedef enum {
N    /*! Interrupt indicator modem status CTR, DSR, RI or DCD status changed
N     */
N    LL_USART_INTR_MODEM_STATUS   = 0x0,
N    /*! Interrupt indicator No event/interrupt pending.
N     */
N    LL_USART_INTR_NO             = 0x1,
N    /*! Interrupt indicator Transmit holding register empty or 
N     *  TX FIFO at or below trigger threshold.
N     */
N    LL_USART_INTR_THR_EMPTY      = 0x2,
N    /*! Interrupt indicator received data available Receive buffer register data
N     *  available (non-FIFO mode) or RX FIFO trigger level reached.
N     */
N    LL_USART_INTR_RX_DATA_AVAIL  = 0x4,
N    /*! Interrupt indicator Overrun/parity/framing error or break interrupt occurred.
N     */
N    LL_USART_INTR_RX_LINE_STATUS = 0x6,
N    /*! Interrupt indicator Attempt to write to the LCR[7] while DW_apb_uart was busy (DLAB).
N     */
N    LL_USART_INTR_BUSY_DETECT    = 0x7,
N    /*! Interrupt indicator No characters in or out of the receiver FIFO during the last four
N     *  character times and there is at least one character in it during this time.
N     */
N    LL_USART_INTR_CHAR_TIMEOUT   = 0xC
N} TYPE_ENUM_LL_USART_INTR_STATUS;
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for USART data length
N  */
Ntypedef enum {
N    /*! Usart word length select 5 bit
N     */
N    LL_USART_WORD_LENGTH_5B = 0,
N    /*! Usart word length select 6 bit
N     */
N    LL_USART_WORD_LENGTH_6B,
N    /*! Usart word length select 7 bit
N     */
N    LL_USART_WORD_LENGTH_7B,
N    /*! Usart word length select 8 bit
N     */
N    LL_USART_WORD_LENGTH_8B,
N} TYPE_ENUM_LL_USART_BIT_WIDTH_SEL;
N
N/**
N  * @brief Enumeration constant for USART stop bit select
N  */
Ntypedef enum {
N    /*! Usart stop bit select 1 bit
N     */
N    LL_USART_STOP_1B = 0,
N    /*! Usart stop bit select 2 bit
N     */
N    LL_USART_STOP_2B,
N} TYPE_ENUM_LL_USART_STOP_BIT_SEL;
N
N/**
N  * @brief Enumeration constant for USART parity select
N  */
Ntypedef enum {
N    /*! Usart no parity check
N     */
N    LL_USART_PARITY_NO = 0,
N    /*! Usart odd parity
N     */
N    LL_USART_PARITY_ODD,
N    /*! Reserver
N     */
N    LL_USART_RESVERS,
N    /*! Usart enven parity
N     */    
N    LL_USART_PARITY_EVEN,
N} TYPE_ENUM_LL_USART_PARITY_SEL;
N
N/**
N  * @brief Enumeration constant for USART stick parity feature
N  */
Ntypedef enum {
N    /*! Usart stick parity disable
N     */
N    LL_USART_STICK_PARITY_DIS = 0,
N    /*! Usart stick parity enable
N     */
N    LL_USART_STICK_PARITY_EN,
N} TYPE_ENUM_LL_USART_STICK_PARITY;
N
N/**
N  * @brief Enumeration constant for USART TX FIFO trigger select
N  */
Ntypedef enum {
N    /*! TX FIFO empty 
N     */
N    LL_USART_TXFIFO_TRIG_EMPTY = 0,
N    /*! 2 characters in TX FIFO  
N     */
N    LL_USART_TXFIFO_TRIG_2CHAR,
N    /*! 1/4 TX FIFO FULL trigger
N     */
N    LL_USART_TXFIFO_TRIG_QUSARTER,
N    /*! 1/2 TX FIFO FULL trigger
N     */
N    LL_USART_TXFIFO_TRIG_HALF,
N} TYPE_ENUM_LL_USART_TXFIFO_TRIG;
N
N/**
N  * @brief Enumeration constant for USART RX FIFO trigger select
N  */
Ntypedef enum {
N    /*! 1 characters in RX FIFO  
N     */
N    LL_USART_RXFIFO_TRIG_1CHAR = 0,
N    /*! 1/4 RX FIFO FULL 
N     */
N    LL_USART_RXFIFO_TRIG_QUSARTER,
N    /*! 1/2 RX FIFO FULL 
N     */
N    LL_USART_RXFIFO_TRIG_HALF,
N    /*! RX FIFO is 2 characters less than FULL 
N     */
N    LL_USART_RXFIFO_TRIG_2LESS_FULL,
N} TYPE_ENUM_LL_USART_RXFIFO_TRIG;
N
N/**
N  * @brief Enumeration constant for USART interrupt source select
N  */
Ntypedef enum {
N    /*! Interrupt trigger select rx ready
N     */
N    LL_USART_INTR_RX_READY      = 0x01,
N    /*! Interrupt trigger select tx empty
N     */
N    LL_USART_INTR_TX_EMPTY      = 0x02,
N    /*! Interrupt trigger select rx line status
N     */
N    LL_USART_INTR_RX_LINE_STAUS = 0x04,
N    /*! Interrupt trigger select modem status
N     */
N    LL_USART_INTR_MODEM_STAUS   = 0x08,
N    /*! Interrupt trigger select programmable THRE
N     */
N    LL_USART_INTR_PROG_THRE     = 0x80,
N} TYPE_ENUM_LL_USART_INTR_SEL;
N
N/**
N  * @brief Enumeration constant for USART IO_MAP select
N  * @note The correspondence table of IO_MAP is as follows:
N  *  
N  *                              USART 232                        USART 485      
N  *  
N  *               LL_USART_IO_MAP0     LL_USART_IO_MAP1      LL_USART_IO_MAP0   
N  *  
N  *    io name    usart_rx/usart_tx    usart_rx/usart_tx    usart_rx/usart_tx/  
N  *                                                         usart_re/usart_de   
N  *  
N  *    USART0         PA10/PA11                             PA10/PA11/PA9/PA8   
N  *  
N  *    USART1         PA12/PA13                             PA12/PA13/PA14/PA15 
N  *  
N  *    USART2          PD2/PD3             PA14/PA15         PD2/PD3/PD1/PD0    
N  *  
N  */
Ntypedef enum {
N    /*! Select the pin of the USART io map0
N     */
N    LL_USART_IO_MAP0 = 0x01,
N    /*! Select the pin of the USART io map1
N     */
N    LL_USART_IO_MAP1 = 0x02,
N} TYPE_ENUM_LL_USART_IOMAP_SEL;
N
N/**
N  * @brief Enumeration constant for USART 485 mode select
N  */
Ntypedef enum {
N    /*! MODE0:  
N     * In this mode, transmit and receive can happen simultaneously. You can
N     * enable DE_EN and RE_EN at any point of time. Turn around timing as
N     * programmed in the TAT register is not applicable in this mode.
N     */
N    LL_USART485_MODE0 = 0x0,
N    /*! MODE1:  
N     * In this mode, DE and RE are mutually exclusive. The hardware considers
N     * the turnaround timings that are programmed in the TAT register while
N     * switching from RE to DE or from DE to RE. Ensure that either DE or RE is
N     * expected to be enabled while programming.
N     * For transmission, hardware waits if it is in the midst of receiving any
N     * transfer, before it starts transmitting.
N     */
N    LL_USART485_MODE1 = 0x1,
N    /*! MODE2:  
N     * In this mode, DE and RE are mutually exclusive. Once DE_EN or RE_EN
N     * is programed, 're' is enabled by default and DW_apb_uart controller will be
N     * ready to receive. If the user programs the TX FIFO with data, then
N     * DW_apb_uart, after ensuring no receive is in progress, disables the 're'
N     * and enables the 'de' signal.
N     * Once the TX FIFO becomes empty, the 're' signal gets enabled and the
N     * 'de' signal will be disabled.
N     * In this mode of operation, the hardware considers the turnaround timings
N     * that are programmed in the TAT register while switching from RE to DE or
N     * from DE to RE. In this mode, 'de' and 're' signals are strictly
N     * complementary to each other.
N     */
N    LL_USART485_MODE2 = 0x2,
N} TYPE_ENUM_LL_USART485_MODE;
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_Exported_Struct USART LL Exported Struct
N  * @ingroup  USART_LL_Driver
N  * @brief    USART LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the USART registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_usart_init. Function, you can configure the USART module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief USART low layer configuration structure
N  */
Ntypedef struct __ll_usart_irq_cfg {
N    /*! Enable interrupt trigger select rx ready
N     */
N    bool rx_ready_intr_en;
N    /*! Enable interrupt trigger select tx empty
N     */
N    bool tx_empty_intr_en;
N    /*! Enable interrupt trigger select rx line status
N     */
N    bool rx_line_status_en;
N    /*! Enable interrupt trigger select modem status
N     */
N    bool modem_status_intr_en;
N    /*! Enable interrupt trigger select programmable THRE
N     */
N    bool program_thre_intr_en;
N} TYPE_LL_USART_IRQ_CFG;
N
N/**
N  * @brief USART low layer configuration structure
N  */
Ntypedef struct __ll_usart_cfg {
N    /***** usart *****/
N    /*! USART stop bit selection
N     */
N    TYPE_ENUM_LL_USART_STOP_BIT_SEL  stop_bit_sel;
N    /*! USART data length selection
N     */
N    TYPE_ENUM_LL_USART_BIT_WIDTH_SEL bit_width_sel;
N    /*! USART parity selection
N     */
N    TYPE_ENUM_LL_USART_PARITY_SEL    parity;
N    /*! USART stick parity feature
N     *  @note Enable this feature will enable parity by force.
N     */
N    TYPE_ENUM_LL_USART_STICK_PARITY  stick_parity;
N
N    /*! Trigger source selection for USART RX FIFO
N     */
N    TYPE_ENUM_LL_USART_RXFIFO_TRIG   rxfifo_trigger;
N    /*! Trigger source selection for USART TX FIFO
N     */
N    TYPE_ENUM_LL_USART_TXFIFO_TRIG   txfifo_trigger;
N    /*! USART baud rate
N     */
N    u16                              baudrate;
N    /*! USART io_map selection : TYPE_ENUM_LL_USART_IOMAP_SEL
N     *  @note The correspondence table of IO_MAP is as follows:
N     *  
N     *                              USART 232                        USART 485      
N     *  
N     *               LL_USART_IO_MAP0     LL_USART_IO_MAP1      LL_USART_IO_MAP0   
N     *  
N     *    io name    usart_rx/usart_tx    usart_rx/usart_tx    usart_rx/usart_tx/  
N     *                                                         usart_re/usart_de   
N     *  
N     *    USART0         PA10/PA11                             PA10/PA11/PA9/PA8   
N     *  
N     *    USART1         PA12/PA13                             PA12/PA13/PA14/PA15 
N     *  
N     *    USART2          PD2/PD3             PA14/PA15         PD2/PD3/PD1/PD0    
N     *  
N     */
N    TYPE_ENUM_LL_USART_IOMAP_SEL     io_map;
N} TYPE_LL_USART_CFG;
N
Ntypedef struct __ll_rs485_cfg {
N    /*! USART 485 MODE selection
N     */
N    TYPE_ENUM_LL_USART485_MODE rs485_mode;
N    /*! USART RS485 Recieve signal output enable
N     */
N    bool                       re_sig_en;
N    /*! USART RS485 Recieve signal active level
N     */
N    Polarity                   re_sig_active_level;
N    /*! USART RS485 Transmit signal output enable
N     */
N    bool                       de_sig_en;
N    /*! USART RS485 Transmit signal active level
N     */
N    Polarity                   de_sig_active_level;
N    /*! USART RS485 Driver enable assertion time.  
N     * This field controls the amount of time (in terms of number of serial clock
N     * periods) between the assertion of rising edge of Driver output enable signal to
N     * serial transmit enable. Any data in transmit buffer, will start on serial output
N     * (sout) after the transmit enable.
N     */
N    u8                         de_assertion_time;
N    /*! USART RS485 Driver enable de-assertion time.  
N     * This field controls the amount of time (in terms of number of serial clock
N     * periods) between the end of stop bit on the serial output (sout) to the falling
N     * edge of Driver output enable signal.
N     */
N    u8                         de_deassertion_time;
N    /*! USART RS485 Receiver Enable to Driver Enable TurnAround time
N     * Turnaround time (in terms of serial clock) for RE de-assertion to DE assertion.
N     * @note:
N     *       If the DE assertion time in the DET register is 0, then the actual value is
N     *          the programmed value + 3.  
N     *       If the DE assertion time in the DET register is 1, then the actual value is
N     *          the programmed value + 2.  
N     *       If the DE assertion time in the DET register is greater than 1, then the
N     *          actual value is the programmed value + 1.
N     */
N    u16                        re2de_turnaround_time;
N    /*! USART RS485 Driver Enable to Receiver Enable TurnAround time
N     * Turnaround time (in terms of serial clock) for DE de-assertion to RE assertion.
N     * @note: The actual time is the programmed value + 1.
N     */
N    u16                        de2re_turnaround_time;
N    /*! USART232 cfg
N     */
N    TYPE_LL_USART_CFG          usart_cfg;
N} TYPE_LL_RS485_CFG;
N
N/**
N  * @brief USART low layer initialization structure
N  */
Ntypedef struct __ll_usart_init {
N    u8 reserved;
N} TYPE_LL_USART_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_Interrupt USART LL Interrupt Handle function
N  * @ingroup  USART_LL_Driver
N  * @brief   USART LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the USART  
N    Interrupt Handle function.
N
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup USART_LL_Inti_Cfg USART LL Initialization And Configuration
N  * @ingroup  USART_LL_Driver
N  * @brief    USART LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the USART data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/** 
N  * @brief  Low layer USART initialization function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @param  p_init : USART initialization struct
N  * @retval None.
N  */
Nvoid ll_usart_init(USART_TypeDef *p_usart, TYPE_LL_USART_INIT *p_init);
N
N/** 
N  * @brief  Low layer USART detele initialization function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
Nvoid ll_usart_deinit(USART_TypeDef *p_usart);
N
N/** 
N  * @brief  Low layer USART interrupt initialization function
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @param  p_cfg  : USART Configuration struct
N  * @retval None.
N  */
Nvoid ll_usart_irq_config(USART_TypeDef *p_usart, TYPE_LL_USART_IRQ_CFG *p_cfg);
N
N/** 
N  * @brief  low layer USART 232 initialization function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @param  p_cfg  : USART Configuration struct
N  * @retval None.
N  */
Nvoid ll_usart232_config(USART_TypeDef *p_usart, TYPE_LL_USART_CFG *p_cfg);
N
N/** 
N  * @brief  Low layer USART 485 initialization function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @param  p_cfg  : USART Configuration struct
N  * @retval None.
N  */
Nvoid ll_usart485_config(USART_TypeDef *p_usart, TYPE_LL_RS485_CFG *p_cfg);
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup USART_LL_Data_Transfers USART LL Data transfers functions
N  * @ingroup  USART_LL_Driver
N  * @brief    USART LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the USART data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/** 
N  * @brief  Get the status flag of the USART interrupt
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval status flag of the USART interrupt
N  */
N#define LL_USART_GET_INTR_STATUS(p_usart)                        ((p_usart)->IIR & LL_USARTX_IIR_IID(0xF)) 
N
N/** 
N  * @brief  Get the read ready state of the USART
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval the read ready state of the USART
N  */
N#define LL_USART_GET_LINE_DATA_READY(p_usart)                     ((p_usart)->LSR & LL_USARTX_LSR_DR)
N
N/** 
N  * @brief  Get the data in the USART
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @param  data   : the var to save result
N  * @retval the data in the USART
N  */
N#define LL_USART_READ_DATA(p_usart, data)                         (data = (p_usart)->RBR)
N
N/** 
N  * @brief  Get the status of whether the TX FIFO in the USART is FULL
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval the status of the TX FIFO in the USART
N  */
N#define LL_USART_TXFIFO_NOT_FULL(p_usart)                         ((p_usart)->USR & LL_USARTX_USR_TFNF)
N
N/** 
N  * @brief  Send data to the USART
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @param  data   : the value to be write
N  * @retval None.
N  */
N#define LL_USART_WRITE_DATA(p_usart, data)                        ((p_usart)->THR = data)
N
N/** 
N  * @brief  USART check rx data avail interrupt enable
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N#define LL_USART_CHECK_RX_DATA_AVAIL_INTERRUPT_ENABLE(p_usart)    ((p_usart)->IER & LL_USARTX_IER_ERBFI)
N
N/** 
N  * @brief  USART check rx line status interrupt enable
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N#define LL_USART_CHECK_RX_LINE_STATUS_INTERRUPT_ENABLE(p_usart)   ((p_usart)->IER & LL_USARTX_IER_ELSI)
N
N/** 
N  * @brief  USART check tx empty interrupt enable
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N#define LL_USART_CHECK_THR_EMPTY_INTERRUPT_ENABLE(p_usart)        ((p_usart)->IER & LL_USARTX_IER_ETBEI)
N
N/** 
N  * @brief  USART check modem status interrupt enable
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N#define LL_USART_CHECK_MODEM_STATUS_INTERRUPT_ENABLE(p_usart)     ((p_usart)->IER & LL_USARTX_IER_EDSSI)
N
N/** 
N  * @brief  USART check program thre interrupt enable
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N#define LL_USART_CHECK_PROGRAM_THRE_INTERRUPT_ENABLE(p_usart)     ((p_usart)->IER & LL_USARTX_IER_PTIME)
N
N/** 
N  * @brief  USART clear rx data avail pending
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N__STATIC_INLINE void ll_usart_clear_rx_data_avail_pending(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_clear_rx_data_avail_pending(USART_TypeDef *p_usart) {
N    /* read USARTx->RBR to clear the interrupt of RX_DATA_AVAIL,  
N     * But need to be implemented in the A function, you can call
N     * LL_USART_READ_DATA() to clear.
N     */
N}
N
N/** 
N  * @brief  USART clear rx line status pending
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N__STATIC_INLINE void ll_usart_clear_rx_line_status_pending(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_clear_rx_line_status_pending(USART_TypeDef *p_usart) {
N    /* read USARTx->LSR to clear the interrupt of RX_LINE_STATUS */
N    p_usart->LSR = p_usart->LSR;
N}
N
N/** 
N  * @brief  USART clear thr empty pending
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N__STATIC_INLINE void ll_usart_clear_thr_empty_pending(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_clear_thr_empty_pending(USART_TypeDef *p_usart) {
N    /* read USARTx->RBR or write USARTx->THR to clear the interrupt 
N     * of THR_EMPTY, But need to be implemented in the A function, 
N     * you can call LL_USART_READ_DATA() or LL_USART_WRITE_DATA to clear 
N     */
N}
N
N/** 
N  * @brief  USART clear busy detect pending
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N__STATIC_INLINE void ll_usart_clear_busy_detect_pending(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_clear_busy_detect_pending(USART_TypeDef *p_usart) {
N    /* read USARTx->USR to clear the interrupt of BUSY_DETECT */
N    p_usart->USR = p_usart->USR;
N}
N
N/** 
N  * @brief  USART clear char timeout pending
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N__STATIC_INLINE void ll_usart_clear_char_timeout_pending(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_clear_char_timeout_pending(USART_TypeDef *p_usart) {
N    /* read USARTx->RBR to clear the interrupt of CHAR_TIMEOUT,  
N     * But need to be implemented in the A function, you can call
N     * LL_USART_READ_DATA() to clear 
N     */
N}
N
N/** 
N  * @brief  USART clear modem status pending
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval result.
N  */
N__STATIC_INLINE void ll_usart_clear_modem_status_pending(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_clear_modem_status_pending(USART_TypeDef *p_usart) {
N    /* read USARTx->MSR to clear the interrupt of MODEM_STATUS */
N    p_usart->MSR = p_usart->MSR;
N}
N
N/** 
N  * @brief  Usart TX wait function.
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_wait_tx_pending(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_wait_tx_pending(USART_TypeDef *p_usart) {
N    /* wait tx fifo empty */
N    while(0 == (p_usart->USR & LL_USARTX_USR_TFE));   
X    while(0 == (p_usart->USR & (1UL << 2)));   
N    while(0 == (p_usart->LSR & LL_USARTX_LSR_TEMT));
X    while(0 == (p_usart->LSR & (1UL << 6)));
N}
N
N/** 
N  * @brief  Usart put char function.
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @param  data   : data which will send to USART TX pin.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_putchar(USART_TypeDef *p_usart, u8 data) {
Xstatic __inline void ll_usart_putchar(USART_TypeDef *p_usart, u8 data) {
N    while((p_usart->USR & LL_USARTX_USR_TFNF) == 0);
X    while((p_usart->USR & (1UL << 1)) == 0);
N    p_usart->THR = data; 
N}
N
N/** 
N  * @brief  Usart get char function.
N  * @param  p_usart: The structure pointer of the USART group (USART0, USART1, USART2) is selected.
N  * @retval The data received by the Usart
N  */
N__STATIC_INLINE u8 ll_usart_getchar(USART_TypeDef *p_usart) {
Xstatic __inline u8 ll_usart_getchar(USART_TypeDef *p_usart) {
N    while((p_usart->LSR & LL_USARTX_LSR_DR) == 0);
X    while((p_usart->LSR & (1UL << 0)) == 0);
N    return p_usart->RBR;
N}
N
N/** 
N  * @brief  Low layer USART enable receive ready interrupt function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_rx_ready_interrupt_enable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_rx_ready_interrupt_enable(USART_TypeDef *p_usart) {
N    p_usart->IER |= LL_USARTX_IER_MASK(LL_USARTX_IER_ERBFI);
X    p_usart->IER |= ((((1UL << 0))&0xFF) << 0);
N}
N
N/** 
N  * @brief  Low layer USART enable send empty interrupt function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_tx_empty_interrupt_enable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_tx_empty_interrupt_enable(USART_TypeDef *p_usart) {
N    p_usart->IER |= LL_USARTX_IER_MASK(LL_USARTX_IER_ETBEI);
X    p_usart->IER |= ((((1UL << 1))&0xFF) << 0);
N}
N
N/** 
N  * @brief  Low layer USART enable receive line status interrupt function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_rx_line_status_interrupt_enable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_rx_line_status_interrupt_enable(USART_TypeDef *p_usart) {
N    p_usart->IER |= LL_USARTX_IER_MASK(LL_USARTX_IER_ELSI);
X    p_usart->IER |= ((((1UL << 2))&0xFF) << 0);
N}
N
N/** 
N  * @brief  Low layer USART enable modem status interrupt function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_modem_status_interrupt_enable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_modem_status_interrupt_enable(USART_TypeDef *p_usart) {
N    p_usart->IER |= LL_USARTX_IER_MASK(LL_USARTX_IER_EDSSI);
X    p_usart->IER |= ((((1UL << 3))&0xFF) << 0);
N}
N
N/** 
N  * @brief  Low layer USART enable program thre interrupt function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_program_thre_interrupt_enable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_program_thre_interrupt_enable(USART_TypeDef *p_usart) {
N    p_usart->IER |= LL_USARTX_IER_MASK(LL_USARTX_IER_PTIME);
X    p_usart->IER |= ((((1UL << 7))&0xFF) << 0);
N}
N
N/** 
N  * @brief  Low layer USART disable receive ready interrupt function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_rx_ready_interrupt_disable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_rx_ready_interrupt_disable(USART_TypeDef *p_usart) {
N    p_usart->IER &= ~(LL_USARTX_IER_MASK(LL_USARTX_IER_ERBFI));
X    p_usart->IER &= ~(((((1UL << 0))&0xFF) << 0));
N}
N
N/** 
N  * @brief  Low layer USART disable send empty interrupt function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_tx_empty_interrupt_disable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_tx_empty_interrupt_disable(USART_TypeDef *p_usart) {
N    p_usart->IER &= ~(LL_USARTX_IER_MASK(LL_USARTX_IER_ETBEI));
X    p_usart->IER &= ~(((((1UL << 1))&0xFF) << 0));
N}
N
N/** 
N  * @brief  Low layer USART disable receive line status interrupt function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_rx_line_status_interrupt_disable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_rx_line_status_interrupt_disable(USART_TypeDef *p_usart) {
N    p_usart->IER &= ~(LL_USARTX_IER_MASK(LL_USARTX_IER_ELSI));
X    p_usart->IER &= ~(((((1UL << 2))&0xFF) << 0));
N}
N
N/** 
N  * @brief  Low layer USART disable modem status interrupt function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_modem_status_interrupt_disable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_modem_status_interrupt_disable(USART_TypeDef *p_usart) {
N    p_usart->IER &= ~(LL_USARTX_IER_MASK(LL_USARTX_IER_EDSSI));
X    p_usart->IER &= ~(((((1UL << 3))&0xFF) << 0));
N}
N
N/** 
N  * @brief  Low layer USART disable program thre interrupt function
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_usart_program_thre_interrupt_disable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart_program_thre_interrupt_disable(USART_TypeDef *p_usart) {
N    p_usart->IER &= ~(LL_USARTX_IER_MASK(LL_USARTX_IER_PTIME));
X    p_usart->IER &= ~(((((1UL << 7))&0xFF) << 0));
N}
N
N/** 
N  * @brief  Low layer USART Receive FIFO Level
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval Receive FIFO Level.
N  */
N#define LL_USART_GET_RX_FIFO_LEVEL(p_usart)     ((p_usart)->RFL)
N  
N/** 
N  * @brief  Low layer USART Transmit FIFO Level
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval Transmit FIFO Level.
N  */
N#define LL_USART_GET_TX_FIFO_LEVEL(p_usart)     ((p_usart)->TFL)
N
N/** 
N  * @brief  Low layer USART 485 mode1 rx enable
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  * @note   This is only used at rs485 mode 1
N  */
N__STATIC_INLINE void ll_usart485_mode1_rx_enable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart485_mode1_rx_enable(USART_TypeDef *p_usart) {
N    p_usart->RE_EN = 1;
N}
N
N/** 
N  * @brief  Low layer USART 485 mode1 rx disable
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  * @note   This is only used at rs485 mode 1
N  */
N__STATIC_INLINE void ll_usart485_mode1_rx_disable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart485_mode1_rx_disable(USART_TypeDef *p_usart) {
N    p_usart->RE_EN = 0;
N}
N
N/** 
N  * @brief  Low layer USART 485 mode1 tx enable
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  * @note   This is only used at rs485 mode 1
N  */
N__STATIC_INLINE void ll_usart485_mode1_tx_enable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart485_mode1_tx_enable(USART_TypeDef *p_usart) {
N    p_usart->DE_EN = 1;
N}
N
N/** 
N  * @brief  Low layer USART 485 mode1 tx disable
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  * @note   This is only used at rs485 mode 1
N  */
N__STATIC_INLINE void ll_usart485_mode1_tx_disable(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart485_mode1_tx_disable(USART_TypeDef *p_usart) {
N    p_usart->DE_EN = 0;
N}
N
N/** 
N  * @brief  USART Parity bit stick to low
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  * @note   Parity and Stick feature must be enabled before transfer.
N  */
N__STATIC_INLINE void ll_usart232_stick_parity_logic_0(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart232_stick_parity_logic_0(USART_TypeDef *p_usart) {
N    p_usart->LCR |= LL_USARTX_LCR_EPS;
X    p_usart->LCR |= (1UL << 4);
N}
N
N/** 
N  * @brief  USART Parity bit stick to high
N  * @param  p_usart: where x can be 1, 2, 3 to select the UART.
N  * @retval None.
N  * @note   Parity and Stick feature must be enabled before transfer.
N  */
N__STATIC_INLINE void ll_usart232_stick_parity_logic_1(USART_TypeDef *p_usart) {
Xstatic __inline void ll_usart232_stick_parity_logic_1(USART_TypeDef *p_usart) {
N    p_usart->LCR &= ~LL_USARTX_LCR_EPS;
X    p_usart->LCR &= ~(1UL << 4);
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_USART_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 29 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe_debug.h" 2
N#include <string.h>
L 1 "D:\Tools\KIEIL\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 30 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe_debug.h" 2
N#include <stdio.h>
L 1 "D:\Tools\KIEIL\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 31 "..\..\..\..\Libraries\Device\Phoenix\include\tx_phe_debug.h" 2
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup debug_interface_gr DEBUG Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup DEBUG_LL_Driver DEBUG LL Driver
N  * @ingroup  debug_interface_gr
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DEBUG_LL_Exported_Constants DEBUG LL Exported Constants
N  * @ingroup  DEBUG_LL_Driver
N  * @brief    DEBUG LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief Debug interface type selection
N  */
Ntypedef enum {
N    DEBUG_NO = 0,
N    DEBUG_ITM,
N    DEBUG_USART0,
N    DEBUG_USART1,
N    DEBUG_USART2,
N} TYPE_ENUM_DEBUG_INTERFACE_SEL;
N  
N/**
N  * @}
N  */
N  
N  
N/** @defgroup DEBUG_LL_Inti_Cfg DEBUG LL Initialization And Configuration
N  * @brief    DEBUG LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DEBUG data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Configure the debug interface, mainly the ITM and USART modules.
N  * @param  debug_interface: Debug interface type selection.
N  * @retval None
N  */
Nvoid debug_select_interface(TYPE_ENUM_DEBUG_INTERFACE_SEL debug_interface);
N
N/**
N  * @}
N  */
N  
N/** @defgroup DEBUG_LL_Data_Transfers DEBUG LL Data transfers functions
N  * @brief    DEBUG LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DEBUG data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/** 
N  * @brief  printf array.
N  * @param  ptr: the address of the data which will send to RS485 TX pin.
N  * @param  len: the len of data which will send.
N  * @retval None.
N  */
Nvoid printf_array(void *ptr, u16 len);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_DEBUG_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 32 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N     
N#include "tx_phe_ll_gpio.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_gpio.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the GPIO LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_GPIO_H
N#define __TX_PHE_LL_GPIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup gpio_interface_gr GPIO Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup GPIO_LL_Driver GPIO LL Driver
N  * @ingroup  gpio_interface_gr
N  * @brief Mainly the driver part of the GPIO module, which includes \b GPIO \b Register 
N  * \b Constants, \b GPIO \b Exported \b Constants, \b GPIO \b Exported \b Struct, \b GPIO
N  * \b Data \b transfers \b functions, \b GPIO \b Initialization \b and \b GPIO \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup GPIO_LL_Register_Constants GPIO LL Register Constants
N  * @ingroup  GPIO_LL_Driver
N  * @brief    GPIO LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the GPIO 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the GPIO register, mainly for convenience. Understand the 
N    configuration of the GPIO.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_LL_Exported_Constants GPIO LL Exported Constants
N  * @ingroup  GPIO_LL_Driver
N  * @brief    GPIO LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N#define GPIOB_PWM_PIN_MASK              0x3FFF
N#define GPIOB_KEY_VALUE                 ((GPIO_KEY_C ) | (GPIO_KEY_B ) | (GPIO_KEY_A ))
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for GPIO pin direction select
N  */
Ntypedef enum {             
N    /*! Set GPIO to input mode.
N     */
N    LL_GPIO_PIN_INPUT,
N    /*! Set GPIO to output mode.
N     */
N    LL_GPIO_PIN_OUTPUT
N} TYPE_ENUM_LL_GPIO_PIN_DIRECTION;
N
N/**
N  * @brief Enumeration constant for GPIO pin pull mode select
N  */
Ntypedef enum {
N    /*! Set the GPIO pull mode to NO.
N     */
N    LL_GPIO_PULL_NONE           = 0x01,
N    /*! Set the GPIO pull mode to pull up mode.
N     */
N    LL_GPIO_PULL_UP             = 0x02,
N    /*! Set the GPIO pull mode to pull down mode.
N     */
N    LL_GPIO_PULL_DOWN           = 0x04,
N
N    /*! Set the GPIO pull open-drain mode mask.
N     */
N    LL_GPIO_OPENDRAIN_PULL_MASK = 0x80,
N    /*! Set the GPIO pull open-drain mode to NO.
N     */
N    LL_GPIO_OPENDRAIN_PULL_NONE = 0x81,
N    /*! Set the GPIO pull open-drain mode to up mode.
N     */
N    LL_GPIO_OPENDRAIN_PULL_UP   = 0x82,
N    /*! Set the GPIO pull open-drain mode to down mode.
N     */
N    LL_GPIO_OPENDRAIN_PULL_DOWN = 0x84,
N} TYPE_ENUM_LL_GPIO_PIN_PULL_MODE;
N
N/** 
N  * @brief  GPIO Bit SET and Bit RESET enumeration 
N  */ 
Ntypedef enum{
N    /*! BIT_SET means to let the GPIO output a high level.
N     */
N    LL_GPIO_RESET = 0x00,
N    /*! BIT_RESET means to let the GPIO output a low level.
N     */
N    LL_GPIO_SET,
N} TYPE_ENUM_LL_GPIO_BIT_ACTION;
N
N/** 
N  * @brief  GPIO debounce clock source selection.
N  */
Ntypedef enum {
N    /*! Clock source selection for GPIO debounce: crystal oscillator clock 26M.
N     */
N    LL_GPIO_DEBOUNCE_CLK_26M = 0,
N    /*! Clock source selection for GPIO debounce: Internal clock source 8M.
N     */
N    LL_GPIO_DEBOUNCE_CLK_RC8M,
N    /*! Clock source selection for GPIO debounce: System clock.
N     */
N    LL_GPIO_DEBOUNCE_CLK_SYSCLK,
N    /*! Clock source selection for GPIO debounce: Internal clock source 32K.
N     */
N    LL_GPIO_DEBOUNCE_CLK_RC32K,
N} TYPE_ENUM_DEBOUNCE_CLK_SEL;
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_LL_Exported_Struct GPIO LL Exported Struct
N  * @ingroup  GPIO_LL_Driver
N  * @brief    GPIO LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the GPIO registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_gpio_init. Function, you can configure the GPIO module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_LL_Interrupt GPIO LL Interrupt Handle function
N  * @brief   GPIO LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the GPIO  
N    Interrupt Handle function.
N
N    how to use?
N
N    The GPIO interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the GPIO in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup GPIO_LL_Inti_Cfg GPIO LL Initialization And Configuration
N  * @brief    GPIO LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the GPIO data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/** 
N  * @brief  Low layer set the gpio dir value.
N  * @param  p_gpio  : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_bits: specifies the port bit to read.
N  *                   This parameter can be gpio_pin_x where x can be (0..15). 
N  * @param  dir     : The dir to be set.
N  * @retval None.
N  */
Nvoid ll_gpio_dir(GPIO_TypeDef *p_gpio, u32 pin_bits, TYPE_ENUM_LL_GPIO_PIN_DIRECTION dir);
N
N/** 
N  * @brief  Low layer Set the gpio pin mode(input or output).
N  * @param  p_gpio  : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_bits: specifies the port bit to read.
N  *                   This parameter can be gpio_pin_x where x can be (0..15). 
N  * @param  mode    : The PULL mode to be set.
N  * @retval None.
N  */
Nvoid ll_gpio_pull(GPIO_TypeDef *p_gpio, u32 pin_bits, TYPE_ENUM_LL_GPIO_PIN_PULL_MODE mode);
N
N/**
N  * @}
N  */
N  
N/** @defgroup GPIO_LL_Data_Transfers GPIO LL Data transfers functions
N  * @brief    GPIO LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the GPIO data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  Low layer set the specified output data port bit.
N  * @param  p_gpio  : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_bits: specifies the port bit to read.
N  *                   This parameter can be GPIO_Pin_x where x can be (0..15).
N  * @retval None.
N  */
N__STATIC_INLINE void ll_gpio_bit_set(GPIO_TypeDef* p_gpio, u16 pin_bits) {
Xstatic __inline void ll_gpio_bit_set(GPIO_TypeDef* p_gpio, u16 pin_bits) {
N    p_gpio->BSRS = ((u32)pin_bits) << 16;
N}
N
N/**
N  * @brief  Low layer reset the specified output data port bit.
N  * @param  p_gpio  : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_bits: specifies the port bit to read.
N  *                   This parameter can be GPIO_Pin_x where x can be (0..15).
N  * @retval None.
N  */
N__STATIC_INLINE void ll_gpio_bit_reset(GPIO_TypeDef* p_gpio, u16 pin_bits) {
Xstatic __inline void ll_gpio_bit_reset(GPIO_TypeDef* p_gpio, u16 pin_bits) {
N    p_gpio->BSRS = ((u32)pin_bits) & 0xFFFF;
N}
N
N/**
N  * @brief  Low layer Reads the specified GPIO data port pin.
N  * @param  p_gpio  : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_bits: specifies the port bit to read.
N  *                   This parameter can be gpio_pin_x where x can be (0..15).
N  * @retval The input port pin value.
N  */
N__STATIC_INLINE TYPE_ENUM_LL_GPIO_BIT_ACTION ll_gpio_read_data_bit(GPIO_TypeDef* p_gpio, u16 pin_bits) {
Xstatic __inline TYPE_ENUM_LL_GPIO_BIT_ACTION ll_gpio_read_data_bit(GPIO_TypeDef* p_gpio, u16 pin_bits) {
N    TYPE_ENUM_LL_GPIO_BIT_ACTION bit_status = LL_GPIO_RESET;
N    
N    if ((p_gpio->DR & pin_bits) != (u32)LL_GPIO_RESET) {
N        bit_status = LL_GPIO_SET;
N    } else {
N        bit_status = LL_GPIO_RESET;
N    }
N    
N    return bit_status;
N}
N
N/**
N  * @brief  Low layer Reads the specified GPIO data port pin.
N  * @param  p_gpio: where x can be (A..D) to select the GPIO peripheral.
N  * @retval GPIO input data port value.
N  */
N__STATIC_INLINE u32 ll_gpio_read_data(GPIO_TypeDef* p_gpio) {
Xstatic __inline u32 ll_gpio_read_data(GPIO_TypeDef* p_gpio) {
N    return (p_gpio->DR);
N}
N
N/**
N  * @brief  Low layer Write the specified output data port bit.
N  * @param  p_gpio  : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_bits: specifies the port bit to read.
N  *                   This parameter can be GPIO_Pin_x where x can be (0..15).
N  * @param  pin_val : gpio set value.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_gpio_write_data_bit(GPIO_TypeDef* p_gpio, u32 pin_bits, u8 pin_val){
Xstatic __inline void ll_gpio_write_data_bit(GPIO_TypeDef* p_gpio, u32 pin_bits, u8 pin_val){
N    u32 bit_status = p_gpio->DR;
N    
N    if (pin_val) {
N        bit_status |= pin_bits;
N    } else {
N        bit_status &= ~pin_bits;
N    }
N    p_gpio->DR = bit_status;
N}
N
N/**
N  * @brief  Low layer Reads the specified GPIO output data port.
N  * @param  p_gpio : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_val: gpio set value.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_gpio_write_data(GPIO_TypeDef* p_gpio, u32 pin_val) {
Xstatic __inline void ll_gpio_write_data(GPIO_TypeDef* p_gpio, u32 pin_val) {
N    p_gpio->DR = pin_val;
N}
N
N/**
N  * @brief  Low layer Gpio disable external interrupt function.
N  * @param  p_gpio  : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_bits: specifies the port bit to read.
N  *                   This parameter can be GPIO_Pin_x where x can be (0..15).
N  * @retval None.
N  */
N__STATIC_INLINE void ll_gpio_interrupt_disable(GPIO_TypeDef* p_gpio, u32 pin_bits) {
Xstatic __inline void ll_gpio_interrupt_disable(GPIO_TypeDef* p_gpio, u32 pin_bits) {
N    p_gpio->INTMASK &= ~pin_bits;
N}
N
N/**
N  * @brief  Low layer Gpio enable external interrupt function.
N  * @param  p_gpio  : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_bits: specifies the port bit to read.
N  *                   This parameter can be GPIO_Pin_x where x can be (0..15).
N  * @retval None.
N  */
N__STATIC_INLINE void ll_gpio_interrupt_enable(GPIO_TypeDef* p_gpio, u32 pin_bits) {
Xstatic __inline void ll_gpio_interrupt_enable(GPIO_TypeDef* p_gpio, u32 pin_bits) {
N    p_gpio->INTMASK |= pin_bits;
N}
N
N/** 
N  * @brief  Enable the debounce function of GPIO.
N  * @param  p_gpio  : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_bits: specifies the port bit to read.
N  *                   This parameter can be gpio_pin_x where x can be (0..15). 
N  * @param  clk_sel : GPIO debounce clock source selection.
N  * @param  div_val : The division ratio of the clock source.
N  * @retval None.
N  * @note   Time to debounce calculation: 1/clk_sel(The actual clock)*
N  */
Nvoid ll_gpio_debounce_enable(GPIO_TypeDef *p_gpio, u16 pin_bits, TYPE_ENUM_DEBOUNCE_CLK_SEL clk_sel, u8 div_val);
N
N/** 
N  * @brief  Disable the debounce function of GPIO.
N  * @param  p_gpio  : where x can be (A..D) to select the GPIO peripheral.
N  * @param  pin_bits: specifies the port bit to read.
N  *                   This parameter can be gpio_pin_x where x can be (0..15). 
N  * @retval None.
N  */
Nvoid ll_gpio_debounce_disable(GPIO_TypeDef *p_gpio, u16 pin_bits);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_GPIO_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 34 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_usart.h"
N#include "tx_phe_ll_epwm.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_epwm.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_epwm.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.2
N  * @date    09-05-2019
N  * @brief   This file contains all the EPWM LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_EPWM_H
N#define __TX_PHE_LL_EPWM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N#include "tx_phe_ll_cc_rst.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_cc_rst.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_cc_rst.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.1
N  * @date    03-08-2018
N  * @brief   This file contains all the CC_RST LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_CC_RST_H
N#define __TX_PHE_LL_CC_RST_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup cc_rst_interface_gr CC_RST Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N
N/** globle clock trees
N *
N *                      WDT 
N *                       |
N *  RC32KHZ--------------|----------->|                       |---->APB0
N *                                    |-->SYS_CLK---->FCLK---->|
N *                      SYSPLL------->|                       |---->APB1|
N *                       ||           ||
N *  HXOSC HZ-------------||---------->||
N *                       ||           ||
N *  RC8MHZ-------------- ||---------->||
N *                       ||            |
N *                      ADCPLL-------->|-->EPWMCLK
N *                       |
N *                      FADC
N *
N */
N 
N
N/** @addtogroup CC_RST_LL_Driver CC_RST LL Driver
N  * @ingroup  cc_rst_interface_gr
N  * @brief Mainly the driver part of the CC_RST module, which includes \b CC_RST \b Register 
N  * \b Constants, \b CC_RST \b Exported \b Constants, \b CC_RST \b Exported \b Struct, \b CC_RST
N  * \b Data \b transfers \b functions, \b CC_RST \b Initialization \b and \b CC_RST \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N	 
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N	 
N/** @defgroup CC_RST_LL_Register_Constants CC_RST LL Register Constants
N  * @ingroup  CC_RST_LL_Driver
N  * @brief    CC_RST LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the CC_RST 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the CC_RST register, mainly for convenience. Understand the 
N    configuration of the CC_RST.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** SYS_CON0 *****/
N/*! test out clock enable
N */
N#define LL_CC_SYSCON0_TEST_OUT_EN                           (1UL << 3)
N
N/***** SYS_CON1 *****/
N
N/***** AIP_CON0 *****/
N/*! The SYSPLL analog section is enabled.
N */
N#define LL_CC_AIPCON0_SYSPLL_EN                             (1UL << 0)
N/*! SYSPLL center frequency setting.
N */
N#define LL_CC_AIPCON0_SYSPLL_BAND_SET(n)                    (((n)&0x03) << 1)
N#define LL_CC_AIPCON0_SYSPLL_BAND_GET(n)                    (((n) >> 1) & 0x03)
N/*! SYSPLL CP current setting.
N */
N#define LL_CC_AIPCON0_SYSPLL_GCP_SET(n)                     (((n)&0x03) << 3)
N/*! SYSPLL VCO frequency adjustment gain control.
N */
N#define LL_CC_AIPCON0_SYSPLL_GVCO_SET(n)                    (((n)&0x03) << 5)
N/*! SYSPLL test signal output selection.
N */
N#define LL_CC_AIPCON0_SYSPLL_TEN_SET(n)                     (((n)&0x0F) << 8)
N/*! The ADCPLL analog section is enabled.
N */
N#define LL_CC_AIPCON0_ADCPLL_EN                             (1UL << 12)
N/*! ADCPLL center frequency setting.
N */
N#define LL_CC_AIPCON0_ADCPLL_BAND_SET(n)                    (((n)&0x03) << 13)
N#define LL_CC_AIPCON0_ADCPLL_BAND_GET(n)                    (((n) >> 13) & 0x03)
N/*! ADCPLL CP current setting.
N */
N#define LL_CC_AIPCON0_ADCPLL_GCP_SET(n)                     (((n)&0x03) << 15)
N/*! ADCPLL VCO frequency adjustment gain control.
N */
N#define LL_CC_AIPCON0_ADCPLL_GVCO_SET(n)                    (((n)&0x03) << 17)
N/*! ADCPLL test signal output selection.
N */
N#define LL_CC_AIPCON0_ADCPLL_TEN_SET(n)                     (((n)&0x0F) << 20)
N/*! SYSPLL reference clock selection
N */
N#define LL_CC_AIPCON0_SYSPLL_LPFSEL_RC8M                    (1UL << 24)
N/*! ADCPLL reference clock selection
N */
N#define LL_CC_AIPCON0_ADCPLL_LPFSEL_RC8M                    (1UL << 26)
N
N/***** AIP_CON1 *****/
N/*! HXOSC enable
N */
N#define LL_CC_AIPCON1_HXOSC_EN                              (1UL << 0)
N/*! HXOSC resonant capacitor coarse adjustment
N */
N#define LL_CC_AIPCON1_HXOSC_CS_SET(n)                       (((n)&0x07) << 1)
N/*! HXOSC HXI port resonant capacitor fine tuning
N */
N#define LL_CC_AIPCON1_HXOSC_CTI_SET(n)                      (((n)&0x07) << 4)
N/*! HXOSC HXO port resonant capacitor fine tuning
N */
N#define LL_CC_AIPCON1_HXOSC_CTO_SET(n)                      (((n)&0x07) << 8)
N/*! HXOSC starting current setting
N */
N#define LL_CC_AIPCON1_HXOSC_DR_SET(n)                       (((n)&0x07) << 12)
N/*! Hysteresis enable for the HXOSC comparator
N */
N#define LL_CC_AIPCON1_HXOSC_HY_EN                           (1UL << 15)
N/*! RC 8M enable
N */
N#define LL_CC_AIPCON1_RC8M_EN                               (1UL << 16)
N
N/***** CLK_CON0 *****/
N/*! system clock source select , reference to TYPE_ENUM_LL_CC_RST_SYSCLK_SRC
N */
N#define LL_CC_RST_SYSCLK_SRC_SEL(n)                         (((n)&0x3) << 0)
N#define LL_CC_RST_SYSCLK_SRC_GET(n)                         (((n) >> 0) & 0x03)
N/*! Test clock output selection
N */
N#define LL_CC_CLKCON0_TEST_CLK_SEL(n)                       (((n)&0x7) << 4)
N#define LL_CC_CLKCON0_TEST_CLK_SEL_MASK                     (0x07UL << 4)
N/*! system pll clock source select , reference to TYPE_ENUM_LL_CC_RST_EPWM_CLK_SRC
N */
N#define LL_CC_RST_EPWM_CLK_SRC_SEL(n)                       (((n)&0x3) << 7)
N
N/*! system pll clock source select , reference to TYPE_ENUM_LL_CC_RST_PLLCLK_SRC
N */
N#define LL_CC_RST_SYSPLL_CLK_SRC_SEL(n)                     (((n)&0x3) << 11)
N#define LL_CC_RST_SYSPLL_CLK_SRC_GET(n)                     (((n) >> 11) & 0x03)
N/*! adc pll clock source select , reference to TYPE_ENUM_LL_CC_RST_PLLCLK_SRC
N */
N#define LL_CC_RST_ADCPLL_CLK_SRC_SEL(n)                     (((n)&0x3) << 15)
N#define LL_CC_RST_ADCPLL_CLK_SRC_GET(n)                     (((n) >> 15) & 0x03)
N
N/*! gpio debunce clock source select , reference to TYPE_ENUM_LL_CC_RST_GPIO_DEBCLK_SRC
N */
N#define LL_CC_RST_GPIOA_DEB_CLK_SRC_SEL(n)                  (((n)&0x3) << 17)
N/*! gpio debunce clock source select , reference to TYPE_ENUM_LL_CC_RST_GPIO_DEBCLK_SRC
N */
N#define LL_CC_RST_GPIOB_DEB_CLK_SRC_SEL(n)                  (((n)&0x3) << 19)
N/*! gpio debunce clock source select , reference to TYPE_ENUM_LL_CC_RST_GPIO_DEBCLK_SRC
N */
N#define LL_CC_RST_GPIOC_DEB_CLK_SRC_SEL(n)                  (((n)&0x3) << 21)
N/*! gpio debunce clock source select , reference to TYPE_ENUM_LL_CC_RST_GPIO_DEBCLK_SRC
N */
N#define LL_CC_RST_GPIOD_DEB_CLK_SRC_SEL(n)                  (((n)&0x3) << 23)
N
N
N/***** CLK_CON1 *****/
N/*! system clock divor , fclk/ahb_clk = sysclk/(divor + 1)
N */
N#define LL_CC_RST_SYSCLK_DIV(n)                             (((n)&0xFF) << 0)
N/*! apb0 clock divor , apb_clk = ahb_clk/(divor + 1)
N */
N#define LL_CC_RST_APB0CLK_DIV(n)                            (((n)&0xFF) << 8)
N/*! apb1 clock divor , apb_clk = ahb_clk/(divor + 1)
N */
N#define LL_CC_RST_APB1CLK_DIV(n)                            (((n)&0xFF) << 16)
N
N
N/***** CLK_CON2 *****/
N/*! EPWM clock divor , epwm_clk = epwm_src_clk/(divor + 1)
N */
N#define LL_CC_RST_EPWMCLK_DIV(n)                            (((n)&0xF) << 12)
N/*! ADCPLL clock divor , adcpll_clk = adcpll_src_clk/(divor + 1)
N */
N#define LL_CC_RST_ADCPLLCLK_DIV(n)                          (((n)&0xF) << 8)
N/*! ADC clock divor , adc_clk = adcpll_clk/(divor + 1)
N */
N#define LL_CC_RST_ADCCLK_DIV(n)                             (((n)&0xF) << 4)
N/*! SYSPLL clock divor , syspll_clk = syspll_src_clk/(divor + 1)
N */
N#define LL_CC_RST_SYSPLLCLK_DIV(n)                          (((n)&0xF) << 0)
N#define LL_CC_RST_SYSPLLCLK_DIV_GET(n)                      (((n) >> 0) & 0x0F)
N
N
N/***** CLK_CON3 *****/
N/*! GPIO debunce clock divor , gpio_debunce_clk = gpio_src_clk/(divor + 1)
N */
N#define LL_CC_RST_GPIOD_DEBCLK_DIV(n)                       (((n)&0xF) << 24)
N/*! GPIO debunce clock divor , gpio_debunce_clk = gpio_src_clk/(divor + 1)
N */
N#define LL_CC_RST_GPIOC_DEBCLK_DIV(n)                       (((n)&0xF) << 16)
N/*! GPIO debunce clock divor , gpio_debunce_clk = gpio_src_clk/(divor + 1)
N */
N#define LL_CC_RST_GPIOB_DEBCLK_DIV(n)                       (((n)&0xF) << 8)
N/*! GPIO debunce clock divor , gpio_debunce_clk = gpio_src_clk/(divor + 1)
N */
N#define LL_CC_RST_GPIOA_DEBCLK_DIV(n)                       (((n)&0xF) << 0)
N
N
N/**
N  * @}
N  */
N
N/** @defgroup CC_RST_LL_Exported_Constants CC_RST LL Exported Constants
N  * @ingroup  CC_RST_LL_Driver
N  * @brief    CC_RST LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief define the PLL reference clock source
N  */
Ntypedef enum {
N    /*! HXOSC.
N     */
N    LL_CC_RST_PLL_REFCLK_HXOSC   = 0,
N    /*! RC8M.
N     */
N    LL_CC_RST_PLL_REFCLK_RC8M     = 1,
N} TYPE_ENUM_LL_CC_RST_PLL_REFCLK;
N
N/**
N  * @brief define the PLL center frequnce
N  */
Ntypedef enum {
N    /*! 312MHZ
N     */
N    LL_CC_RST_PLL_FREQ_312DIV4MHZ   = 0,
N    /*! 396MHZ
N     */
N    LL_CC_RST_PLL_FREQ_396DIV4MHZ   = 1,
N    /*! 466MHZ
N     */
N    LL_CC_RST_PLL_FREQ_466DIV4MHZ   = 2,
N    /*! 520MHZ
N     */
N    LL_CC_RST_PLL_FREQ_520DIV4MHZ   = 3,
N} TYPE_ENUM_LL_CC_RST_PLL_FREQ;
N
N/**
N  * @brief define the epwm clock source
N  */
Ntypedef enum {
N    /*! RC8M.
N     */
N    LL_CC_RST_EPWM_CLK_RC8M     = 0,
N    /*! HXOSC.
N     */
N    LL_CC_RST_EPWM_CLK_HXOSC    = 1,
N    /*! SYSPLL
N     */
N    LL_CC_RST_EPWM_CLK_SYSPLL   = 2,
N    /*! ADCPLL
N     */
N    LL_CC_RST_EPWM_CLK_ADCPLL   = 3,
N
N} TYPE_ENUM_LL_CC_RST_EPWM_CLK_SRC;
N
N/**
N  * @brief define the pll clock source
N  */
Ntypedef enum {
N    /*! OSC 26Mhz.
N     */
N    LL_CC_RST_PLLCLK_SRC_HXOSC     = 0,
N    /*! RC 8Mhz.
N     */
N    LL_CC_RST_PLLCLK_SRC_RC8M      = 1,
N    /*! no clock
N     */
N    LL_CC_RST_PLLCLK_SRC_NONE      = 2,
N    /*! dft clock input
N     */
N    LL_CC_RST_PLLCLK_SRC_DFTCLK    = 3,
N
N} TYPE_ENUM_LL_CC_RST_PLLCLK_SRC;
N
N/**
N  * @brief define the system clock source
N  */
Ntypedef enum {
N    /*! RC32Khz.
N     */
N    LL_CC_RST_SYSCLK_SRC_RC32K          = 0,
N    /*! OSC 26Mhz.
N     */
N    LL_CC_RST_SYSCLK_SRC_HXOSC          = 1,
N    /*! PLL DIV
N     */
N    LL_CC_RST_SYSCLK_SRC_SYSPLL_DIV     = 2,
N    /*! RC 8Mhz.
N     */
N    LL_CC_RST_SYSCLK_SRC_RC8M           = 3,
N
N} TYPE_ENUM_LL_CC_RST_SYSCLK_SRC;
N
N/**
N  * @brief define the gpio debunce clock source
N  */
Ntypedef enum {
N    /*! HXOSC.
N     */
N    LL_CC_RST_GPIO_DEBCLK_SRC_HXOSC    = 0,
N    /*! RC8M.
N     */
N    LL_CC_RST_GPIO_DEBCLK_SRC_RC8M     = 1,
N    /*! CPU CLK
N     */
N    LL_CC_RST_GPIO_DEBCLK_SRC_CPUCLK   = 1,
N    /*! RC32K
N     */
N    LL_CC_RST_GPIO_DEBCLK_SRC_RC32K    = 3,
N} TYPE_ENUM_LL_CC_RST_GPIO_DEBCLK_SRC;
N
N
N/**
N  * @brief define the APB0 peripheral modules
N  */
Ntypedef enum {
N    /*! APB0 SPI0
N     */
N    LL_CC_RST_APB0_M_SPI0    = (27),
N    /*! APB0 SPI1
N     */
N    LL_CC_RST_APB0_M_SPI1    = (26),
N    /*! APB0 UART0
N     */
N    LL_CC_RST_APB0_M_UART0   = (23),
N    /*! APB0 UART1
N     */
N    LL_CC_RST_APB0_M_UART1   = (22),
N    /*! APB0 UART2
N     */
N    LL_CC_RST_APB0_M_UART2   = (21),
N    /*! APB0 IIC0
N     */
N    LL_CC_RST_APB0_M_IIC0    = (20),
N    /*! APB0 IIC1
N     */
N    LL_CC_RST_APB0_M_IIC1    = (19),
N    /*! APB0 TMR1
N     */
N    LL_CC_RST_APB0_M_TMR1    = (12),
N
N} TYPE_ENUM_LL_CC_RST_APB0_M;
N    
N/**
N  * @brief define the APB1 peripheral modules
N  */
Ntypedef enum {
N    /*! APB1 TMR0
N     */
N    LL_CC_RST_APB1_M_TMR0    = (11),
N    /*! APB1 QEI
N     */
N    LL_CC_RST_APB1_M_QEI     = (15),
N    /*! APB1 CRC
N     */
N    LL_CC_RST_APB1_M_CRC     = (17),
N
N} TYPE_ENUM_LL_CC_RST_APB1_M;
N
N/**
N  * @brief define the APB2 peripheral modules
N  */
Ntypedef enum {
N    /*! APB2 EFLASH , CLKCON4
N     */
N    LL_CC_RST_APB2_M_EFLASH  = (1),
N    /*! APB2 SARADC, CLKCON4
N     */
N    LL_CC_RST_APB2_M_SARADC  = (4),
N    /*! APB2 HCC, CLKCON5
N     */
N    LL_CC_RST_APB2_M_HCC     = (9),
N
N} TYPE_ENUM_LL_CC_RST_APB2_M;
N
N/**
N  * @brief define the AHB0 peripheral modules
N  */
Ntypedef enum {
N    /*! AHB0 GPIOA , CLKCON4
N     */
N    LL_CC_RST_AHB0_M_GPIOA  = (31),
N    /*! AHB0 GPIOB , CLKCON4
N     */
N    LL_CC_RST_AHB0_M_GPIOB  = (30),
N    /*! AHB0 GPIOC , CLKCON4
N     */
N    LL_CC_RST_AHB0_M_GPIOC  = (29),
N    /*! AHB0 GPIOD , CLKCON4
N     */
N    LL_CC_RST_AHB0_M_GPIOD  = (28),
N    /*! AHB0 DAC , CLKCON4
N     */
N    LL_CC_RST_AHB0_M_DAC    = (3),
N    /*! AHB0 CAN , CLKCON4
N     */
N    LL_CC_RST_AHB0_M_CAN    = (13),
N    
N    /*! AHB0 DMAC , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_DMAC   = (0),
N    /*! AHB0 GMAC , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_GMAC   = (8),
N    /*! AHB0 ROM , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_ROM    = (10),
N    /*! AHB0 SRAM0 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM0  = (11),
N    /*! AHB0 SRAM1 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM1  = (12),
N    /*! AHB0 SRAM2 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM2  = (13),
N    /*! AHB0 SRAM3 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM3  = (14),
N    /*! AHB0 SRAM4 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM4  = (15),
N    /*! AHB0 SRAM5 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM5  = (16),
N    /*! AHB0 SRAM6 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM6  = (17),
N    /*! AHB0 SRAM7 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM7  = (18),
N    /*! AHB0 SRAM8 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM8  = (19),
N    /*! AHB0 SRAM9 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM9  = (20),
N    /*! AHB0 SRAM10 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM10 = (21),
N    /*! AHB0 SRAM11 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM11 = (22),
N    /*! AHB0 SRAM12 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM12 = (23),
N    /*! AHB0 SRAM13 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM13 = (24),
N    /*! AHB0 SRAM14 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM14 = (25),
N    /*! AHB0 SRAM15 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM15 = (26),
N    /*! AHB0 SRAM16 , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_SRAM16 = (27),
N    /*! AHB0 FADC , CLKCON5
N     */
N    LL_CC_RST_AHB0_M_FADC   = (28),
N
N} TYPE_ENUM_LL_CC_RST_AHB0_M;
N
N/**
N  * @brief define the peripheral modules for soft reset
N  */
Ntypedef enum {
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_FPLL0  = (0),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_FPLL1  = (1),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_AHB0   = (2),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_AHB1   = (3),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_AHB2   = (4),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_APB0   = (5),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_APB1   = (6),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_EFLASH = (7),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_DMAC   = (8),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_IIC0   = (9),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_IIC1   = (10),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_SPI0   = (11),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_SPI1   = (12),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_UART0  = (13),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_UART1  = (14),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_UART2  = (15),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_ADVTMR = (16),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_PWRACE = (17),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_SARADC = (18),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_HCC    = (19),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_CRC    = (21),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_TMR    = (22),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_WDT    = (23),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_GPIO   = (24),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_CAN    = (25),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_EVSYS  = (26),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_QEI    = (27),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_GMAC   = (28),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_FADC   = (29),
N    /*! soft reset peripheral
N     */
N    LL_CC_RST_SOFTRST_M_EPWM   = (30),
N
N} TYPE_ENUM_LL_CC_RST_SOFTRST_M;
N
N/**
N  * @brief Test clock enumeration type
N  */
Ntypedef enum {
N    LL_CC_TEST_OUT_OSC_26M          = 0x00,
N    LL_CC_TEST_OUT_RC32K            = 0x01,
N    LL_CC_TEST_OUT_SYSPLL_DIV_CLK   = 0x02,
N    LL_CC_TEST_OUT_SYSPLL_DIV32_CLK = 0x03,
N    LL_CC_TEST_OUT_RC8M             = 0x04,
N    LL_CC_TEST_OUT_ADCPLL_DIV_CLK   = 0x06,
N    LL_CC_TEST_OUT_ADCPLL_DIV32_CLK = 0x07,
N} TYPE_ENUM_LL_CC_TEST_OUT;
N
N/**
N  * @}
N  */
N
N/** @defgroup CC_RST_LL_Exported_Struct CC_RST LL Exported Struct
N  * @ingroup  CC_RST_LL_Driver
N  * @brief    CC_RST LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the CC_RST registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_cc_rst_init. Function, you can configure the CC_RST module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N
N/**
N  * @}
N  */
N
N/** @defgroup CC_RST_LL_Interrupt CC_RST LL Interrupt Handle function
N  * @brief   CC_RST LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the CC_RST  
N    Interrupt Handle function.
N
N    how to use?
N
N    The CC_RST interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the CC_RST in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief System clock tree divider structure type
N  */
Ntypedef struct {
N    /*! System clock division control
N     *  @note system clock = SYS_CLK / (sys_clk_div+1);  
N     *        The sys_clk_div must be less than 0xFF.
N     */
N    u8 sys_clk_div;
N    /*! APB0 clock division control
N     *  @note APB0 clock = system clock / (apb0_clk_div+1);  
N     *        The apb0_clk_div must be less than 0xFF.
N     */
N    u8 apb0_clk_div;
N    /*! APB1 clock division control
N     *  @note APB1 clock = system clock / (apb1_clk_div+1);  
N     *        The apb1_clk_div must be less than 0xFF.
N     */
N    u8 apb1_clk_div;
N} TYPE_LL_CC_DIV_CFG;
N
N/**
N  * @}
N  */
N  
N/** @defgroup CC_RST_LL_Inti_Cfg CC_RST LL Initialization And Configuration
N  * @brief    CC_RST LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the CC_RST data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Set the ADCPLL clock frequency.
N  * @param  freq        : ADCPLL frequency
N  * @param  pll_clk_src : the reference clock source for the ADCPLL
N  * @retval None
N  */
Nvoid ll_cc_adcpll_set(u32 freq, TYPE_ENUM_LL_CC_RST_PLLCLK_SRC pll_clk_src);
N
N/**
N  * @brief  Set SYSPLL
N  * @param  sys_max_clk : maximum system clock frequency
N  * @param  pll_clk_src : the reference clock source for SYSPLL
N  * @retval None
N  */
Nvoid ll_cc_syspll_set(u32 sys_max_clk, TYPE_ENUM_LL_CC_RST_PLLCLK_SRC pll_clk_src);
N
N/**
N  * @brief  SYS_CLK source config
N  * @param  p_cfg : SYS_CLK configure structure pointer
N  * @retval None
N  */
Nvoid ll_cc_sysclk_select(TYPE_ENUM_LL_CC_RST_SYSCLK_SRC src);
N
N/**
N  * @brief  System clock tree divider setting
N  * @param  p_cfg : Clock divider structure pointer
N  * @retval None
N  */
Nvoid ll_cc_clk_div_config(TYPE_LL_CC_DIV_CFG *p_cfg);
N
N/**
N  * @brief  Get the real system clock frequency
N  * @retval Returns the system clock frequency in Hz
N  */
Nu32 ll_cc_sys_clk_get(void);
N
N/**
N  * @brief  Get the oscillation frequency of the ADCPLL
N  * @retval Returns the oscillation frequency of the ADCPLL in Hz
N  */
Nu32 ll_cc_adc_pll_get(void);
N
N/**
N  * @brief  Test clock output function
N  * @param  clk_sel : Select the clock to output
N  * @retval None
N  * @note   The clock will be output through PC0
N  */
Nvoid ll_cc_test_clk_out(TYPE_ENUM_LL_CC_TEST_OUT clk_sel);
N
N/**
N  * @}
N  */
N  
N/** @defgroup CC_RST_LL_Data_Transfers CC_RST LL Data transfers functions
N  * @brief    CC_RST LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the CC_RST data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  CC_RST soft reset peripheral 
N  * @param  periph : TYPE_ENUM_LL_CC_RST_SOFTRST_M
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_softreset(TYPE_ENUM_LL_CC_RST_SOFTRST_M  periph) {
Xstatic __inline void ll_cc_rst_softreset(TYPE_ENUM_LL_CC_RST_SOFTRST_M  periph) {
N    SYSCTRL_REG_OPT(SYSCTRL->SYS_CON2 &= ~(BIT(periph)););
X    do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_CON2 &= ~(((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N}
N
N/**
N  * @brief  CC_RST release soft reset peripheral 
N  * @param  periph : TYPE_ENUM_LL_CC_RST_SOFTRST_M
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_softreset_release(TYPE_ENUM_LL_CC_RST_SOFTRST_M  periph) {
Xstatic __inline void ll_cc_rst_softreset_release(TYPE_ENUM_LL_CC_RST_SOFTRST_M  periph) {
N    SYSCTRL_REG_OPT(SYSCTRL->SYS_CON2 |= BIT(periph););
X    do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_CON2 |= ((uint32_t)1<<(periph));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N}
N
N/**
N  * @brief  CC_RST enable AHB0/APB0 CLK.
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_ahpb0_clk_enable(void) {
Xstatic __inline void ll_cc_rst_ahpb0_clk_enable(void) {
N    SYSCTRL_REG_OPT(SYSCTRL->CLK_CON5 |= BIT(3););
X    do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON5 |= ((uint32_t)1<<(3));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N}
N
N/**
N  * @brief  CC_RST disable AHB0/APB0 CLK.
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_ahpb0_clk_disable(void) {
Xstatic __inline void ll_cc_rst_ahpb0_clk_disable(void) {
N    SYSCTRL_REG_OPT(SYSCTRL->CLK_CON5 &= ~(BIT(3)););
X    do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON5 &= ~(((uint32_t)1<<(3)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N}
N
N/**
N  * @brief  CC_RST enable AHB1/APB1 CLK.
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_ahpb1_clk_enable(void) {
Xstatic __inline void ll_cc_rst_ahpb1_clk_enable(void) {
N    SYSCTRL_REG_OPT(SYSCTRL->CLK_CON5 |= BIT(2););
X    do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON5 |= ((uint32_t)1<<(2));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N}
N
N/**
N  * @brief  CC_RST disable AHB1/APB1 CLK.
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_ahpb1_clk_disable(void) {
Xstatic __inline void ll_cc_rst_ahpb1_clk_disable(void) {
N    SYSCTRL_REG_OPT(SYSCTRL->CLK_CON5 &= ~(BIT(2)););
X    do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON5 &= ~(((uint32_t)1<<(2)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N}
N
N/**
N  * @brief  CC_RST enable APB0 peripheral CLK.
N  * @param  periph : TYPE_ENUM_LL_CC_RST_APB0_M
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_apb0_peripheral_clk_enable(TYPE_ENUM_LL_CC_RST_APB0_M periph) {
Xstatic __inline void ll_cc_rst_apb0_peripheral_clk_enable(TYPE_ENUM_LL_CC_RST_APB0_M periph) {
N    SYSCTRL_REG_OPT(SYSCTRL->CLK_CON4 |= (BIT(periph)););
X    do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON4 |= (((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N}
N
N/**
N  * @brief  CC_RST disable APB0 peripheral CLK.
N  * @param  periph : TYPE_ENUM_LL_CC_RST_APB0_M
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_apb0_peripheral_clk_disable(TYPE_ENUM_LL_CC_RST_APB0_M periph) {
Xstatic __inline void ll_cc_rst_apb0_peripheral_clk_disable(TYPE_ENUM_LL_CC_RST_APB0_M periph) {
N    SYSCTRL_REG_OPT(SYSCTRL->CLK_CON4 &= ~(BIT(periph)););
X    do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON4 &= ~(((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N}
N
N/**
N  * @brief  CC_RST enable APB1 peripheral CLK.
N  * @param  periph : TYPE_ENUM_LL_CC_RST_APB1_M
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_apb1_peripheral_clk_enable(TYPE_ENUM_LL_CC_RST_APB1_M periph) {
Xstatic __inline void ll_cc_rst_apb1_peripheral_clk_enable(TYPE_ENUM_LL_CC_RST_APB1_M periph) {
N    SYSCTRL_REG_OPT(SYSCTRL->CLK_CON4 |= (BIT(periph)););
X    do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON4 |= (((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N}
N
N/**
N  * @brief  CC_RST disable APB1 peripheral CLK.
N  * @param  periph : TYPE_ENUM_LL_CC_RST_APB1_M
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_apb1_peripheral_clk_disable(TYPE_ENUM_LL_CC_RST_APB1_M periph) {
Xstatic __inline void ll_cc_rst_apb1_peripheral_clk_disable(TYPE_ENUM_LL_CC_RST_APB1_M periph) {
N    SYSCTRL_REG_OPT(SYSCTRL->CLK_CON4 &= ~(BIT(periph)););
X    do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON4 &= ~(((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N}
N
N/**
N  * @brief  CC_RST enable APB2 peripheral CLK.
N  * @param  periph : TYPE_ENUM_LL_CC_RST_APB2_M
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_apb2_peripheral_clk_enable(TYPE_ENUM_LL_CC_RST_APB2_M periph) {
Xstatic __inline void ll_cc_rst_apb2_peripheral_clk_enable(TYPE_ENUM_LL_CC_RST_APB2_M periph) {
N    if((LL_CC_RST_APB2_M_HCC == periph)) {
N        SYSCTRL_REG_OPT(SYSCTRL->CLK_CON5 |= (BIT(periph)););
X        do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON5 |= (((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N    } else {
N        SYSCTRL_REG_OPT(SYSCTRL->CLK_CON4 |= (BIT(periph)););
X        do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON4 |= (((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N    }
N}
N
N/**
N  * @brief  CC_RST disable APB2 peripheral CLK.
N  * @param  periph : TYPE_ENUM_LL_CC_RST_APB2_M
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_apb2_peripheral_clk_disable(TYPE_ENUM_LL_CC_RST_APB2_M periph) {
Xstatic __inline void ll_cc_rst_apb2_peripheral_clk_disable(TYPE_ENUM_LL_CC_RST_APB2_M periph) {
N    if((LL_CC_RST_APB2_M_HCC == periph)) {
N        SYSCTRL_REG_OPT(SYSCTRL->CLK_CON5 &= ~(BIT(periph)););
X        do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON5 &= ~(((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N    } else {
N        SYSCTRL_REG_OPT(SYSCTRL->CLK_CON4 &= ~(BIT(periph)););
X        do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON4 &= ~(((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N    }
N}
N
N/**
N  * @brief  CC_RST enable AHB0 peripheral CLK.
N  * @param  periph : TYPE_ENUM_LL_CC_RST_AHB0_M
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_ahb0_peripheral_clk_enable(TYPE_ENUM_LL_CC_RST_AHB0_M periph) {
Xstatic __inline void ll_cc_rst_ahb0_peripheral_clk_enable(TYPE_ENUM_LL_CC_RST_AHB0_M periph) {
N    if((LL_CC_RST_AHB0_M_GPIOA == periph) || 
N       (LL_CC_RST_AHB0_M_GPIOB == periph) ||
N       (LL_CC_RST_AHB0_M_GPIOC == periph) ||
N       (LL_CC_RST_AHB0_M_GPIOD == periph) ||
N       (LL_CC_RST_AHB0_M_DAC == periph)   ||
N       (LL_CC_RST_AHB0_M_CAN == periph)) {
N        SYSCTRL_REG_OPT(SYSCTRL->CLK_CON4 |= (BIT(periph)););
X        do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON4 |= (((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N    } else {
N        SYSCTRL_REG_OPT(SYSCTRL->CLK_CON5 |= (BIT(periph)););
X        do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON5 |= (((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N    }
N}
N
N/**
N  * @brief  CC_RST disable AHB0 peripheral CLK.
N  * @param  periph : TYPE_ENUM_LL_CC_RST_AHB0_M
N  * @retval None
N  */
N__STATIC_INLINE void ll_cc_rst_ahb0_peripheral_clk_disable(TYPE_ENUM_LL_CC_RST_AHB0_M periph) {
Xstatic __inline void ll_cc_rst_ahb0_peripheral_clk_disable(TYPE_ENUM_LL_CC_RST_AHB0_M periph) {
N    if((LL_CC_RST_AHB0_M_GPIOA == periph) || 
N       (LL_CC_RST_AHB0_M_GPIOB == periph) ||
N       (LL_CC_RST_AHB0_M_GPIOC == periph) ||
N       (LL_CC_RST_AHB0_M_GPIOD == periph) ||
N       (LL_CC_RST_AHB0_M_DAC == periph)   ||
N       (LL_CC_RST_AHB0_M_CAN == periph)) {
N        SYSCTRL_REG_OPT(SYSCTRL->CLK_CON4 &= ~(BIT(periph)););
X        do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON4 &= ~(((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N    } else {
N        SYSCTRL_REG_OPT(SYSCTRL->CLK_CON5 &= ~(BIT(periph)););
X        do { uint8_t ie = !__get_PRIMASK(); if(ie) __disable_irq(); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x3fac87e4); __asm volatile ("nop"); ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->CLK_CON5 &= ~(((uint32_t)1<<(periph)));; ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = (0x0); if(ie) __enable_irq(); } while(0);
N    }
N}
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_CC_RST_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 29 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_epwm.h" 2
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup epwm_interface_gr EPWM Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup EPWM_LL_Driver EPWM LL Driver
N  * @ingroup  epwm_interface_gr
N  * @brief Mainly the driver part of the EPWM module, which includes \b EPWM \b Register 
N  * \b Constants, \b EPWM \b Exported \b Constants, \b EPWM \b Exported \b Struct, \b EPWM
N  * \b Data \b transfers \b functions, \b EPWM \b Initialization \b and \b EPWM \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N     
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N     
N/** @defgroup EPWM_LL_Register_Constants EPWM LL Register Constants
N  * @ingroup  EPWM_LL_Driver
N  * @brief    EPWM LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the EPWM 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the EPWM register, mainly for convenience. Understand the 
N    configuration of the EPWM.
N    
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** EPWM_TTCTL *****/
N/*! Trip-Zone module interrupt pending
N */
N#define LL_EPWM_TZINT_PNG(n)                     (((n)&0x7F) << 25)
N/*! Event-Trigger module interrupt pending
N */
N#define LL_EPWM_ETINT_PNG(n)                     (((n)&0x7F) << 18)
N/*! Trip-Zone cpu software set value
N */
N#define LL_EPWM_CPUTZ_ZERO                       (1UL << 10)
N#define LL_EPWM_CPUTZ_ONE                        (0UL << 10)
N/*! EPWM enable
N */
N#define LL_EPWM_EN(n)                            (((n)&0x7F) << 0)
N
N
N/***** EPWM_ADCSEL0 *****/
N/*! Adc0 select epwm channel
N */
N#define LL_EPWM_ADC_SEL0(n, i)                   (((n)&0x7) << (3*(i)))
N/*! Adc1 select epwm channel
N */
N#define LL_EPWM_ADC_SEL1(n, i)                   (((n)&0x7) << (3*(i)))
N
N
N/***** EPWM_TBCLT *****/
N/*! read TBCTR value
N */
N#define LL_EPWM_TBCTR(n)                         (((n)&0xFFFF) << 16)
N/*! read TBCTR value enable
N */
N#define LL_EPWM_READ_TBCTR_EN                    (1UL << 10)
N#define LL_EPWM_READ_TBCTR_DIS                   (0UL << 10)
N/*! TBCTR dir
N */
N#define LL_EPWM_TBCTR_DIR                        (1UL << 9)
N/*! Input Synchronization Latched Status Bit
N */
N#define LL_EPWM_SYNC_LATCHED                     (1UL << 8)
N/*! Output Synchronization Latched Status Bit
N */
N#define LL_EPWM_SYNCO_SEL(n)                     (((n)&0x7) << 5)
N/*! Software Synchronization enable
N */
N#define LL_EPWM_SWF_SYNC                         (1UL << 4)
N/*! Phase Synchronization enable
N */
N#define LL_EPWM_PHSEN                            (1UL << 3)
N/*! TBCTR mode select
N */
N#define LL_EPWM_CTRMODE(n)                       (((n)&0x3) << 1)
N/*! Active Period Register Load From Shadow Register Select
N */
N#define LL_EPWM_PRDLD_DIS                        (1UL << 0)
N
N
N/***** EPWM_TBPRD_SD *****/
N/*! EPWMB fraction value
N */
N#define LL_EPWM_FRACB_VALUE(n)                   (((n)&0x7) << 21)
N/*! EPWMB edge select
N */
N#define LL_EPWM_FRACB_EDGE_NEG                   (1UL << 20)
N#define LL_EPWM_FRACB_EDGE_POS                   (0UL << 20)
N/*! EPWMA fraction value
N */
N#define LL_EPWM_FRACA_VALUE(n)                   (((n)&0x7) << 17)
N/*! EPWMA edge select.
N */
N#define LL_EPWM_FRACA_EDGE_NEG                   (1UL << 16)
N#define LL_EPWM_FRACA_EDGE_POS                   (0UL << 16)
N/*! These bits determine the period of the time-base counter
N */
N#define LL_EPWM_TBPRD(n)                         (((n)&0xFFFF) << 0)
N
N
N/***** EPWM_TBPHASE *****/
N/*! These bits set time-base counter direction in Phase Synchronization
N */
N#define LL_EPWM_TBDIR_UP                         (1UL << 16)
N#define LL_EPWM_TBDIR_DOWN                       (0UL << 16)
N/*! These bits set time-base counter phase
N */
N#define LL_EPWM_TBPHS(n)                         (((n)&0xFFFF) << 0)
N
N
N/***** EPWM_CMPCTL *****/
N/*! Counter-compare C (CMPC) Shadow Register Full Status Flag
N */
N#define LL_EPWM_SHDW_C_FULL_PNG                  (1UL << 11)
N/*! Counter-compare C (CMPC) Register Operating Mode0 Shadow mode
N */
N#define LL_EPWM_SHDW_C_MODE                      (1UL << 10)
N/*! Active Counter-Compare C (CMPC) Load From Shadow Select Mode
N */
N#define LL_EPWM_LOAD_C_DATA_MODE(n)              (((n)&0x3) << 8)
N/*! Counter-compare B (CMPB) Shadow Register Full Status Flag
N */
N#define LL_EPWM_SHDW_B_FULL_PNG                  (1UL << 7)
N/*! Counter-compare A (CMPA) Shadow Register Full Status Flag
N */
N#define LL_EPWM_SHDW_A_FULL_PNG                  (1UL << 6)
N/*! Counter-compare B (CMPB) Register Operating Mode0 Shadow mode
N */
N#define LL_EPWM_SHDW_B_MODE                      (1UL << 5)
N/*! Counter-compare A (CMPA) Register Operating Mode0 Shadow mode
N */
N#define LL_EPWM_SHDW_A_MODE                      (1UL << 4)
N/*! Active Counter-Compare B (CMPB) Load From Shadow Select Mode
N */
N#define LL_EPWM_LOAD_B_DATA_MODE(n)              (((n)&0x3) << 2)
N/*! Active Counter-Compare A (CMPA) Load From Shadow Select Mode
N */
N#define LL_EPWM_LOAD_A_DATA_MODE(n)              (((n)&0x3) << 0)
N
N
N/***** EPWM_CMPA_SD *****/
N/*! CMPA used to access the counter-compare A value
N */
N#define LL_EPWM_CPMA_VALUE(n)                    (((n)&0xFFFF) << 0)
N
N
N/***** EPWM_CMPB_SD *****/
N/*! CMPB used to access the counter-compare B value
N */
N#define LL_EPWM_CPMB_VALUE(n)                    (((n)&0xFFFF) << 0)
N
N
N/***** EPWM_CMPC_SD *****/
N/*! CMPC used to access the counter-compare C value
N */
N#define LL_EPWM_CPMC_VALUE(n)                    (((n)&0xFFFF) << 0)
N
N
N/***** EPWM_AQCTLAB *****/
N/*! Action when the counter equals the active CMPB register and the counter is decrementing
N */
N#define LL_EPWM_CPMB_DEC_DONE_B(n)               (((n)&0x3) << 26)
N/*! Action when the counter equals the active CMPB register and the counter is incrementing
N */
N#define LL_EPWM_CPMB_INC_DONE_B(n)               (((n)&0x3) << 24)
N/*! Action when the counter equals the active CMPA register and the counter is decrementing
N */
N#define LL_EPWM_CPMA_DEC_DONE_B(n)               (((n)&0x3) << 22)
N/*! Action when the counter equals the active CMPA register and the counter is incrementing
N */
N#define LL_EPWM_CPMA_INC_DONE_B(n)               (((n)&0x3) << 20)
N/*! Action when the counter equals the period
N */
N#define LL_EPWM_PRD_DONE_B(n)                    (((n)&0x3) << 18)
N/*! Action when counter equals zero
N */
N#define LL_EPWM_ZERO_DONE_B(n)                   (((n)&0x3) << 16)
N/*! Action when the counter equals the active CMPB register and the counter is decrementing
N */
N#define LL_EPWM_CPMB_DEC_DONE_A(n)               (((n)&0x3) << 10)
N/*! Action when the counter equals the active CMPB register and the counter is incrementing
N */
N#define LL_EPWM_CPMB_INC_DONE_A(n)               (((n)&0x3) << 8)
N/*! Action when the counter equals the active CMPA register and the counter is decrementing
N */
N#define LL_EPWM_CPMA_DEC_DONE_A(n)               (((n)&0x3) << 6)
N/*! Action when the counter equals the active CMPA register and the counter is incrementing
N */
N#define LL_EPWM_CPMA_INC_DONE_A(n)               (((n)&0x3) << 4)
N/*! Action when the counter equals the period
N */
N#define LL_EPWM_PRD_DONE_A(n)                    (((n)&0x3) << 2)
N/*! Action when counter equals zero
N */
N#define LL_EPWM_ZERO_DONE_A(n)                   (((n)&0x3) << 0)
N
N
N/***** EPWM_AQSFRC *****/
N/*! AQCSFRC Active Register Reload From Shadow
N */
N#define LL_EPWM_RLDCSF(n)                        (((n)&0x3) << 6)
N/*! One-Time Software Forced Event on Output B
N */
N#define LL_EPWM_OTSFB_EN                         (1UL << 5)
N/*! Action when One-Time Software Force B Is invoked
N */
N#define LL_EPWM_ACTSFB(n)                        (((n)&0x3) << 3)
N/*! One-Time Software Forced Event on Output A
N */
N#define LL_EPWM_OTSFA_EN                         (1UL << 2)
N/*! Action When One-Time Software Force A Is Invoked
N */
N#define LL_EPWM_ACTSFA(n)                        (((n)&0x3) << 0)
N
N
N/***** EPWM_AQCSFRC *****/
N/*! Continuous Software Force on Output B
N */
N#define LL_EPWM_CSFB(n)                          (((n)&0x3) << 2)
N/*! Continuous Software Force on Output A
N */
N#define LL_EPWM_CSFA(n)                          (((n)&0x3) << 0)
N
N
N/***** EPWM_DBCTL *****/
N/*! Half Cycle Clocking Enable Bit
N */
N#define LL_EPWM_HALF_CYCLE                       (1UL << 6)
N/*! Dead Band Input Mode Control
N */
N#define LL_EPWM_IN_MODE(n)                       (((n)&0x3) << 4)
N/*! Polarity Select Control
N */
N#define LL_EPWM_POLSEL(n)                        (((n)&0x3) << 2)
N/*! Dead-band Output Mode Control
N */
N#define LL_EPWM_OUT_MODE(n)                      (((n)&0x3) << 0)
N
N
N/***** EPWM_DBDELAY *****/
N/*! Falling Edge Delay Count. 10-bit counter
N */
N#define LL_EPWM_FED(n)                           (((n)&0x3FF) << 16)
N/*! Rising Edge Delay Count. 10-bit counter
N */
N#define LL_EPWM_RED(n)                           (((n)&0x3FF) << 0)
N
N
N/***** EPWM_ETCTL *****/
N/*! Enable the ADC Start of Conversion B (EPWMxSOCB) Pulse
N */
N#define LL_EPWM_SOCBEN                           (1UL << 30)
N/*! EPWMxSOCB Selection Options
N */
N#define LL_EPWM_SOCBSEL(n)                       (((n)&0xF) << 26)
N/*! Enable the ADC Start of Conversion A (EPWMxSOCA) Pulse
N */
N#define LL_EPWM_SOCAEN                           (1UL << 25)
N/*! EPWMxSOCA Selection Options
N */
N#define LL_EPWM_SOCASEL(n)                       (((n)&0xF) << 21)
N/*! Enable ePWM Interrupt (EPWMx_INT) Generation
N */
N#define LL_EPWM_INTEN                            (1UL << 20)
N/*! EPWM Interrupt (EPWMx_INT) Selection Options
N */
N#define LL_EPWM_INTSEL(n)                        (((n)&0xF) << 16)
N/*! EPWM ADC Start-of-Conversion B Event (EPWMxSOCB) Counter Register
N */
N#define LL_EPWM_SOCBCNT(n)                       (((n)&0x3) << 14)
N/*! EPWM ADC Start-of-Conversion B Event (EPWMxSOCB) Period Select
N */
N#define LL_EPWM_SOCBPRD(n)                       (((n)&0x3) << 12)
N/*! EPWM ADC Start-of-Conversion A Event (EPWMxSOCA) Counter Register
N */
N#define LL_EPWM_SOCACNT(n)                       (((n)&0x3) << 10)
N/*! EPWM ADC Start-of-Conversion A Event (EPWMxSOCA) Period Select
N */
N#define LL_EPWM_SOCAPRD(n)                       (((n)&0x3) << 8)
N/*! EPWM Interrupt Event (EPWMx_INT) Counter Register
N */
N#define LL_EPWM_INTCNT(n)                        (((n)&0x3) << 2)
N/*! EPWM Interrupt (EPWMx_INT) Period Select
N */
N#define LL_EPWM_INTPRD(n)                        (((n)&0x3) << 0)
N
N
N/***** EPWM_ETFLAG *****/
N/*! SOCB Force Bit
N */
N#define LL_EPWM_FRCSOCB_FLAG                     (1UL << 11)
N/*! SOCA Force Bit
N */
N#define LL_EPWM_FRCSOCA_FLAG                     (1UL << 10)
N/*! INT Force Bit
N */
N#define LL_EPWM_FRCINT_FLAG                      (1UL << 8)
N/*! EPWM ADC Start-of-Conversion B (EPWMxSOCB) Flag Clear Bit
N */
N#define LL_EPWM_CLRSOCB_FLAG                     (1UL << 7)
N/*! EPWM ADC Start-of-Conversion A (EPWMxSOCA) Flag Clear Bit
N */
N#define LL_EPWM_CLRSOCA_FLAG                     (1UL << 6)
N/*! EPWM Interrupt (EPWMx_INT) Flag Clear Bit
N */
N#define LL_EPWM_CLRINT_FLAG                      (1UL << 4)
N/*! Latched ePWM ADC Start-of-Conversion B (EPWMxSOCB) Status Flag
N */
N#define LL_EPWM_SOCB_FLAG                        (1UL << 3)
N/*! Latched ePWM ADC Start-of-Conversion A (EPWMxSOCA) Status Flag
N */
N#define LL_EPWM_SOCA_FLAG                        (1UL << 2)
N/*! Latched ePWM Interrupt (EPWMx_INT) Status Flag
N */
N#define LL_EPWM_INT_FLAG                         (1UL << 0)
N
N
N/***** EPWM_DCCTL *****/
N/*! DCAEVT2 Force Synchronization Signal Select
N */
N#define LL_EPWM_AEVT2FRCSYNCSEL_ASYN             (1UL << 19)
N#define LL_EPWM_AEVT2FRCSYNCSEL_SYNC             (0UL << 19)
N/*! DCAEVT2 Source Signal Select
N */
N#define LL_EPWM_AEVT2SRCSEL_FILT                 (1UL << 18)
N#define LL_EPWM_AEVT2SRCSEL_EVT                  (0UL << 18)
N/*! DCAEVT1 SYNC, Enable/Disable
N */
N#define LL_EPWM_AEVT1SYNCE_EN                    (1UL << 17)
N/*! DCAEVT1 SOC, Enable/Disable
N */
N#define LL_EPWM_AEVT1SOCE_EN                     (1UL << 16)
N/*! DCAEVT1 Force Synchronization Signal Select
N */
N#define LL_EPWM_AEVT1FRCSYNCSEL_ASYN             (1UL << 15)
N#define LL_EPWM_AEVT1FRCSYNCSEL_SYNC             (0UL << 15)
N/*! DCAEVT1 Source Signal Select
N */
N#define LL_EPWM_AEVT1SRCSEL_FILT                 (1UL << 14)
N#define LL_EPWM_AEVT1SRCSEL_EVT                  (0UL << 14)
N/*! DCBEVT2 Force Synchronization Signal Select
N */
N#define LL_EPWM_BEVT2FRCSYNCSEL_ASYN             (1UL << 13)
N#define LL_EPWM_BEVT2FRCSYNCSEL_SYNC             (0UL << 13)
N/*! DCBEVT2 Source Signal Select
N */
N#define LL_EPWM_BEVT2SRCSEL_FILT                 (1UL << 12)
N#define LL_EPWM_BEVT2SRCSEL_EVT                  (0UL << 12)
N/*! DCBEVT1 SYNC, Enable/Disable
N */
N#define LL_EPWM_BEVT1SYNCE_EN                    (1UL << 11)
N/*! DCBEVT1 SOC, Enable/Disable
N */
N#define LL_EPWM_BEVT1SOCE_EN                     (1UL << 10)
N/*! DCBEVT1 Force Synchronization Signal Select
N */
N#define LL_EPWM_BEVT1FRCSYNCSEL_ASYN             (1UL << 9)
N#define LL_EPWM_BEVT1FRCSYNCSEL_SYNC             (0UL << 9)
N/*! DCBEVT1 Source Signal Select
N */
N#define LL_EPWM_BEVT1SRCSEL_FILT                 (1UL << 8)
N#define LL_EPWM_BEVT1SRCSEL_EVT                  (0UL << 8)
N/*! Pulse Select For Blanking & Capture Alignment
N */
N#define LL_EPWM_PULSESEL(n)                      (((n)&0x3) << 6)
N/*! Blanking Window Inversion
N */
N#define LL_EPWM_BLANKINV                         (1UL << 5)
N/*! Blanking Window Enable/Disable
N */
N#define LL_EPWM_BLANKE_EN                        (1UL << 4)
N/*! Filter Block Signal Source Select
N */
N#define LL_EPWM_FILTSRCSEL(n)                    (((n)&0x3) << 2)
N/*! TBCTR Counter Capture Shadow Select Mode
N */
N#define LL_EPWM_SHDWMODE                         (1UL << 1)
N/*! TBCTR Counter Capture Enable/Disable
N */
N#define LL_EPWM_CAPE_EN                          (1UL << 0)
N
N
N/***** EPWM_DCTRIPSEL *****/
N/*! Digital Compare Output B Event 2 Selection
N */
N#define LL_EPWM_DCBEVT2(n)                       (((n)&0x7) << 25)
N/*! Digital Compare Output B Event 1 Selection
N */
N#define LL_EPWM_DCBEVT1(n)                       (((n)&0x7) << 22)
N/*! Digital Compare Output A Event 2 Selection
N */
N#define LL_EPWM_DCAEVT2(n)                       (((n)&0x7) << 19)
N/*! Digital Compare Output A Event 1 Selection
N */
N#define LL_EPWM_DCAEVT1(n)                       (((n)&0x7) << 16)
N/*! Digital Compare B Low Input Select
N */
N#define LL_EPWM_DCBLCOMPSEL(n)                   (((n)&0xF) << 12)
N/*! Digital Compare B High Input Select
N */
N#define LL_EPWM_DCBHCOMPSEL(n)                   (((n)&0xF) << 8)
N/*! Digital Compare A Low Input Select Defines the source for the DCAL input
N */
N#define LL_EPWM_DCALCOMPSEL(n)                   (((n)&0xF) << 4)
N/*! Digital Compare A High Input Select
N */
N#define LL_EPWM_DCAHCOMPSEL(n)                   (((n)&0xF) << 0)
N
N
N/***** EPWM_DCCAP *****/
N/*! Digital Compare Time-Base Counter Capture
N */
N#define LL_EPWM_DCCAP(n)                         (((n)&0xFFFF) << 0)
N
N
N/***** EPWM_BLANKOFFSET *****/
N/*! Blanking Window Offset
N */
N#define LL_EPWM_OFFSET(n)                        (((n)&0xFFFF) << 0)
N
N
N/***** EPWM_WINWIDTH *****/
N/*! Blanking Window Width
N */
N#define LL_EPWM_WINDOW(n)                        (((n)&0xFFF) << 0)
N
N
N/***** EPWM_TZCTL *****/
N/*! Digital Compare Output B Event 1 Select
N */
N#define LL_EPWM_TZ_DCBEVT1_EN                    (1UL << 31)
N/*! Digital Compare Output A Event 1 Select
N */
N#define LL_EPWM_TZ_DCAEVT1_EN                    (1UL << 30)
N/*! Trip-zone 6 (TZ6) Select
N */
N#define LL_EPWM_TZ_OSHT6_EN                      (1UL << 29)
N/*! Trip-zone 5 (TZ5) Select
N */
N#define LL_EPWM_TZ_OSHT5_EN                      (1UL << 28)
N/*! Trip-zone 4 (TZ4) Select
N */
N#define LL_EPWM_TZ_OSHT4_EN                      (1UL << 27)
N/*! Trip-zone 3 (TZ3) Select
N */
N#define LL_EPWM_TZ_OSHT3_EN                      (1UL << 26)
N/*! Trip-zone 2 (TZ2) Select
N */
N#define LL_EPWM_TZ_OSHT2_EN                      (1UL << 25)
N/*! Trip-zone 1 (TZ1) Select
N */
N#define LL_EPWM_TZ_OSHT1_EN                      (1UL << 24)
N/*! Digital Compare Output B Event 2 Select
N */
N#define LL_EPWM_TZ_DCBEVT2_EN                    (1UL << 23)
N/*! Digital Compare Output A Event 2 Select
N */
N#define LL_EPWM_TZ_DCAEVT2_EN                    (1UL << 22)
N/*! Trip-zone 6 (TZ6) Select
N */
N#define LL_EPWM_TZ_CBC6_EN                       (1UL << 21)
N/*! Trip-zone 5 (TZ5) Select
N */
N#define LL_EPWM_TZ_CBC5_EN                       (1UL << 20)
N/*! Trip-zone 4 (TZ4) Select
N */
N#define LL_EPWM_TZ_CBC4_EN                       (1UL << 19)
N/*! Trip-zone 3 (TZ3) Select
N */
N#define LL_EPWM_TZ_CBC3_EN                       (1UL << 18)
N/*! Trip-zone 2 (TZ2) Select
N */
N#define LL_EPWM_TZ_CBC2_EN                       (1UL << 17)
N/*! Trip-zone 1 (TZ1) Select
N */
N#define LL_EPWM_TZ_CBC1_EN                       (1UL << 16)
N/*! Digital Compare Output B Event 2 Action On EPWMxB
N */
N#define LL_EPWM_TZ_DCBEVT2(n)                    (((n)&0x3) << 10)
N/*! Digital Compare Output A Event 2 Action On EPWMxA
N */
N#define LL_EPWM_TZ_DCAEVT2(n)                    (((n)&0x3) << 8)
N/*! Digital Compare Output B Event 1 Action On EPWMxB
N */
N#define LL_EPWM_TZ_DCBEVT1(n)                    (((n)&0x3) << 6)
N/*! Digital Compare Output A Event 1 Action On EPWMxA
N */
N#define LL_EPWM_TZ_DCAEVT1(n)                    (((n)&0x3) << 4)
N/*! When a trip event occurs the following action is taken on output EPWMxB
N */
N#define LL_EPWM_TZ_TZB(n)                        (((n)&0x3) << 2)
N/*! When a trip event occurs the following action is taken on output EPWMxA
N */
N#define LL_EPWM_TZ_TZA(n)                        (((n)&0x3) << 0)
N
N
N/***** EPWM_TZFLAG *****/
N/*! Digital Comparator Output B Event 2 Interrupt Enable
N */
N#define LL_EPWM_TZ_DCBEVT2INTE                   (1UL << 30)
N/*! Digital Comparator Output B Event 1 Interrupt Enable
N */
N#define LL_EPWM_TZ_DCBEVT1INTE                   (1UL << 29)
N/*! Digital Comparator Output A Event 2 Interrupt Enable
N */
N#define LL_EPWM_TZ_DCAEVT2INTE                   (1UL << 28)
N/*! Digital Comparator Output A Event 1 Interrupt Enable
N */
N#define LL_EPWM_TZ_DCAEVT1INTE                   (1UL << 27)
N/*! Trip-zone One-Shot Interrupt Enable
N */
N#define LL_EPWM_TZ_OSTINTE                       (1UL << 26)
N/*! Trip-zone Cycle-by-Cycle Interrupt Enable
N */
N#define LL_EPWM_TZ_CBCINTE                       (1UL << 25)
N/*! Digital Comparator Output B Event 2 clear pending
N */
N#define LL_EPWM_TZ_CLRDCBEVT2                    (1UL << 22)
N/*! Digital Comparator Output B Event 1 clear pending
N */
N#define LL_EPWM_TZ_CLRDCBEVT1                    (1UL << 21)
N/*! Digital Comparator Output A Event 2 clear pending
N */
N#define LL_EPWM_TZ_CLRDCAEVT2                    (1UL << 20)
N/*! Digital Comparator Output A Event 1 clear pending
N */
N#define LL_EPWM_TZ_CLRDCAEVT1                    (1UL << 19)
N/*! Trip-zone One-Shot clear pending
N */
N#define LL_EPWM_TZ_CLROST                        (1UL << 18)
N/*! Trip-zone Cycle-by-Cycle clear pending
N */
N#define LL_EPWM_TZ_CLRCBC                        (1UL << 17)
N/*! interrupt clear pending
N */
N#define LL_EPWM_TZ_CLRINT                        (1UL << 16)
N/*! Force Flag for Digital Compare Output B Event 2
N */
N#define LL_EPWM_TZ_FRCDCBEVT2                    (1UL << 14)
N/*! Force Flag for Digital Compare Output B Event 1
N */
N#define LL_EPWM_TZ_FRCDCBEVT1                    (1UL << 13)
N/*! Force Flag for Digital Compare Output A Event 2
N */
N#define LL_EPWM_TZ_FRCDCAEVT2                    (1UL << 12)
N/*! Force Flag for Digital Compare Output A Event 1
N */
N#define LL_EPWM_TZ_FRCDCAEVT1                    (1UL << 11)
N/*! Force a One-Shot Trip Event via Software
N */
N#define LL_EPWM_TZ_FRCOST                        (1UL << 10)
N/*! Force a Cycle-by-Cycle Trip Event via Software
N */
N#define LL_EPWM_TZ_FRCCBC                        (1UL << 9)
N/*! Latched Status Flag for Digital Compare Output B Event 2
N */
N#define LL_EPWM_TZ_DCBEVT2_FLAG                  (1UL << 6)
N/*! Latched Status Flag for Digital Compare Output B Event 1
N */
N#define LL_EPWM_TZ_DCBEVT1_FLAG                  (1UL << 5)
N/*! Latched Status Flag for Digital Compare Output A Event 2
N */
N#define LL_EPWM_TZ_DCAEVT2_FLAG                  (1UL << 4)
N/*! Latched Status Flag for Digital Compare Output A Event 1
N */
N#define LL_EPWM_TZ_DCAEVT1_FLAG                  (1UL << 3)
N/*! Latched Status Flag for A One-Shot Trip Event
N */
N#define LL_EPWM_TZ_OST                           (1UL << 2)
N/*! Latched Status Flag for Cycle-By-Cycle Trip Event
N */
N#define LL_EPWM_TZ_CBC                           (1UL << 1)
N/*! Latched Trip Interrupt Status Flag
N */
N#define LL_EPWM_TZ_INT                           (1UL << 0)
N
N
N/**
N  * @}
N  */
N
N/** @defgroup EPWM_LL_Exported_Constants EPWM LL Exported Constants
N  * @ingroup  EPWM_LL_Driver
N  * @brief    EPWM LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the low 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N/**
N  * @brief define for low layer EPWM channel enable mask
N  */
N#define LL_EPWM_EN_MASK                          (((u32)0x7F) << 0) 
N
N/**
N  * @brief define for low layer EPWM Maximum channel threshold
N  */
N#define LL_EPWM_MAX_CHANNEL                      7
N
N/**
N  * @brief define for low layer EPWM trigger adc Maximum channel threshold
N  */
N#define LL_EPWM_MAX_ADC_CHANNEL                  14
N
N/**
N  * @brief Enumeration constant for low layer EPWM channel mapping to adc channel.
N  */
Ntypedef enum {
N    /*! Select the channel 0 channel of adc.
N     */
N    LL_EPWM_ADC_CHN0 = 0,
N    /*! Select the channel 1 channel of adc.
N     */
N    LL_EPWM_ADC_CHN1,
N    /*! Select the channel 2 channel of adc.
N     */
N    LL_EPWM_ADC_CHN2,
N    /*! Select the channel 3 channel of adc.
N     */
N    LL_EPWM_ADC_CHN3,
N    /*! Select the channel 4 channel of adc.
N     */
N    LL_EPWM_ADC_CHN4,
N    /*! Select the channel 5 channel of adc.
N     */
N    LL_EPWM_ADC_CHN5,
N    /*! Select the channel 6 channel of adc.
N     */
N    LL_EPWM_ADC_CHN6,
N    /*! Select the channel 7 channel of adc.
N     */
N    LL_EPWM_ADC_CHN7,
N    /*! Select the channel 8 channel of adc.
N     */
N    LL_EPWM_ADC_CHN8,
N    /*! Select the channel 9 channel of adc.
N     */
N    LL_EPWM_ADC_CHN9,
N    /*! Select the channel 10 channel of adc.
N     */
N    LL_EPWM_ADC_CHN10,
N    /*! Select the channel 11 channel of adc.
N     */
N    LL_EPWM_ADC_CHN11,
N    /*! Select the channel 12 channel of adc.
N     */
N    LL_EPWM_ADC_CHN12,
N    /*! Select the channel 13 channel of adc.
N     */
N    LL_EPWM_ADC_CHN13,
N} TYPE_LL_EPWM_CHANNEL;
N
N
N/***** LL API *****/
N
N/**
N  * @brief Enumeration constant for low layer EPWM AB select
N  */
Ntypedef enum {
N    /*! EPWM output selection both A end B
N    */
N    LL_EPWM_IO_MAP_SEL_AB = 0,
N    /*! EPWM output selection A
N     */
N    LL_EPWM_IO_MAP_SEL_A,
N    /*! EPWM output selection B
N     */
N    LL_EPWM_IO_MAP_SEL_B,
N    /*! EPWM output selection NO
N     */
N    LL_EPWM_IO_MAP_SEL_NO,
N} TYPE_ENUM_LL_EPWM_IO_MAP_SEL;
N
N/**
N  * @brief Enumeration constant for low layer EPWM TZ6 force value
N  */
Ntypedef enum {
N    /*! Set EPWM force TZ6 to zero
N     */
N    LL_EPWM_FORCE_TZ6_0 = 0,
N    /*! Set EPWM force TZ6 to one
N     */
N    LL_EPWM_FORCE_TZ6_1,
N} TYPE_ENUM_LL_EPWM_TZ6_FORCE;
N
N/**
N  * @brief Enumeration constant for low layer EPWM channel select to trigger adc
N  * @note  1SARADC channel_0~channel_6 can only select the channel trigger source of EPWM_A.
N  *        2SARADC channel_7~channel_13 can only select the channel trigger source of EPWM_B.
N  */
Ntypedef enum {
N    /*! Disable
N     */
N    LL_EPWM_DIS = 0,
N    /*! EPWM0 channel select to trigger adc
N     */
N    LL_EWPM0_SOCAB,
N    /*! EPWM1 channel select to trigger adc
N     */
N    LL_EWPM1_SOCAB,
N    /*! EPWM2 channel select to trigger adc
N     */
N    LL_EWPM2_SOCAB,
N    /*! EPWM3 channel select to trigger adc
N     */
N    LL_EWPM3_SOCAB,
N    /*! EPWM4 channel select to trigger adc
N     */
N    LL_EWPM4_SOCAB,
N    /*! EPWM5 channel select to trigger adc
N     */
N    LL_EWPM5_SOCAB,
N    /*! EPWM6 channel select to trigger adc
N     */
N    LL_EWPM6_SOCAB,
N} TYPE_ENUM_LL_EPWM_ADC_SEL;
N
N/**
N  * @brief Enumeration constant for low layer EPWM TB synco select
N  */
Ntypedef enum {
N    /*! EPWM TB synco select sysn in
N     */
N    LL_EPWM_SYSNC_IN = 0,
N    /*! EPWM TB synco select count equal zero
N     */
N    LL_EPWM_TB_CNT_EQUAL_ZERO,
N    /*! EPWM TB synco select count equal cmpa
N     */
N    LL_EPWM_TB_CNT_EQUAL_COMPA,
N    /*! EPWM TB synco select count equal cmpb
N     */
N    LL_EPWM_TB_CNT_EQUAL_COMPB,
N    /*! EPWM TB synco select count equal NO
N     */
N    LL_EPWM_SEL_NO,
N} TYPE_ENUM_LL_EPWM_SYSCO_SEL;
N
N/**
N  * @brief Enumeration constant for low layer EPWM TB counter mode
N  */
Ntypedef enum {
N    /*! EPWM TB counter mode: up
N     */
N    LL_EPWM_MODE_UP = 0,
N    /*! EPWM TB counter mode: down
N     */
N    LL_EPWM_MODE_DOWN,
N    /*! EPWM TB counter mode: up and down
N     */
N    LL_EPWM_MODE_UP_DOWN,
N    /*! EPWM TB counter mode: constant
N     */
N    LL_EPWM_MODE_CONSTANT,
N} TYPE_ENUM_LL_EPWM_CNT_MODE;
N
N/**
N  * @brief Enumeration constant for low layer EPWM TB force pluse edge
N  */
Ntypedef enum {
N    /*! EPWM TB force pluse edge: rising
N     */
N    LL_EPWM_TB_FRAC_EDGE_RISING = 0,
N    /*! EPWM TB force pluse edge: falling
N     */
N    LL_EPWM_TB_FRAC_EDGE_FALLING,
N} TYPE_ENUM_LL_EPWM_TB_FRAC_EDGE;
N
N/**
N  * @brief Enumeration constant for low layer EPWM TB force pluse cycle value
N  */
Ntypedef enum {
N    /*! EPWM TB force pluse cycle value: DIS
N     */
N    LL_EPWM_TB_FRAC_PULSE_DIS = 0,
N    /*! EPWM TB force pluse cycle value: ONE
N     */
N    LL_EPWM_TB_FRAC_PULSE_ONE,
N    /*! EPWM TB force pluse cycle value: TWO
N     */
N    LL_EPWM_TB_FRAC_PULSE_TWO,
N    /*! EPWM TB force pluse cycle value: THREE
N     */
N    LL_EPWM_TB_FRAC_PULSE_THREE,
N    /*! EPWM TB force pluse cycle value: FOUR
N     */
N    LL_EPWM_TB_FRAC_PULSE_FOUR,
N    /*! EPWM TB force pluse cycle value: FIVE
N     */
N    LL_EPWM_TB_FRAC_PULSE_FIVE,
N    /*! EPWM TB force pluse cycle value: SIX
N     */
N    LL_EPWM_TB_FRAC_PULSE_SIX,
N    /*! EPWM TB force pluse cycle value: SEVEN
N     */
N    LL_EPWM_TB_FRAC_PULSE_SEVEN,
N} TYPE_ENUM_LL_EPWM_TB_FRAC_PULSE;
N
N/**
N  * @brief Enumeration constant for low layer EPWM CC shadow mode
N  */
Ntypedef enum {
N    /*! EPWM CC shadow mode: shadow
N     */
N    LL_EPWM_MODE_SHADOW = 0,
N    /*! EPWM CC shadow mode: immediate
N     */
N    LL_EPWM_MODE_IMMEDIATE,
N} TYPE_ENUM_LL_EPWM_CC_SHDW_MODE;
N
N/**
N  * @brief Enumeration constant for low layer EPWM CC load mode
N  */
Ntypedef enum {
N    /*! EPWM CC load mode: ZERO
N     */
N    LL_EPWM_LOAD_ON_CTR_ZERO = 0,
N    /*! EPWM CC load mode: PRD
N     */
N    LL_EPWM_LOAD_ON_CTR_PRD,
N    /*! EPWM CC load mode: ALL
N     */
N    LL_EPWM_LOAD_ON_CTR_ALL,
N    /*! EPWM CC load mode: NO
N     */
N    LL_EPWM_LOAD_NO,
N} TYPE_ENUM_LL_EPWM_CC_LOAD_MODE;
N
N/**
N  * @brief Enumeration constant for low layer EPWM AQ output mode
N  */
Ntypedef enum {
N    /*! EPWM AQ output mode: NO
N     */
N    LL_EPWM_AQ_OUT_NO = 0,
N    /*! EPWM AQ output mode: LOW
N     */  
N    LL_EPWM_AQ_OUT_LOW,
N    /*! EPWM AQ output mode: HIGH
N     */
N    LL_EPWM_AQ_OUT_HIGH,
N    /*! EPWM AQ output mode: TOGGLE
N     */
N    LL_EPWM_AQ_OUT_TOGGLE,
N} TYPE_ENUM_LL_EPWM_AQ_OUTMODE;
N
N/**
N  * @brief Enumeration constant for low layer EPWM AQ software force output mode
N  */
Ntypedef enum {
N    /*! EPWM AQ software force output mode: NO
N     */
N    LL_EPWM_SOFT_OUT_NO_EFFECT = 0,
N    /*! EPWM AQ software force output mode: LOW
N     */
N    LL_EPWM_SOFT_OUT_LOW,
N    /*! EPWM AQ software force output mode: HIGH
N     */
N    LL_EPWM_SOFT_OUT_HIGH,
N    /*! EPWM AQ software force output mode: DISABLE 
N     */
N    LL_EPWM_SOFT_OUT_DISABLE,
N} TYPE_ENUM_LL_EPWM_AQ_SW_FORCE;
N
N/**
N  * @brief Enumeration constant for low layer EPWM DB input edge mode
N  */
Ntypedef enum {                         
N    /*! DB input edge mode: A both fall and rise   
N     */
N    LL_EPWM_DB_IN_A_BOTH_EDGE = 0,
N    /*! DB input edge mode: A fall, B rise
N     */
N    LL_EPWM_DB_IN_A_FALL_B_RISE,
N    /*! DB input edge mode: A rise, B fall
N     */
N    LL_EPWM_DB_IN_A_RISE_B_FALL,
N    /*! DB input edge mode: B both fall and rise
N     */
N    LL_EPWM_DB_IN_B_BOTH_EDGE,
N} TYPE_ENUM_LL_EPWM_DB_INMODE;
N
N/**
N  * @brief Enumeration constant for low layer EPWM DB output polsel mode
N  */
Ntypedef enum {
N    /*! EPWM Both A and B inverted no
N     */
N    LL_EPWM_DB_BOTH_AB_NO = 0,
N    /*! EPWM A inverted and B no
N     */
N    LL_EPWM_DB_A_INVERTED_B_NO,
N    /*! EPWM A no and B inverted
N     */
N    LL_EPWM_DB_B_INVERTED_A_NO,
N    /*! EPWM Both A and B inverted
N     */
N    LL_EPWM_DB_BOTH_AB_INVERTED,
N} TYPE_ENUM_LL_EPWM_DB_POLSEL;
N
N/**
N  * @brief Enumeration constant for low layer EPWM DB output mode
N  */
Ntypedef enum {
N    /*! DB output mode: both no
N     */
N    LL_EPWM_DB_OUT_BOTH_NO = 0,
N    /*! DB output mode: falling
N     */
N    LL_EPWM_DB_OUT_FALL,
N    /*! DB output mode: rising
N     */
N    LL_EPWM_DB_OUT_RISIE,
N    /*! DB output mode: both falling and rising
N     */
N    LL_EPWM_DB_OUT_BOTH_FALL_RISE,
N} TYPE_ENUM_LL_EPWM_DB_OUTMODE;
N
N/**
N  * @brief Enumeration constant for low layer EPWM ET input source select
N  */
Ntypedef enum {
N    /*! DC B event1
N     */
N    LL_EPWM_ET_SOCSEL_DCBEVT1 = 0,
N    /*! TB count zero
N     */
N    LL_EPWM_ET_SOCSEL_TBCTR_ZERO,
N    /*! TB count period
N     */
N    LL_EPWM_ET_SOCSEL_TBCTR_PRD,
N    /*! both TB count zero and period
N     */
N    LL_EPWM_ET_SOCSEL_BOTH_TBCTR,
N    /*! count dir is up, and count to CMPA
N     */
N    LL_EPWM_ET_SOCSEL_TBCTR_CMPA_INC,
N    /*! count dir is down, and count to CMPA
N     */
N    LL_EPWM_ET_SOCSEL_TBCTR_CMPA_DEC,
N    /*! count dir is up, and count to CMPB
N     */
N    LL_EPWM_ET_SOCSEL_TBCTR_CMPB_INC,
N    /*! count dir is down, and count to CMPB
N     */
N    LL_EPWM_ET_SOCSEL_TBCTR_CMPB_DEC,
N    /*! count dir is up, and count to CMPC
N     */
N    LL_EPWM_ET_SOCSEL_TBCTR_CMPC_INC,
N    /*! count dir is down, and count to CMPC
N     */
N    LL_EPWM_ET_SOCSEL_TBCTR_CMPC_DEC,
N} TYPE_ENUM_LL_EPWM_ET_SOCSEL;
N
N/**
N  * @brief Enumeration constant for low layer EPWM ET adc event count select
N  */
Ntypedef enum {
N    /*! event trigger no
N     */
N    LL_EPWM_ET_EVENT_NO = 0,
N    /*! event trigger every one times
N     */
N    LL_EPWM_ET_EVENT_ONE,
N    /*! event trigger every two times
N     */
N    LL_EPWM_ET_EVENT_TWO,
N    /*! event trigger every three times
N     */
N    LL_EPWM_ET_EVENT_THREE,
N} TYPE_ENUM_LL_EPWM_ET_ADCEVENT;
N
N/**
N  * @brief Enumeration constant for low layer EPWM DC pulse select
N  */
Ntypedef enum {
N    /*! DC pulse select: count period
N     */
N    LL_EPWM_PULSESEL_CTR_PRD = 0,
N    /*! DC pulse select: count zero
N     */
N    LL_EPWM_PULSESEL_CTR_ZERO,
N    /*! DC pulse select: no
N     */
N    LL_EPWM_PULSESEL_NO,
N} TYPE_ENUM_LL_EPWM_DC_PULSESEL;
N
N/**
N  * @brief Enumeration constant for low layer EPWM DC filter sel
N  */
Ntypedef enum {
N    /*! DC filter sel: dc A event1
N     */
N    LL_EPWM_FILTSRCSEL_DCAEVT1 = 0,
N    /*! DC filter sel: dc A event2
N     */
N    LL_EPWM_FILTSRCSEL_DCAEVT2,
N    /*! DC filter sel: dc B event1
N     */
N    LL_EPWM_FILTSRCSEL_DCBEVT1,
N    /*! DC filter sel: dc B event2
N     */
N    LL_EPWM_FILTSRCSEL_DCBEVT2,
N} TYPE_ENUM_LL_EPWM_DC_FILTSRCSEL;
N
N/**
N  * @brief Enumeration constant for low layer EPWM DC event output mode
N  */
Ntypedef enum {
N    /*! DC event output mode: disable
N     */
N    LL_EPWM_EVT_OUT_DISABLE = 0,
N    /*! DC event output mode: DCH low
N     */
N    LL_EPWM_EVT_OUT_DCH_LOW,
N    /*! DC event output mode: DCH high
N     */
N    LL_EPWM_EVT_OUT_DCH_HIGH,
N    /*! DC event output mode: DCL low
N     */
N    LL_EPWM_EVT_OUT_DCL_LOW,
N    /*! DC event output mode: DCL high
N     */
N    LL_EPWM_EVT_OUT_DCL_HIGH,
N    /*! DC event output mode: DCL high and DCH low 
N     */
N    LL_EPWM_EVT_OUT_DCL_HIGH_DCH_LOW,
N    /*! DC event output mode: DCL low and DCH high 
N     */
N    LL_EPWM_EVT_OUT_DCL_LOW_DCH_HIGH,
N} TYPE_ENUM_LL_EPWM_DC_EVT_OUT;
N
N/**
N  * @brief Enumeration constant for low layer EPWM DC input select
N  */
Ntypedef enum {
N    /*! DC input select: TZ1
N     */
N    LL_EPWM_COMPSEL_TZ1_INPUT = 0,
N    /*! DC input select: TZ2
N     */
N    LL_EPWM_COMPSEL_TZ2_INPUT,
N    /*! DC input select: TZ3
N     */
N    LL_EPWM_COMPSEL_TZ3_INPUT,
N    /*! DC input select: TZ4
N     */
N    LL_EPWM_COMPSEL_TZ4_INPUT,
N    /*! DC input select: compare 1 output
N     */
N    LL_EPWM_COMPSEL_COMP1OUT_INPUT = 8,
N    /*! DC input select: compare 2 output
N     */
N    LL_EPWM_COMPSEL_COMP2OUT_INPUT,
N    /*! DC input select: compare 3 output
N     */
N    LL_EPWM_COMPSEL_COMP3OUT_INPUT,
N    /*! DC input select: compare 4 output
N     */
N    LL_EPWM_COMPSEL_COMP4OUT_INPUT,
N    /*! DC input select: compare 5 output
N     */
N    LL_EPWM_COMPSEL_COMP5OUT_INPUT,
N} TYPE_ENUM_LL_EPWM_DC_COMPSEL;
N
N/**
N  * @brief Enumeration constant for low layer EPWM DC sync select
N  */
Ntypedef enum {
N    /*! DC sync select: Synchronization signal
N     */
N    LL_EPWM_DC_SYNC_SIG = 0,
N    /*! DC sync select: Asynchronous signal
N     */
N    LL_EPWM_DC_ASYNC_SIG,
N} TYPE_ENUM_LL_EPWM_DC_SYNC_SEL;
N
N/**
N  * @brief Enumeration constant for low layer EPWM DC source event select
N  */
Ntypedef enum {
N    /*! DC source event select: event signal
N     */
N    LL_EPWM_DC_EVT_SRC_EVT = 0,
N    /*! DC source event select: event filter signal 
N     */
N    LL_EPWM_DC_EVT_SRC_EVTFILT,
N} TYPE_ENUM_LL_EPWM_DC_EVT_SRC;
N
N/**
N  * @brief Enumeration constant for low layer EPWM TZ action select
N  */
Ntypedef enum {
N    /*! TZ action select: high impedance
N     */
N    LL_EPWM_TZ_ACTION_HIGH_IMPEDANCE = 0, 
N    /*! TZ action select: high
N     */
N    LL_EPWM_TZ_ACTION_HIGH,
N    /*! TZ action select: low
N     */
N    LL_EPWM_TZ_ACTION_LOW,
N    /*! TZ action select: disable
N     */
N    LL_EPWM_TZ_ACTION_DISABLE,
N} TYPE_ENUM_LL_EPWM_TZ_ACTION;
N  
N/***** LL API AND DRIVER API *****/
N
N
N
N/**
N  * @}
N  */
N
N/** @defgroup EPWM_LL_Exported_Struct EPWM LL Exported Struct
N  * @ingroup  EPWM_LL_Driver
N  * @brief    EPWM LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the EPWM registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the low 
N    layer and call hal_epwm_init. Function, you can configure the EPWM module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief configuration structure for low layer EPWM TB module struct
N  */
Ntypedef struct __ll_epwm_tb_cfg {
N    /*! EPWM TB TBCTR Read Cnt Enable
N     */
N    bool                            read_counter_en;
N    /*! EPWM TB Input Synchronization Latched Status Bit
N     */
N    bool                            sync_latched_clr;
N    /*! EPWM TB Software Sync Enable
N     */
N    bool                            soft_sync_en;
N    /*! EPWM TB Phase Sync Enable
N     */
N    bool                            phase_sync_en;
N    /*! EPWM TB Active Period Register Load From Shadow Enable
N     */
N    bool                            shadow_load_dis;
N    /*! EPWM TB Set Time-base Counter Direction Of The Selected EPWM
N     */
N    bool                            phase_sync_dir_up_en;
N    /*! EPWM TB Sync Out Select Bit
N     */
N    TYPE_ENUM_LL_EPWM_SYSCO_SEL     sync_sel;
N    /*! EPWM TB Counter Direction Status Bit
N     */
N    TYPE_ENUM_LL_EPWM_CNT_MODE      count_dir_mode;
N    /*! EPWM TB EPWMB Fraction Value
N     */
N    TYPE_ENUM_LL_EPWM_TB_FRAC_PULSE frac_b_val;
N    /*! EPWM TB EPWMB Edge Select
N     */
N    TYPE_ENUM_LL_EPWM_TB_FRAC_EDGE  frac_b_edge;
N    /*! EPWM TB EPWMA Fraction Value
N     */
N    TYPE_ENUM_LL_EPWM_TB_FRAC_PULSE frac_a_val;
N    /*! EPWM TB EPWMA Edge Select
N     */
N    TYPE_ENUM_LL_EPWM_TB_FRAC_EDGE  frac_a_edge;
N    /*! EPWM TB Determine The Period Of The Time-base Counter
N     */
N    u16                             period_val;
N    /*! EPWM TB Set Time-base Counter Phase Of The Selected EPWM
N     */
N    u16                             phase_val;
N} TYPE_LL_EPWM_TB_CFG;
N
N/**
N  * @brief configuration structure for low layer EPWM CC module struct
N  */
Ntypedef struct __ll_epwm_cc_cfg {
N    /*! EPWM CC Counter-compare A (CMPA) Operating Mode
N     */
N    TYPE_ENUM_LL_EPWM_CC_SHDW_MODE shadow_a_mode;
N    /*! EPWM CC Counter-compare B (CMPB) Operating Mode
N     */
N    TYPE_ENUM_LL_EPWM_CC_SHDW_MODE shadow_b_mode;
N    /*! EPWM CC Counter-compare C (CMPC) Operating Mode
N    */
N    TYPE_ENUM_LL_EPWM_CC_SHDW_MODE shadow_c_mode;
N    /*! EPWM CC Active Counter-Compare A (CMPA) Load From Shadow Select Mode
N     */
N    TYPE_ENUM_LL_EPWM_CC_LOAD_MODE load_a_mode;
N    /*! EPWM CC Active Counter-Compare B (CMPB) Load From Shadow Select Mode
N     */
N    TYPE_ENUM_LL_EPWM_CC_LOAD_MODE load_b_mode;
N    /*! EPWM CC Active Counter-Compare C (CMPC) Load From Shadow Select Mode
N     */
N    TYPE_ENUM_LL_EPWM_CC_LOAD_MODE load_c_mode;
N    /*! EPWM CC used to access the counter-compare A value
N     *  Value should satisfy: 1 < cmp_a_val < tb.period_val
N     */
N    u16                            cmp_a_val;
N    /*! EPWM CC used to access the counter-compare B value
N     *  Value should satisfy: 1 < cmp_b_val < tb.period_val
N     */
N    u16                            cmp_b_val;
N    /*! EPWM CC used to access the counter-compare C value
N     *  Value should satisfy: 1 < cmp_c_val < tb.period_val
N     */
N    u16                            cmp_c_val;
N} TYPE_LL_EPWM_CC_CFG;
N
N/**
N  * @brief configuration structure for low layer EPWM AQ module struct
N  */
Ntypedef struct __ll_epwm_aq_cfg {
N    /*! EPWMB AQ Action when the TB cnt equals the active CMPB, the cnt is decrementing 
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  cmp_b_dec_b_out;
N    /*! EPWMB AQ Action when the TB cnt equals the active CMPB, the cnt is incrementing 
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  cmp_b_inc_b_out;
N    /*! EPWMB AQ Action when the TB cnt equals the active CMPA, the cnt is decrementing 
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  cmp_a_dec_b_out;
N    /*! EPWMB AQ Action when the TB cnt equals the active CMPA, the cnt is incrementing 
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  cmp_a_inc_b_out;
N    /*! EPWMB AQ Action when the counter equals the period
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  period_b_out;
N    /*! EPWMB AQ Action when counter equals zero
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  zero_b_out;
N    /*! EPWMA AQ Action when the TB cnt equals the active CMPB, the cnt is decrementing 
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  cmp_b_dec_a_out;
N    /*! EPWMA AQ Action when the TB cnt equals the active CMPB, the cnt is incrementing 
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  cmp_b_inc_a_out;
N    /*! EPWMA AQ Action when the TB cnt equals the active CMPA, the cnt is decrementing 
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  cmp_a_dec_a_out;
N    /*! EPWMA AQ Action when the TB cnt equals the active CMPA, the cnt is incrementing 
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  cmp_a_inc_a_out;
N    /*! EPWMA AQ Action when the counter equals the period
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  period_a_out;
N    /*! EPWMA AQ Action when counter equals zero
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  zero_a_out;
N    /*! EPWMB AQ One-Time Software Forced Event on Output B
N     */
N    bool                          soft_one_time_b_en;
N    /*! EPWMB AQ Action when One-Time Software Force B Is invoked
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  soft_b_out;
N    /*! EPWMA AQ One-Time Software Forced Event on Output A
N     */
N    bool                          soft_one_time_a_en;
N    /*! EPWMA AQ Action When One-Time Software Force A Is Invoked
N     */
N    TYPE_ENUM_LL_EPWM_AQ_OUTMODE  soft_a_out;
N    /*! EPWMB AQ Continuous Software Force on Output B
N     */
N    TYPE_ENUM_LL_EPWM_AQ_SW_FORCE contine_soft_b;
N    /*! EPWMA AQ Continuous Software Force on Output A
N     */
N    TYPE_ENUM_LL_EPWM_AQ_SW_FORCE contine_soft_a;
N} TYPE_LL_EPWM_AQ_CFG;
N
N/**
N  * @brief configuration structure for low layer EPWM DB module struct
N  */
Ntypedef struct __ll_epwm_db_cfg {
N    /*! EPWM DB Half Cycle Clocking Enable Bit
N     */
N    bool                         half_cycle_en;
N    /*! EPWM DB Dead Band Input Mode Control
N     */
N    TYPE_ENUM_LL_EPWM_DB_INMODE  in_mode;
N    /*! EPWM DB Polarity Select Control
N     */
N    TYPE_ENUM_LL_EPWM_DB_POLSEL  pol_sel;
N    /*! EPWM DB Dead-band Output Mode Control
N     */
N    TYPE_ENUM_LL_EPWM_DB_OUTMODE out_mode;
N    /*! EPWM DB Falling Edge Delay Count. 10-bit counter
N     */
N    u16                          fall_cnt;
N    /*! EPWM DB Rising Edge Delay Count. 10-bit counter
N     */
N    u16                          rise_cnt;
N} TYPE_LL_EPWM_DB_CFG;
N
N/**
N  * @brief configuration structure for low layer EPWM ET module struct
N  */
Ntypedef struct __ll_epwm_et_cfg {
N    /*! EWPM ET Enable the ADC Start of Conversion B (EPWMxSOCB) Pulse
N     */
N    bool                          soc_b_en;
N    /*! EWPM ET EPWMxSOCB Selection Options
N     */
N    TYPE_ENUM_LL_EPWM_ET_SOCSEL   soc_b_sel;
N    /*! EWPM ET Enable the ADC Start of Conversion A (EPWMxSOCA) Pulse
N     */
N    bool                          soc_a_en;
N    /*! EWPM ET EPWMxSOCA Selection Options
N     */
N    TYPE_ENUM_LL_EPWM_ET_SOCSEL   soc_a_sel;
N    /*! EWPM ET Enable ePWM Interrupt (EPWMx_INT) Generation
N     */
N    bool                          intr_en;
N    /*! EWPM ET Interrupt (EPWMx_INT) Selection Options
N     */
N    TYPE_ENUM_LL_EPWM_ET_SOCSEL   intr_sel;
N    /*! EWPM ET ADC Start-of-Conversion B Event (EPWMxSOCB) Period
N     */
N    TYPE_ENUM_LL_EPWM_ET_ADCEVENT soc_b_event;
N    /*! EWPM ET ADC Start-of-Conversion A Event (EPWMxSOCA) Period
N     */
N    TYPE_ENUM_LL_EPWM_ET_ADCEVENT soc_a_event;
N    /*! EWPM ET Interrupt (EPWMx_INT) Period Select
N     */
N    TYPE_ENUM_LL_EPWM_ET_ADCEVENT intr_event;
N} TYPE_LL_EPWM_ET_CFG;
N
N/**
N  * @brief configuration structure for low layer EPWM DC module struct
N  */
Ntypedef struct __ll_epwm_dc_cfg {
N    /*! EPWM DC DCAEVT1 SYNC Enable
N     */
N    bool                            a_evt1_sync_en;
N    /*! EPWM DC DCAEVT1 SOC Enable
N     */
N    bool                            a_evt1_soc_en;
N    /*! EPWM DC DCAEVT2 Force Synchronization Signal Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_SYNC_SEL   a_evt2_force_sync_sel;
N    /*! EPWM DC DCAEVT2 Source Signal Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_EVT_SRC    a_evt2_src_sel;
N    /*! EPWM DC DCAEVT1 Force Synchronization Signal Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_SYNC_SEL   a_evt1_force_sync_sel;
N    /*! EPWM DC DCAEVT1 Source Signal Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_EVT_SRC    a_evt1_src_sel;
N    /*! EPWM DC DCBEVT1 SYNC Enable
N     */
N    bool                            b_evt1_sync_en;
N    /*! EPWM DC DCBEVT1 SOC Enable
N     */
N    bool                            b_evt1_soc_en;
N    /*! EPWM DC DCBEVT2 Force Synchronization Signal Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_SYNC_SEL   b_evt2_force_sync_sel;
N    /*! EPWM DC DCBEVT2 Source Signal Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_EVT_SRC    b_evt2_src_sel;
N    /*! EPWM DC DCBEVT1 Force Synchronization Signal Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_SYNC_SEL   b_evt1_force_sync_sel;
N    /*! EPWM DC DCBEVT1 Source Signal Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_EVT_SRC    b_evt1_src_sel;
N    /*! EPWM DC Pulse Select For Blanking & Capture Alignment
N     */
N    TYPE_ENUM_LL_EPWM_DC_PULSESEL   pulse_sel;
N    /*! EPWM DC Blanking Window Inversion
N     */
N    bool                            blank_invert;
N    /*! EPWM DC Blanking Window Enable
N     */
N    bool                            blank_en;
N    /*! EPWM DC Filter Block Signal Source Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_FILTSRCSEL filt_src_sel;
N    /*! EPWM DC TBCTR Counter Capture Shadow Select Mode
N     */
N    bool                            shadow_mode_dis;
N    /*! EPWM DC TBCTR Counter Capture Enable
N     */
N    bool                            capture_en;
N
N    /*! EPWM DC Digital Compare Output B Event 2 Selection
N     */
N    TYPE_ENUM_LL_EPWM_DC_EVT_OUT    dc_b_evt2_out;
N    /*! EPWM DC Digital Compare Output B Event 1 Selection
N     */
N    TYPE_ENUM_LL_EPWM_DC_EVT_OUT    dc_b_evt1_out;
N    /*! EPWM DC Digital Compare Output A Event 2 Selection
N     */
N    TYPE_ENUM_LL_EPWM_DC_EVT_OUT    dc_a_evt2_out;
N    /*! EPWM DC Digital Compare Output A Event 1 Selection
N     */
N    TYPE_ENUM_LL_EPWM_DC_EVT_OUT    dc_a_evt1_out;
N    /*! EPWM DC Digital Compare B Low Input Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_COMPSEL    dc_bl_cmp_in;
N    /*! EPWM DC Digital Compare A High Input Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_COMPSEL    dc_bh_cmp_in;
N    /*! EPWM DC Digital Compare B Low Input Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_COMPSEL    dc_al_cmp_in;
N    /*! EPWM DC Digital Compare A High Input Select
N     */
N    TYPE_ENUM_LL_EPWM_DC_COMPSEL    dc_ah_cmp_in;
N    /*! EPWM DC Digital Compare Time-Base Counter Capture
N     */
N    u16                             dc_capture_cnt;
N    /*! EPWM DC Blanking Window Offset
N     */
N    u16                             blank_offset;
N    /*! EPWM DC Blanking Window Width
N     */
N    u16                             window_width;
N} TYPE_LL_EPWM_DC_CFG;
N
N/**
N  * @brief configuration structure for low layer EPWM TZ module struct
N  */
Ntypedef struct __ll_epwm_tz_cfg {
N    /*! EPWM TZ Digital Compare Output B Event 1 Select
N     */
N    bool                        dc_b_evt1_en;
N    /*! EPWM TZ Digital Compare Output A Event 1 Select
N     */
N    bool                        dc_a_evt1_en;
N    /*! EPWM TZ Trip-zone 6 (TZ6) As one-shot Enable
N     */
N    bool                        tz6_as_trip_en;
N    /*! EPWM TZ Trip-zone 5 (TZ5) As one-shot Enable
N     */
N    bool                        tz5_as_trip_en;
N    /*! EPWM TZ Trip-zone 4 (TZ4) As one-shot Enable
N     */
N    bool                        tz4_as_trip_en;
N    /*! EPWM TZ Trip-zone 3 (TZ3) As one-shot Enable
N     */
N    bool                        tz3_as_trip_en;
N    /*! EPWM TZ Trip-zone 2 (TZ2) As one-shot Enable
N     */
N    bool                        tz2_as_trip_en;
N    /*! EPWM TZ Trip-zone 1 (TZ1) As one-shot Enable
N     */
N    bool                        tz1_as_trip_en;
N    
N    /*! EPWM TZ Digital Compare Output B Event 2 Select
N     */
N    bool                        dc_b_evt2_en;
N    /*! EPWM TZ Digital Compare Output A Event 2 Select
N     */
N    bool                        dc_a_evt2_en;
N    /*! EPWM TZ Trip-zone 6 (TZ6) As cycle-by_cycle Enable
N     */
N    bool                        tz6_as_cbc_en;
N    /*! EPWM TZ Trip-zone 5 (TZ5) As cycle-by_cycle Enable
N     */
N    bool                        tz5_as_cbc_en;       
N    /*! EPWM TZ Trip-zone 4 (TZ4) As cycle-by_cycle Enable
N     */
N    bool                        tz4_as_cbc_en;
N    /*! EPWM TZ Trip-zone 3 (TZ3) As cycle-by_cycle Enable
N     */
N    bool                        tz3_as_cbc_en;
N    /*! EPWM TZ Trip-zone 2 (TZ2) As cycle-by_cycle Enable
N     */
N    bool                        tz2_as_cbc_en;
N    /*! EPWM TZ Trip-zone 1 (TZ1) As cycle-by_cycle Enable
N     */
N    bool                        tz1_as_cbc_en;
N    
N    /*! EPWM TZ Digital Comparator Output B Event 2 Interrupt Enable
N     */
N    bool                        dc_b_evt2_intr_en;   
N    /*! EPWM TZ Digital Comparator Output B Event 1 Interrupt Enable
N     */
N    bool                        dc_b_evt1_intr_en;
N    /*! EPWM TZ Digital Comparator Output A Event 2 Interrupt Enable
N     */
N    bool                        dc_a_evt2_intr_en;
N    /*! EPWM TZ Digital Comparator Output A Event 1 Interrupt Enable
N     */
N    bool                        dc_a_evt1_intr_en;
N    /*! EPWM TZ Trip-zone One-Shot Interrupt Enable
N     */
N    bool                        tz_trip_intr_en;
N    /*! EPWM TZ Trip-zone Cycle-by-Cycle Interrupt Enable
N     */
N    bool                        tz_cbc_intr_en;
N    
N    /*! EPWM TZ Digital Compare Output B Event 2 Action On EPWMxB
N     */
N    TYPE_ENUM_LL_EPWM_TZ_ACTION dc_b_evt2_action;
N    /*! EPWM TZ Digital Compare Output B Event 1 Action On EPWMxB
N     */
N    TYPE_ENUM_LL_EPWM_TZ_ACTION dc_b_evt1_action;
N    /*! EPWM TZ Digital Compare Output A Event 2 Action On EPWMxA
N     */
N    TYPE_ENUM_LL_EPWM_TZ_ACTION dc_a_evt2_action;
N    /*! EPWM TZ Digital Compare Output A Event 1 Action On EPWMxA
N     */
N    TYPE_ENUM_LL_EPWM_TZ_ACTION dc_a_evt1_action;
N    /*! EPWM TZ a trip event occurs the following action is taken on out EPWMxB
N     */
N    TYPE_ENUM_LL_EPWM_TZ_ACTION tz_b_action;
N    /*! EPWM TZ a trip event occurs the following action is taken on out EPWMxA
N     */
N    TYPE_ENUM_LL_EPWM_TZ_ACTION tz_a_action;
N} TYPE_LL_EPWM_TZ_CFG;
N
N/**
N  * @brief configuration structure for low layer EPWM channel struct
N  */
Ntypedef struct __ll_epwm_chn_cfg {
N    /*! EPWM CHN Time-Base module config struct
N     */
N    TYPE_LL_EPWM_TB_CFG tb;
N    /*! EPWM CHN Counter-Compare module config struct
N     */
N    TYPE_LL_EPWM_CC_CFG cc;
N    /*! EPWM CHN Action-Qualifier module config struct
N     */
N    TYPE_LL_EPWM_AQ_CFG aq;
N    /*! EPWM CHN Dead-Band module config struct
N     */
N    TYPE_LL_EPWM_DB_CFG db;
N    /*! EPWM CHN Event-Trigger module config struct
N     */
N    TYPE_LL_EPWM_ET_CFG et;
N    /*! EPWM CHN Digital Compare module config struct
N     */
N    TYPE_LL_EPWM_DC_CFG dc;
N    /*! EPWM CHN Trip-Zone module config struct
N     */
N    TYPE_LL_EPWM_TZ_CFG tz;
N} TYPE_LL_EPWM_CHN_CFG;
N
N/**
N  * @brief configuration structure for low layer EPWM module struct
N  */ 
Ntypedef struct __ll_epwm_cfg {       
N    /*! Select the channel to be configured by EPWM
N     *  @note The range of chn can only be between 0 and 6.
N     */
N    u8                            chn;
N    /*! Select the EPWM output.
N     */
N    TYPE_ENUM_LL_EPWM_IO_MAP_SEL  io_map_sel;
N    /*! EPWM Trip-Zone cpu kick value
N     *  @note The TZ6 will refer to the software triggering the TZ behavior, 
N     *        which triggers each channel.
N     */     
N    TYPE_ENUM_LL_EPWM_TZ6_FORCE   cpu_tz; 
N    /*! EPWM channel 0 to channel 6 config struct
N     */
N    TYPE_LL_EPWM_CHN_CFG          module;
N} TYPE_LL_EPWM_CFG; 
N
N/**
N  * @brief initialization structure for low layer EPWM module struct
N  */ 
Ntypedef struct __ll_epwm_init {
N    /*! Configure the source select for EPWM 
N     */
N    TYPE_ENUM_LL_CC_RST_EPWM_CLK_SRC    src;
N    /*! Configure the division ratio of the EPWM operating clock, Fadc and epwm share an adpll, 
N     *  the default configuration is 180M.
N     *  The epwm_adpll_div_val must be less than 15.
N     */
N    u8                                  epwm_adpll_div_val;
N} TYPE_LL_EPWM_INIT; 
N
N/**
N  * @}
N  */
N
N/** @defgroup EPWM_LL_Interrupt EPWM LL Interrupt Handle function
N  * @brief   EPWM LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the EPWM  
N    Interrupt Handle function.
N
N    how to use?
N
N
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup EPWM_LL_Inti_Cfg EPWM LL Initialization And Configuration
N  * @brief    EPWM LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the EPWM data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Low layer EPWM initialization function
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  p_init: Low layer initialization variable
N  * @retval None
N  */
Nvoid ll_epwm_init(EPWM_TypeDef *p_epwm, TYPE_LL_EPWM_INIT *p_init);
N
N/**
N  * @brief  Low layer EPWM delete initialization function
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @retval None
N  */
Nvoid ll_epwm_deinit(EPWM_TypeDef *p_epwm);
N
N/**
N  * @brief  Low layer EPWM Configuration function
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  p_cfg : Low layer initialization variable
N  * @retval None
N  */
Nvoid ll_epwm_config(EPWM_TypeDef *p_epwm, TYPE_LL_EPWM_CFG *p_cfg);
N
N/**
N  * @brief  Low layer Path selection between Saradc and epwm.
N  * @param  p_epwm  : Select the initialized EPWM group pointer
N  * @param  adc_chn : Select the configured adc path, range 0~14.
N  * @param  epwm_sel: Select the trigger source of adc.
N  * @retval None
N  * @note   1.The EPWM trigger source selected by saradc0 ~ saradc6 can only be selected between epwm0_soca ~epwm6_soca.
N  *         2.The EPWM trigger source selected by saradc7 ~ saradc13 can only be selected between epwm0_socb ~epwm6_socb.
N  */
Nvoid ll_epwm_saradc_sel_config(EPWM_TypeDef *p_epwm, u8 adc_chn, TYPE_ENUM_LL_EPWM_ADC_SEL epwm_sel);
N
N/**
N  * @brief  Low layer Configure the map that triggers the signal between fadc and epwm.
N  * @param  p_epwm: Select the initialized EPWM group pointer
N  * @retval None
N  */
Nvoid ll_epwm_fadc_map_config(EPWM_TypeDef *p_epwm);
N
N/**
N  * @}
N  */
N  
N/** @defgroup EPWM_LL_Data_Transfers EPWM LL Data transfers functions
N  * @brief    EPWM LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the EPWM data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  Low layer EPWM direct configuration start function
N  * @param  p_epwm  : Structure pointer set to EPWM.
N  * @param  chn_bits: Channel value with shift
N  * @retval None
N  * @note   This function is a direct configuration register, but 
N  *         bit_chn must be assigned the form of BIT(chn).
N  */
Nvoid ll_epwm_start(EPWM_TypeDef *p_epwm, u32 chn_bits);
N
N/**
N  * @brief  Low layer EPWM direct configuration stop function
N  * @param  p_epwm  : Structure pointer set to EPWM.
N  * @param  chn_bits: Channel value with shift
N  * @param  a_action: When the EPWM is stopped, the safe level of the EPWM_A output is required.
N  * @param  b_action: When the EPWM is stopped, the safe level of the EPWM_B output is required.
N  * @retval None
N  * @note   This function is a direct configuration register, but 
N  *         bit_chn must be assigned the form of BIT(chn).
N  */
Nvoid ll_epwm_stop(EPWM_TypeDef               *p_epwm, 
N                  u32                         chn_bits, 
N                  TYPE_ENUM_LL_EPWM_TZ_ACTION a_action,
N                  TYPE_ENUM_LL_EPWM_TZ_ACTION b_action);
N
N/**
N  * @brief  Low layer EPWM check channel enable
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  chn   : Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N#define LL_EPWM_CHECK_CHANNEL_ENABLE(p_epwm, chn)                ((p_epwm)->EPWM_TTCTL & LL_EPWM_EN(BIT(chn)))
N
N/**
N  * @brief  Low layer EPWM check ET interrupt pending
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  chn   : Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N#define LL_EPWM_CHECK_ET_INTERRUPT_ENABLE(p_epwm, chn)           ((p_epwm)->CH[chn].EPWM_ETCTL & LL_EPWM_INTEN)
N
N/**
N  * @brief  Low layer EPWM check TZ dc b event2 interrupt pending
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  chn   : Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N#define LL_EPWM_CHECK_TZ_DCBEVT2_INTERRUPT_ENABLE(p_epwm, chn)   ((p_epwm)->CH[chn].EPWM_TZFLAG & LL_EPWM_TZ_DCBEVT2INTE)
N
N/**
N  * @brief  Low layer EPWM check TZ dc b event1 interrupt pending
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  chn   : Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N#define LL_EPWM_CHECK_TZ_DCBEVT1_INTERRUPT_ENABLE(p_epwm, chn)   ((p_epwm)->CH[chn].EPWM_TZFLAG & LL_EPWM_TZ_DCBEVT1INTE)
N
N/**
N  * @brief  Low layer EPWM check TZ dc a event2 interrupt pending
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  chn   : Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N#define LL_EPWM_CHECK_TZ_DCAEVT2_INTERRUPT_ENABLE(p_epwm, chn)   ((p_epwm)->CH[chn].EPWM_TZFLAG & LL_EPWM_TZ_DCAEVT2INTE)
N
N/**
N  * @brief  Low layer EPWM check TZ dc a event1 interrupt pending
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  chn   : Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N#define LL_EPWM_CHECK_TZ_DCAEVT1_INTERRUPT_ENABLE(p_epwm, chn)   ((p_epwm)->CH[chn].EPWM_TZFLAG & LL_EPWM_TZ_DCAEVT1INTE)
N
N/**
N  * @brief  Low layer EPWM check TZ one-shot interrupt pending
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  chn   : Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N#define LL_EPWM_CHECK_TZ_OST_INTERRUPT_ENABLE(p_epwm, chn)       ((p_epwm)->CH[chn].EPWM_TZFLAG & LL_EPWM_TZ_OSTINTE)
N
N/**
N  * @brief  Low layer EPWM check TZ cycle-by-cycle interrupt pending
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  chn   : Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N#define LL_EPWM_CHECK_TZ_CBC_INTERRUPT_ENABLE(p_epwm, chn)       ((p_epwm)->CH[chn].EPWM_TZFLAG & LL_EPWM_TZ_CBCINTE)
N
N/**
N  * @brief  Low layer EPWM get ET interrupt pending
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  chn   : Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N#define LL_EPWM_GET_ET_INTERRUPT_PENDING(p_epwm, chn)            ((p_epwm)->CH[chn].EPWM_ETFLAG)
N
N/**
N  * @brief  Low layer EPWM get TZ interrupt pending
N  * @param  p_epwm: Structure pointer set to EPWM.
N  * @param  chn   : Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N#define LL_EPWM_GET_TZ_INTERRUPT_PENDING(p_epwm, chn)            ((p_epwm)->CH[chn].EPWM_TZFLAG)
N
N/**
N  * @brief  Low layer EPWM clear ET interrupt pending
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_clear_et_interrupt_pending(u8 chn) {
Xstatic __inline void ll_epwm_clear_et_interrupt_pending(u8 chn) {
N    EPWM->CH[chn].EPWM_ETFLAG |= LL_EPWM_CLRINT_FLAG;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_ETFLAG |= (1UL << 4);
N}
N
N/**
N  * @brief  Low layer EPWM clear TZ dc b event2 interrupt pending
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_clear_tz_dc_b_event2_interrupt_pending(u8 chn) {
Xstatic __inline void ll_epwm_clear_tz_dc_b_event2_interrupt_pending(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLRDCBEVT2;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 22);
N}
N
N/**
N  * @brief  Low layer EPWM clear TZ dc b event1 interrupt pending
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_clear_tz_dc_b_event1_interrupt_pending(u8 chn) {
Xstatic __inline void ll_epwm_clear_tz_dc_b_event1_interrupt_pending(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLRDCBEVT1;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 21);
N}
N
N/**
N  * @brief  Low layer EPWM clear TZ dc a event2 interrupt pending
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_clear_tz_dc_a_event2_interrupt_pending(u8 chn) {
Xstatic __inline void ll_epwm_clear_tz_dc_a_event2_interrupt_pending(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLRDCAEVT2;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 20);
N}
N
N/**
N  * @brief  Low layer EPWM clear TZ dc a event1 interrupt pending
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_clear_tz_dc_a_event1_interrupt_pending(u8 chn) {
Xstatic __inline void ll_epwm_clear_tz_dc_a_event1_interrupt_pending(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLRDCAEVT1;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 19);
N}
N
N/**
N  * @brief  Low layer EPWM clear TZ one-shot interrupt pending
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_clear_tz_one_shot_interrupt_pending(u8 chn) {
Xstatic __inline void ll_epwm_clear_tz_one_shot_interrupt_pending(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLROST;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 18);
N}
N
N/**
N  * @brief  Low layer EPWM clear TZ cycle-by-cycle interrupt pending
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_clear_tz_cycle_by_cycle_interrupt_pending(u8 chn) {
Xstatic __inline void ll_epwm_clear_tz_cycle_by_cycle_interrupt_pending(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLRCBC;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 17);
N}
N
N/**
N  * @brief  Low layer EPWM clear TZ interrupt pending
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_clear_tz_interrupt_pending(u8 chn) {
Xstatic __inline void ll_epwm_clear_tz_interrupt_pending(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLRINT;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 16);
N}
N
N/**
N  * @brief  Low layer EPWM disable TB software force synchronous
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tb_swf_sync_disable(u8 chn) {
Xstatic __inline void ll_epwm_tb_swf_sync_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TBCTL &= ~LL_EPWM_SWF_SYNC;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TBCTL &= ~(1UL << 4);
N}
N
N/**
N  * @brief  Low layer EPWM ensable TB software force synchronous
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tb_soft_sync_enable(u8 chn) {
Xstatic __inline void ll_epwm_tb_soft_sync_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TBCTL |= LL_EPWM_SWF_SYNC;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TBCTL |= (1UL << 4);
N}
N
N/**
N  * @brief  Low layer EPWM set period value
N  * @param  chn       : Channel num of EPWM, Zreo to six
N  * @param  period_val: period value
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_period(u8 chn, u16 period_val) {
Xstatic __inline void ll_epwm_set_period(u8 chn, u16 period_val) {
N    EPWM->CH[chn].EPWM_TBPRD = LL_EPWM_TBPRD(period_val);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TBPRD = (((period_val)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM set phase value
N  * @param  chn      : Channel num of EPWM, Zreo to six
N  * @param  phase_val: phase value
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_phase(u8 chn, u16 phase_val) {
Xstatic __inline void ll_epwm_set_phase(u8 chn, u16 phase_val) {
N    EPWM->CH[chn].EPWM_TBPHASE = LL_EPWM_TBPHS(phase_val);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TBPHASE = (((phase_val)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM set compare A value
N  * @param  chn       : Channel num of EPWM, Zreo to six
N  * @param  cmpa_value: compare A value
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_compare_a(u8 chn, u16 cmpa_value) {
Xstatic __inline void ll_epwm_set_compare_a(u8 chn, u16 cmpa_value) {
N    EPWM->CH[chn].EPWM_CMPA = LL_EPWM_CPMA_VALUE(cmpa_value);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPA = (((cmpa_value)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM set compare B value
N  * @param  chn       : Channel num of EPWM, Zreo to six
N  * @param  cmpb_value: compare B value
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_compare_b(u8 chn, u16 cmpb_value) {
Xstatic __inline void ll_epwm_set_compare_b(u8 chn, u16 cmpb_value) {
N    EPWM->CH[chn].EPWM_CMPB = LL_EPWM_CPMB_VALUE(cmpb_value);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPB = (((cmpb_value)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM set compare A and B value
N  * @param  chn       : Channel num of EPWM, Zreo to six
N  * @param  cmpa_value: compare A value
N  * @param  cmpb_value: compare B value
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_compare_a_and_b(u8 chn, u16 cmpa_value, u16 cmpb_value) {
Xstatic __inline void ll_epwm_set_compare_a_and_b(u8 chn, u16 cmpa_value, u16 cmpb_value) {
N    TX_ASSERT((cmpa_value != 0)                                 && 
N              (cmpb_value != 0)                                 && 
N              (cmpa_value != (EPWM->CH[chn].EPWM_TBPRD&0xFFFF)) && 
N              (cmpb_value != (EPWM->CH[chn].EPWM_TBPRD&0xFFFF)));
X    (((cmpa_value != 0) && (cmpb_value != 0) && (cmpa_value != (((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn]. EPWM_TBPRD&0xFFFF)) && (cmpb_value != (((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn]. EPWM_TBPRD&0xFFFF))) ? (void)0U : tx_assert_false((uint8_t *)"..\\..\\..\\..\\Libraries\\Driver\\include\\LL\\tx_phe_ll_epwm.h", 1996));
N    
N    if((cmpa_value == cmpb_value) && !(EPWM->CH[chn].EPWM_AQCTLAB & 0x0F000F00)) {
X    if((cmpa_value == cmpb_value) && !(((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_AQCTLAB & 0x0F000F00)) {
N        EPWM->CH[chn].EPWM_CMPB = LL_EPWM_CPMB_VALUE(cmpb_value+1);
X        ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPB = (((cmpb_value + 1)&0xFFFF) << 0);
N    } else {
N        EPWM->CH[chn].EPWM_CMPB = LL_EPWM_CPMB_VALUE(cmpb_value);
X        ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPB = (((cmpb_value)&0xFFFF) << 0);
N    }
N    EPWM->CH[chn].EPWM_CMPA = LL_EPWM_CPMA_VALUE(cmpa_value);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPA = (((cmpa_value)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM set compare C value
N  * @param  chn       : Channel num of EPWM, Zreo to six
N  * @param  cmpc_value: compare C value
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_compare_c(u8 chn, u16 cmpc_value) {
Xstatic __inline void ll_epwm_set_compare_c(u8 chn, u16 cmpc_value) {
N    EPWM->CH[chn].EPWM_CMPC = LL_EPWM_CPMC_VALUE(cmpc_value);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPC = (((cmpc_value)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM sets the duty ratio of compare A by the fixed point percentage,
N  *         At count=0, the behavior of AQ is pulled high.
N  * @param  chn          : Channel num of EPWM, Zreo to six
N  * @param  fixed_percent: Fixed point percentage, 15bit fixed point value.
N  * @param  period       : Period value.
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_compare_a_by_fixed_in_zero_high(u8 chn, u16 fixed_percent, u16 period) {
Xstatic __inline void ll_epwm_set_compare_a_by_fixed_in_zero_high(u8 chn, u16 fixed_percent, u16 period) {
N    EPWM->CH[chn].EPWM_CMPA = LL_EPWM_CPMA_VALUE(((u32)period*fixed_percent)>>15);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPA = (((((u32)period*fixed_percent)>>15)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM sets the duty ratio of compare B by the fixed point percentage,
N  *         At count=0, the behavior of AQ is pulled high.
N  * @param  chn          : Channel num of EPWM, Zreo to six
N  * @param  fixed_percent: Fixed point percentage, 15bit fixed point value.
N  * @param  period       : Period value.
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_compare_b_by_fixed_in_zero_high(u8 chn, u16 fixed_percent, u16 period) {
Xstatic __inline void ll_epwm_set_compare_b_by_fixed_in_zero_high(u8 chn, u16 fixed_percent, u16 period) {
N    EPWM->CH[chn].EPWM_CMPB = LL_EPWM_CPMB_VALUE(((u32)period*fixed_percent)>>15);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPB = (((((u32)period*fixed_percent)>>15)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM sets the duty ratio of compare C by the fixed point percentage,
N  *         At count=0, the behavior of AQ is pulled high.
N  * @param  chn          : Channel num of EPWM, Zreo to six
N  * @param  fixed_percent: Fixed point percentage, 15bit fixed point value.
N  * @param  period       : Period value.
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_compare_c_by_fixed_in_zero_high(u8 chn, u16 fixed_percent, u16 period) {
Xstatic __inline void ll_epwm_set_compare_c_by_fixed_in_zero_high(u8 chn, u16 fixed_percent, u16 period) {
N    EPWM->CH[chn].EPWM_CMPC = LL_EPWM_CPMC_VALUE(((u32)period*fixed_percent)>>15);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPC = (((((u32)period*fixed_percent)>>15)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM sets the duty ratio of compare A by the fixed point percentage,
N  *         At count=0, the behavior of AQ is pulled low.
N  * @param  chn          : Channel num of EPWM, Zreo to six
N  * @param  fixed_percent: Fixed point percentage, 15bit fixed point value.
N  * @param  period       : Period value.
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_compare_a_by_fixed_in_zero_low(u8 chn, u16 fixed_percent, u16 period) {
Xstatic __inline void ll_epwm_set_compare_a_by_fixed_in_zero_low(u8 chn, u16 fixed_percent, u16 period) {
N    EPWM->CH[chn].EPWM_CMPA = LL_EPWM_CPMA_VALUE(period - (((u32)period*fixed_percent)>>15));
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPA = (((period - (((u32)period*fixed_percent)>>15))&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM sets the duty ratio of compare B by the fixed point percentage,
N  *         At count=0, the behavior of AQ is pulled low.
N  * @param  chn          : Channel num of EPWM, Zreo to six
N  * @param  fixed_percent: Fixed point percentage, 15bit fixed point value.
N  * @param  period       : Period value.
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_compare_b_by_fixed_in_zero_low(u8 chn, u16 fixed_percent, u16 period) {
Xstatic __inline void ll_epwm_set_compare_b_by_fixed_in_zero_low(u8 chn, u16 fixed_percent, u16 period) {
N    EPWM->CH[chn].EPWM_CMPB = LL_EPWM_CPMB_VALUE(period - (((u32)period*fixed_percent)>>15));
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPB = (((period - (((u32)period*fixed_percent)>>15))&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM sets the duty ratio of compare C by the fixed point percentage,
N  *         At count=0, the behavior of AQ is pulled low.
N  * @param  chn          : Channel num of EPWM, Zreo to six
N  * @param  fixed_percent: Fixed point percentage, 15bit fixed point value.
N  * @param  period       : Period value.
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_compare_c_by_fixed_in_zero_low(u8 chn, u16 fixed_percent, u16 period) {
Xstatic __inline void ll_epwm_set_compare_c_by_fixed_in_zero_low(u8 chn, u16 fixed_percent, u16 period) {
N    EPWM->CH[chn].EPWM_CMPC = LL_EPWM_CPMC_VALUE(period - (((u32)period*fixed_percent)>>15));
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPC = (((period - (((u32)period*fixed_percent)>>15))&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM need to wait for the shadow register to be 
N  *         in nofull state before updating cmpa value
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_wait_compare_a_shadow_nofull(u8 chn) {
Xstatic __inline void ll_epwm_wait_compare_a_shadow_nofull(u8 chn) {
N    while(EPWM->CH[chn].EPWM_CMPCTL & LL_EPWM_SHDW_A_FULL_PNG);
X    while(((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPCTL & (1UL << 6));
N}
N
N/**
N  * @brief  Low layer EPWM need to wait for the shadow register to be 
N  *         in nofull state before updating cmpb value
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_wait_compare_b_shadow_nofull(u8 chn) {
Xstatic __inline void ll_epwm_wait_compare_b_shadow_nofull(u8 chn) {
N    while(EPWM->CH[chn].EPWM_CMPCTL & LL_EPWM_SHDW_B_FULL_PNG);
X    while(((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPCTL & (1UL << 7));
N}
N
N/**
N  * @brief  Low layer EPWM need to wait for the shadow register to be 
N  *         in nofull state before updating cmpc value
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_wait_compare_c_shadow_nofull(u8 chn) {
Xstatic __inline void ll_epwm_wait_compare_c_shadow_nofull(u8 chn) {
N    while(EPWM->CH[chn].EPWM_CMPCTL & LL_EPWM_SHDW_C_FULL_PNG);
X    while(((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_CMPCTL & (1UL << 11));
N}
N
N/**
N  * @brief  Low layer EPWM AQ enable One-Time Software Forced Event on Output A
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_a_aq_soft_force_one_enable(u8 chn) {
Xstatic __inline void ll_epwm_a_aq_soft_force_one_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_AQSFRC |= LL_EPWM_OTSFA_EN;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_AQSFRC |= (1UL << 2);
N}
N
N/**
N  * @brief  Low layer EPWM AQ enable One-Time Software Forced Event on Output B
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_b_aq_soft_force_one_enable(u8 chn) {
Xstatic __inline void ll_epwm_b_aq_soft_force_one_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_AQSFRC |= LL_EPWM_OTSFB_EN;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_AQSFRC |= (1UL << 5);
N}
N
N/**
N  * @brief  Low layer EPWM AQ enable Continuous Software Force on Output A
N  * @param  chn    : Channel num of EPWM, Zreo to six
N  * @param  force_a: Set the level mode of the output
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_a_aq_soft_continue_enable(u8 chn, 
Xstatic __inline void ll_epwm_a_aq_soft_continue_enable(u8 chn, 
N                                                       TYPE_ENUM_LL_EPWM_AQ_SW_FORCE force_a) {
N	uint32_t temp;
N    temp = EPWM->CH[chn].EPWM_AQCSFRC;
X    temp = ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_AQCSFRC;
N    temp &= ~(LL_EPWM_CSFA(3UL));
X    temp &= ~((((3UL)&0x3) << 0));
N    temp |= LL_EPWM_CSFA(force_a);
X    temp |= (((force_a)&0x3) << 0);
N	EPWM->CH[chn].EPWM_AQCSFRC = temp;
X	((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_AQCSFRC = temp;
N}
N
N/**
N  * @brief  Low layer EPWM AQ disable Continuous Software Force on Output A
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_a_aq_soft_continue_disable(u8 chn) {
Xstatic __inline void ll_epwm_a_aq_soft_continue_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_AQCSFRC &= ~(LL_EPWM_CSFA(3UL));
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_AQCSFRC &= ~((((3UL)&0x3) << 0));
N}
N
N/**
N  * @brief  Low layer EPWM AQ enable Continuous Software Force on Output B
N  * @param  chn    : Channel num of EPWM, Zreo to six
N  * @param  force_b: Set the level mode of the output
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_b_aq_soft_continue_enable(u8 chn, 
Xstatic __inline void ll_epwm_b_aq_soft_continue_enable(u8 chn, 
N                                                       TYPE_ENUM_LL_EPWM_AQ_SW_FORCE force_b) {
N	uint32_t temp;
N	temp = EPWM->CH[chn].EPWM_AQCSFRC;
X	temp = ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_AQCSFRC;
N    temp &= ~(LL_EPWM_CSFB(3UL));
X    temp &= ~((((3UL)&0x3) << 2));
N    temp |= LL_EPWM_CSFB(force_b);
X    temp |= (((force_b)&0x3) << 2);
N	EPWM->CH[chn].EPWM_AQCSFRC = temp;
X	((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_AQCSFRC = temp;
N}
N
N/**
N  * @brief  Low layer EPWM AQ enable Continuous Software Force on Output B
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_b_aq_soft_continue_disable(u8 chn) {
Xstatic __inline void ll_epwm_b_aq_soft_continue_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_AQCSFRC &= ~(LL_EPWM_CSFB(3UL));
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_AQCSFRC &= ~((((3UL)&0x3) << 2));
N}
N
N/**
N  * @brief  Low layer EPWM DC set Blanking Window Offset value
N  * @param  chn       : Channel num of EPWM, Zreo to six
N  * @param  offset_val: Set the value of the Blanking Window Offset
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_b_set_dc_blank_offset(u8 chn, u16 offset_val) {
Xstatic __inline void ll_epwm_b_set_dc_blank_offset(u8 chn, u16 offset_val) {
N    EPWM->CH[chn].EPWM_BLANKOFFSET = LL_EPWM_OFFSET(offset_val);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_BLANKOFFSET = (((offset_val)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM DC set Blanking Window Width value
N  * @param  chn       : Channel num of EPWM, Zreo to six
N  * @param  window_val: Set the value of the Blanking Window Width
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_b_set_dc_window_width(u8 chn, u16 window_val) {
Xstatic __inline void ll_epwm_b_set_dc_window_width(u8 chn, u16 window_val) {
N    EPWM->CH[chn].EPWM_WINWIDTH = LL_EPWM_WINDOW(window_val);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_WINWIDTH = (((window_val)&0xFFF) << 0);
N}
N
N/**
N  * @brief  Low layer EPWM set TZ6 to false
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_tz6_false(void) {
Xstatic __inline void ll_epwm_set_tz6_false(void) {
N    EPWM->EPWM_TTCTL |= LL_EPWM_CPUTZ_ZERO;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->EPWM_TTCTL |= (1UL << 10);
N}
N
N/**
N  * @brief  Low layer EPWM set TZ6 to true
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_set_tz6_true(void) {
Xstatic __inline void ll_epwm_set_tz6_true(void) {
N    EPWM->EPWM_TTCTL &= ~LL_EPWM_CPUTZ_ZERO;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->EPWM_TTCTL &= ~(1UL << 10);
N}
N
N/**
N  * @brief  Low layer EPWM TZ enable Software Force a Cycle-by-Cycle Trip Event
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_cbc_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_cbc_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_FRCCBC;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 9);
N}
N
N/**
N  * @brief  Low layer EPWM TZ enable Software Force a One-Shot Trip Event
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_ost_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_ost_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_FRCOST;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 10);
N}
N
N/**
N  * @brief  Low layer EPWM TZ enable Software Force Flag for Digital Compare Output A Event 1
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_dca_evt1_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_dca_evt1_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_FRCDCAEVT1;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 11);
N}
N
N/**
N  * @brief  Low layer EPWM TZ enable Software Force Flag for Digital Compare Output A Event 2
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_dca_evt2_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_dca_evt2_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_FRCDCAEVT2;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 12);
N}
N
N/**
N  * @brief  Low layer EPWM TZ enable Software Force Flag for Digital Compare Output B Event 1
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_dcb_evt1_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_dcb_evt1_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_FRCDCBEVT1;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 13);
N}
N
N/**
N  * @brief  Low layer EPWM TZ enable Software Force Flag for Digital Compare Output B Event 2
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_dcb_evt2_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_dcb_evt2_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_FRCDCBEVT2;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 14);
N}
N
N/**
N  * @brief  Low layer EPWM TZ disable Software Force a Cycle-by-Cycle Trip Event
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_cbc_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_cbc_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLRCBC;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 17);
N}
N
N/**
N  * @brief  Low layer EPWM TZ disable Software Force a One-Shot Trip Event
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_ost_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_ost_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLROST;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 18);
N}
N
N/**
N  * @brief  Low layer EPWM TZ disable Software Force Flag for Digital Compare Output A Event 1
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_dca_evt1_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_dca_evt1_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG = LL_EPWM_TZ_CLRDCAEVT1;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG = (1UL << 19);
N}
N
N/**
N  * @brief  Low layer EPWM TZ disable Software Force Flag for Digital Compare Output A Event 2
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_dca_evt2_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_dca_evt2_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLRDCAEVT2;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 20);
N}
N
N/**
N  * @brief  Low layer EPWM TZ disable Software Force Flag for Digital Compare Output B Event 1
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_dcb_evt1_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_dcb_evt1_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLRDCBEVT1;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 21);
N}
N
N/**
N  * @brief  Low layer EPWM TZ disable Software Force Flag for Digital Compare Output B Event 2
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_force_dcb_evt2_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_force_dcb_evt2_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CLRDCBEVT2;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 22);
N}
N
N/**
N  * @brief  Low layer EPWM enable ET interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_et_interrupt_enable(u8 chn) {
Xstatic __inline void ll_epwm_et_interrupt_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_ETCTL |= LL_EPWM_INTEN;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_ETCTL |= (1UL << 20);
N}
N
N/**
N  * @brief  Low layer EPWM disable ET interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_et_interrupt_disable(u8 chn) {
Xstatic __inline void ll_epwm_et_interrupt_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_ETCTL &= ~(LL_EPWM_INTEN);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_ETCTL &= ~((1UL << 20));
N}
N
N/**
N  * @brief  Low layer EPWM enable TZ dc b event2 interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_dc_b_event2_interrupt_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_dc_b_event2_interrupt_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_DCBEVT2INTE;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 30);
N}
N
N/**
N  * @brief  Low layer EPWM disable TZ dc b event2 interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_dc_b_event2_interrupt_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_dc_b_event2_interrupt_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG &= ~(LL_EPWM_TZ_DCBEVT2INTE);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG &= ~((1UL << 30));
N}
N
N/**
N  * @brief  Low layer EPWM enable TZ dc b event1 interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_dc_b_event1_interrupt_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_dc_b_event1_interrupt_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_DCBEVT1INTE;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 29);
N}
N
N/**
N  * @brief  Low layer EPWM disable TZ dc b event1 interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_dc_b_event1_interrupt_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_dc_b_event1_interrupt_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG &= ~(LL_EPWM_TZ_DCBEVT1INTE);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG &= ~((1UL << 29));
N}
N
N/**
N  * @brief  Low layer EPWM enable TZ dc a event2 interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_dc_a_event2_interrupt_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_dc_a_event2_interrupt_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_DCAEVT2INTE;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 28);
N}
N
N/**
N  * @brief  Low layer EPWM disable TZ dc a event2 interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_dc_a_event2_interrupt_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_dc_a_event2_interrupt_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG &= ~(LL_EPWM_TZ_DCAEVT2INTE);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG &= ~((1UL << 28));
N}
N
N/**
N  * @brief  Low layer EPWM enable TZ dc a event1 interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_dc_a_event1_interrupt_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_dc_a_event1_interrupt_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_DCAEVT1INTE;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 27);
N}
N
N/**
N  * @brief  Low layer EPWM disable TZ dc a event1 interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_dc_a_event1_interrupt_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_dc_a_event1_interrupt_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG &= ~(LL_EPWM_TZ_DCAEVT1INTE);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG &= ~((1UL << 27));
N}
N
N/**
N  * @brief  Low layer EPWM enable TZ One-Shot interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_one_shot_interrupt_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_one_shot_interrupt_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_OSTINTE;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 26);
N}
N
N/**
N  * @brief  Low layer EPWM disable TZ One-Shot interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_one_shot_interrupt_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_one_shot_interrupt_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG &= ~(LL_EPWM_TZ_OSTINTE);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG &= ~((1UL << 26));
N}
N
N/**
N  * @brief  Low layer EPWM enable TZ Cycle-by-Cycle interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_cycle_by_cycle_interrupt_enable(u8 chn) {
Xstatic __inline void ll_epwm_tz_cycle_by_cycle_interrupt_enable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG |= LL_EPWM_TZ_CBCINTE;
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG |= (1UL << 25);
N}
N
N/**
N  * @brief  Low layer EPWM disable TZ Cycle-by-Cycle interrupt
N  * @param  chn: Channel num of EPWM, Zreo to six
N  * @retval None
N  */
N__STATIC_INLINE void ll_epwm_tz_cycle_by_cycle_interrupt_disable(u8 chn) {
Xstatic __inline void ll_epwm_tz_cycle_by_cycle_interrupt_disable(u8 chn) {
N    EPWM->CH[chn].EPWM_TZFLAG &= ~(LL_EPWM_TZ_CBCINTE);
X    ((EPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x8000))->CH[chn].EPWM_TZFLAG &= ~((1UL << 25));
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_EPWM_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 36 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_saradc.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_saradc.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_saradc.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.1
N  * @date    04-08-2019
N  * @brief   This file contains all the SARADC LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_SARADC_H
N#define __TX_PHE_LL_SARADC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup saradc_interface_gr SARADC Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup SARADC_LL_Driver SARADC LL Driver
N  * @ingroup  saradc_interface_gr
N  * @brief Mainly the driver part of the SARADC module, which includes \b SARADC \b Register 
N  * \b Constants, \b SARADC \b Exported \b Constants, \b SARADC \b Exported \b Struct, \b SARADC
N  * \b Data \b transfers \b functions, \b SARADC \b Initialization \b and \b SARADC \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N     
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N     
N/** @defgroup SARADC_LL_Register_Constants SARADC LL Register Constants
N  * @ingroup  SARADC_LL_Driver
N  * @brief    SARADC LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the SARADC 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the SARADC register, mainly for convenience. Understand the 
N    configuration of the SARADC.
N    
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** SARADC_CON(Register) *****/
N/*! ADC18~ADC0 enable control
N */
N#define LL_SARADC_CH_EN(n)                  (1UL << ((n)))
N
N
N/***** SARADC_CON1(Register) *****/
N/*! ADC13~ADC0 DMA enable control
N */
N#define LL_SARADC_CH_DMA_EN(n)              (1UL << ((n)))
N
N
N/***** SARADC_PENDING0(Register) *****/
N/*! ADC18-0 sample done pending
N */
N#define LL_SARADC_CH_SAMPLE_DONE(n)         (1UL << ((n)))
N
N
N/***** SARADC_PENDING1(Register) *****/
N/*! ADC13-0 DMA half done pending
N */
N#define LL_SARADC_CH_HALF_DONE(n)           (1UL << ((n)))
N
N
N/***** SARADC_PENDING2(Register) *****/
N/*! ADC13-0 DMA full done pending
N */
N#define LL_SARADC_CH_FULL_DONE(n)           (1UL << ((n)))
N
N
N/***** SARADC_PENDING0_CLR(Register) *****/
N/*! ADC18-0 sample done pending clear
N */
N#define LL_SARADC_SAMPLE_DONE_PD_CLR(n)     (1UL << ((n)))
N
N
N/***** SARADC_PENDING1_CLR(Register) *****/
N/*! ADC13-0 DMA half pending clear
N */
N#define LL_SARADC_HALF_DMA_PD_CLR(n)        (1UL << ((n)))
N
N
N/***** SARADC_PENDING2_CLR(Register) *****/
N/*! ADC13-0 DMA full pending clear
N */
N#define LL_SARADC_FULL_DMA_PD_CLR(n)        (1UL << ((n)))
N
N
N/***** SARADC_INT_CONTROL0(Register) *****/
N/*! ADC18~ADC0 sample done interrupt enable
N */
N#define LL_SARADC_SAMPLE_DONE_INT_EN(n)     (1UL << ((n)))
N
N
N/***** SARADC_INT_CONTROL1(Register) *****/
N/*! ADC18~ADC0 DMA half interrupt enable
N */
N#define LL_SARADC_HALF_DONE_INT_EN(n)       (1UL << ((n)))
N
N
N/***** SARADC_INT_CONTROL2(Register) *****/
N/*! ADC18~ADC0 DMA full interrupt enable
N */
N#define LL_SARADC_FULL_DONE_INT_EN(n)       (1UL << ((n)))
N
N
N/***** SARADC_CDIV_DMALEN[0 ~ 18](Register) ADC_CH_DMA_LEN is valid in ch[0-13] *****/
N/*! Sample rate control.  
N *  If the system clock is K MHz:    sample rate =K MHz / CONVERT_DIV
N */
N#define LL_SARADC_CH_DIV(n)                 (((n)&0x3FFFF) << 14)
N/*! Convert counter enable
N */
N#define LL_SARADC_CH_DIV_EN                 (1UL << 13)
N#define LL_SARADC_CH_DIV_DIS                (0UL << 13)
N/*! DMA length configure. The unit is byte
N */
N#define LL_SARADC_CH_DMA_LEN(n)             (((n)&0x1FFF) << 0)
N
N
N/***** SARADC_COM_ACFG(Register) *****/
N/*! Analog clock divider control  
N *  ADC clock frequency = System clock frequency/CLOCK_DIV
N */
N#define LL_SARADC_CLK_DIV(n)                (((n)&0xFF) << 0)
N/*! Analog debug output select.  
N *  0000 : sar0_dbug_vdd  
N *  0001 : sar1_dbug_vdd  
N *  ...  
N *  1101 : sar13_dbug_vdd  
N */
N#define LL_SARADC_DBG_SEL(n)                (((n)&0xF) << 8)
N/*! Analog Vref enable.
N */
N#define LL_SARADC_SARVREF_EN(n)             (((n)&0x3) << 12)
N/*! Analog test data.
N */
N#define LL_SARADC_K(n)                      (((n)&0xFFF) << 16)
N
N
N/***** SARADC_ACFG0~13(Register) *****/
N/*! Analog ADC enable
N */
N#define LL_SARADC_ANALOG_EN                 (1UL << 0)
N/*! K select. SARADC's sub_dac code selection bit  
N *  0: use SAR Logic output data  
N *  1: use SARADC_K[11:0]  
N */
N#define LL_SARADC_KSEL                      (1UL << 1)
N/*! PGA enable
N */
N#define LL_SARADC_PGA_EN                    (1UL << 2)
N/*! Analog PGA switch.  
N    PGA offset trim signal;1'b1=disconnect PAD<-x->PGA, connect PAD<--->VREF_BUF
N*/
N#define LL_SARADC_ANALOG_PGA_SW             (1UL << 3)
N/*! Analog timing setting. sample time selection bit  
N *  0: 2 clock cycle  
N *  1: 4 clock cycle  
N */
N#define LL_SARADC_STIMESET                  (1UL << 4)
N/*! Analog test select.  
N *  SARADC's analog debug signal selection:  
N *  ATSEL [3:2] be reserved  
N *  ATSEL [1:0]  
N *  00: No signal be pushed to Analog test PIN  
N *  01: DAC_OUT be pushed  to Analog test PIN  
N *  10: VREF_BUF be pushed to Analog test PIN  
N *  11:  AVDD_SAR be pushed to Analog test PIN  
N */
N#define LL_SARADC_ATSEL(n)                  (((n)&0xF) << 5)
N/*! PGA GAIN select.  
N *  3'b000=0.5x;  
N *  3'b001=1x;  
N *  3'b010=1.5x;  
N *  3'b011=2x;  
N *  3'b100=3x;  
N *  3'b101=4x;  
N *  3'b110=6x;  
N *  3'b111=8x;  
N */
N#define LL_SARADC_GAIN(n)                   (((n)&0x7) << 9)
N/*! adc average enable
N */
N#define LL_SARADC_AVERAGE_EN                (1UL << 13)
N/*! ADC sample data average option  
N *  00 : 2 sequential sample data averaging  
N *  01 : 4 sequential sample data averaging  
N *  10 : 8 sequential sample data averaging  
N *  11 : reserved  
N */
N#define LL_SARADC_AVERAGE(n)                (((n)&0x3) << 14)
N/*! adc sample_data minus this & shift left 4 bit save to ADC_DATA
N */
N#define LL_SARADC_DC_OFFSET(n)              (((n)&0xFFF) << 16)
N/*! ADC sample data down sample rate: div by (n+1)  
N *  000 : no down sample  
N *  001 : down sample 2  
N *  010 : down sample 3  
N *  011 : down sample 4  
N *  100 : down sample 5  
N *  101 : down sample 6  
N *  110 : down sample 7  
N *  111 : down sample 8  
N */
N#define LL_SARADC_DOWNSAMPLE(n)             (((n)&0x7) << 28)
N
N
N/***** SARADC_ACFG14~18(Register) *****/
N/*! Analog ADC enable
N */
N#define LL_SARADC_ANALOG_EN                 (1UL << 0)
N/*! Analog DAC enable
N */
N#define LL_SARADC_DAC_EN                    (1UL << 1)
N/*! Analog CMP enable
N */
N#define LL_SARADC_CMP_EN                    (1UL << 2)
N/*! Analog set
N */
N#define LL_SARADC_ANALOG_SET(n)             (((n)&0x7) << 3)
N/*! adc or cmp mode input channel select
N */
N#define LL_SARADC_AUX_EN(n)                 (((n)&0xF) << 6)
N/*! adc average enable
N */
N#define LL_SARADC_AVERAGE_EN                (1UL << 13)
N/*! adc average select
N */
N#define LL_SARADC_AVERAGE(n)                (((n)&0x3) << 14)
N/*! adc dc offset set
N */
N#define LL_SARADC_DC_OFFSET(n)              (((n)&0xFFF) << 16)
N/*! adc sample times div by (n+1)
N */
N#define LL_SARADC_DOWNSAMPLE(n)             (((n)&0x7) << 28)
N
N
N/***** SARADC_QUANTIFY_CON0~13(Register) *****/
N/*! adc quantify enable
N */
N#define LL_SARADC_QUANTIFY_EN               (1UL << 0)
N/*! Quantify output data remain how many decimal width  
N *  000 : 0 bit decimal width  
N *  ...  
N *  111 : 7 bit decimal width  
N */
N#define LL_SARADC_QUANTIFY_DECIMAL_WIDTH(n) (((n)&0x7) << 1)
N/*! Quantify coef,unsigned, 16bit data width, 15bit is decimal width
N */
N#define LL_SARADC_QUANTIFY_COEF(n)          (((n)&0xFFFFUL) << 16)
N
N
N/***** SARADC_START_POINT0~13(Register) *****/
N/*! Convert counter coUnt to this value convert kick start 
N */
N#define LL_SARADC_START_POINT(n)            (((n)&0x3FFFF) << 0)
N
N
N/***** DACCMP_CON14~18(Register) *****/
N/*! WO write 1 : clear DAC_DONE
N */
N#define LL_SARADC_DAC_DONE_CLR                  (1UL << 28)
N/*! RO DAC data output done
N */
N#define LL_SARADC_DAC_DONE                      (1UL << 15)
N/*! RW Comparator interrupt enable
N */
N#define LL_SARADC_CMP_INT_EN                    (1UL << 14)
N/*! RW DAC interrupt enable
N */
N#define LL_SARADC_DAC_INT_EN                    (1UL << 13)
N/*! RW CMP_TO_IO source invert enable
N */
N#define LL_SARADC_CMPTOIO_INV_EN                (1UL << 12)
N/*! RW CMP_TO_IO select : 0-Analog 1-Debounce
N */
N#define LL_SARADC_CMPTOIO_SEL(n)                (((n)&0x1) << 11)
N/*! RW Comparator output to CPU
N */
N#define LL_SARADC_CMP_RESULT                    (1UL << 10)
N/*! RW CMP_TO_CPU source invert enable
N */
N#define LL_SARADC_CMPTOCPU_INV_EN               (1UL << 9)
N/*! RW CMP_TO_CPU select : 0-Analog 1-Debounce
N */
N#define LL_SARADC_CMPTOCPU_SEL(n)               (((n)&0x1) << 8)
N/*! RW CMP_TO_DATA select 0-DATA0 1-DATA1
N */
N#define LL_SARADC_CMP_DATA_SEL(n)               (((n)&0x1) << 7)
N
N
N/***** DACCMP_DATA14~18(Register) *****/
N/*! RW DATA output to DAC and CMP ananlog, when CMP_TO_DATA value is 0, output DACCMP_DATA0
N */
N#define LL_SARADC_CMP_DATA0(n)                  (((n)&0xFFF) << 0)
N/*! RW DATA output to DAC and CMP ananlog, when CMP_TO_DATA value is 1, output DACCMP_DATA1
N */
N#define LL_SARADC_CMP_DATA1(n)                  (((n)&0xFFF) << 16)
N
N
N/***** DACCMP_DEBOUNCE14~18(Register) *****/
N/*! Comparator output debounce select
N */
N#define LL_SARADC_CMP_DEBOUNCE(n)               (((n)&0xFFFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup SARADC_LL_Exported_Constants SARADC LL Exported Constants
N  * @ingroup  SARADC_LL_Driver
N  * @brief    SARADC LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N/*! saradc max channel counter
N */
N#define LL_SARADC_CHN_MAX                         19
N/*! saradc max adc channel counter
N * @note  saradc adc channel voltage range is [0, 3.0v]
N *        saradc adc data format[1, 16, 15]  
N */
N#define LL_SARADC_ADC_CHN_MAX                     14
N/*! saradc max dac channel counter
N * @note  saradc adc/dac/cmp channel voltage range is [0, 3.3v]
N *        saradc adc data format[1, 16, 15]  
N *        saradc dac data format[0, 12, 12]  
N *        saradc cmp data format[0, 12, 12]  
N */
N#define LL_SARADC_DAC_CHN_MAX                     (LL_SARADC_CHN_MAX-LL_SARADC_ADC_CHN_MAX)
N
N
N/***** LL API *****/
N
N/**
N  * @brief SARADC low layer sample data average times typedef
N  */
Ntypedef enum {
N    /*! saradc average point select: 1
N     */
N    LL_SARADC_AVERAGE_1 = 3,
N    /*! saradc average point select: 2
N     */
N    LL_SARADC_AVERAGE_2 = 0,
N    /*! saradc average point select: 4
N     */
N    LL_SARADC_AVERAGE_4 = 1,
N    /*! saradc average point select: 8
N     */
N    LL_SARADC_AVERAGE_8 = 2,
N} TYPE_ENUM_LL_SARADC_AVERAGE_SEL;
N
N/**
N  * @brief SARADC low layer downsample times typedef
N  */
Ntypedef enum {
N    /*! saradc down sample select: 1
N     */
N    LL_SARADC_DOWNSAMPLE_1 = 0,
N    /*! saradc down sample select: 2
N     */
N    LL_SARADC_DOWNSAMPLE_2,
N    /*! saradc down sample select: 3
N     */
N    LL_SARADC_DOWNSAMPLE_3,
N    /*! saradc down sample select: 4
N     */
N    LL_SARADC_DOWNSAMPLE_4,
N    /*! saradc down sample select: 5
N     */
N    LL_SARADC_DOWNSAMPLE_5,
N    /*! saradc down sample select: 6
N     */
N    LL_SARADC_DOWNSAMPLE_6,
N    /*! saradc down sample select: 7
N     */
N    LL_SARADC_DOWNSAMPLE_7,
N    /*! saradc down sample select: 8
N     */
N    LL_SARADC_DOWNSAMPLE_8,
N} TYPE_ENUM_LL_SARADC_DOWNSAMPLE_SEL;
N
N/**
N  * @brief SARADC low layer sample gain typedef
N  */
Ntypedef enum {
N    /*! saradc gain select: 0.5
N     */
N    LL_SARADC_GAIN_0_5 = 0,
N    /*! saradc gain select: 1.0
N     */
N    LL_SARADC_GAIN_1_0,
N    /*! saradc gain select: 1.5
N     */
N    LL_SARADC_GAIN_1_5,
N    /*! saradc gain select: 2.0
N     */
N    LL_SARADC_GAIN_2_0,
N    /*! saradc gain select: 3.0
N     */
N    LL_SARADC_GAIN_3_0,
N    /*! saradc gain select: 4.0
N     */
N    LL_SARADC_GAIN_4_0,
N    /*! saradc gain select: 6.0
N     */
N    LL_SARADC_GAIN_6_0,
N    /*! saradc gain select: 8.0
N     */
N    LL_SARADC_GAIN_8_0,
N} TYPE_ENUM_LL_SARADC_GAIN_SEL;
N    
N/**
N  * @brief SARADC low layer ad/compare source typedef
N  */
Ntypedef enum {
N    /*! saradc compare select: AIN0 : PA0(ADC14)  PA4(ADC15)  PA8(ADC16)  PA12(ADC17)  PD1(ADC18)
N     */
N    LL_SARADDA_AIN0 = 1,
N    /*! saradc compare select: AIN1 : PA1(ADC14)  PA5(ADC15)  PA9(ADC16)  PA13(ADC17)  PD2(ADC18)
N     */
N    LL_SARADDA_AIN1 = 2,
N    /*! saradc compare select: AIN2 : PA2(ADC14)  PA6(ADC15)  PA10(ADC16) PA14(ADC17)  PD3(ADC18)
N     */
N    LL_SARADDA_AIN2 = 4,
N    /*! saradc compare select: AIN3 :                                     PA15(ADC17)  PD4(ADC18)
N     */
N    LL_SARADDA_AIN3 = 8,
N} TYPE_ENUM_LL_SARADDA_AUX_SEL;
N
N/**
N  * @brief SARADC low layer compare output typedef
N  */
Ntypedef enum {
N    /*! saradc compare out select: analog
N     */
N    LL_SARADC_CMP_OUT_ANALOG =  0x00,
N    /*! saradc compare out select: debunce
N     */
N    LL_SARADC_CMP_OUT_DEBUNCE = 0x01,
N} TYPE_ENUM_LL_SARADDA_CMP_OUT_TYPE_SEL;
N
N/**
N  * @brief SARADC low layer compare destination typedef
N  */
Ntypedef enum {
N    /*! saradc compare out des: io+cpu
N     */
N    LL_SARADC_CMP_TO_IO_AND_CPU = 0,
N    /*! saradc compare out des: cpu
N     */
N    LL_SARADC_CMP_TO_CPU        = 1,
N} TYPE_ENUM_LL_SARADDA_CMP_DST_SEL;
N
N/**
N  * @brief SARADC low layer compare DATA typedef
N  */
Ntypedef enum {
N    /*! saradc compare source sel: data0
N     */
N    LL_SARADC_CMP_SRC_DAT0 = 0,
N    /*! saradc compare source sel: data1
N     */
N    LL_SARADC_CMP_SRC_DAT1 = 1,
N} TYPE_ENUM_LL_SARADDA_CMP_SRC_SEL;
N
N/***** LL API AND DRIVER API *****/
N
N
N/**
N  * @}
N  */
N
N/** @defgroup SARADC_LL_Exported_Struct SARADC LL Exported Struct
N  * @ingroup  SARADC_LL_Driver
N  * @brief    SARADC LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the SARADC registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_saradc_init. Function, you can configure the SARADC module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief SARADC low layer adc irq_config struct
N  */
Ntypedef struct __ll_saradc_irq_cfg {
N    /*! adc channel index : 0 ~ SARADC_CHN_CNT_MAX
N     */
N    u8   chn;
N    /*! adc sample done interrupt enable
N     */
N    bool sample_intr_en;
N    /*! adc dma_half interrupt enable
N     */
N    bool dma_half_intr_en;
N    /*! adc dma_full interrupt enable
N     */
N    bool dma_full_intr_en;
N    /*! dac mode interrupt enable
N     */
N    bool dac_intr_en;
N    /*! cmp mode interrupt enable
N     *  cmp interrupt usable only when adc & dac interrupt is disabled
N     */
N    bool cmp_intr_en;
N} TYPE_LL_SARADC_IRQ_CFG ;
N
N/**
N  * @brief SARADC low layer adc config struct
N  */
Ntypedef struct __ll_saradc_cfg {
N    /*! adc channel index : 0 ~ LL_SARADC_CHN_MAX
N     */
N    u8                                  chn;
N    /*! average points: 0/2/4/8
N     */
N    TYPE_ENUM_LL_SARADC_AVERAGE_SEL     average; 
N    /*! down_sample select: 1/2/3/4/5/6/7/8
N     */
N    TYPE_ENUM_LL_SARADC_DOWNSAMPLE_SEL  downsample;
N    /*! sample_rate_div = SYS_CLK/sample_rate
N     */
N    u32                                 sample_rate_div;
N    /*! adc chn gain setting  :TYPE_ENUM_SARADC_GAIN_SEL, use for 0 ~ LL_SARADC_ADC_CHN_MAX
N     *  @note : use for channel 0 ~ LL_SARADC_ADC_CHN_MAX
N     */
N    TYPE_ENUM_LL_SARADC_GAIN_SEL        gain;
N    /*! Convert kick start by external module (spwm,svpwm,epwm .ect) enable
N     */    
N    u8                                  adc_kick_by_extern_en;
N    /*! adc chn dc offset, sample data = adc_inter_val- dc_offset
N     */
N    u16                                 dc_offset;
N    /*! Convert counter coUnt to this value convert kick start
N     */
N    u32                                 start_point;
N    /*! Quantify coef,unsigned, 16bit data width, 15bit is decimal width
N     */
N    u16                                 quantify_coef;
N    /*! Quantify output data remain how many decimal width  
N     *  000 : 0 bit decimal width  
N     *  ...  
N     *  111 : 7 bit decimal width  
N     */    
N    u16                                 quantify_out_decimal_width;
N    /*! adc quantify enable
N     *  @note usage :  
N     *        use for channel 0 ~ LL_SARADC_ADC_CHN_MAX
N     */
N    u8                                  quantify_en;
N    /*! adc dma start address: SRAM0/SRAM10/SRAM1/SRAM2/SRAM3  aligned(2)
N     *  @note usage :  
N     *        s16 saradc_buf[256] __attribute__((aligned(2), section("SRAM1")));
N     *        use for channel LL_SARADC_ADC_CHN_MAX ~ LL_SARADC_CHN_MAX
N     */
N    u32                                 dma_addr;
N    /*! adc dma length, unit byte, 12bit
N     *  @note : use for channel LL_SARADC_ADC_CHN_MAX ~ LL_SARADC_CHN_MAX
N     *          a zero dma_len means dma is disabled
N     */
N    u16                                 dma_len;
N    /*! adc input channel select, use for channel LL_SARADC_ADC_CHN_MAX ~ LL_SARADC_CHN_MAX
N     *  @note : use for channel LL_SARADC_ADC_CHN_MAX ~ LL_SARADC_CHN_MAX
N     */
N    TYPE_ENUM_LL_SARADDA_AUX_SEL        aux_sel;
N    
N} TYPE_LL_SARADC_CFG ;
N
N/**
N  * @brief SARADC low layer adc_dac config struct
N  */
Ntypedef struct __ll_saradc_dac_cfg {
N    /*! adc channel index : LL_SARADC_ADC_CHN_MAX ~ LL_SARADC_CHN_MAX
N     *  channel[14,18] IO : PA3/PA7/PA11/PD0/PD5
N     */
N    u8                                  chn;
N    /*! dac_updata_data_rate_div = SYS_CLK/updata_data_rate
N     */
N    u32                                 updata_data_rate_div;
N    /*! dac kick start by external module (spwm,svpwm,epwm .ect) enable
N     */    
N    bool                                dac_kick_by_extern_en;        
N    /*! Convert counter count to this value convert kick start
N     */
N    u32                                 start_point;
N} TYPE_LL_SARADC_DAC_CFG ;
N
N/**
N  * @brief SARADC low layer cmp config struct
N  */
Ntypedef struct __ll_saradc_cmp_cfg {
N    /*! adc channel index : LL_SARADC_ADC_CHN_MAX ~ LL_SARADC_CHN_MAX
N     */
N    u8                                    chn;
N    /*! cmp mode input channel select
N     */
N    TYPE_ENUM_LL_SARADDA_AUX_SEL          aux_sel;
N    /*! Comparator output debounce select  
N     *  0: debounce disable;  
N     *  1: CMP level change must assert unless 2 clock;  
N     *  ...  
N     *  65535: CMP level change must assert unless 65536 clock  
N     */
N    u16                                   cmp_out_debunce_cnt;
N    /*! cmp mode des select: cpu or cpu&io
N     */
N    TYPE_ENUM_LL_SARADDA_CMP_DST_SEL      cmp_des_sel;
N    /*! cmp mode des_io config: anolog or debunce, both can be invert
N     */
N    TYPE_ENUM_LL_SARADDA_CMP_OUT_TYPE_SEL cmp_des_type_sel_io;
N    /*! cmp mode des_cpu config: anolog or debunce, both can be invert
N     */
N    TYPE_ENUM_LL_SARADDA_CMP_OUT_TYPE_SEL cmp_des_type_sel_cpu;
N    /*! cmp output be invert
N     */
N    bool                                  cmp_io_out_invert_en;
N    /*! cmp output be invert
N     */
N    bool                                  cmp_cpu_out_invert_en;
N} TYPE_LL_SARADC_CMP_CFG ;
N
N/**
N  * @brief SARADC low layer init struct
N  */
Ntypedef struct __ll_saradda_init {
N    /*! adc clk : fpga_max 250000, IC_max:2500000 && must bigger than (18 * Max(sample_rate))
N     *  clk_div = SYS_CLK / adc_clk, adc_clk is recommand to 2000000
N     */
N    u32     clk_div;
N} TYPE_LL_SARADDA_INIT ;
N
N/**
N  * @}
N  */
N
N/** @defgroup SARADC_LL_Interrupt SARADC LL Interrupt Handle function
N  * @brief   SARADC LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SARADC  
N    Interrupt Handle function.
N
N    how to use?
N
N    The SARADC interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the SARADC in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N  
N/** 
N  * @brief  SARADC interrupt handle function.
N  * @param  None.
N  * @retval None.
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup SARADC_LL_Inti_Cfg SARADC LL Initialization And Configuration
N  * @brief    SARADC LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SARADC data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/** 
N  * @brief  SARADC init function. reset & enable saradc
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  p_init  : pointer to TYPE_LL_SARADDA_INIT SARADC init struct
N  * @retval None.
N  */
Nvoid ll_saradc_init(ADC_TypeDef *p_saradc, TYPE_LL_SARADDA_INIT *p_init);
N
N/** 
N  * @brief  SARADC deinit function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @retval none
N  */
Nvoid ll_saradc_deinit(ADC_TypeDef *p_saradc);
N
N/** 
N  * @brief  SARADC irq config function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  p_cfg   : \ref TYPE_LL_SARADC_IRQ_CFG config interrupt enable
N  * @retval state   : 1(success), 0(failed).
N  */
Nu32 ll_saradc_irq_config(ADC_TypeDef *p_saradc, TYPE_LL_SARADC_IRQ_CFG *p_cfg);
N
N/** 
N  * @brief  SARADC config function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  p_cfg   : \ref TYPE_LL_SARADC_CFG config adda sample_rate, int, average, downsample, dc_offset, gain, 
N                      quantify, dma, compare, dac, ect.
N  * @retval state   : 1(success), 0(failed).
N  */
Nu32 ll_saradc_config(ADC_TypeDef *p_saradc, TYPE_LL_SARADC_CFG *p_cfg);
N
N/** 
N  * @brief  SARADC dac config function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  p_cfg   : \ref TYPE_LL_SARADC_CFG config
N  * @retval state   : 1(success), 0(failed).
N  */
Nu32 ll_saradc_dac_config(ADC_TypeDef *p_saradc, TYPE_LL_SARADC_DAC_CFG *p_cfg);
N
N/** 
N  * @brief  SARADC dac config function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  p_cfg   : \ref TYPE_LL_SARADC_CMP_CFG config
N  * @retval state   : 1(success), 0(failed).
N  */
Nu32 ll_saradc_cmp_config(ADC_TypeDef *p_saradc, TYPE_LL_SARADC_CMP_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup SARADC_LL_Data_Transfers SARADC LL Data transfers functions
N  * @brief    SARADC LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SARADC data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/** 
N  * @brief  SARADC start function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn to start, use bit field.
N  * @retval None.
N  */
Nvoid ll_saradc_start(ADC_TypeDef *p_saradc, u32 chn_bits);
N
N/** 
N  * @brief  SARADC stop function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn to stop, use bit field.
N  * @retval None.
N  */
Nvoid ll_saradc_stop(ADC_TypeDef *p_saradc, u32 chn_bits);
N
N/** 
N  * @brief  SARADC dac start function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn: specify adc chn to start
N  * @retval None.
N  */
Nvoid ll_saradc_dac_start(ADC_TypeDef *p_saradc, u32 chn);
N
N/** 
N  * @brief  SARADC dac stop function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn: specify adc chn to start
N  * @retval None.
N  */
Nvoid ll_saradc_dac_stop(ADC_TypeDef *p_saradc, u32 chn);
N
N/** 
N  * @brief  SARADC cmp start function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn: specify adc chn to start
N  * @retval None.
N  */
Nvoid ll_saradc_cmp_start(ADC_TypeDef *p_saradc, u32 chn);
N
N/** 
N  * @brief  SARADC dac stop function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn: specify adc chn to start
N  * @retval None.
N  */
Nvoid ll_saradc_cmp_stop(ADC_TypeDef *p_saradc, u32 chn);
N
N/** 
N  * @brief  SARADC saradc_dc_offset_set function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to set
N  * @param  offset  : specify adc chn dc_offset[0:11] to set
N  * @retval None.
N  */
Nvoid ll_saradc_set_dc_offset(ADC_TypeDef *p_saradc, u32 chn, u16 offset);
N
N/** 
N  * @brief  SARADC saradc_quantify_set function.
N  * @param  p_saradc         : pointer to ADC_TypeDef SARADC controller 
N  * @param  chn              : specify adc chn to set
N  * @param  coef             : specify adc chn coef to set, rang [0:32767] means [0:1)
N  * @param  out_decimal_width: specify Quantify output data remain how many decimal width rang:[0,6]
N  * @retval None.
N  */
Nvoid ll_saradc_set_quantify(ADC_TypeDef *p_saradc, u8 chn, u16 coef, u8 out_decimal_width);
N
N/** 
N  * @brief  SARADC saradc_average_times_set function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to set
N  * @param  average : specify average times \ref TYPE_ENUM_LL_SARADC_AVERAGE_SEL
N  * @retval None.
N  */
Nvoid ll_saradc_set_average(ADC_TypeDef *p_saradc, u8 chn, TYPE_ENUM_LL_SARADC_AVERAGE_SEL average);
N
N/** 
N  * @brief  SARADC saradc_down_sample_times_set function.
N  * @param  p_saradc  : pointer to ADC_TypeDef SARADC controller 
N  * @param  chn       : specify adc chn to set
N  * @param  downsample: \ref TYPE_ENUM_LL_SARADC_DOWNSAMPLE_SEL specify down_sample times
N  * @retval None.
N  */
Nvoid ll_saradc_set_downsample(ADC_TypeDef *p_saradc, u8 chn, TYPE_ENUM_LL_SARADC_DOWNSAMPLE_SEL downsample);
N
N
N/** 
N  * @brief  SARADC saradc_sample_rate_get function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to get
N  * @retval divor read from reg, sample_rate = sys_clk/divor
N  */
Nu16 ll_saradc_get_sample_rate(ADC_TypeDef *p_saradc, u8 chn);
N
N/** 
N  * @brief  SARADC saradc_sample_rate_set function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to set
N  * @param  divor   : = sys_clk/sample_rate
N  * @retval divor read from reg.
N  */
Nu16 ll_saradc_set_sample_rate(ADC_TypeDef *p_saradc, u8 chn, u16 divor);
N
N/** 
N  * @brief  SARADC ll_saradc_sample_done_interrupt_enable function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn to set(bit field)
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_sample_interrupt_enable(ADC_TypeDef *p_saradc, u32 chn_bits) {
Xstatic __inline void ll_saradc_sample_interrupt_enable(ADC_TypeDef *p_saradc, u32 chn_bits) {
N    p_saradc->SARADC_INT_CONTROL0 |= chn_bits;
N}
N
N/** 
N  * @brief  SARADC ll_saradc_sample_done_interrupt_disable function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn to set(bit field)
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_sample_interrupt_disable(ADC_TypeDef *p_saradc, u32 chn_bits) {
Xstatic __inline void ll_saradc_sample_interrupt_disable(ADC_TypeDef *p_saradc, u32 chn_bits) {
N    p_saradc->SARADC_INT_CONTROL0 &= ~chn_bits;
N}
N
N/** 
N  * @brief  LL_SARADC_CHECK_SAMPLE_INTERRUPT_ENABLE
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn (bit field)
N  * @retval interrupt_enable  
N  */
N#define LL_SARADC_CHECK_SAMPLE_INTERRUPT_ENABLE(p_saradc, chn_bits) ((p_saradc)->SARADC_INT_CONTROL0 & chn_bits)
N
N/** 
N  * @brief  SARADC LL_SARADC_GET_SAMPLE_PENDING function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn (bit field)
N  * @retval adc sample data.
N  */
N#define LL_SARADC_GET_SAMPLE_PENDING(p_saradc, chn_bits)            ((p_saradc)->SARADC_PENDING0 & chn_bits)
N
N/** 
N  * @brief  SARADC ll_saradc_clear_sample_pending function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn (bit field)
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_clear_sample_pending(ADC_TypeDef *p_saradc, u32 chn_bits) {
Xstatic __inline void ll_saradc_clear_sample_pending(ADC_TypeDef *p_saradc, u32 chn_bits) {
N    p_saradc->SARADC_PENDING0_CLR |= chn_bits;
N}
N
N/** 
N  * @brief  SARADC ll_saradc_dma_half_interrupt_enable function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn to set(bit field)
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_dma_half_interrupt_enable(ADC_TypeDef *p_saradc, u32 chn_bits) {
Xstatic __inline void ll_saradc_dma_half_interrupt_enable(ADC_TypeDef *p_saradc, u32 chn_bits) {
N    p_saradc->SARADC_INT_CONTROL1 |= chn_bits;
N}
N
N/** 
N  * @brief  SARADC ll_saradc_dma_half_interrupt_disable function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn to set(bit field)
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_dma_half_interrupt_disable(ADC_TypeDef *p_saradc, u32 chn_bits) {
Xstatic __inline void ll_saradc_dma_half_interrupt_disable(ADC_TypeDef *p_saradc, u32 chn_bits) {
N    p_saradc->SARADC_INT_CONTROL1 &= ~chn_bits;
N}
N
N/** 
N  * @brief  LL_SARADC_CHECK_DMA_HALF_INTERRUPT_ENABLE
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn (bit field)
N  * @retval interrupt_enable  
N  */
N#define LL_SARADC_CHECK_DMA_HALF_INTERRUPT_ENABLE(p_saradc, chn_bits)   ((p_saradc)->SARADC_INT_CONTROL1 & chn_bits)
N
N/** 
N  * @brief  SARADC LL_SARADC_GET_DMA_HALF_PENDING function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn (bit field)
N  * @retval adc sample data.
N  */
N#define LL_SARADC_GET_DMA_HALF_PENDING(p_saradc, chn_bits)              ((p_saradc)->SARADC_PENDING1 & chn_bits)
N
N/** 
N  * @brief  SARADC ll_saradc_clear_dma_half_pending function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn (bit field)
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_clear_dma_half_pending(ADC_TypeDef *p_saradc, u32 chn_bits) {
Xstatic __inline void ll_saradc_clear_dma_half_pending(ADC_TypeDef *p_saradc, u32 chn_bits) {
N    p_saradc->SARADC_PENDING1_CLR |= chn_bits;
N}
N
N/** 
N  * @brief  SARADC ll_saradc_dma_full_interrupt_enable function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn to set(bit field)
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_dma_full_interrupt_enable(ADC_TypeDef *p_saradc, u32 chn_bits) {
Xstatic __inline void ll_saradc_dma_full_interrupt_enable(ADC_TypeDef *p_saradc, u32 chn_bits) {
N    p_saradc->SARADC_INT_CONTROL2 |= chn_bits;
N}
N
N/** 
N  * @brief  SARADC ll_saradc_dma_full_interrupt_disable function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn to set(bit field)
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_dma_full_interrupt_disable(ADC_TypeDef *p_saradc, u32 chn_bits) {
Xstatic __inline void ll_saradc_dma_full_interrupt_disable(ADC_TypeDef *p_saradc, u32 chn_bits) {
N    p_saradc->SARADC_INT_CONTROL2 &= ~chn_bits;
N}
N
N/** 
N  * @brief  LL_SARADC_CHECK_DMA_FULL_INTERRUPT_ENABLE
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn (bit field)
N  * @retval interrupt_enable  
N  */
N#define LL_SARADC_CHECK_DMA_FULL_INTERRUPT_ENABLE(p_saradc, chn_bits)   ((p_saradc)->SARADC_INT_CONTROL2 & chn_bits)
N
N/** 
N  * @brief  SARADC LL_SARADC_GET_DMA_FULL_PENDING function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn_bits (bit field)
N  * @retval adc sample data.
N  */
N#define LL_SARADC_GET_DMA_FULL_PENDING(p_saradc, chn_bits)              ((p_saradc)->SARADC_PENDING2 & chn_bits)
N
N/** 
N  * @brief  SARADC ll_saradc_clear_dma_full_pending function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn_bits: specify adc chn to set(bit field)
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_clear_dma_full_pending(ADC_TypeDef *p_saradc, u32 chn_bits) {
Xstatic __inline void ll_saradc_clear_dma_full_pending(ADC_TypeDef *p_saradc, u32 chn_bits) {
N    p_saradc->SARADC_PENDING2_CLR |= chn_bits;
N}
N
N/** 
N  * @brief  SARADC ll_saradc_set_cmp_data function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to set
N  * @param  data0    : 12bit unsigned [0,3.3v] 
N  * @param  data1    : 12bit unsigned [0,3.3v]
N  * @retval none
N  * @note   the compare use Hysteresis window control [dat_lit, dat_big] 
N  *                                                      
N  *             dat_lit<------^--------1
N  *                   |       |
N  *         0---------V------>dat_big
N  */
Nvoid ll_saradc_set_cmp_data(ADC_TypeDef *p_saradc, u8 chn, u16 data0, u16 data1);
N
N/** 
N  * @brief  SARADC ll_saradc_set_dac_data function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to set
N  * @param  data    : 12bit unsigned [0,3.3v] 
N  */
Nvoid ll_saradc_set_dac_data(ADC_TypeDef *p_saradc, u8 chn, s16 data);
N
N/** 
N  * @brief  SARADC ll_saradc_dac_interrupt_enable function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify dac chn to set , must > LL_SARADC_ADC_CHN_MAX
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_dac_interrupt_enable(ADC_TypeDef *p_saradc, u32 chn) {
Xstatic __inline void ll_saradc_dac_interrupt_enable(ADC_TypeDef *p_saradc, u32 chn) {
N    p_saradc->DACCMP_CON[chn-LL_SARADC_ADC_CHN_MAX] |=  LL_SARADC_DAC_INT_EN;
X    p_saradc->DACCMP_CON[chn-14] |=  (1UL << 13);
N}
N
N/** 
N  * @brief  SARADC ll_saradc_dac_interrupt_disable function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify dac chn to set,, must > LL_SARADC_ADC_CHN_MAX
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_dac_interrupt_disable(ADC_TypeDef *p_saradc, u32 chn) {
Xstatic __inline void ll_saradc_dac_interrupt_disable(ADC_TypeDef *p_saradc, u32 chn) {
N    p_saradc->DACCMP_CON[chn-LL_SARADC_ADC_CHN_MAX] &= ~LL_SARADC_DAC_INT_EN;
X    p_saradc->DACCMP_CON[chn-14] &= ~(1UL << 13);
N}
N
N/** 
N  * @brief  LL_SARADC_CHECK_DMA_FULL_INTERRUPT_ENABLE
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to set
N  * @retval interrupt_enable  
N  */
N#define LL_SARADC_CHECK_DAC_INTERRUPT_ENABLE(p_saradc, chn)     ((p_saradc)->DACCMP_CON[chn-LL_SARADC_ADC_CHN_MAX] & LL_SARADC_DAC_INT_EN)
N
N/** 
N  * @brief  SARADC LL_SARADC_GET_COMPARE_PENDING function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn 
N  * @retval adc sample data.
N  */
N#define LL_SARADC_GET_DAC_PENDING(p_saradc, chn)                ((p_saradc)->DACCMP_CON[chn-LL_SARADC_ADC_CHN_MAX] & LL_SARADC_DAC_DONE)
N
N/** 
N  * @brief  SARADC ll_saradc_clear_sample_pending function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn  
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_clear_dac_pending(ADC_TypeDef *p_saradc, u32 chn) {
Xstatic __inline void ll_saradc_clear_dac_pending(ADC_TypeDef *p_saradc, u32 chn) {
N    p_saradc->DACCMP_CON[chn-LL_SARADC_ADC_CHN_MAX] |= LL_SARADC_DAC_DONE_CLR;
X    p_saradc->DACCMP_CON[chn-14] |= (1UL << 28);
N}
N
N/** 
N  * @brief  SARADC get sample_data function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to get
N  * @retval adc sample data.
N  */
N#define LL_SARADC_GET_SAMPLE_DATA(p_saradc, chn)            ((p_saradc)->SARADC_DATA[chn])
N
N/** 
N  * @brief  SARADC get dma index function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to get
N  * @retval adc sample data.
N  */
N#define LL_SARADC_GET_DMA_INDEX(p_saradc, chn)              ((p_saradc)->SARADC_DMA_INDEX[chn])
N
N/** 
N  * @brief  LL_SARADC_CHECK_CMP_INTERRUPT_ENABLE
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to set
N  * @retval interrupt_enable  
N  */
N#define LL_SARADC_CHECK_CMP_INTERRUPT_ENABLE(p_saradc, chn)     ((p_saradc)->DACCMP_CON[chn-LL_SARADC_ADC_CHN_MAX] & LL_SARADC_CMP_INT_EN)
N
N/** 
N  * @brief  SARADC LL_SARADC_GET_CMP_PENDING function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn 
N  * @retval adc sample data.
N  */
N#define LL_SARADC_GET_CMP_CPU_VALUE(p_saradc, chn)              (((p_saradc)->DACCMP_CON[chn-LL_SARADC_ADC_CHN_MAX] & LL_SARADC_CMP_RESULT) ? 1 : 0)
N
N/** 
N  * @brief  SARADC ll_saradc_dma_full_interrupt_enable function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to set
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_compare_interrupt_enable(ADC_TypeDef *p_saradc, u32 chn) {
Xstatic __inline void ll_saradc_compare_interrupt_enable(ADC_TypeDef *p_saradc, u32 chn) {
N    p_saradc->DACCMP_CON[chn-LL_SARADC_ADC_CHN_MAX] |=  LL_SARADC_CMP_INT_EN;
X    p_saradc->DACCMP_CON[chn-14] |=  (1UL << 14);
N}
N
N/** 
N  * @brief  SARADC ll_saradc_dma_full_interrupt_disable function.
N  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
N  * @param  chn     : specify adc chn to set
N  * @retval none
N  */
N__STATIC_INLINE void ll_saradc_compare_interrupt_disable(ADC_TypeDef *p_saradc, u32 chn) {
Xstatic __inline void ll_saradc_compare_interrupt_disable(ADC_TypeDef *p_saradc, u32 chn) {
N    p_saradc->DACCMP_CON[chn-LL_SARADC_ADC_CHN_MAX] &= ~LL_SARADC_CMP_INT_EN;
X    p_saradc->DACCMP_CON[chn-14] &= ~(1UL << 14);
N}
N
N#if 0
S/** 
S  * @brief  SARADC ll_saradc_clear_cmp_pending function.
S  * @param  p_saradc: pointer to ADC_TypeDef SARADC controller 
S  * @param  chn     : specify adc chn  
S  * @retval none
S  */
S__STATIC_INLINE void ll_saradc_clear_cmp_pending(ADC_TypeDef *p_saradc, u32 chn) {
S    p_saradc->DACCMP_CON[chn-LL_SARADC_ADC_CHN_MAX] |= LL_SARADC_DAC_DONE_CLR;
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_SARADC_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 37 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_timer.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_timer.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_timer.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.1
N  * @date    08-04-2019
N  * @brief   This file contains all the TIMER LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_TIMER_H
N#define __TX_PHE_LL_TIMER_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup timer_interface_gr TIMER Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup TIMER_LL_Driver TIMER LL Driver
N  * @ingroup  timer_interface_gr
N  * @brief Mainly the driver part of the TIMER module, which includes \b TIMER \b Register 
N  * \b Constants, \b TIMER \b Exported \b Constants, \b TIMER \b Exported \b Struct, \b TIMER
N  * \b Data \b transfers \b functions, \b TIMER \b Initialization \b and \b TIMER \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N     
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N     
N/** @defgroup TIMER_LL_Register_Constants TIMER LL Register Constants
N  * @ingroup  TIMER_LL_Driver
N  * @brief    TIMER LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in the TIMER register. In the 
N    process of configuration, the macro definition can be directly called to configure 
N    the TIMER register, mainly for convenience. Understand the configuration of the TIMER.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** TMRx_CON *****/
N/*! RW, TIMERx pending, write 1 clear pending
N */
N#define LL_TMR_CON_TIMER_PNG                (1UL << 15)
N/*! RW, TIMERx capture pending, write 1 clear pending
N */
N#define LL_TMR_CON_CAPTURE_PNG              (1UL << 14)
N/*! RW, TIMERx timer mode interrupt enable
N */
N#define LL_TMR_CON_TMR_INTR_EN              (1UL << 13)
N/*! RW, TIMERx capture mode interrupt enable
N */
N#define LL_TMR_CON_CAP_INTR_EN              (1UL << 12)
N/*! RW, TIMERx timer's prescaler setting
N */
N#define LL_TMR_CON_PSC(n)                   (((n)&0x7) << 8)
N/*! RW, TIMERx capture mode edge select
N */
N#define LL_TMR_CON_CAP_EDGE(n)              (((n)&0x3) << 6)
N/*! RW, TIMERx mode select
N */
N#define LL_TMR_CON_MODE(n)                  (((n)&0x3) << 4)
N#define LL_TMR_CON_MODE_DIS_MASK            (0x03UL << 4)
N/*! RW, TIMERx timer counter source select
N */
N#define LL_TMR_CON_INC_SRC(n)               (((n)&0x7) << 0)
N
N
N/***** TMRx_PR *****/
N/*! RW, TIMERx Prescaler register
N */
N#define LL_TMR_TIMER_PR(n)                  (((n)&0xFFFF) << 0)
N
N
N/***** TMRx_CNT *****/
N/*! RW, TIMERx Count register
N */
N#define LL_TMR_TIMER_CNT(n)                 (((n)&0xFFFF) << 0)
N
N
N/***** TMRx_PWM *****/
N/*! RW, TIMERx Pulse width modulation
N */
N#define LL_TMR_TIMER_PWM(n)                 (((n)&0xFFFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup TIMER_LL_Exported_Constants TIMER LL Exported Constants
N  * @ingroup  TIMER_LL_Driver
N  * @brief    TIMER LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N/***** LL API *****/
N/**
N  * @brief Enumeration constant for low layer TIMER Prescaler for timer
N  */
Ntypedef enum {
N    /*! Timer clock source 0 prescaler
N     */
N    LL_TMR_TIMER_PSC_0 = 0,
N    /*! Timer clock source 2 prescaler
N     */
N    LL_TMR_TIMER_PSC_2,
N    /*! Timer clock source 4 prescaler
N     */
N    LL_TMR_TIMER_PSC_4,
N    /*! Timer clock source 8 prescaler
N     */
N    LL_TMR_TIMER_PSC_8,
N    /*! Timer clock source 16 prescaler
N     */
N    LL_TMR_TIMER_PSC_16,
N    /*! Timer clock source 32 prescaler
N     */
N    LL_TMR_TIMER_PSC_32,
N    /*! Timer clock source 64 prescaler
N     */
N    LL_TMR_TIMER_PSC_64,
N    /*! Timer clock source 128 prescaler
N     */
N    LL_TMR_TIMER_PSC_128,
N}TYPE_ENUM_LL_TMR_PSC;
N
N/**
N  * @brief Enumeration constant for low layer TIMER Trigger mode selection in timer's capture mode
N  */
Ntypedef enum {
N    /*! Timer trigger source selection: RISING
N     */
N    LL_TMR_EDGE_SEL_RISING = 0,
N    /*! Timer trigger source selection: FALLING
N     */
N    LL_TMR_EDGE_SEL_FALLING,
N    /*! Timer trigger source selection: RISING and FALLING
N     */
N    LL_TMR_EDGE_SEL_RISING_FALLING,
N}TYPE_ENUM_LL_TMR_CAP_EDGE;
N
N/**
N  * @brief Enumeration constant for low layer TIMER clock source
N  */
Ntypedef enum {
N    /*! Timer clock source selection: pin rising
N     */
N    LL_TMR_SOURCE_PIN_RISING = 0,
N    /*! Timer clock source selection: pin falling
N     */
N    LL_TMR_SOURCE_PIN_FALLING,
N    /*! Timer clock source selection: half of 26M
N     */
N    LL_TMR_SOURCE_HALF_26M,
N    /*! Timer clock source selection: half of 13K
N     */
N    LL_TMR_SOURCE_HALF_32K,
N    /*! Timer clock source selection: the rising of sys clk
N     */
N    LL_TMR_SOURCE_SYS_RISING,
N}TYPE_ENUM_LL_TMR_SRC_SEL;
N
N  
N/***** LL API AND DRIVER API *****/
N/**
N  * @brief Enumeration constant for low layer TIMER type of timer IO map
N  */
Ntypedef enum {
N    /*! Select the pin of the timer io map none
N     */
N    LL_TMR_IO_MAP_NONE = 0,
N    /*! Select the pin of the timer io map0
N     */
N    LL_TMR_IO_MAP0     = 0x01,
N    /*! Select the pin of the timer io map1
N     */
N    LL_TMR_IO_MAP1     = 0x02,
N}TYPE_ENUM_LL_TMR_IO_MAP;
N
N/**
N  * @brief Enumeration constant for low layer TIMER the pattern of the timer
N  */
Ntypedef enum {
N    /*! Timer mode selection: disable
N     */
N    LL_TMR_MODE_SEL_DISABLE = 0,
N    /*! Timer mode selection: counter mode
N     */
N    LL_TMR_MODE_SEL_COUNTER,
N    /*! Timer mode selection: PWM mode
N     */
N    LL_TMR_MODE_SEL_PWM,
N    /*! Timer mode selection: capture mode
N     */
N    LL_TMR_MODE_SEL_CAPTURE,
N}TYPE_ENUM_LL_TMR_MODE_SEL;
N
N/**
N  * @brief Enumeration constant grouped for low layer TIMER 
N  */
Ntypedef enum {
N    /*! Timer selection: group 0
N     */
N    LL_TMR_TIMER_GROUP0 = 0,
N    /*! Timer selection: group 1
N     */
N    LL_TMR_TIMER_GROUP1,
N    /*! Timer selection: group 2
N     */
N    LL_TMR_TIMER_GROUP2,
N    /*! Timer selection: group 3
N     */
N    LL_TMR_TIMER_GROUP3,
N}TYPE_ENUM_LL_TMR_GROUP;
N
N/**
N  * @}
N  */
N
N/** @defgroup TIMER_LL_Exported_Struct TIMER LL Exported Struct
N  * @ingroup  TIMER_LL_Driver
N  * @brief    TIMER LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the TIMER registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_timer_init. Function, you can configure the TIMER module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief Enumeration constant for low layer TIMER Configure the timer structure
N  */
Ntypedef struct __ll_timer_irq_cfg {
N    /*! timer interrupt enable
N     */
N    bool             intr_en;
N    /*! capture interrupt enable
N     */
N    bool             capture_intr_en;
N} TYPE_LL_TIMER_IRQ_CFG;
N
N/**
N  * @brief Enumeration constant for low layer TIMER Configure the timer structure
N  */
Ntypedef struct __ll_timer_cfg {
N    /*! count cycle value.
N     *  Note: The TIMER period can be set to a maximum of 100ms, 
N     *  and a period larger than 100ms cannot be supported. 
N     *  For example: if you want 100ms, then period=1s/100ms=10.
N     */
N    u16                       period;
N    /*! the initial value of count
N     */
N    u16                       count;
N    /*! pwm value
N     */
N    u16                       duty;
N    /*! prescaler value
N     */
N    TYPE_ENUM_LL_TMR_PSC      prescaler;
N    /*! trigger source selection
N     */
N    TYPE_ENUM_LL_TMR_CAP_EDGE edge_sel;
N    /*! timer mode selection
N     */
N    TYPE_ENUM_LL_TMR_MODE_SEL mode_sel;
N    /*! timer clock source selection
N     */
N    TYPE_ENUM_LL_TMR_SRC_SEL  timer_src_sel;
N    /*! IO map selection for timer
N     *  @note The correspondence table of IO_MAP is as follows:
N     *  
N     *         timer               mode          IO_MAP0      IO_MAP1   
N     *  
N     *                             PWM            PC12          PD9     
N     *                       
N     *         TIMER0         External clock      PA0           PD4     
N     *                       
N     *                            capture         PA0           PD4     
N     *  
N     *                             PWM            PC13          PD10    
N     *                       
N     *         TIMER1         External clock      PA1           PD5     
N     *                       
N     *                            capture         PA1           PD5     
N     *  
N     *                             PWM            PC14          PD11    
N     *                       
N     *         TIMER2         External clock      PA2           PC15    
N     *                       
N     *                            capture         PA2           PC15    
N     *  
N     *                             PWM            PC15          PD12    
N     *                       
N     *         TIMER3         External clock      PA3           PC14    
N     *                       
N     *                            capture         PA3           PC14    
N     *  
N     *                             PWM            PD6                   
N     *                       
N     *         TIMER4         External clock      PA4                   
N     *                       
N     *                            capture         PA4                   
N     *  
N     *                             PWM            PD7                   
N     *                       
N     *         TIMER5         External clock      PA5                   
N     *                       
N     *                            capture         PA5                   
N     *  
N     *                             PWM            PD8                   
N     *                       
N     *         TIMER6         External clock      PC13                  
N     *                       
N     *                            capture         PC13                  
N     *  
N     *                             PWM            PD9                   
N     *                       
N     *         TIMER7         External clock      PC12                  
N     *                       
N     *                            capture         PC12                  
N     *  
N     */
N    TYPE_ENUM_LL_TMR_IO_MAP   io_map;
N} TYPE_LL_TIMER_CFG;
N
N/**
N  * @brief Enumeration constant for low layer TIMER Configure the timer structure
N  */
Ntypedef struct __ll_timer_init { 
N   u8 reserved;
N} TYPE_LL_TIMER_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup TIMER_LL_Interrupt TIMER LL Interrupt Handle function
N  * @brief   TIMER LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the TIMER  
N    Interrupt Handle function.
N
N    how to use?
N
N    The TIMER interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the TIMER in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup TIMER_LL_Inti_Cfg TIMER LL Initialization And Configuration
N  * @brief    TIMER LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the TIMER data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  Low layer timer init function
N  * @param  p_timer: Structure pointer set to TIMER0 to TIMER7
N  * @param  p_init : Configure the p_timer initialization structure
N  * @retval None
N  */
Nvoid ll_timer_init(TIMER_TypeDef *p_timer, TYPE_LL_TIMER_INIT *p_init);
N
N/**
N  * @brief  Low layer timer delete init function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
Nvoid ll_timer_deinit(TIMER_TypeDef *p_timer);
N
N/**
N  * @brief  Low layer timer interrupt config function
N  * @param  p_timer: Structure pointer set to TIMER0 to TIMER7
N  * @param  p_cfg  : Configure the p_timer interrupt initialization structure
N  * @retval None
N  */
Nvoid ll_timer_irq_config(TIMER_TypeDef *p_timer, TYPE_LL_TIMER_IRQ_CFG *p_cfg);
N
N/**
N  * @brief  Low layer timer Configure function
N  * @param  p_timer: Structure pointer set to TIMER0 to TIMER7
N  * @param  p_init : Configure the p_timer initialization structure
N  * @retval None
N  */
Nvoid ll_timer_config(TIMER_TypeDef *p_timer, TYPE_LL_TIMER_CFG *p_init);
N
N/**
N  * @}
N  */
N  
N/** @defgroup TIMER_LL_Data_Transfers TIMER LL Data transfers functions
N  * @brief    TIMER LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the TIMER data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  Low layer timer start function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @param  mode_sel : Select to enable the timer mode.
N  * @retval None
N  */
Nvoid ll_timer_start(TIMER_TypeDef *p_timer,  
N                    TYPE_ENUM_LL_TMR_MODE_SEL mode_sel);
N
N/**
N  * @brief  Low layer timer disable function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
Nvoid ll_timer_stop(TIMER_TypeDef *p_timer);
N
N/**
N  * @brief  Low layer timer check interrupt enable
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N#define LL_TIMER_CHECK_INTERRUPT_ENABLE(p_timer)                    ((p_timer)->TMR_CON & LL_TMR_CON_TMR_INTR_EN)
N
N/**
N  * @brief  Low layer timer check capture interrupt enable
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N#define LL_TIMER_CHECK_CAPTURE_INTERRUPT_ENABLE(p_timer)            ((p_timer)->TMR_CON & LL_TMR_CON_CAP_INTR_EN)
N
N/**
N  * @brief  Low layer timer get capture value function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N#define LL_TIMER_GET_CAPTURE_VALUE(p_timer)                         (LL_TMR_TIMER_PWM(p_timer->TMR_PWM))
N  
N/**
N  * @brief  Low layer timer get interrupt pending function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N#define LL_TIMER_GET_PENDING(p_timer)                               ((p_timer)->TMR_CON & LL_TMR_CON_TIMER_PNG)
N
N/**
N  * @brief  Low layer timer get interrupt pending function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N#define LL_TIMER_GET_CAPTURE_PENDING(p_timer)                       ((p_timer)->TMR_CON & LL_TMR_CON_CAPTURE_PNG)
N
N/**
N  * @brief  Low layer timer clear interrupt pending function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N__STATIC_INLINE void ll_timer_clear_interrupt_pending(TIMER_TypeDef *p_timer) {
Xstatic __inline void ll_timer_clear_interrupt_pending(TIMER_TypeDef *p_timer) {
N    p_timer->TMR_CON |= LL_TMR_CON_TIMER_PNG;
X    p_timer->TMR_CON |= (1UL << 15);
N}
N                                                      
N/**
N  * @brief  Low layer timer clear capture interrupt pending function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N__STATIC_INLINE void ll_timer_clear_capture_interrupt_pending(TIMER_TypeDef *p_timer) {
Xstatic __inline void ll_timer_clear_capture_interrupt_pending(TIMER_TypeDef *p_timer) {
N    p_timer->TMR_CON |= LL_TMR_CON_CAPTURE_PNG;
X    p_timer->TMR_CON |= (1UL << 14);
N}
N
N/**
N  * @brief  Low layer timer enable interrupt function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N__STATIC_INLINE void ll_timer_interrupt_enable(TIMER_TypeDef *p_timer) {
Xstatic __inline void ll_timer_interrupt_enable(TIMER_TypeDef *p_timer) {
N    p_timer->TMR_CON |= LL_TMR_CON_TMR_INTR_EN;
X    p_timer->TMR_CON |= (1UL << 13);
N}
N
N/**
N  * @brief  Low layer timer enable capture interrupt function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N__STATIC_INLINE void ll_timer_capture_interrupt_enable(TIMER_TypeDef *p_timer) {
Xstatic __inline void ll_timer_capture_interrupt_enable(TIMER_TypeDef *p_timer) {
N    p_timer->TMR_CON |= LL_TMR_CON_CAP_INTR_EN;
X    p_timer->TMR_CON |= (1UL << 12);
N}
N
N/**
N  * @brief  Low layer timer disable interrupt function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N__STATIC_INLINE void ll_timer_interrupt_disable(TIMER_TypeDef *p_timer) {
Xstatic __inline void ll_timer_interrupt_disable(TIMER_TypeDef *p_timer) {
N    p_timer->TMR_CON &= ~LL_TMR_CON_TMR_INTR_EN;
X    p_timer->TMR_CON &= ~(1UL << 13);
N}
N
N/**
N  * @brief  Low layer timer disable capture interrupt function
N  * @param  p_timer  : Structure pointer set to TIMER0 to TIMER7
N  * @retval None
N  */
N__STATIC_INLINE void ll_timer_capture_interrupt_disable(TIMER_TypeDef *p_timer) {
Xstatic __inline void ll_timer_capture_interrupt_disable(TIMER_TypeDef *p_timer) {
N    p_timer->TMR_CON &= ~LL_TMR_CON_CAP_INTR_EN;
X    p_timer->TMR_CON &= ~(1UL << 12);
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_TIMER_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 38 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_dftrans.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_dftrans.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_dftrans.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the DFTRANS LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_DFTRANS_H
N#define __TX_PHE_LL_DFTRANS_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup dftrans_interface_gr DFTRANS Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup DFTRANS_LL_Driver DFTRANS LL Driver
N  * @ingroup  dftrans_interface_gr
N  * @brief Mainly the driver part of the DFTRANS module, which includes \b DFTRANS \b Register 
N  * \b Constants, \b DFTRANS \b Exported \b Constants, \b DFTRANS \b Exported \b Struct, \b DFTRANS
N  * \b Data \b transfers \b functions, \b DFTRANS \b Initialization \b and \b DFTRANS \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N     
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N     
N/** @defgroup DFTRANS_LL_Register_Constants DFTRANS LL Register Constants
N  * @ingroup  DFTRANS_LL_Driver
N  * @brief    DFTRANS LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the DFTRANS 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the DFTRANS register, mainly for convenience. Understand the 
N    configuration of the DFTRANS.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** DFTRANS_CON *****/
N/*! DFTRANS dma input data downsample select
N */
N#define LL_DFTRAN_DOWNSAMPLE_SEL(n)               (((n)&0xF) << 10)
N/*! DFTRANS interrupt enable
N */
N#define LL_DFTRAN_IE                              (1UL << 9)
N/*! DFTRANS Completion mark
N */
N#define LL_DFTRAN_PEND                            (1UL << 8)
N/*! (cos+/-j*sin) is an option to add or subtract
N */
N#define LL_DFTRAN_ADD_MINUS                       (1UL << 6)
N/*! The imaginary part of the DMA complex and the real part DMA exchange
N */
N#define LL_DFTRAN_REAL_IMAG_EXCHANG               (1UL << 5)
N/*! The imaginary part of the complex number of DMA is 0
N */
N#define LL_DFTRAN_IMAG_ZERO                       (1UL << 4)
N/*! DFTRANS module enable
N */
N#define LL_DFTRAN_ENABLE                          (1UL << 0)
N
N
N/***** DFTRANS_LEN *****/
N/*! DFTRANS The length of the cyclic buffer that stores REAL and IMAG 
N    data, in units of 16-bit data.
N */
N#define LL_DFTRAN_LEN(n)                          (((n)&0xFFFF) << 0)
N
N
N/***** DFTRANS_INDEX *****/
N/*! DFTRANS The index of the circular buffer that stores REAL and IMAG 
N    data, in units of 16-bit data. Indicates that the operation starts 
N    to fetch data from here.
N */
N#define LL_DFTRAN_INDEX(n)                        (((n)&0xFFFF) << 0)
N
N
N/***** DFTRANS_STEP *****/
N/*! The step of the angle of COS and SIN, the unit is pi. 32-bit unsigned 
N    number, of which 31 are decimal places. The value range is [0, 2). 
N    Calculation formula: (2*X/DFTRANS_LEN)*2^31
N */
N#define LL_DFTRAN_STEP(n)                         (((n)&0xFFFFFFFF) << 0)
N
N
N/***** DFTRANS_REAL_START *****/
N/*! The real data DMA start address of the complex number. 
N    Need 16bit alignment.
N */
N#define LL_DFTRAN_REAL_START(n)                   (((n)&0xFFFFFFFF) << 0)
N
N
N/***** DFTRANS_IMAG_START *****/
N/*! The imaginary part of the imaginary data DMA start address. 
N    Need 16bit alignment.
N */
N#define LL_DFTRAN_IMAG_START(n)                   (((n)&0xFFFFFFFF) << 0)
N
N
N/***** DFTRANS_OUT *****/
N/*! The real part of the DFTRAN calculation results. 16-bit signed numbers, 
N    15 of which are decimals.
N */
N#define LL_DFTRAN_REAL_OUT(n)                     (((n)&0xFFFF) << 16)
N/*! The imaginary part of the DFTRAN calculation result. 16-bit signed 
N    numbers, 15 of which are decimals.
N */
N#define LL_DFTRAN_IMAG_OUT(n)                     (((n)&0xFFFF) << 0)
N
N
N/***** DFTRANS_DMA_LEN *****/
N/*! The number of DMA points in Dftrans, ranging from 17 to 1024.
N */
N#define LL_DFTRAN_DMA_LEN(n)                      (((n)&0x7FF) << 0)
N
N
N/***** DFTRANS_NORMALIZED_COEF *****/
N/*! Normalization coefficient. It is the end of the calculation step: 
N    divided by the part of dma_len.The calculation formula is: 
N    (1 /DFTRANS_DMA_LEN) * 2^19, the result is saturated to 32767.
N */
N#define LL_DFTRAN_NORMALIZED_COEF(n)              (((n)&0x7FFF) << 0)
N
N
N/***** DFTRANS_OUT_ADR *****/
N/*! Save the register DFTRANS_OUT to the DMA start address of the SRAM. 
N    Requires 64bit alignment. The output will take up 64 bits of space.
N */
N#define LL_DFTRAN_OUT_START(n)                    (((n)&0xFFFFFFFF) << 0)
N
N
N/**
N  * @}
N  */
N
N/** @defgroup DFTRANS_LL_Exported_Constants DFTRANS LL Exported Constants
N  * @ingroup  DFTRANS_LL_Driver
N  * @brief    DFTRANS LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for DFTRAN downsample select
N  */
Ntypedef enum {
N    /*! DFTRAN downsample select 1
N     */
N    LL_DFTRAN_DOWNSAMPLE_1 = 0,
N    /*! DFTRAN downsample select 2
N     */
N    LL_DFTRAN_DOWNSAMPLE_2,
N    /*! DFTRAN downsample select 3
N     */
N    LL_DFTRAN_DOWNSAMPLE_3,
N    /*! DFTRAN downsample select 4
N     */
N    LL_DFTRAN_DOWNSAMPLE_4,
N    /*! DFTRAN downsample select 5
N     */
N    LL_DFTRAN_DOWNSAMPLE_5,
N    /*! DFTRAN downsample select 6
N     */
N    LL_DFTRAN_DOWNSAMPLE_6,
N    /*! DFTRAN downsample select 7
N     */
N    LL_DFTRAN_DOWNSAMPLE_7,
N    /*! DFTRAN downsample select 8
N     */
N    LL_DFTRAN_DOWNSAMPLE_8,
N    /*! DFTRAN downsample select 9
N     */
N    LL_DFTRAN_DOWNSAMPLE_9,
N    /*! DFTRAN downsample select 10
N     */
N    LL_DFTRAN_DOWNSAMPLE_10,
N    /*! DFTRAN downsample select 11
N     */
N    LL_DFTRAN_DOWNSAMPLE_11,
N    /*! DFTRAN downsample select 12
N     */
N    LL_DFTRAN_DOWNSAMPLE_12,
N    /*! DFTRAN downsample select 13
N     */
N    LL_DFTRAN_DOWNSAMPLE_13,
N    /*! DFTRAN downsample select 14
N     */
N    LL_DFTRAN_DOWNSAMPLE_14,
N    /*! DFTRAN downsample select 15
N     */
N    LL_DFTRAN_DOWNSAMPLE_15,
N    /*! DFTRAN downsample select 16
N     */
N    LL_DFTRAN_DOWNSAMPLE_16,
N} TYPE_ENUM_LL_DFTRAN_DOWNSAMPLE;
N
N/**
N  * @brief Enumeration constant for DFTRAN imaginary select addition or subtraction 
N  */
Ntypedef enum {
N    /*! DFTRAN imaginary select addition
N     */
N    LL_DFTRAN_ADD = 0,
N    /*! DFTRAN imaginary select subtraction
N     */
N    LL_DFTRAN_MINUS,
N} TYPE_ENUM_LL_DFTRAN_ADD_MIN;
N
N/**
N  * @brief Enumeration constant for DFTRAN real and imag exchang select
N  */
Ntypedef enum {
N    /*! imaginary part of the DMA complex and the real part DMA no exchange 
N     */
N    LL_DFTRAN_R_I_EX_NO = 0,
N    /*! imaginary part of the DMA complex and the real part DMA exchange
N     */
N    LL_DFTRAN_R_I_EX,
N} TYPE_ENUM_LL_DFTRAN_R_I_EX;
N
N/**
N  * @brief Enumeration constant for DFTRAN imaginary value select
N  */
Ntypedef enum {
N    /*! The imaginary part of the complex number of DMA is not 0
N     */
N    LL_DFTRAN_IMAG_NO_ZERO = 0,
N    /*! The imaginary part of the complex number of DMA is 0
N     */
N    LL_DFTRAN_IMAG_IS_ZREO,
N} TYPE_ENUM_LL_DFTRAN_IMAG;
N
N/**
N  * @}
N  */
N
N/** @defgroup DFTRANS_LL_Exported_Struct DFTRANS LL Exported Struct
N  * @ingroup  DFTRANS_LL_Driver
N  * @brief    DFTRANS LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the DFTRANS registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_dftrans_init. Function, you can configure the DFTRANS module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief DFTRAN low layer configuration structure
N  */
Ntypedef struct __ll_dftrans_cfg { 
N    /*! Configure the second complex step increment direction
N     *  @note Valid values are LL_DFTRAN_ADD and LL_DFTRAN_MINUS.
N     */
N    TYPE_ENUM_LL_DFTRAN_ADD_MIN    step_dir;
N    /*! DMA real and imaginary address exchange.For example, the default
N     *  real part of DFTRANS0 is placed in SRAM1 (ie, DFTRANS_REAL_STAR is
N     *  in SRAM1) and the imaginary part is in SRAM2 (ie, DFTRANS_IMAG_STAR
N     *  is in SRAM2). If the DMA exchanges real and imaginary addresses,
N     *  then DFTRANS_REAL_STAR will be located in SRAM2 and
N     *  DFTRANS_IMAG_STAR will be located in SRAM1.
N     *  @note Valid values are LL_DFTRAN_R_I_EX_NO and LL_DFTRAN_R_I_EX.
N     */
N    TYPE_ENUM_LL_DFTRAN_R_I_EX     dma_real_img_swap;
N    /*! If the value is DFTC_IMG_ALL_ZERO, then the DMA imaginary part is
N     *  all 0.
N     *  @note Valid values are LL_DFTRAN_IMAG and LL_DFTRAN_IMAG_ZREO.
N     */
N    TYPE_ENUM_LL_DFTRAN_IMAG       img_val_sel;
N    /*! The number of points calculated by the dft module. The valid range
N     *  is 16 to 1024; 
N     */
N    u16                            dft_points;
N    /*! Len represents the cycle length of the DMA buffer. The value of len
N     *  must not be less than the number of dft_points * downsample_sel.
N     */    
N    u16                            dma_points;
N    /*! Index represents the subscript offset of the DMA buffer.           
N     */
N    u16                            index;
N    /*! Step represents the radians step of the second complex cos and sin.
N     *  The unit is PI.
N     *  @note step = (2*n/dft_points)*2^31
N     */
N    u32                            step;
N    /*! (a+b*j) DMA real part start address of complex number, 2 byte
N     *  aligned. The real part data is a 16-bit signed number with 15 bit
N     *  fixed point.
N     *  @note DFTRANS0's real_dma_src_addr can only be located in SRAM1.  
N     *        DFTRANS1's real_dma_src_addr can only be located in SRAM2.  
N     *        DFTRANS2's real_dma_src_addr can only be located in SRAM3.  
N     */
N    u32                            real_dma_src_addr;
N    /*! (a+b*j) DMA imaginary part start address of complex number, 2 byte
N     *  aligned. The imaginary part data is a 16-bit signed number with 15
N     *  bit fixed point.
N     *  @note DFTRANS0's img_dma_src_addr can only be located in SRAM2.  
N     *        DFTRANS1's img_dma_src_addr can only be located in SRAM3.  
N     *        DFTRANS2's img_dma_src_addr can only be located in SRAM1. 
N     */
N    u32                            img_dma_src_addr;
N    /*! Need to use an address to save the output(64bit size) in accordance with 64bit
N     *  aligned variables.  
N     *  @note DFTRANS0's dma_dst_addr can only be located in SRAM1.  
N     *        DFTRANS1's dma_dst_addr can only be located in SRAM2.  
N     *        DFTRANS2's dma_dst_addr can only be located in SRAM3. 
N     */
N    u32                            dma_dst_addr;
N    /*! Index Steps for each increment. The valid range is 1 to 16.
N     */
N    TYPE_ENUM_LL_DFTRAN_DOWNSAMPLE downsample_sel;
N} TYPE_LL_DFTRANS_CFG;
N
N/**
N  * @brief DFTRAN low layer Initialization structure
N  */
Ntypedef struct __ll_dftrans_init {
N    u8 reserved;
N} TYPE_LL_DFTRANS_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup DFTRANS_LL_Interrupt DFTRANS LL Interrupt Handle function
N  * @brief   DFTRANS LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DFTRANS  
N    Interrupt Handle function.
N
N    how to use?
N
N    The DFTRANS interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the DFTRANS in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup DFTRANS_LL_Inti_Cfg DFTRANS LL Initialization And Configuration
N  * @brief    DFTRANS LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DFTRANS data 
N    Initialization and Configuration.
N    
N    formula:
N    when ADD_MINUS = 0, 
N        result = sum((a(n)+b(n)*j)*(cos(2*n*PI/N)+j*sin(2*n*PI/N)))/N, 
N        n = 0,1,2,3,4....N-1
N    when ADD_MINUS = 1, 
N        result = sum((a(n)+b(n)*j)*(cos(2*n*PI/N)-j*sin(2*n*PI/N)))/N, 
N        n = 0,1,2,3,4....N-1
N        
N    how to use?
N    
N    1. Declare the DFTRAN initialization structure TYPE_LL_DFTRANS_INIT, and call the 
N       ll_dftran_init() function to reset the module and enable the module clock.
N    1. Declare the configuration structure TYPE_LL_DFTRANS_CFG of DFTRAN and 
N       configure it according to actual needs.
N    2. Call the ll_dftran_config() function to initialize.
N    3. Call function ll_dftran_start() to start DFTRAN work.
N    4. Call function ll_dftran_wait() to wait for DFTRAN to complete the calculation, 
N       or call LL_DFTRAN_GET_FINISHED_PEG() function to make PEG wait for judgment.
N    5. Call ll_dftran_get_result() function to get the calculation result of DFTRAN.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  DFTRAN module initialization function
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @param  p_init  : Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_dftran_init(DFT_TypeDef *p_dftran, TYPE_LL_DFTRANS_INIT *p_init);
N
N/**
N  * @brief  DFTRAN module detele initialization function
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @retval None
N  */
Nvoid ll_dftran_deinit(DFT_TypeDef *p_dftran);
N
N/**
N  * @brief  DFTRAN module configuration
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @param  p_cfg   : Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_dftran_config(DFT_TypeDef *p_dftran, TYPE_LL_DFTRANS_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup DFTRANS_LL_Data_Transfers DFTRANS LL Data transfers functions
N  * @brief    DFTRANS LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DFTRANS data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  DFTRAN module start function
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @retval None
N  */
Nvoid ll_dftran_start(DFT_TypeDef *p_dftran);
N
N/**
N  * @brief  DFTRAN module stop function
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @retval None
N  */
Nvoid ll_dftran_stop(DFT_TypeDef *p_dftran);
N
N/**
N  * @brief  DFTRAN get finished pending
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @retval pending value
N  */
N#define LL_DFTRAN_GET_DONE_PENDING(p_dftran)      ((p_dftran)->CON & LL_DFTRAN_PEND)
N
N/**
N  * @brief  DFTRAN clear finished pending
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_dftran_clear_done_pending(DFT_TypeDef *p_dftran) { 
Xstatic __inline void ll_dftran_clear_done_pending(DFT_TypeDef *p_dftran) { 
N    p_dftran->CON |= LL_DFTRAN_PEND;
X    p_dftran->CON |= (1UL << 8);
N}
N
N/**
N  * @brief  DFTRAN enable interrupt
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_dftran_interrupt_enable(DFT_TypeDef *p_dftran) { 
Xstatic __inline void ll_dftran_interrupt_enable(DFT_TypeDef *p_dftran) { 
N    p_dftran->CON |= LL_DFTRAN_IE;
X    p_dftran->CON |= (1UL << 9);
N}
N
N/**
N  * @brief  DFTRAN disable interrupt
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_dftran_interrupt_disable(DFT_TypeDef *p_dftran) { 
Xstatic __inline void ll_dftran_interrupt_disable(DFT_TypeDef *p_dftran) { 
N    p_dftran->CON &= ~LL_DFTRAN_IE;
X    p_dftran->CON &= ~(1UL << 9);
N}
N
N/**
N  * @brief  DFTRAN Wait for the specified channel to finish computing
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_dftran_wait_done_pending(DFT_TypeDef *p_dftran) {    
Xstatic __inline void ll_dftran_wait_done_pending(DFT_TypeDef *p_dftran) {    
N    /* After the calculation is completed, pending is set to 1 and enable 
N     * is cleared. So the following 2 statements are equivalent
N     */
N    while(p_dftran->CON & LL_DFTRAN_ENABLE);
X    while(p_dftran->CON & (1UL << 0));
N    p_dftran->CON |= LL_DFTRAN_PEND;
X    p_dftran->CON |= (1UL << 8);
N}
N
N/**
N  * @brief  Get DFTRAN module specific channel calculations
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @param  p_real  : The real part of the calculation. The real part data is a
N  *                   16-bit signed number with 15 bit fixed point.
N  * @param  p_imag  : The imaginary part of the result. The imaginary part data
N  *                   is a 16-bit signed number with 15 bit fixed point.
N  * @retval None
N  */
N__STATIC_INLINE void ll_dftran_get_result(DFT_TypeDef *p_dftran, s16 *p_real, s16 *p_imag) {
Xstatic __inline void ll_dftran_get_result(DFT_TypeDef *p_dftran, s16 *p_real, s16 *p_imag) {
N    u32 result = p_dftran->OUT;
N    
N    *p_real = (result >> 16) & 0xFFFF;
N    *p_imag  = result & 0xFFFF;
N}
N
N/**
N  * @brief  Set DFTRAN module specific channel INDEX
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @param  index   : 16bit index to be set, the index is small than dft_points
N  * @retval None
N  */
N__STATIC_INLINE void ll_dftran_set_index(DFT_TypeDef *p_dftran, u16 index) {    
Xstatic __inline void ll_dftran_set_index(DFT_TypeDef *p_dftran, u16 index) {    
N    p_dftran->INDEX = LL_DFTRAN_INDEX(index);
X    p_dftran->INDEX = (((index)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Get DFTRAN module specific channel INDEX
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @retval Index
N  */
N#define LL_DFTRAN_GET_INDEX(p_dftran)             ((p_dftran)->INDEX & LL_DFTRAN_INDEX(0xFFFF))
N
N/**
N  * @brief  Set DFTRAN module specific channel real_dma_src_addr
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @param  addr    : 32bit addr \ref TYPE_LL_DFTRANS_CFG
N  * @retval None
N  */
N__STATIC_INLINE void ll_dftran_set_real_dma_src_addr(DFT_TypeDef *p_dftran, u32 addr) {
Xstatic __inline void ll_dftran_set_real_dma_src_addr(DFT_TypeDef *p_dftran, u32 addr) {
N    p_dftran->REAL_STADR = LL_DFTRAN_REAL_START(addr);
X    p_dftran->REAL_STADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  Set DFTRAN module specific channel img_dma_src_addr
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @param  addr    : 32bit addr \ref TYPE_LL_DFTRANS_CFG
N  * @retval None
N  */
N__STATIC_INLINE void ll_dftran_set_img_dma_src_addr(DFT_TypeDef *p_dftran, u32 addr) {
Xstatic __inline void ll_dftran_set_img_dma_src_addr(DFT_TypeDef *p_dftran, u32 addr) {
N    p_dftran->IMAG_STADR = LL_DFTRAN_IMAG_START(addr);
X    p_dftran->IMAG_STADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  Set DFTRAN module specific channel dma_dst_addr
N  * @param  p_dftran: Select the initialized DFTRAN group pointer
N  * @param  addr    : 32bit addr \ref TYPE_LL_DFTRANS_CFG
N  * @retval None
N  */
N__STATIC_INLINE void ll_dftran_set_dma_dst_addr(DFT_TypeDef *p_dftran, u32 addr) {
Xstatic __inline void ll_dftran_set_dma_dst_addr(DFT_TypeDef *p_dftran, u32 addr) {
N    p_dftran->OUT_ADR = LL_DFTRAN_OUT_START(addr);
X    p_dftran->OUT_ADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_DFTRANS_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 39 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_fft.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_fft.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_fft.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the FFT LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>                                                      
N  *
N  * Description of the FFT module:
N  *
N  * 1. Windowing module:
N  *    The FFT contains two windowed coefficient tables, the hanning window and the nuttallwin window. 
N  * Of course, you can also pass the windowed coefficients to the FFT module via memory, but if you 
N  * want to use the internal window coefficients, you can refer to the array fft_hanning_window and 
N  * the array fft_nuttallwin_window. These two arrays contain specific coefficients, both of which 
N  * are 1024 bytes.
N  *
N  * u16 fft_hanning_window[1024] = {
N  *    0,     0,     1,     1,     2,     4,     6,     8,     10,    12,    15,    19,   
N  *    22,    26,    30,    35,    39,    45,    50,    56,    62,    68,    75,    81,   
N  *    89,    96,    104,   112,   121,   129,   138,   148,   157,   167,   178,   188,  
N  *    199,   210,   222,   233,   246,   258,   271,   283,   297,   310,   324,   338,  
N  *    353,   367,   383,   398,   413,   429,   446,   462,   479,   496,   513,   531,  
N  *    549,   567,   586,   604,   624,   643,   663,   683,   703,   723,   744,   765,  
N  *    787,   808,   830,   852,   875,   897,   920,   944,   967,   991,   1015,  1040, 
N  *    1064,  1089,  1114,  1140,  1165,  1191,  1218,  1244,  1271,  1298,  1325,  1353, 
N  *    1381,  1409,  1437,  1466,  1494,  1523,  1553,  1582,  1612,  1642,  1673,  1703, 
N  *    1734,  1765,  1796,  1828,  1859,  1892,  1924,  1956,  1989,  2022,  2055,  2088, 
N  *    2122,  2156,  2190,  2224,  2259,  2294,  2329,  2364,  2399,  2435,  2471,  2507, 
N  *    2543,  2580,  2617,  2653,  2691,  2728,  2765,  2803,  2841,  2879,  2918,  2956, 
N  *    2995,  3034,  3073,  3112,  3152,  3192,  3232,  3272,  3312,  3352,  3393,  3434, 
N  *    3475,  3516,  3558,  3599,  3641,  3683,  3725,  3767,  3809,  3852,  3895,  3937, 
N  *    3980,  4024,  4067,  4111,  4154,  4198,  4242,  4286,  4330,  4375,  4419,  4464, 
N  *    4509,  4554,  4599,  4644,  4689,  4735,  4781,  4826,  4872,  4918,  4964,  5011, 
N  *    5057,  5104,  5150,  5197,  5244,  5291,  5338,  5385,  5432,  5480,  5527,  5575, 
N  *    5622,  5670,  5718,  5766,  5814,  5862,  5910,  5959,  6007,  6056,  6104,  6153, 
N  *    6202,  6250,  6299,  6348,  6397,  6446,  6495,  6545,  6594,  6643,  6693,  6742, 
N  *    6791,  6841,  6891,  6940,  6990,  7040,  7090,  7139,  7189,  7239,  7289,  7339, 
N  *    7389,  7439,  7489,  7539,  7589,  7639,  7690,  7740,  7790,  7840,  7890,  7941, 
N  *    7991,  8041,  8091,  8142,  8192,  8242,  8293,  8343,  8393,  8443,  8494,  8544, 
N  *    8594,  8644,  8694,  8745,  8795,  8845,  8895,  8945,  8995,  9045,  9095,  9145, 
N  *    9195,  9245,  9294,  9344,  9394,  9444,  9493,  9543,  9593,  9642,  9691,  9741, 
N  *    9790,  9839,  9889,  9938,  9987,  10036, 10085, 10134, 10182, 10231, 10280, 10328,
N  *    10377, 10425, 10474, 10522, 10570, 10618, 10666, 10714, 10762, 10809, 10857, 10904,
N  *    10952, 10999, 11046, 11093, 11140, 11187, 11234, 11280, 11327, 11373, 11420, 11466,
N  *    11512, 11558, 11603, 11649, 11695, 11740, 11785, 11830, 11875, 11920, 11965, 12009,
N  *    12054, 12098, 12142, 12186, 12230, 12273, 12317, 12360, 12404, 12447, 12489, 12532,
N  *    12575, 12617, 12659, 12701, 12743, 12785, 12826, 12868, 12909, 12950, 12991, 13032,
N  *    13072, 13112, 13152, 13192, 13232, 13272, 13311, 13350, 13389, 13428, 13466, 13505,
N  *    13543, 13581, 13619, 13656, 13693, 13731, 13767, 13804, 13841, 13877, 13913, 13949,
N  *    13985, 14020, 14055, 14090, 14125, 14160, 14194, 14228, 14262, 14296, 14329, 14362,
N  *    14395, 14428, 14460, 14492, 14525, 14556, 14588, 14619, 14650, 14681, 14711, 14742,
N  *    14772, 14802, 14831, 14861, 14890, 14918, 14947, 14975, 15003, 15031, 15059, 15086,
N  *    15113, 15140, 15166, 15193, 15219, 15244, 15270, 15295, 15320, 15344, 15369, 15393,
N  *    15417, 15440, 15464, 15487, 15509, 15532, 15554, 15576, 15597, 15619, 15640, 15661,
N  *    15681, 15701, 15721, 15741, 15760, 15780, 15798, 15817, 15835, 15853, 15871, 15888,
N  *    15905, 15922, 15938, 15955, 15971, 15986, 16001, 16017, 16031, 16046, 16060, 16074,
N  *    16087, 16101, 16113, 16126, 16138, 16151, 16162, 16174, 16185, 16196, 16206, 16217,
N  *    16227, 16236, 16246, 16255, 16263, 16272, 16280, 16288, 16295, 16303, 16309, 16316,
N  *    16322, 16328, 16334, 16339, 16345, 16349, 16354, 16358, 16362, 16365, 16369, 16372,
N  *    16374, 16376, 16378, 16380, 16382, 16383, 16383, 16384, 16384, 16384, 16383, 16383,
N  *    16382, 16380, 16378, 16376, 16374, 16372, 16369, 16365, 16362, 16358, 16354, 16349,
N  *    16345, 16339, 16334, 16328, 16322, 16316, 16309, 16303, 16295, 16288, 16280, 16272,
N  *    16263, 16255, 16246, 16236, 16227, 16217, 16206, 16196, 16185, 16174, 16162, 16151,
N  *    16138, 16126, 16113, 16101, 16087, 16074, 16060, 16046, 16031, 16017, 16001, 15986,
N  *    15971, 15955, 15938, 15922, 15905, 15888, 15871, 15853, 15835, 15817, 15798, 15780,
N  *    15760, 15741, 15721, 15701, 15681, 15661, 15640, 15619, 15597, 15576, 15554, 15532,
N  *    15509, 15487, 15464, 15440, 15417, 15393, 15369, 15344, 15320, 15295, 15270, 15244,
N  *    15219, 15193, 15166, 15140, 15113, 15086, 15059, 15031, 15003, 14975, 14947, 14918,
N  *    14890, 14861, 14831, 14802, 14772, 14742, 14711, 14681, 14650, 14619, 14588, 14556,
N  *    14525, 14492, 14460, 14428, 14395, 14362, 14329, 14296, 14262, 14228, 14194, 14160,
N  *    14125, 14090, 14055, 14020, 13985, 13949, 13913, 13877, 13841, 13804, 13767, 13731,
N  *    13693, 13656, 13619, 13581, 13543, 13505, 13466, 13428, 13389, 13350, 13311, 13272,
N  *    13232, 13192, 13152, 13112, 13072, 13032, 12991, 12950, 12909, 12868, 12826, 12785,
N  *    12743, 12701, 12659, 12617, 12575, 12532, 12489, 12447, 12404, 12360, 12317, 12273,
N  *    12230, 12186, 12142, 12098, 12054, 12009, 11965, 11920, 11875, 11830, 11785, 11740,
N  *    11695, 11649, 11603, 11558, 11512, 11466, 11420, 11373, 11327, 11280, 11234, 11187,
N  *    11140, 11093, 11046, 10999, 10952, 10904, 10857, 10809, 10762, 10714, 10666, 10618,
N  *    10570, 10522, 10474, 10425, 10377, 10328, 10280, 10231, 10182, 10134, 10085, 10036,
N  *    9987,  9938,  9889,  9839,  9790,  9741,  9691,  9642,  9593,  9543,  9493,  9444, 
N  *    9394,  9344,  9294,  9245,  9195,  9145,  9095,  9045,  8995,  8945,  8895,  8845, 
N  *    8795,  8745,  8694,  8644,  8594,  8544,  8494,  8443,  8393,  8343,  8293,  8242, 
N  *    8192,  8142,  8091,  8041,  7991,  7941,  7890,  7840,  7790,  7740,  7690,  7639, 
N  *    7589,  7539,  7489,  7439,  7389,  7339,  7289,  7239,  7189,  7139,  7090,  7040, 
N  *    6990,  6940,  6891,  6841,  6791,  6742,  6693,  6643,  6594,  6545,  6495,  6446, 
N  *    6397,  6348,  6299,  6250,  6202,  6153,  6104,  6056,  6007,  5959,  5910,  5862, 
N  *    5814,  5766,  5718,  5670,  5622,  5575,  5527,  5480,  5432,  5385,  5338,  5291, 
N  *    5244,  5197,  5150,  5104,  5057,  5011,  4964,  4918,  4872,  4826,  4781,  4735, 
N  *    4689,  4644,  4599,  4554,  4509,  4464,  4419,  4375,  4330,  4286,  4242,  4198, 
N  *    4154,  4111,  4067,  4024,  3980,  3937,  3895,  3852,  3809,  3767,  3725,  3683, 
N  *    3641,  3599,  3558,  3516,  3475,  3434,  3393,  3352,  3312,  3272,  3232,  3192, 
N  *    3152,  3112,  3073,  3034,  2995,  2956,  2918,  2879,  2841,  2803,  2765,  2728, 
N  *    2691,  2653,  2617,  2580,  2543,  2507,  2471,  2435,  2399,  2364,  2329,  2294, 
N  *    2259,  2224,  2190,  2156,  2122,  2088,  2055,  2022,  1989,  1956,  1924,  1892, 
N  *    1859,  1828,  1796,  1765,  1734,  1703,  1673,  1642,  1612,  1582,  1553,  1523, 
N  *    1494,  1466,  1437,  1409,  1381,  1353,  1325,  1298,  1271,  1244,  1218,  1191, 
N  *    1165,  1140,  1114,  1089,  1064,  1040,  1015,  991,   967,   944,   920,   897,  
N  *    875,   852,   830,   808,   787,   765,   744,   723,   703,   683,   663,   643,  
N  *    624,   604,   586,   567,   549,   531,   513,   496,   479,   462,   446,   429,  
N  *    413,   398,   383,   367,   353,   338,   324,   310,   297,   283,   271,   258,  
N  *    246,   233,   222,   210,   199,   188,   178,   167,   157,   148,   138,   129,  
N  *    121,   112,   104,   96,    89,    81,    75,    68,    62,    56,    50,    45,   
N  *    39,    35,    30,    26,    22,    19,    15,    12,    10,    8,     6,     4,    
N  *    2,     1,     1,     0,
N  * };
N  *
N  * u16 fft_nuttallwin_window[1024] = { 
N  *    6,     6,     6,     6,     6,     6,     6,     7,     7,     7,     7,     7,    
N  *    8,     8,     8,     9,     9,     9,     10,    10,    11,    11,    12,    12,   
N  *    13,    14,    14,    15,    16,    17,    17,    18,    19,    20,    21,    22,   
N  *    23,    24,    25,    26,    27,    28,    29,    31,    32,    33,    35,    36,   
N  *    38,    39,    41,    42,    44,    46,    47,    49,    51,    53,    55,    57,   
N  *    59,    61,    64,    66,    68,    71,    73,    76,    78,    81,    84,    86,   
N  *    89,    92,    95,    98,    101,   105,   108,   111,   115,   118,   122,   126,  
N  *    130,   134,   138,   142,   146,   150,   155,   159,   164,   169,   173,   178,  
N  *    183,   189,   194,   199,   205,   210,   216,   222,   228,   234,   240,   247,  
N  *    253,   260,   266,   273,   280,   287,   295,   302,   310,   318,   325,   333,  
N  *    342,   350,   359,   367,   376,   385,   394,   403,   413,   423,   432,   442,  
N  *    453,   463,   474,   484,   495,   506,   518,   529,   541,   553,   565,   577,  
N  *    590,   602,   615,   628,   642,   655,   669,   683,   697,   711,   726,   741,  
N  *    756,   771,   787,   803,   819,   835,   851,   868,   885,   902,   920,   938,  
N  *    956,   974,   992,   1011,  1030,  1049,  1069,  1089,  1109,  1129,  1150,  1171, 
N  *    1192,  1213,  1235,  1257,  1280,  1302,  1325,  1348,  1372,  1395,  1419,  1444, 
N  *    1468,  1493,  1519,  1544,  1570,  1596,  1623,  1649,  1676,  1704,  1731,  1759, 
N  *    1788,  1816,  1845,  1875,  1904,  1934,  1964,  1995,  2026,  2057,  2089,  2121, 
N  *    2153,  2185,  2218,  2251,  2285,  2319,  2353,  2388,  2423,  2458,  2493,  2529, 
N  *    2565,  2602,  2639,  2676,  2714,  2752,  2790,  2829,  2868,  2907,  2947,  2987, 
N  *    3027,  3068,  3109,  3150,  3192,  3234,  3276,  3319,  3362,  3405,  3449,  3493, 
N  *    3538,  3582,  3628,  3673,  3719,  3765,  3811,  3858,  3905,  3953,  4001,  4049, 
N  *    4097,  4146,  4195,  4245,  4295,  4345,  4395,  4446,  4497,  4548,  4600,  4652, 
N  *    4704,  4757,  4810,  4863,  4917,  4971,  5025,  5079,  5134,  5189,  5244,  5300, 
N  *    5356,  5412,  5469,  5525,  5583,  5640,  5697,  5755,  5813,  5872,  5931,  5989, 
N  *    6049,  6108,  6168,  6228,  6288,  6348,  6409,  6470,  6531,  6592,  6654,  6715, 
N  *    6777,  6840,  6902,  6965,  7027,  7090,  7154,  7217,  7280,  7344,  7408,  7472, 
N  *    7536,  7601,  7665,  7730,  7795,  7860,  7925,  7990,  8055,  8121,  8187,  8252, 
N  *    8318,  8384,  8450,  8516,  8582,  8649,  8715,  8782,  8848,  8915,  8981,  9048, 
N  *    9115,  9182,  9248,  9315,  9382,  9449,  9516,  9583,  9650,  9717,  9784,  9851, 
N  *    9917,  9984,  10051, 10118, 10185, 10251, 10318, 10385, 10451, 10517, 10584, 10650,
N  *    10716, 10782, 10848, 10914, 10980, 11045, 11111, 11176, 11242, 11307, 11372, 11436,
N  *    11501, 11565, 11630, 11694, 11757, 11821, 11885, 11948, 12011, 12074, 12136, 12199,
N  *    12261, 12323, 12384, 12446, 12507, 12568, 12628, 12688, 12748, 12808, 12867, 12927,
N  *    12985, 13044, 13102, 13160, 13217, 13274, 13331, 13387, 13443, 13499, 13554, 13609,
N  *    13664, 13718, 13772, 13825, 13878, 13930, 13982, 14034, 14085, 14136, 14186, 14236,
N  *    14286, 14335, 14383, 14431, 14479, 14526, 14573, 14619, 14664, 14709, 14754, 14798,
N  *    14842, 14885, 14927, 14969, 15011, 15052, 15092, 15132, 15171, 15210, 15248, 15286,
N  *    15323, 15359, 15395, 15430, 15465, 15499, 15533, 15566, 15598, 15630, 15661, 15691,
N  *    15721, 15750, 15779, 15807, 15834, 15861, 15887, 15913, 15937, 15962, 15985, 16008,
N  *    16030, 16052, 16073, 16093, 16113, 16131, 16150, 16167, 16184, 16200, 16216, 16231,
N  *    16245, 16258, 16271, 16283, 16295, 16306, 16316, 16325, 16334, 16342, 16349, 16356,
N  *    16362, 16367, 16371, 16375, 16378, 16381, 16383, 16384, 16384, 16384, 16383, 16381,
N  *    16378, 16375, 16371, 16367, 16362, 16356, 16349, 16342, 16334, 16325, 16316, 16306,
N  *    16295, 16283, 16271, 16258, 16245, 16231, 16216, 16200, 16184, 16167, 16150, 16131,
N  *    16113, 16093, 16073, 16052, 16030, 16008, 15985, 15962, 15937, 15913, 15887, 15861,
N  *    15834, 15807, 15779, 15750, 15721, 15691, 15661, 15630, 15598, 15566, 15533, 15499,
N  *    15465, 15430, 15395, 15359, 15323, 15286, 15248, 15210, 15171, 15132, 15092, 15052,
N  *    15011, 14969, 14927, 14885, 14842, 14798, 14754, 14709, 14664, 14619, 14573, 14526,
N  *    14479, 14431, 14383, 14335, 14286, 14236, 14186, 14136, 14085, 14034, 13982, 13930,
N  *    13878, 13825, 13772, 13718, 13664, 13609, 13554, 13499, 13443, 13387, 13331, 13274,
N  *    13217, 13160, 13102, 13044, 12985, 12927, 12867, 12808, 12748, 12688, 12628, 12568,
N  *    12507, 12446, 12384, 12323, 12261, 12199, 12136, 12074, 12011, 11948, 11885, 11821,
N  *    11757, 11694, 11630, 11565, 11501, 11436, 11372, 11307, 11242, 11176, 11111, 11045,
N  *    10980, 10914, 10848, 10782, 10716, 10650, 10584, 10517, 10451, 10385, 10318, 10251,
N  *    10185, 10118, 10051, 9984,  9917,  9851,  9784,  9717,  9650,  9583,  9516,  9449, 
N  *    9382,  9315,  9248,  9182,  9115,  9048,  8981,  8915,  8848,  8782,  8715,  8649, 
N  *    8582,  8516,  8450,  8384,  8318,  8252,  8187,  8121,  8055,  7990,  7925,  7860, 
N  *    7795,  7730,  7665,  7601,  7536,  7472,  7408,  7344,  7280,  7217,  7154,  7090, 
N  *    7027,  6965,  6902,  6840,  6777,  6715,  6654,  6592,  6531,  6470,  6409,  6348, 
N  *    6288,  6228,  6168,  6108,  6049,  5989,  5931,  5872,  5813,  5755,  5697,  5640, 
N  *    5583,  5525,  5469,  5412,  5356,  5300,  5244,  5189,  5134,  5079,  5025,  4971, 
N  *    4917,  4863,  4810,  4757,  4704,  4652,  4600,  4548,  4497,  4446,  4395,  4345, 
N  *    4295,  4245,  4195,  4146,  4097,  4049,  4001,  3953,  3905,  3858,  3811,  3765, 
N  *    3719,  3673,  3628,  3582,  3538,  3493,  3449,  3405,  3362,  3319,  3276,  3234, 
N  *    3192,  3150,  3109,  3068,  3027,  2987,  2947,  2907,  2868,  2829,  2790,  2752, 
N  *    2714,  2676,  2639,  2602,  2565,  2529,  2493,  2458,  2423,  2388,  2353,  2319, 
N  *    2285,  2251,  2218,  2185,  2153,  2121,  2089,  2057,  2026,  1995,  1964,  1934, 
N  *    1904,  1875,  1845,  1816,  1788,  1759,  1731,  1704,  1676,  1649,  1623,  1596, 
N  *    1570,  1544,  1519,  1493,  1468,  1444,  1419,  1395,  1372,  1348,  1325,  1302, 
N  *    1280,  1257,  1235,  1213,  1192,  1171,  1150,  1129,  1109,  1089,  1069,  1049, 
N  *    1030,  1011,  992,   974,   956,   938,   920,   902,   885,   868,   851,   835,  
N  *    819,   803,   787,   771,   756,   741,   726,   711,   697,   683,   669,   655,  
N  *    642,   628,   615,   602,   590,   577,   565,   553,   541,   529,   518,   506,  
N  *    495,   484,   474,   463,   453,   442,   432,   423,   413,   403,   394,   385,  
N  *    376,   367,   359,   350,   342,   333,   325,   318,   310,   302,   295,   287,  
N  *    280,   273,   266,   260,   253,   247,   240,   234,   228,   222,   216,   210,  
N  *    205,   199,   194,   189,   183,   178,   173,   169,   164,   159,   155,   150,  
N  *    146,   142,   138,   134,   130,   126,   122,   118,   115,   111,   108,   105,  
N  *    101,   98,    95,    92,    89,    86,    84,    81,    78,    76,    73,    71,   
N  *    68,    66,    64,    61,    59,    57,    55,    53,    51,    49,    47,    46,   
N  *    44,    42,    41,    39,    38,    36,    35,    33,    32,    31,    29,    28,   
N  *    27,    26,    25,    24,    23,    22,    21,    20,    19,    18,    17,    17,   
N  *    16,    15,    14,    14,    13,    12,    12,    11,    11,    10,    10,    9,    
N  *    9,     9,     8,     8,     8,     7,     7,     7,     7,     7,     6,     6,    
N  *    6,     6,     6,     6, 
N  * };  
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_FFT_H
N#define __TX_PHE_LL_FFT_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup fft_interface_gr FFT Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup FFT_LL_Driver FFT LL Driver
N  * @ingroup  fft_interface_gr
N  * @brief Mainly the driver part of the FFT module, which includes \b FFT \b Register 
N  * \b Constants, \b FFT \b Exported \b Constants, \b FFT \b Exported \b Struct, \b FFT
N  * \b Data \b transfers \b functions, \b FFT \b Initialization \b and \b FFT \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N     
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N     
N/** @defgroup FFT_LL_Register_Constants FFT LL Register Constants
N  * @ingroup  FFT_LL_Driver
N  * @brief    FFT LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the FFT 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the FFT register, mainly for convenience. Understand the 
N    configuration of the FFT.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** FFT_DMA_CON *****/
N/*! Indicates whether the real or imaginary data after FFT windowing has at least one 
N *  data greater than (+-) (fft_maximum*2).
N */
N#define LL_FFT_DMA_CON_FFT_OV2                    (1UL << 16)
N/*! Indicates whether the real or imaginary data after FFT windowing has at least one 
N *  data greater than (+-) (fft_maximum).
N */
N#define LL_FFT_DMA_CON_FFT_OV1                    (1UL << 15)
N/*! FFT dma input data downsample select: The downsampling range is from 1 to 16.
N */
N#define LL_FFT_DMA_CON_DOWN_SAMPLE(n)             (((n)&0xF) << 11)
N/*! FFT DMA finish interrupt enable
N */
N#define LL_FFT_DMA_CON_FFT_DMA_IE                 (1UL << 10)
N/*! FFT DMA real and imag interface exchange
N */
N#define LL_FFT_DMA_CON_REAL_IMAG_EXCHANGE         (1UL << 9)
N/*! FFT DMA finish flag
N */
N#define LL_FFT_DMA_CON_FFT_DMA_PEND               (1UL << 8)
N/*! FFT DMA Window source select
N */
N#define LL_FFT_DMA_CON_WINDOW_SRC(n)              (((n)&0x3) << 6)
N/*! IMAGE input is zero select
N */
N#define LL_FFT_DMA_CON_IMAGE_SEL(n)               (((n)&0x3) << 4)
N/*! FFT DMA sample selection.
N */
N#define LL_FFT_DMA_CON_FFT_MODE(n)                (((n)&0x7) << 1)
N/*! FFT DMA enable. This bit will be cleared automatically after finish
N */
N#define LL_FFT_DMA_CON_ENABLE                     (1UL << 0)
N
N
N/***** FFT_REAL_STADR *****/
N/*! REAL data DMA start address. Requires 16bit alignment.
N */
N#define LL_FFT_REAL_STADR(n)                      (((n)&0xFFFFFFFF) << 0) 
N
N
N/***** FFT_IMAG_STADR *****/
N/*! IMAG data DMA start address. Requires 16bit alignment.
N */
N#define LL_FFT_IMAG_STADR(n)                      (((n)&0xFFFFFFFF) << 0) 
N
N
N/***** FFT_WINDOW_STADR *****/
N/*! WINDOW data DMA address. Requires 16bit alignment.
N */
N#define LL_FFT_WINDOW_STADR(n)                    (((n)&0xFFFFFFFF) << 0)
N
N
N/***** FFT_REALIMAG_OUT_STADR *****/ 
N/*! REALIMAG data output DMA start address. Requires 32bit alignment.
N */
N#define LL_FFT_REALIMAG_OUT_STADR(n)              (((n)&0xFFFFFFFF) << 0)
N
N
N/***** FFT_LEN *****/ 
N/*! FFT DMA buffer length
N */
N#define LL_FFT_LEN(n)                             (((n)&0xFFFF) << 0) 
N
N
N/***** FFT_INDEX *****/
N/*! FFT_DMA finish once will increase 1. when increase to FFT_LEN, cleared to 0.
N */
N#define LL_FFT_INDEX(n)                           (((n)&0xFFFF) << 0) 
N
N
N/***** FFT_STADR *****/   
N/*! FFT input data DMA start address. Requires 64bit alignment. This register does not 
N *  need to be configured and is read only. The hardware automatically loads 
N *  FFT_REALIMAG_OUT_STADR into this register during FFT_KS.
N */
N#define LL_FFT_STADR(n)                           (((n)&0xFFFFFFFF) << 0) 
N
N
N/***** FFT_KS *****/    
N/*! FFT kick start, Write 1 to kick off FFT.
N */
N#define LL_FFT_KS                                 (1UL << 0)
N
N
N/***** FFT_CTRL *****/    
N/*! FFT enable interrupt
N */
N#define LL_FFT_CTRL_IRQ_EN                        (1UL << 7)
N/*! Saturate Shift Control:  
N *  0 -> right shift 1 bit at last stage  
N *  1 -> right shift (N-SAT_CNT) bits at last stage  
N */
N#define LL_FFT_CTRL_SHIFT_CTRL                    (1UL << 6)
N/*! Select the mode of the FFT: 0 -> FFT MODE; 1 -> IFFT MODE.
N */
N#define LL_FFT_CTRL_IFFT_MODE                     (1UL << 5)
N/*! IFFT DMA sample selection.
N */
N#define LL_FFT_CTRL_FFT_POINT_SEL(n)              (((n)&0x7) << 1) 
N/*! FFT enable, This bit will be cleared automatically after finish
N */
N#define LL_FFT_CTRL_FFT_EN                        (1UL << 0)
N
N
N/***** FFT_STAT *****/
N/*! FFT IRQ pending, writes1 to clear it.
N */
N#define LL_FFT_STAT_IRQ_PEDING                    (1UL << 4)
N/*! FFT calculate overflow times.
N */
N#define LL_FFT_STAT_OVERFLOW_TIMES(n)             (((n)&0xF) << 0) 
N
N
N/***** FFT_MAXIMUM *****/
N/*! The maximum value of the input data of the real or imaginary part that the FFT 
N *  operation module can accept. The default is 11584.
N */
N#define LL_FFT_MAXIMUM(n)                         (((n)&0xFFFF) << 0) 
N
N
N/**
N  * @}
N  */
N
N/** @defgroup FFT_LL_Exported_Constants FFT LL Exported Constants
N  * @ingroup  FFT_LL_Driver
N  * @brief    FFT LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for FFT downsample select
N  */
Ntypedef enum {
N    /*! FFT downsample select 1
N     */
N    LL_FFT_DOWNSAMPLE_1 = 0,
N    /*! FFT downsample select 2
N     */
N    LL_FFT_DOWNSAMPLE_2,
N    /*! FFT downsample select 3
N     */
N    LL_FFT_DOWNSAMPLE_3,
N    /*! FFT downsample select 4
N     */
N    LL_FFT_DOWNSAMPLE_4,
N    /*! FFT downsample select 5
N     */
N    LL_FFT_DOWNSAMPLE_5,
N    /*! FFT downsample select 6
N     */
N    LL_FFT_DOWNSAMPLE_6,
N    /*! FFT downsample select 7
N     */
N    LL_FFT_DOWNSAMPLE_7,
N    /*! FFT downsample select 8
N     */
N    LL_FFT_DOWNSAMPLE_8,
N    /*! FFT downsample select 9
N     */
N    LL_FFT_DOWNSAMPLE_9,
N    /*! FFT downsample select 10
N     */
N    LL_FFT_DOWNSAMPLE_10,
N    /*! FFT downsample select 11
N     */
N    LL_FFT_DOWNSAMPLE_11,
N    /*! FFT downsample select 12
N     */
N    LL_FFT_DOWNSAMPLE_12,
N    /*! FFT downsample select 13
N     */
N    LL_FFT_DOWNSAMPLE_13,
N    /*! FFT downsample select 14
N     */
N    LL_FFT_DOWNSAMPLE_14,
N    /*! FFT downsample select 15
N     */
N    LL_FFT_DOWNSAMPLE_15,
N    /*! FFT downsample select 16
N     */
N    LL_FFT_DOWNSAMPLE_16,
N} TYPE_ENUM_LL_FFT_DOWNSAMPLE;
N
N/**
N  * @brief Enumeration constant for FFT real and imag exchang select
N  */
Ntypedef enum {
N    /*! imaginary part of the DMA complex and the real part DMA no exchange
N     */
N    LL_FFT_R_I_EX_NO = 0,
N    /*! imaginary part of the DMA complex and the real part DMA exchange
N     */
N    LL_FFT_R_I_EX,
N} TYPE_ENUM_LL_FFT_R_I_EX;
N
N/**
N  * @brief Enumeration constant for FFT windowed data source selection.
N  */
Ntypedef enum {
N    /*! The FFT's windowed data comes from Memory and is added by the user.
N     */
N    LL_FFT_WINDOW_SRC_MEM = 0,
N    /*! The windowed data of the FFT is derived from the internal hanning table.
N     *  For specific coefficients, please refer to array fft_hanning_window.
N     */
N    LL_FFT_WINDOW_SRC_HANNING,
N    /*! The windowed data of the FFT is derived from the internal nuttallwin table. 
N     *  For specific coefficients, please refer to array fft_nuttallwin_window.
N     */
N    LL_FFT_WINDOW_SRC_NUTTALLWIN,
N    /*! Set the FFT windowed data to constant 1, that is, the windowing is invalid. 
N     */
N    LL_FFT_WINDOW_SRC_CONSTANT_1,
N} TYPE_ENUM_LL_FFT_WINDOOW;
N
N/**
N  * @brief Enumeration constant for FFT imaginary data source processing selection.
N  */
Ntypedef enum {
N    /*! The FFT imaginary data comes from memory.
N     */
N    LL_FFT_IMAG_INPUT_DMA = 0,
N    /*! The FFT imaginary data is all zero.
N     */
N    LL_FFT_IMAG_INPUT_ZERO,
N    /*! The FFT imaginary data is all inverted.
N     */
N    LL_FFT_IMAG_INPUT_NEGATE,
N} TYPE_ENUM_LL_FFT_IMG_SEL;
N
N/**
N  * @brief Enumeration constant for FFT calculation sample selection
N  */
Ntypedef enum {
N    /*! FFT calculation sample number selection: 32 points.
N     */
N    LL_FFT_POINT_32 = 0,
N    /*! FFT calculation sample number selection: 64 points.
N     */
N    LL_FFT_POINT_64,
N    /*! FFT calculation sample number selection: 128 points.
N     */
N    LL_FFT_POINT_128,
N    /*! FFT calculation sample number selection: 256 points.
N     */
N    LL_FFT_POINT_256,
N    /*! FFT calculation sample number selection: 512 points.
N     */
N    LL_FFT_POINT_512,
N    /*! FFT calculation sample number selection: 1024 points.
N     */
N    LL_FFT_POINT_1024,
N} TYPE_ENUM_LL_FFT_POINT_SEL;
N
N/**
N  * @brief Enumeration constant for FFT internal calculation shift selection
N  */
Ntypedef enum {
N    /*! Indicates that each level is divided by 2, and after the cumulative log(N) 
N     *  level, Equivalent to the effect of dividing by N.
N     */
N    LL_FFT_SHIFT_EVERY_STAGE = 0,
N    /*! When it indicates that a certain level is saturated, it divides by 2, when 
N     *  it is not saturated, it does not divide by 2, waits for the last stage to 
N     *  be added again, and how much compensation is needed is the value of (N - STA_CNT).
N     */
N    LL_FFT_SHIFT_SATURATION,
N} TYPE_ENUM_LL_FFT_SHIFT;
N
N/**
N  * @brief Enumeration constant for FFT mode select
N  */
Ntypedef enum {
N    /*! Select the FFT calculation mode.
N     */
N    LL_FFT_MODE_FFT = 0,
N    /*! Select the IFFT calculation mode.
N     */
N    LL_FFT_MODE_IFFT,
N} TYPE_ENUM_LL_FFT_MODE;
N
N/**
N  * @}
N  */
N
N/** @defgroup FFT_LL_Exported_Struct FFT LL Exported Struct
N  * @ingroup  FFT_LL_Driver
N  * @brief    FFT LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the FFT registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_fft_init. Function, you can configure the FFT module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief FFT DMA low layer configuration structure
N  */
Ntypedef struct __ll_fft_irq_cfg {
N    /*! Interrupt enable control.
N     *  @note false represents enable interrupt, true represents disable interrupt.
N     */
N    bool dma_intr_en;
N    /*! Interrupt enable control.
N     *  @note false represents enable interrupt, true represents disable interrupt.
N     */
N    bool intr_en;
N} TYPE_LL_FFT_IRQ_CFG;
N
N/**
N  * @brief FFT data preprocess low layer configuration structure
N  */
Ntypedef struct __ll_fft_preprocess_cfg {
N    /*! Configure the value of the FFT downsample. 
N     */
N    TYPE_ENUM_LL_FFT_DOWNSAMPLE downsample_sel;
N    /*! DMA real and imaginary address exchange.For example, the default
N     *  real part of FFT0 is placed in SRAM1 (ie, FFT_REAL_STAR is
N     *  in SRAM1) and the imaginary part is in SRAM2 (ie, FFT_IMAG_STAR
N     *  is in SRAM2). If the DMA exchanges real and imaginary addresses,
N     *  then FFT_REAL_STAR will be located in SRAM2 and
N     *  FFT_IMAG_STAR will be located in SRAM1.
N     */
N    TYPE_ENUM_LL_FFT_R_I_EX     real_img_swap;
N    /*! Configure the selection of the windowing factor.Please refer to 
N     *  TYPE_ENUM_LL_FFT_WINDOOW for the specific type.
N     */
N    TYPE_ENUM_LL_FFT_WINDOOW    window_src;
N    /*! Configure the selection of the FFT imaginary coefficient value.
N     *  Please refer to TYPE_ENUM_LL_FFT_IMG_SEL for the specific type.
N     */
N    TYPE_ENUM_LL_FFT_IMG_SEL    img_val_sel;
N    /*! Configure the FFT to calculate the number of samples.
N     *  Please refer to TYPE_ENUM_LL_FFT_POINT_SEL for the specific type.
N     */
N    TYPE_ENUM_LL_FFT_POINT_SEL  point_sel;
N    /*! Configure the length of the FFT input buffer.
N     */
N    u16                         dma_points;
N    /*! Index represents the subscript offset of the DMA buffer.
N     */
N    u16                         index;
N    /*! (a+b*j) DMA real part start address of complex number, 2 byte
N     *  aligned. The real part data is a 16-bit signed number with 15 bit
N     *  fixed point.
N     *  @note FFT0's real_dma_src_addr can only be located in SRAM1.  
N     *        FFT1's real_dma_src_addr can only be located in SRAM2.  
N     *        FFT2's real_dma_src_addr can only be located in SRAM3.  
N     *        Statement example:  
N     *        static s16 fft0_buf_real[1024] __attribute__((section("SRAM1")));
N     */
N    u32                         real_dma_src_addr;
N    /*! (a+b*j) DMA imaginary part start address of complex number, 2 byte
N     *  aligned. The imaginary part data is a 16-bit signed number with 15
N     *  bit fixed point.
N     *  @note FFT0's img_dma_src_addr can only be located in SRAM2.  
N     *        FFT1's img_dma_src_addr can only be located in SRAM3.  
N     *        FFT2's img_dma_src_addr can only be located in SRAM1.  
N     *        Statement example:  
N     *        static s16 fft0_buf_img[1024] __attribute__((section("SRAM2")));
N     */
N    u32                         img_dma_src_addr;
N    /*! The start address of the windowed buffer. 2Byte address alignment.  
N     *  @note FFT0's window_dma_src_addr can only be located in SRAM0.  
N     *        FFT1's window_dma_src_addr can only be located in SRAM0.  
N     *        FFT2's window_dma_src_addr can only be located in SRAM0.  
N     *        Statement example:  
N     *        static u16 fft_buf_wind[64] __attribute__((section("SRAM0")));
N     */
N    u32                         window_dma_src_addr;
N    /*! Need to use an address to save the output(32bit size) in accordance 
N     *  with 32bit aligned variables.  
N     *  @note FFT0's dma_dst_addr can only be located in SRAM4 and SRAM5.  
N     *        FFT1's dma_dst_addr can only be located in SRAM2 and SRAM5.  
N     *        FFT2's dma_dst_addr can only be located in SRAM3 and SRAM5.  
N     *        Statement example:  
N     *        static u32 fft0_obuf[1024] __attribute__((section("SRAM4_5")));
N     */
N    u32                         dma_dst_addr;
N} TYPE_LL_FFT_PREPROCESS_CFG;
N
N/**
N  * @brief FFT low layer configuration structure
N  */
Ntypedef struct __ll_fft_cfg {
N    /*! Configure the FFT power normalization mode.
N     *  Please refer to TYPE_ENUM_LL_FFT_SHIFT for the specific type.
N     */    
N    TYPE_ENUM_LL_FFT_SHIFT     shift_sel;
N    /*! Configure the FFT calculation mode, FFT mode or IFFT mode.
N     *  Please refer to TYPE_ENUM_LL_FFT_MODE for the specific type.
N     */
N    TYPE_ENUM_LL_FFT_MODE      mode;
N    /*! Configure the FFT to calculate the number of samples.
N     *  Please refer to TYPE_ENUM_LL_FFT_POINT_SEL for the specific type.
N     */
N    TYPE_ENUM_LL_FFT_POINT_SEL point_sel;
N} TYPE_LL_FFT_CFG;
N
N/**
N  * @brief FFT low layer Initialization structure
N  */
Ntypedef struct __ll_fft_init {
N    u8 reserved;
N} TYPE_LL_FFT_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup FFT_LL_Interrupt FFT LL Interrupt Handle function
N  * @brief   FFT LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the FFT  
N    Interrupt Handle function.
N
N    how to use?
N
N    The FFT interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the FFT in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N  
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup FFT_LL_Inti_Cfg FFT LL Initialization And Configuration
N  * @brief    FFT LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the FFT data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Low layer FFT module initialization
N  * @param  p_fft: The structure pointer of the FFT group (FFT0, FFT1, FFT2) is selected.
N  * @param  p_init: Module configuration structure pointer(TYPE_LL_FFT_INIT)
N  * @retval None
N  */
Nvoid ll_fft_init(FFT_TypeDef *p_fft, TYPE_LL_FFT_INIT *p_init);
N
N/**
N  * @brief  Low layer FFT module detele initialization
N  * @param  p_fft: The structure pointer of the FFT group (FFT0, FFT1, FFT2) is selected.
N  * @retval None
N  */
Nvoid ll_fft_deinit(FFT_TypeDef *p_fft);
N
N/**
N  * @brief  Low layer FFT module interrupt configuration
N  * @param  p_fft: The structure pointer of the FFT group (FFT0, FFT1, FFT2) is selected.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_FFT_IRQ_CFG)
N  * @retval None
N  */
Nvoid ll_fft_irq_config(FFT_TypeDef *p_fft, TYPE_LL_FFT_IRQ_CFG *p_cfg);
N  
N/**
N  * @brief  Low layer FFT preprocess configuration
N  * @param  p_fft: The structure pointer of the FFT group (FFT0, FFT1, FFT2) is selected.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_FFT_PREPROCESS_CFG)
N  * @retval None
N  */
Nvoid ll_fft_preprocess_config(FFT_TypeDef *p_fft, TYPE_LL_FFT_PREPROCESS_CFG *p_cfg);
N  
N/**
N  * @brief  Low layer FFT module configuration
N  * @param  p_fft: The structure pointer of the FFT group (FFT0, FFT1, FFT2) is selected.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_FFT_CFG)
N  * @retval None
N  */
Nvoid ll_fft_config(FFT_TypeDef *p_fft, TYPE_LL_FFT_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup FFT_LL_Data_Transfers FFT LL Data transfers functions
N  * @brief    FFT LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the FFT data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Low layer FFT preprocess start function
N  * @param  p_fft: The structure pointer of the FFT group (FFT0, FFT1, FFT2) is selected.
N  * @retval None
N  */
Nvoid ll_fft_preprocess_start(FFT_TypeDef *p_fft);
N
N/**
N  * @brief  Low layer FFT module start function
N  * @param  p_fft: The structure pointer of the FFT group (FFT0, FFT1, FFT2) is selected.
N  * @retval None
N  */
Nvoid ll_fft_start(FFT_TypeDef *p_fft);
N
N/**
N  * @brief  Low layer FFT preprocess stop function
N  * @param  p_fft: The structure pointer of the FFT group (FFT0, FFT1, FFT2) is selected.
N  * @retval None
N  */
Nvoid ll_fft_preprocess_stop(FFT_TypeDef *p_fft);
N
N/**
N  * @brief  Low layer FFT module stop function
N  * @param  p_fft: The structure pointer of the FFT group (FFT0, FFT1, FFT2) is selected.
N  * @retval None
N  */
N void ll_fft_stop(FFT_TypeDef *p_fft);
N  
N/**
N  * @brief  FFT preprocess get finished pending
N  * @param  p_fft: Select the initialized FFT preprocess group pointer
N  * @retval pending value
N  */
N#define LL_FFT_PREPROCESS_GET_DONE_PENDING(p_fft) ((p_fft)->DMA_CON & LL_FFT_DMA_CON_FFT_DMA_PEND)
N
N/**
N  * @brief  FFT get finished pending
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @retval pending value
N  */
N#define LL_FFT_GET_DONE_PENDING(p_fft)            ((p_fft)->STAT & LL_FFT_STAT_IRQ_PEDING)
N
N/**
N  * @brief  FFT clear preprocess done pending
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_clear_preprocess_done_pending(FFT_TypeDef *p_fft) {
Xstatic __inline void ll_fft_clear_preprocess_done_pending(FFT_TypeDef *p_fft) {
N    p_fft->DMA_CON |= LL_FFT_DMA_CON_FFT_DMA_PEND;
X    p_fft->DMA_CON |= (1UL << 8);
N}
N
N/**
N  * @brief  FFT clear done pending
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_clear_done_pending(FFT_TypeDef *p_fft) {
Xstatic __inline void ll_fft_clear_done_pending(FFT_TypeDef *p_fft) {
N    p_fft->STAT |= LL_FFT_STAT_IRQ_PEDING;
X    p_fft->STAT |= (1UL << 4);
N}
N
N/**
N  * @brief  FFT preprocess wait for the specified channel to finish computing
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_wait_preprocess_done_pending(FFT_TypeDef *p_fft) {
Xstatic __inline void ll_fft_wait_preprocess_done_pending(FFT_TypeDef *p_fft) {
N    while(!(p_fft->DMA_CON & LL_FFT_DMA_CON_FFT_DMA_PEND));
X    while(!(p_fft->DMA_CON & (1UL << 8)));
N    p_fft->DMA_CON |= LL_FFT_DMA_CON_FFT_DMA_PEND;
X    p_fft->DMA_CON |= (1UL << 8);
N}
N
N/**
N  * @brief  FFT Wait for the specified channel to finish computing
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_wait_done_pending(FFT_TypeDef *p_fft) {
Xstatic __inline void ll_fft_wait_done_pending(FFT_TypeDef *p_fft) {
N    while(!(p_fft->STAT & LL_FFT_STAT_IRQ_PEDING));
X    while(!(p_fft->STAT & (1UL << 4)));
N    p_fft->STAT |= LL_FFT_STAT_IRQ_PEDING;
X    p_fft->STAT |= (1UL << 4);
N}
N
N/**
N  * @brief  FFT enable preprocess interrupt
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_preprocess_interrupt_enable(FFT_TypeDef *p_fft) {
Xstatic __inline void ll_fft_preprocess_interrupt_enable(FFT_TypeDef *p_fft) {
N    p_fft->DMA_CON |= LL_FFT_DMA_CON_FFT_DMA_IE;
X    p_fft->DMA_CON |= (1UL << 10);
N}
N
N/**
N  * @brief  FFT disable preprocess interrupt
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_preprocess_interrupt_disable(FFT_TypeDef *p_fft) {
Xstatic __inline void ll_fft_preprocess_interrupt_disable(FFT_TypeDef *p_fft) {
N    p_fft->DMA_CON &= ~(LL_FFT_DMA_CON_FFT_DMA_IE);
X    p_fft->DMA_CON &= ~((1UL << 10));
N}
N
N/**
N  * @brief  FFT enable interrupt
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_interrupt_enable(FFT_TypeDef *p_fft) {
Xstatic __inline void ll_fft_interrupt_enable(FFT_TypeDef *p_fft) {
N    p_fft->CTRL |= LL_FFT_CTRL_IRQ_EN;
X    p_fft->CTRL |= (1UL << 7);
N}
N
N/**
N  * @brief  FFT disable interrupt
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_interrupt_disable(FFT_TypeDef *p_fft) {
Xstatic __inline void ll_fft_interrupt_disable(FFT_TypeDef *p_fft) {
N    p_fft->CTRL &= ~(LL_FFT_CTRL_IRQ_EN);
X    p_fft->CTRL &= ~((1UL << 7));
N}
N
N/**
N  * @brief  FFT index set
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @param  index: fft index , rang : [0,fft_points)
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_set_index(FFT_TypeDef *p_fft, u16 index) {
Xstatic __inline void ll_fft_set_index(FFT_TypeDef *p_fft, u16 index) {
N    p_fft->INDEX = LL_FFT_INDEX(index);
X    p_fft->INDEX = (((index)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  FFT index Get
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @retval None
N  */
N#define LL_FFT_GET_INDEX(p_fft)            ((p_fft)->INDEX & LL_FFT_INDEX(0xFFFF))
N  
N/**
N  * @brief  FFT index set dma_dst_addr
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @param  addr : fft dma_dst_addr, \ref TYPE_LL_FFT_PREPROCESS_CFG
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_set_preprocess_dma_dst_addr(FFT_TypeDef *p_fft, u32 addr) {
Xstatic __inline void ll_fft_set_preprocess_dma_dst_addr(FFT_TypeDef *p_fft, u32 addr) {
N    p_fft->REALIMAG_OUT_STADR = LL_FFT_REALIMAG_OUT_STADR(addr);
X    p_fft->REALIMAG_OUT_STADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  FFT index set window dma_dst_addr
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @param  addr : fft window_dma_dst_addr, \ref TYPE_LL_FFT_PREPROCESS_CFG
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_set_preprocess_window_dma_dst_addr(FFT_TypeDef *p_fft, u32 addr) {
Xstatic __inline void ll_fft_set_preprocess_window_dma_dst_addr(FFT_TypeDef *p_fft, u32 addr) {
N    p_fft->WINDOW_STADR = LL_FFT_WINDOW_STADR(addr);
X    p_fft->WINDOW_STADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  FFT index set real_dma_src_addr
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @param  addr : fft real_dma_src_addr, \ref TYPE_LL_FFT_PREPROCESS_CFG
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_set_preprocess_real_dma_src_addr(FFT_TypeDef *p_fft, u32 addr) {
Xstatic __inline void ll_fft_set_preprocess_real_dma_src_addr(FFT_TypeDef *p_fft, u32 addr) {
N    p_fft->REAL_STADR = LL_FFT_REAL_STADR(addr);
X    p_fft->REAL_STADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  FFT index set imag_dma_src_addr
N  * @param  p_fft: Select the initialized FFT group pointer
N  * @param  addr : fft imag_dma_src_addr, \ref TYPE_LL_FFT_PREPROCESS_CFG
N  * @retval None
N  */
N__STATIC_INLINE void ll_fft_set_preprocess_imag_dma_src_addr(FFT_TypeDef *p_fft, u32 addr) {
Xstatic __inline void ll_fft_set_preprocess_imag_dma_src_addr(FFT_TypeDef *p_fft, u32 addr) {
N    p_fft->IMAG_STADR = LL_FFT_IMAG_STADR(addr);
X    p_fft->IMAG_STADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_FFT_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 40 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_matrix.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_matrix.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_matrix.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the MATRIX LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_MATRIX_H
N#define __TX_PHE_LL_MATRIX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup matrix_interface_gr MATRIX Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup MATRIX_LL_Driver MATRIX LL Driver
N  * @ingroup  matrix_interface_gr
N  * @brief Mainly the driver part of the MATRIX module, which includes \b MATRIX \b Register 
N  * \b Constants, \b MATRIX \b Exported \b Constants, \b MATRIX \b Exported \b Struct, \b MATRIX
N  * \b Data \b transfers \b functions, \b MATRIX \b Initialization \b and \b MATRIX \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup MATRIX_LL_Register_Constants MATRIX LL Register Constants
N  * @ingroup  MATRIX_LL_Driver
N  * @brief    MATRIX LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the MATRIX 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the MATRIX register, mainly for convenience. Understand the 
N    configuration of the MATRIX.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** MATRIX_EN *****/
N/*! MATRIX CHX_CFG_EN, Want to configure CH3_ENABLE,this bit must write1
N */
N#define LL_MAXTRIX_CFG_EN_CH(n)                 (1UL << (8+(n)))
N/*! MATRIX CHX_EN
N */
N#define LL_MAXTRIX_ENABLE_CH(n)                 (0x101UL << (0+(n)))
N#define LL_MAXTRIX_DISABLE_CH(n)                (0x100UL << (0+(n)))
N
N
N/***** MATRIX_PENDING *****/
N/*! MATRIX PENDING
N */
N#define LL_MAXTRIX_PENDING_CH(n)                (1UL << (0+(n)))
N
N
N/***** MATRIX_IE *****/
N/*! MATRIX interrupt enable
N */
N#define LL_MAXTRIX_INT_EN_CH(n)                 (1UL << (0+(n)))
N
N
N/***** MATRIX_COEF_SEL *****/
N/*! MATRIX coef select
N */
N#define LL_MAXTRIX_INT_EN_CH(n)                 (1UL << (0+(n)))
N
N/**
N  * @}
N  */
N
N/** @defgroup MATRIX_LL_Exported_Constants MATRIX LL Exported Constants
N  * @ingroup  MATRIX_LL_Driver
N  * @brief    MATRIX LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N/*! MATRIX channel max
N */
N#define LL_MAXTRIX_CHN_MAX                      4
N
N/**
N  * @}
N  */
N
N/** @defgroup MATRIX_LL_Exported_Struct MATRIX LL Exported Struct
N  * @ingroup  MATRIX_LL_Driver
N  * @brief    MATRIX LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the MATRIX registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_matrix_init. Function, you can configure the MATRIX module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief The 3x3 matrix coefficients are all 16-bit signed numbers, of 
N  *        which 15 bits are fixed points. As follows:
N@verbatim 
N           coef_00   coef_01   coef_02 
N           coef_10   coef_11   coef_12 
N           coef_20   coef_21   coef_22 
N@endverbatim
N  */
Ntypedef struct __ll_matrix_3x3_cfg {
N    /*! Hardware module supports storage of 2 sets of coefficients
N     */
N    u16 select;
N    /*! coef_00
N     */
N    s16 coef_00;
N    /*! coef_01
N     */
N    s16 coef_01;
N    /*! coef_02
N     */
N    s16 coef_02;
N    /*! coef_10
N     */
N    s16 coef_10;
N    /*! coef_11
N     */
N    s16 coef_11;
N    /*! coef_12
N     */
N    s16 coef_12;
N    /*! coef_20
N     */
N    s16 coef_20;
N    /*! coef_21
N     */
N    s16 coef_21;
N    /*! coef_22
N     */
N    s16 coef_22;
N} TYPE_LL_MATRIX_3X3_CFG;
N
N/**
N  * @brief The 3x1 input matrix coefficients are all 16-bit signed numbers,
N  *        As follow:
N@verbatim 
N           coeff_00_in_addr[i] 
N           coeff_10_in_addr[i] 
N           coeff_20_in_addr[i] 
N@endverbatim
N  *       The 3x1 output matrix coefficients are all 16-bit signed numbers,
N  *       As follow:
N@verbatim 
N          coeff_00_out_addr[i]
N          coeff_10_out_addr[i]
N          coeff_20_out_addr[i]
N@endverbatim
N  *       The matrix multiplication module requires that all DMA addresses 
N  *       are 2 byte aligned.
N  */
Ntypedef struct __ll_matrix_calc_cfg {
N    /*! Hardware supports 4-channel simultaneous operations.
N     */
N    u8  chn;
N    /*! 3x3 matrix coefficient selection, only 2 options of 0 and 1.
N     */
N    u16 matrix_3x3_select;
N    /*! DMA input and output buf subscript offset. You can only configure 
N     *  the same offset for the time being.
N     */
N    u32 index;
N    /*! DMA input and output buf cycle length. Can only be configured to the 
N     *  same length for the time being.
N     */
N    u32 dma_points;
N    /*! The fixed-point number of the 3x1 input matrix, valid range is 8~15.
N     */
N    u32 in_frac_width;
N    /*! The fixed-point number of the 3x1 output matrix, valid range is 8~15.
N     */
N    u32 out_frac_width;
N    /*! Address 2byte alignment, can only be the address in SRAM1.
N     *  @note usage :  
N     *        s16 matrix_ibuf0[256] __attribute__((aligned(2), section("SRAM1")));
N     */
N    u32 dma_src_addr_x;
N    /*! Address 2byte alignment, can only be the address in SRAM2.
N     */
N    u32 dma_src_addr_y;
N    /*! Address 2byte alignment, can only be the address in SRAM3.
N     */    
N    u32 dma_src_addr_z;
N    /*! Address 2byte alignment, can only be the address in SRAM1.
N     */
N    u32 dma_dst_addr_x;
N    /*! Address 2byte alignment, can only be the address in SRAM2.
N     */
N    u32 dma_dst_addr_y;
N    /*! Address 2byte alignment, can only be the address in SRAM3.
N     */
N    u32 dma_dst_addr_z;
N} TYPE_LL_MATRIX_CALC_CFG;
N
N/**
N  * @brief MATRIX low layer Initialization structure
N  */
Ntypedef struct __ll_matrix_init {
N    u8 reserved;
N} TYPE_LL_MATRIX_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup MATRIX_LL_Interrupt MATRIX LL Interrupt Handle function
N  * @brief   MATRIX LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the MATRIX  
N    Interrupt Handle function.
N
N    how to use?
N
N    The MATRIX interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the MATRIX in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup MATRIX_LL_Inti_Cfg MATRIX LL Initialization And Configuration
N  * @brief    MATRIX LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the MATRIX data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  Matrix Multiplication Module Initialization
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  p_init   : pointer to the init struct TYPE_LL_MATRIX_INIT
N  * @retval None
N  */
Nvoid ll_matrix_init(MATRIX_TypeDef *p_matrix, TYPE_LL_MATRIX_INIT *p_init);
N
N/**
N  * @brief  Matrix Multiplication Module Initialization
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @retval None
N  */
Nvoid ll_matrix_deinit(MATRIX_TypeDef *p_matrix);
N
N/**
N  * @brief  3x3 matrix configuration
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  p_cfg    : \ref TYPE_LL_MATRIX_3X3_CFG, Configure 3x3 matrix values and where they 
N  *                    re stored.
N  * @retval None
N  */
Nvoid ll_matrix_3x3_coef_config(MATRIX_TypeDef *p_matrix, TYPE_LL_MATRIX_3X3_CFG *p_cfg);
N
N/**
N  * @brief  Matrix Multiplication
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  p_cfg    : \ref TYPE_LL_MATRIX_CALC_CFG, Configure matrix computing module.
N  * @retval None
N  */
Nvoid ll_matrix_config(MATRIX_TypeDef *p_matrix, TYPE_LL_MATRIX_CALC_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup MATRIX_LL_Data_Transfers MATRIX LL Data transfers functions
N  * @brief    MATRIX LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the MATRIX data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Start matrix module operation
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  chn      : Select the channel to enable
N  * @retval None
N  * @note   Each call to a function will only cause the module to perform a 
N  *         matrix multiplication operation. That is, there will be only one
N  *         output at a time.
N  */
Nvoid ll_matrix_start(MATRIX_TypeDef *p_matrix, u8 chn);
N
N/**
N  * @brief  Wait for the completion of the matrix multiplication of a 
N  *         particular channel
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  chn      : the channel waiting to be calculated.
N  * @retval None
N  */
Nvoid ll_matrix_wait_done_pending(MATRIX_TypeDef *p_matrix, u8 chn);
N
N/**
N  * @brief  stop matrix module operation
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  chn      : Select the channel to enable
N  * @retval None
N  * @note   Each call to a function will only cause the module to perform a 
N  *         matrix multiplication operation. That is, there will be only one
N  *         output at a time.
N  */
Nvoid ll_matrix_stop(MATRIX_TypeDef *p_matrix, u8 chn);
N
N/**
N  * @brief  LL_MATRIX_CHECK_CHN_DONE_INTERRUPT_ENABLE
N  * @param  p_matrix: Select the initialized MATRIX group pointer
N  * @param  chn     : specify adc chn to set
N  * @retval interrupt_enable
N  * @note : user can use this function instead of ll_matrix_wait_done_pending(MATRIX_TypeDef *p_matrix, u8 chn);
N  */
N#define LL_MATRIX_CHECK_CHN_DONE_INTERRUPT_ENABLE(p_matrix, chn)    ((p_matrix)->MATRIX_IE & BIT(chn))
N
N/**
N  * @brief  MATRIX get finished pending
N  * @param  p_matrix: Select the initialized MATRIX group pointer
N  * @param  chn     : specify adc chn to set
N  * @retval pending value
N  * @note : user can use this function instead of ll_matrix_wait_done_pending(MATRIX_TypeDef *p_matrix, u8 chn);
N  */
N#define LL_MATRIX_GET_CHN_DONE_PENDING(p_matrix, chn)               ((p_matrix)->MATRIX_PEND & BIT(chn))
N
N/**
N  * @brief  MATRIX clear finished pending
N  * @param  p_matrix: Select the initialized MATRIX group pointer
N  * @param  chn     : specify adc chn to set
N  * @retval None
N  */
N__STATIC_INLINE void ll_matrix_clear_chn_done_pending(MATRIX_TypeDef *p_matrix, u8 chn) {
Xstatic __inline void ll_matrix_clear_chn_done_pending(MATRIX_TypeDef *p_matrix, u8 chn) {
N    p_matrix->MATRIX_PEND |= BIT(chn);
X    p_matrix->MATRIX_PEND |= ((uint32_t)1<<(chn));
N}
N
N/** 
N  * @brief  MATRIX ll_matrix_interrupt_enable function.
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  chn      : specify adc chn to set
N  * @retval none
N  */
N__STATIC_INLINE void ll_matrix_interrupt_enable(MATRIX_TypeDef *p_matrix, u8 chn) {
Xstatic __inline void ll_matrix_interrupt_enable(MATRIX_TypeDef *p_matrix, u8 chn) {
N    p_matrix->MATRIX_IE |= BIT(chn);
X    p_matrix->MATRIX_IE |= ((uint32_t)1<<(chn));
N}
N
N/** 
N  * @brief  MATRIX ll_matrix_interrupt_disable function.
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  chn      : specify adc chn to set
N  * @retval none
N  */
N__STATIC_INLINE void ll_matrix_interrupt_disable(MATRIX_TypeDef *p_matrix, u8 chn) {
Xstatic __inline void ll_matrix_interrupt_disable(MATRIX_TypeDef *p_matrix, u8 chn) {
N    p_matrix->MATRIX_IE &= ~(BIT(chn));
X    p_matrix->MATRIX_IE &= ~(((uint32_t)1<<(chn)));
N}
N
N/** 
N  * @brief  MATRIX ll_matrix_set_index function.
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  chn      : specify adc chn to set
N  * @param  out_index: specify output buffer index to set
N  * @param  in_index : specify input buffer index to set
N  * @retval none
N  */
N__STATIC_INLINE void ll_matrix_set_index(MATRIX_TypeDef *p_matrix, u8 chn, u16 out_index, u16 in_index) {
Xstatic __inline void ll_matrix_set_index(MATRIX_TypeDef *p_matrix, u8 chn, u16 out_index, u16 in_index) {
N    MATRIX_CH_TypeDef *p_matrix_ch = &p_matrix->CH[chn];
N    p_matrix_ch->LEN  = (out_index << 16) | in_index;
N}
N
N/** 
N  * @brief  MATRIX ll_matrix_get_index function.
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  chn      : specify adc chn to set
N  * @param  out_index: specify output buffer index to set
N  * @param  in_index : specify input buffer index to set
N  * @retval none
N  */
N__STATIC_INLINE void ll_matrix_get_index(MATRIX_TypeDef *p_matrix, u8 chn, u16 *out_index, u16 *in_index) {
Xstatic __inline void ll_matrix_get_index(MATRIX_TypeDef *p_matrix, u8 chn, u16 *out_index, u16 *in_index) {
N    MATRIX_CH_TypeDef *p_matrix_ch = &p_matrix->CH[chn];
N    u32 index = p_matrix_ch->LEN;
N    *in_index = index & 0xFFFF;
N    *in_index = (index >> 16) & 0xFFFF;
N}
N
N/** 
N  * @brief  MATRIX ll_matrix_set_dma_src_addr function.
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  chn      : specify adc chn to set
N  * @param  addr_x   : specify X buffer addr to set
N  * @param  addr_y   : specify Y buffer addr to set
N  * @param  addr_z   : specify Z buffer addr to set
N  * @retval none
N  */
N__STATIC_INLINE void ll_matrix_set_dma_src_addr(MATRIX_TypeDef *p_matrix, u8 chn, u16 addr_x, u16 addr_y, u16 addr_z) {
Xstatic __inline void ll_matrix_set_dma_src_addr(MATRIX_TypeDef *p_matrix, u8 chn, u16 addr_x, u16 addr_y, u16 addr_z) {
N    MATRIX_CH_TypeDef *p_matrix_ch = &p_matrix->CH[chn];
N    p_matrix_ch->DATAIN_STADR0   = addr_x;
N    p_matrix_ch->DATAIN_STADR1   = addr_y;
N    p_matrix_ch->DATAIN_STADR2   = addr_z;
N}
N
N/** 
N  * @brief  MATRIX ll_matrix_set_dma_dst_addr function.
N  * @param  p_matrix : pointer to the hardware MATRIX_TypeDef
N  * @param  chn      : specify adc chn to set
N  * @param  addr_x   : specify X buffer addr to set
N  * @param  addr_y   : specify Y buffer addr to set
N  * @param  addr_z   : specify Z buffer addr to set
N  * @retval none
N  */
N__STATIC_INLINE void ll_matrix_set_dma_dst_addr(MATRIX_TypeDef *p_matrix, u8 chn, u16 addr_x, u16 addr_y, u16 addr_z) {
Xstatic __inline void ll_matrix_set_dma_dst_addr(MATRIX_TypeDef *p_matrix, u8 chn, u16 addr_x, u16 addr_y, u16 addr_z) {
N    MATRIX_CH_TypeDef *p_matrix_ch = &p_matrix->CH[chn];
N    p_matrix_ch->DATAOUT_STADR0   = addr_x;
N    p_matrix_ch->DATAOUT_STADR1   = addr_y;
N    p_matrix_ch->DATAOUT_STADR2   = addr_z;
N}
N
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_MATRIX_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 41 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_sincos.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_sincos.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_sincos.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the SINCOS LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_SINCOS_H
N#define __TX_PHE_LL_SINCOS_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup sincos_interface_gr SINCOS Driver
N  * @ingroup    TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup SINCOS_LL_Driver SINCOS LL Driver
N  * @ingroup  sincos_interface_gr
N  * @brief Mainly the driver part of the SINCOS module, which includes \b SINCOS \b Register 
N  * \b Constants, \b SINCOS \b Exported \b Constants, \b SINCOS \b Exported \b Struct, \b SINCOS
N  * \b Data \b transfers \b functions, \b SINCOS \b Initialization \b and \b SINCOS \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N     
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N     
N/** @defgroup SINCOS_LL_Register_Constants SINCOS LL Register Constants
N  * @ingroup  SINCOS_LL_Driver
N  * @brief    SINCOS LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the SINCOS 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the SINCOS register, mainly for convenience. Understand the 
N    configuration of the SINCOS.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** SINCOS_CON *****/
N/*! The SINCOS module calculates the completion flag.
N */
N#define LL_SINCOS_PEND                      (1UL << 8)
N/*! The SINCOS module interrupt enable bit.
N */
N#define LL_SINCOS_IE                        (1UL << 5)
N/*! Mode selection for SINCOS radians.
N */
N#define LL_SINCOS_DMA_MODE                  (1UL << 4)
N/*! The choice of SINCOS calculation mode.
N */
N#define LL_SINCOS_DMA_EN                    (1UL << 3)
N/*! SINCOS input buffer data format selection.
N */
N#define LL_SINCOS_MODE(n)                   (((n)&0x3) << 1)
N/*! The enable bit of the SINCOS module.
N */
N#define LL_SINCOS_ENABLE                    (1UL << 0)
N
N
N/***** SINCOS_LEN *****/
N/*! The length of the buffer in SINCOS DMA mode.
N */
N#define LL_SINCOS_LEN(n)                    (((n)&0xFFFF) << 0)
N
N
N/***** SINCOS_STEP *****/
N/*! In SINCOS DMA mode, the radians value is set to  auto increment,
N *  which sets the auto increment step of the radians value. 
N */
N#define LL_SINCOS_STEP(n)                   (((n)&0xFFFF) << 0)
N
N
N/***** SINCOS_DATA_IN *****/  
N/*! Data input value in SINCOS CPU mode.
N */
N#define LL_SINCOS_DATA_IN(n)                (((n)&0xFFFF) << 0)
N
N
N/***** SINCOS_DATA_OUT *****/
N/*! Data output value in SINCOS CPU mode.
N */
N#define LL_SINCOS_DATA_OUT(n)               (((n)&0xFFFFFFFF) << 0)
N
N
N/***** SINCOS_DATA_IN_ADR *****/   
N/*! In SINCOS DMA mode, enter the starting address of the buffer.
N */
N#define LL_SINCOS_DATA_IN_ADR(n)            (((n)&0xFFFFFFFF) << 0)
N
N
N/***** SINCOS_DATA_OUT_ADR *****/
N/*! In SINCOS DMA mode, the starting address of the output buffer.
N */
N#define LL_SINCOS_DATA_OUT_ADR(n)           (((n)&0xFFFFFFFF) << 0)
N
N
N/**
N  * @}
N  */
N
N/** @defgroup SINCOS_LL_Exported_Constants SINCOS LL Exported Constants
N  * @ingroup  SINCOS_LL_Driver
N  * @brief    SINCOS LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for SINCOS radians value input mode selection.
N  */
Ntypedef enum {
N    /*! The input radians of SICNOS are selected from the memory, 
N     *  which is the memory space pointed to by dma_src_addr in
N     *  TYPE_LL_SINCOS_CFG. 
N     */
N    LL_SINCOS_RADIAN_MEM = 0,
N    /*! The input radians of SICNOS are selected to be incremented 
N     * according to the step size of the step. 
N     */
N    LL_SINCOS_RADIAN_STEP_INC,
N} TYPE_ENUM_LL_SINCOS_RADIAN;
N
N/**
N  * @brief Enumeration constant for SICNOS calculation mode selection.
N  */
Ntypedef enum {
N    /*! When the SICNOS calculation mode is selected to use the CPU mode, 
N     *  the input data is acquired from the data_in in the configuration 
N     *  structure TYPE_LL_SINCOS_CFG, and is calculated only once. 
N     */
N    LL_SINCOS_MODE_CPU = 0,
N    /*! When the SICNOS calculation mode is selected to use the DMA mode, 
N     *  the input data is obtained from the start address of dma_src_addr 
N     *  in the configuration structure TYPE_LL_SINCOS_CFG, and the space of 
N     *  length len is obtained, and a total of len times are calculated. 
N     */
N    LL_SINCOS_MODE_DMA,
N} TYPE_ENUM_LL_SINCOS_MODE;
N
N/**
N  * @brief Enumeration constant for SICNOS data format selection.
N  */
Ntypedef enum {
N    /*! SINCOS input data 32Bit, the format is {sin1, sin0}, 
N     *  each occupying 16Bit. 
N     */
N    LL_SINCOS_MODE_DATA_SIN = 0,
N    /*! SINCOS input data 32Bit, the format is {cos1, cos0}, 
N     *  each occupying 16Bit. 
N     */
N    LL_SINCOS_MODE_DATA_COS,
N    /*! SINCOS input data 32Bit, the format is {cos0, sin0}, 
N     *  each occupying 16Bit. 
N     */
N    LL_SINCOS_MODE_DATA_COSSIN,
N} TYPE_ENUM_LL_SINCOS_MODE_DATA_FORMAT;
N
N/**
N  * @}
N  */
N
N/** @defgroup SINCOS_LL_Exported_Struct SINCOS LL Exported Struct
N  * @ingroup  SINCOS_LL_Driver
N  * @brief    SINCOS LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the SINCOS registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_sincos_init. Function, you can configure the SINCOS module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief SINCOS low layer configuration structure
N  */
Ntypedef struct __ll_sincos_cfg {
N    /*! Configure the SINCOS radians value input mode selection.
N     *  Please refer to TYPE_ENUM_LL_SINCOS_RADIAN for the specific type.
N     */
N    TYPE_ENUM_LL_SINCOS_RADIAN           radian_sel;
N    /*! Configure the calculation mode of SINCOS, CPU mode or DMA mode.
N     *  Please refer to TYPE_ENUM_LL_SINCOS_MODE for the specific type.
N     */
N    TYPE_ENUM_LL_SINCOS_MODE             work_mode;
N    /*! Configure the data format of the SINCOS input buffer.
N     *  Please refer to TYPE_ENUM_LL_SINCOS_DATA_FORMAT for the specific type.
N     */
N    TYPE_ENUM_LL_SINCOS_MODE_DATA_FORMAT mode;
N    
N    /***** SINCOS CPU MODE *****/
N    /*! Only used in cpu mode.  
N     *  data_in = actual radian/PI*32768  
N     *  Effective radians is between 0 and 2*PI (not including 2*PI).  
N     *  @note The calculation result is equivalent to:  
N     *        eg: int radians = data_in/32768.0*PI;  
N     *            int sin_temp = (int)(sin(radians)*32768);
N     */
N    u16                                  data_in;
N    
N    /***** SINCOS DMA MODE *****/
N    /*! Configure the length of the SINCOS DMA input buffer.
N     */
N    u16                                  dma_points;
N    /*! Configure the step value of SINCOS.
N     */
N    u16                                  step;
N    /*! SINCOS DMA start address of input buffer, 8 byte aligned. 
N     *  The real part data is a 16-bit signed number with 15 bit
N     *  fixed point.
N     *  @note SINCOS0's dma_src_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3.  
N     *        SINCOS1's dma_src_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3.  
N     *        Statement example:  
N     *        static s16 sincos_ibuf[512] __attribute__((aligned(8),section("SRAM0")));
N     */
N    u32                                  dma_src_addr;
N    /*! SINCOS DMA start address of output buffer, 8 byte aligned. 
N     *  The real part data is a 16-bit signed number with 15 bit
N     *  fixed point.
N     *  @note SINCOS0's dma_dst_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3.  
N     *        SINCOS1's dma_dst_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3.  
N     *        Statement example:  
N     *        static s16 sincos_obuf[512*2] __attribute__((aligned(8),section("SRAM0")));
N     */
N    u32                                  dma_dst_addr;
N} TYPE_LL_SINCOS_CFG;
N
N/**
N  * @brief SINCOS low layer Initialization structure
N  */
Ntypedef struct __ll_sincos_init {
N    u8 reserved;
N} TYPE_LL_SINCOS_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup SINCOS_LL_Interrupt SINCOS LL Interrupt Handle function
N  * @brief    SINCOS LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SINCOS  
N    Interrupt Handle function.
N
N    how to use?
N
N    The SINCOS interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the SINCOS in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup SINCOS_LL_Inti_Cfg SINCOS LL Initialization And Configuration
N  * @brief    SINCOS LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SINCOS data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  SINCOS module initialization function
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @param  p_init  : Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_sincos_init(SINCOS_TypeDef *p_sincos, TYPE_LL_SINCOS_INIT *p_init);
N
N/**
N  * @brief  SINCOS module detele initialization function
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @retval None
N  */
Nvoid ll_sincos_deinit(SINCOS_TypeDef *p_sincos);
N
N/**
N  * @brief  SINCOS module configuration function
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @param  p_cfg   : Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_sincos_config(SINCOS_TypeDef *p_sincos, TYPE_LL_SINCOS_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup SINCOS_LL_Data_Transfers SINCOS LL Data transfers functions
N  * @brief    SINCOS LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SINCOS data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  SINCOS module start function
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @retval None
N  */
Nvoid ll_sincos_start(SINCOS_TypeDef *p_sincos);
N
N/**
N  * @brief  SINCOS module stop function
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @retval None
N  */
Nvoid ll_sincos_stop(SINCOS_TypeDef *p_sincos);
N
N/**
N  * @brief  SINCOS get finished pending
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @retval pending value
N  */
N#define LL_SINCOS_GET_DONE_PENDING(p_sincos)      ((p_sincos)->CON & LL_SINCOS_PEND)
N
N/**
N  * @brief  SINCOS clear pending
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @retval None.
N  */
N__STATIC_INLINE void ll_sincos_clear_done_pending(SINCOS_TypeDef *p_sincos) {
Xstatic __inline void ll_sincos_clear_done_pending(SINCOS_TypeDef *p_sincos) {
N    p_sincos->CON |= LL_SINCOS_PEND;
X    p_sincos->CON |= (1UL << 8);
N}
N
N/**
N  * @brief  SINCOS enable interrupt
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_sincos_interrupt_enable(SINCOS_TypeDef *p_sincos) {
Xstatic __inline void ll_sincos_interrupt_enable(SINCOS_TypeDef *p_sincos) {
N    p_sincos->CON |= LL_SINCOS_IE;
X    p_sincos->CON |= (1UL << 5);
N}
N
N/**
N  * @brief  SINCOS disable interrupt
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_sincos_interrupt_disable(SINCOS_TypeDef *p_sincos) {
Xstatic __inline void ll_sincos_interrupt_disable(SINCOS_TypeDef *p_sincos) {
N    p_sincos->CON &= ~(LL_SINCOS_IE);
X    p_sincos->CON &= ~((1UL << 5));
N}
N
N/**
N  * @brief  SINCOS set input data function
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @param  data: input data
N  * @retval None
N  */
N__STATIC_INLINE void ll_sincos_set_input_data(SINCOS_TypeDef *p_sincos, u16 data) {
Xstatic __inline void ll_sincos_set_input_data(SINCOS_TypeDef *p_sincos, u16 data) {
N    p_sincos->DATA_IN = data;
N}
N
N/**
N  * @brief  SINCOS Wait for the specified channel to finish computing
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_sincos_wait_done_pending(SINCOS_TypeDef *p_sincos) {
Xstatic __inline void ll_sincos_wait_done_pending(SINCOS_TypeDef *p_sincos) {
N    /* After the calculation is completed, pending is set to 1 and enable 
N     * is cleared. So the following 2 statements are equivalent
N     */
N    while(p_sincos->CON & LL_SINCOS_ENABLE);
X    while(p_sincos->CON & (1UL << 0));
N    p_sincos->CON |= LL_SINCOS_PEND;
X    p_sincos->CON |= (1UL << 8);
N}
N
N/**
N  * @brief  Get the SINCOS calculation result function.
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @param  p_result_h: Save the high 16bit of the sincos calculation result.
N  * @param  p_result_l: Save the low 16bit of the sincos calculation result.
N  * @retval None
N  */
N__STATIC_INLINE void ll_sincos_get_result(SINCOS_TypeDef *p_sincos, s16 *p_result_h, s16 *p_result_l) {
Xstatic __inline void ll_sincos_get_result(SINCOS_TypeDef *p_sincos, s16 *p_result_h, s16 *p_result_l) {
N    /* After the calculation is completed, pending is set to 1 and enable 
N     * is cleared. So the following 2 statements are equivalent
N     */
N    u32 result_data = 0;
N    while(p_sincos->CON & LL_SINCOS_ENABLE);
X    while(p_sincos->CON & (1UL << 0));
N    p_sincos->CON |= LL_SINCOS_PEND;
X    p_sincos->CON |= (1UL << 8);
N    
N    result_data = p_sincos->DATA_OUT;
N    *p_result_h = result_data >> 16;
N    *p_result_l = result_data & 0xFFFF;
N}
N
N/**
N  * @brief  Returns the SINCOS calculation result function.
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @retval Returns the result of SINCOS calculation, 32bit.
N  */
N__STATIC_INLINE u32 ll_sincos_return_result(SINCOS_TypeDef *p_sincos) {
Xstatic __inline u32 ll_sincos_return_result(SINCOS_TypeDef *p_sincos) {
N    /* After the calculation is completed, pending is set to 1 and enable 
N     * is cleared. So the following 2 statements are equivalent
N     */
N    while(p_sincos->CON & LL_SINCOS_PEND);
X    while(p_sincos->CON & (1UL << 8));
N    p_sincos->CON |= LL_SINCOS_PEND;
X    p_sincos->CON |= (1UL << 8);
N    
N    return p_sincos->DATA_OUT;
N}
N
N/**
N  * @brief  Sincos sin mode single point calculation function.
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @param  data    : input data
N  * @retval The calculation result of sin.
N  */
Ns16 ll_sincos_calculate_sin_once(SINCOS_TypeDef *p_sincos, u16 data);
N
N/**
N  * @brief  Sincos cos mode single point calculation function.
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @param  data    : input data
N  * @retval The calculation result of sin.
N  */
Ns16 ll_sincos_calculate_cos_once(SINCOS_TypeDef *p_sincos, u16 data);
N
N/**
N  * @brief  Sincos cos and sin mode single point calculation function.
N  * @param  p_sincos: Select the initialized SINCOS group pointer
N  * @param  data    : input data
N  * @param  p_sin   : Calculate the saved value of the result sin.
N  * @param  p_cos   : Calculate the saved value of the result cos.
N  * @retval The calculation result of sin and cos.
N  */
Nvoid ll_sincos_calculate_cossin_once(SINCOS_TypeDef *p_sincos, u16 data, s16 *p_sin, s16 *p_cos);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_SINCOS_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 42 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_spwm.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_spwm.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_spwm.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the SPWM LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_SPWM_H
N#define __TX_PHE_LL_SPWM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup spwm_interface_gr SPWM Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup SPWM_LL_Driver SPWM LL Driver
N  * @ingroup  spwm_interface_gr
N  * @brief Mainly the driver part of the SPWM module, which includes \b SPWM \b Register 
N  * \b Constants, \b SPWM \b Exported \b Constants, \b SPWM \b Exported \b Struct, \b SPWM
N  * \b Data \b transfers \b functions, \b SPWM \b Initialization \b and \b SPWM \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SPWM_LL_Register_Constants SPWM LL Register Constants
N  * @ingroup  SPWM_LL_Driver
N  * @brief    SPWM LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the SPWM 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the SPWM register, mainly for convenience. Understand the 
N    configuration of the SPWM.
N    
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** SPWM_CON Register *****/
N/*! auto-scale enable
N */
N#define LL_SPWM_AUTO_SCALE_EN                      (1UL << 26)
N/*! systerm error(osc stop or lvd) protect enable
N */
N#define LL_SPWM_SYSERR_PROTECT_EN                  (1UL << 25)
N/*! PWM configure SFR write enable. configure SFR Include:
N *  SPWM_CON[14:0]
N *  SPWM_PERIOD
N *  FAULT_INFO
N *  FAULT_INVERT
N *  1: CPU can write configure SFR.
N *  0: CPU can NOT write configure SFR .
N */
N#define LL_SPWM_CFG_EN                             (1UL << 24)
N/*! unit 64 clk
N */
N#define LL_SPWM_FAULT_DEBOUNCE(n)                  (((n)&0xF) << 20)
N/*! Clear data error pending
N */
N#define LL_SPWM_CLR_DATAERR_PD_ALL                 (1UL << 19)
N/*! Clear hardware protect pending
N */
N#define LL_SPWM_CLR_HWP_PD                         (1UL << 17)
N/*! Clear PWM enable
N */
N#define LL_SPWM_CLR_PWMEN                          (1UL << 16)
N/*! Data error pending
N */
N#define LL_SPWM_DATAERR_PD_ALL                     (1UL << 15)
N/*! Data error protect disable
N */
N#define LL_SPWM_DATAERR_DIS_ALL                    (1UL << 14)
N/*! PWM work : 1
N */
N#define LL_SPWM_WORK_FLAG                          (1UL << 13)
N/*! Data error interrupt enable
N */
N#define LL_SPWM_DATAERR_INT_EN_ALL                 (1UL << 12)
N/*! Hardware protect pending
N */
N#define LL_SPWM_HWP_PD                             (1UL << 11)
N/*! Hardware protect interrupt enable
N */
N#define LL_SPWM_HWP_INT_EN                         (1UL << 10)
N/*! Load data interrupt enable
N */
N#define LL_SPWM_LOAD_INT_EN_ALL                    (1UL << 9)
N/*! Hardware protect Disable
N */
N#define LL_SPWM_HWP_DIS                            (1UL << 8)
N/*! PWM Invert  
N *  1: Invert the PWM. Output 0 means IGBT ON.  
N *  0: Not invert the PWM. Output 1 means IGBT ON  
N */
N#define LL_SPWM_PWM_INVERT                         (1UL << 7)
N/*! Use PWM  
N *  1: Use this PWM  
N *  0: Not Use this PWM. The output always 0(PWM_INVERT==0) or 1(PWM_INVERT==1)  
N */
N#define LL_SPWM_SEL(n)                             (((n)&0x7) << 1)
N/*! SPWM enbale
N */
N#define LL_SPWM_PWM_EN                             (1UL << 0)
N
N
N/***** SPWM_PERIOD Register *****/
N/*! PERIOD unit : 1 sys clk
N */
N#define LL_SPWM_PWM_PERIOD(n)                      (((n)&0xFFFF) << 0) 
N
N
N/***** SPWM_PERIOD1 Register *****/
N /*! MIN_TIME unit : 2 sys clk
N  */
N#define LL_SPWM_MIN_TIME(n)                        (((n)&0xFFF) << 24) 
N/*! DEAD_TIME unit : 2 sys clk, must > 0
N */
N#define LL_SPWM_DEAD_TIME(n)                       (((n)&0xFFF) << 16)
N
N
N/***** SPWM_MATCH Register *****/
N/*! SPWM match pending clear
N */
N#define LL_SPWM_MATCH_PENDING_CLR                  (1UL << 20)
N/*! SPWM match pending 
N */
N#define LL_SPWM_MATCH_PENDING                      (1UL << 19)
N/*! SPWM match interrupt enable
N */
N#define LL_SPWM_MATCH_INT_EN                       (1UL << 18)
N/*! Select which PWM to compare with MATCH_VALUE  
N *  0:Disable compare  
N *  1:PWM0  
N *  2:PWM1  
N *  3:PWM2  
N */
N#define LL_SPWM_MATCH_SEL(n)                       (((n)&0x03) << 16)
N/*! If PWM counter equal this value, the MATCH_PENDING will be assert.  
N    This value range should be 0~ (PWM_PERIOD-1) 
N*/
N#define LL_SPWM_MATCH_VALUE(n)                     (((n)&0xFFFF) << 0) 
N
N
N/***** SPWM_ADCC Register *****/
N/*! ADC control enable. Select which ADC to control. adc:0~13  
N *  ADC_CONTROL_MODE select which mode to use.  
N *  1: Enable. If MATCH_PENDING change to 1, Start ADC convert at the same time  
N *  0: Disable  
N */
N#define LL_SPWM_CONTROL_ADC_EN(n)                   (((n)&0x3FFF) << 0)
N
N
N/***** SPWM_CNT0/1/2 Register *****/
N/*! Two level mode  
N *  1: Two level mode  
N *  0: Three level mode  
N */
N#define LL_SPWM_TWO_LEVEL                           (1UL << 22)
N/*! Dead balance mode enable. This mode only use at PWM_CARRIER_MODE==0.  
N *  If PWM_CARRIER_MODE==1, this bit unused.  
N *  Recommend set this bit to 1.  
N *  1: Enable. Balance Dead Time whatever data is positive or negative, But it may made pulse time 
N *     small than minimum pulse(mean MIN_PULSE). 
N *  0: Disable  
N */
N#define LL_SPWM_DEAD_BALANCE_MODE                   (1UL << 21)
N/*! spwm clear load data pending
N */
N#define LL_SPWM_CLR_LOAD_PD                         (1UL << 20)
N/*! spwm load data pending
N */
N#define LL_SPWM_LOAD_PD                             (1UL << 19)
N/*! spwm load data interrupt enable
N */
N#define LL_SPWM_LOAD_INT_EN                         (1UL << 18)
N/*! PWM data error detect disable  
N *  1: Disable PWM data error detect  
N *  0: Enable PWM data error detect  
N */
N#define LL_SPWM_DATAERR_DIS                         (1UL << 17)
N/*! PWM triangle carrier mode  
N *  0: Mode0. Positive and negative number have same phase. Data will load to the register while 
N *     triangle carrier counter==0.  
N *  1: Mode1. Positive and negative number have different phase. Recommend use this mode. Data will 
N *  load to the register while triangle carrier counter==MAX.  
N */
N#define LL_PWM_CARRIER_MODE                         (1UL << 16)
N/*! PWM counter initial direction 
N *  0: PWM counter will increase if start
N *  1: PWM counter will decrease if start
N */
N#define LL_PWM_CNT_INI_DIR                          (1UL << 15)
N/*! PWM counter initial value 
N */
N#define LL_PWM_CNT_INI_VAL(n)                       (((n)&0x7FFF) << 0)
N
N
N/***** FAULT_INFO Register *****/
N/*! Each Fault disable.  
N *  1: disable fault detect  
N *  0: enable fault detect  
N */
N#define LL_SPWM_FAULT_DIS(n)                        (((n)&0xFFFF) << 0)
N/*! There are 16 fault sources which are mapping to {PB28~PB31,PC0~PC11}.If the fault source is valid,
N *  this pending will set to one
N */
N#define LL_SPWM_FAULT_PD(n)                         (((n)&0xFFFF) << 16)
N
N
N/***** FAULT_INVERT Register *****/
N/*! Invert the Fault source  
N *  1: The fault source is valid when it's 0.  
N *  0: The fault source is valid when it's 1.  
N */
N#define LL_SPWM_FAULT_INVERT(n)                     (((n)&0xFFFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup SPWM_LL_Exported_Constants SPWM LL Exported Constants
N  * @ingroup  SPWM_LL_Driver
N  * @brief    SPWM LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N#define SPWM_DATA_MASK                          (0xFFFF)
N
N/**
N  * @brief SPWM match type.
N  */
Ntypedef enum {
N    /*! spwm match mode disable
N     */
N    LL_SPWM_MM_DISABLE = 0,
N    /*! spwm match mode sel spwm1
N     */
N    LL_SPWM_MM_SPWM1,
N    /*! spwm match mode sel spwm2
N     */
N    LL_SPWM_MM_SPWM2,
N    /*! spwm match mode sel spwm3
N     */
N    LL_SPWM_MM_SPWM3,
N} TYPE_ENUM_LL_SPWM_MATCH_MODE;
N
N/**
N  * @brief SPWM channel group type.
N  */
Ntypedef enum {
N    /*! spwm select none
N     */
N    LL_SPWM_SEL_NONE    = 0x0,
N    /*! spwm1 valid
N     */
N    LL_SPWM_SEL_SPWM1   = 0x1,
N    /*! spwm2 valid
N     */
N    LL_SPWM_SEL_SPWM2   = 0x2,
N    /*! spwm3 valid
N     */
N    LL_SPWM_SEL_SPWM3   = 0x4,
N    /*! spwm12 valid
N     */
N    LL_SPWM_SEL_SPWM12  = 0x3,
N    /*! spwm13 valid
N     */
N    LL_SPWM_SEL_SPWM13  = 0x5,
N    /*! spwm23 valid
N     */
N    LL_SPWM_SEL_SPWM23  = 0x6,
N    /*! spwm123 valid
N     */
N    LL_SPWM_SEL_SPWM123 = 0x7,
N} TYPE_ENUM_LL_SPWM_SEL;
N
N/**
N  * @brief SPWM counter dir type.
N  */
Ntypedef enum {
N    /*! spwm counter increase
N     */
N    LL_SPWM_CNT_DIR_INC = 0,
N    /*! spwm counter decrease
N     */
N    LL_SPWM_CNT_DIR_DEC = 1,
N} TYPE_ENUM_LL_SPWM_CNT_DIR;
N
N/**
N  * @brief SPWM level mode type.
N  */
Ntypedef enum {
N    /*! spwm level two
N     */
N    LL_SPWM_TWO_LEVEL_MODE   = 1,
N    /*! spwm level three
N     */
N    LL_SPWM_THREE_LEVEL_MODE = 0,
N} TYPE_ENUM_LL_SPWM_LEVEL_MODE;
N
N/**
N  * @brief SPWM carry mode type.
N  */
Ntypedef enum {
N    /*! spwm carry at counter == 0
N     */
N    LL_SPWM_CARRIER_AT_CNT_0   = 0,
N    /*! spwm carry at counter == max
N     */
N    LL_SPWM_CARRIER_AT_CNT_MAX = 1,
N} TYPE_ENUM_LL_SPWM_CARRIER_MODE;
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N
N
N/**
N  * @}
N  */
N
N/** @defgroup SPWM_LL_Exported_Struct SPWM LL Exported Struct
N  * @ingroup  SPWM_LL_Driver
N  * @brief    SPWM LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the SPWM registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_spwm_init. Function, you can configure the SPWM module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief SPWM interrupt configuration struct.
N  */
Ntypedef struct __ll_spwm_irq_cfg {
N    /*! fault_intr_en
N     */
N    bool fault_intr_en;
N    /*! match_intr_en 
N     */
N    bool match_intr_en;
N    /*! data_err_intr_en
N     */
N    bool data_err_intr_en;
N    /*! load_data0_intr_en
N     */
N    bool load_data0_intr_en;
N    /*! load_data1_intr_en
N     */
N    bool load_data1_intr_en;
N    /*! load_data2_intr_en
N     */
N    bool load_data2_intr_en;
N} TYPE_LL_SPWM_IRQ_CFG;
N
N
N/**
N  * @brief SPWM counter A/B/C group configuration struct.
N  */
Ntypedef struct __ll_spwm_cnt_cfg {
N    /*! cnt_init_val : 15bit value 
N     */
N    u16                             cnt_init_val;
N    /*! cnt_dir : 0(inc), 1(dec), TYPE_ENUM_LL_SPWM_CNT_DIR
N     */
N    TYPE_ENUM_LL_SPWM_CNT_DIR       cnt_dir;
N    /*! deadtime_balance_en : 1 (enable) 
N     */
N    bool                            deadtime_balance_en;
N    /*! level_mode : 1 (Two level mode)  0(Three level mode) TYPE_ENUM_LL_SPWM_LEVEL_MODE
N     */
N    TYPE_ENUM_LL_SPWM_LEVEL_MODE    level_mode;
N    /*! carrier_mode : 0(data load at cnt=0), 1(data load at cnt=max) 
N     */
N    TYPE_ENUM_LL_SPWM_CARRIER_MODE  carrier_mode;
N    /*! data_err_dis : 1(disable data error protect) 
N     */
N    bool                            data_err_dis;
N} SPWM_LL_CNT_CFG;
N
N/**
N  * @brief SPWM configuration struct.
N  */
Ntypedef struct __ll_spwm_cfg {
N    /*! fault valid control : [15:0] set to 1 means '0' valid 
N     *
N     * @brief  SPWM io init function
N     * @param  None
N     * @retval None
N     * @note   The GPIO use as follows:
N     *         |-------------------------------------------|
N     *         |                   |         GPIO          |
N     *         |-------------------------------------------|
N     *         | spwm_a0           |         PB3           |
N     *         | spwm_a1           |         PB2           |
N     *         | spwm_a2           |         PB1           |
N     *         | spwm_a3           |         PB0           |
N     *         | spwm_b0           |         PB7           |
N     *         | spwm_b1           |         PB6           |
N     *         | spwm_b2           |         PB5           |
N     *         | spwm_b3           |         PB4           |
N     *         | spwm_c0           |         PB11          |
N     *         | spwm_c1           |         PB10          |
N     *         | spwm_c2           |         PB9           |
N     *         | spwm_c3           |         PB8           |
N     *         | fault_msb2lsb     | {PB12~PB15,PC0~PC11}. |
N     *         |-------------------------------------------|
N     */
N    u16                             fault_invert;
N    /*! fault enable control : [15:0] set to 1 means disable fault detect 
N     */
N    u16                             fault_disable;
N    /*! fault_debunce_time : [3:0] Unit is system clock*64 
N     */
N    u8                              fault_debunce_time;
N    /*! fault_protect_en : 
N     */
N    bool                            fault_protect_en;
N    /*! match_kick_adc_chn_bits : [13:0] means adc[13:0] 
N     */
N    u16                             match_kick_adc_chn_bits;
N    /*! match_value : 0~ (PWM_PERIOD-1) 
N     */
N    u16                             match_value;
N    /*! match_work_mode : TYPE_SPWM_MATCH_MODE 
N     */
N    TYPE_ENUM_LL_SPWM_MATCH_MODE    match_work_mode;
N    /*! dead_time : [11:0] Unit is system clock*2 
N     */
N    u16                             dead_time;
N    /*! mini_time : [11:0] Unit is system clock*2 
N     */
N    u16                             mini_time;
N    /*! period :  sys_clk/(spwm_freq) [15:0] Unit is system clock 
N     */
N    u16                             period;
N    /*! output_invert_en : [15:0] set to 1 means output '0' valid 
N     */
N    bool                            output_invert_en;
N    /*! pwm_sel : TYPE_SPWM_SEL 
N     */
N    TYPE_ENUM_LL_SPWM_SEL           pwm_sel;
N    /*! SPWM counter A/B/C group configuration struct.
N     */
N    SPWM_LL_CNT_CFG                 pwm_chn[3];
N} TYPE_LL_SPWM_CFG;
N
N/**
N  * @brief initialization structure for low layer SPWM module 
N  */ 
Ntypedef struct __ll_spwm_init {
N    u8  reserved;
N} TYPE_LL_SPWM_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup SPWM_LL_Interrupt SPWM LL Interrupt Handle function
N  * @brief   SPWM LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SPWM  
N    Interrupt Handle function.
N
N    how to use?
N
N    The SPWM interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the SPWM in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup SPWM_LL_Inti_Cfg SPWM LL Initialization And Configuration
N  * @brief    SPWM LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SPWM data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N
N/**
N  * @brief  LL_SPWM_REG_OPT : use for config SPWM_CON register
N  * @param  expression : pointer to the hardware SPWM_TypeDef
N  * @retval None
N  */
N#define LL_SPWM_REG_OPT(expression)   \
Ndo {                                  \
N    SPWM->SPWM_CON |= LL_SPWM_CFG_EN; \
N    __asm("NOP");                     \
N    expression;                       \
N    SPWM->SPWM_CON &= ~LL_SPWM_CFG_EN;\
N} while(0)
X#define LL_SPWM_REG_OPT(expression)   do {                                      SPWM->SPWM_CON |= LL_SPWM_CFG_EN;     __asm("NOP");                         expression;                           SPWM->SPWM_CON &= ~LL_SPWM_CFG_EN;} while(0)
N
N/**
N  * @brief  ll_spwm_soft_reset : use for reset spwm 
N  * @retval None
N  */
N__STATIC_INLINE void ll_spwm_soft_reset(void) {
Xstatic __inline void ll_spwm_soft_reset(void) {
N    SYSCTRL->SYS_KEY = 0x4c5de9b3;
X    ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = 0x4c5de9b3;
N    SYSCTRL->SPWM_SOFTRESET = 0;
X    ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SPWM_SOFTRESET = 0;
N    __ASM("NOP"); __ASM("NOP"); __ASM("NOP"); __ASM("NOP");
X    __asm("NOP"); __asm("NOP"); __asm("NOP"); __asm("NOP");
N    SYSCTRL->SPWM_SOFTRESET = 1;
X    ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SPWM_SOFTRESET = 1;
N    SYSCTRL->SYS_KEY = 0;
X    ((SYSCTRL_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x6000))->SYS_KEY = 0;
N}
N
N/**
N  * @brief  spwm_init
N  * @param  p_spwm : pointer to the hardware SPWM_TypeDef
N  * @param  p_init : pointer to the init struct TYPE_LL_SPWM_INIT
N  * @retval None
N  */
Nvoid ll_spwm_init(SPWM_TypeDef *p_spwm, TYPE_LL_SPWM_INIT *p_init);
N
N/**
N  * @brief  spwm_deinit
N  * @param  p_spwm : pointer to the hardware SPWM_TypeDef
N  * @retval None
N  */
Nvoid ll_spwm_deinit(SPWM_TypeDef *p_spwm);
N
N/**
N  * @brief  spwm config
N  * @param  p_spwm : pointer to the hardware SPWM_TypeDef
N  * @param  p_cfg  : pointer to the init struct TYPE_LL_SPWM_IRQ_CFG
N  * @retval None
N  */
Nvoid ll_spwm_irq_config(SPWM_TypeDef *p_spwm, TYPE_LL_SPWM_IRQ_CFG *p_cfg);
N
N/**
N  * @brief  spwm config
N  * @param  p_spwm : pointer to the hardware SPWM_TypeDef
N  * @param  p_cfg  : pointer to the init struct TYPE_LL_SPWM_CFG
N  * @retval None
N  */
Nvoid ll_spwm_config(SPWM_TypeDef *p_spwm, TYPE_LL_SPWM_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup SPWM_LL_Data_Transfers SPWM LL Data transfers functions
N  * @brief    SPWM LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SPWM data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  spwm_start
N  * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N  * @retval None
N  */
Nvoid ll_spwm_start(SPWM_TypeDef *p_spwm);
N
N/**
N  * @brief  spwm stop
N  * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N  * @retval None
N  */
Nvoid ll_spwm_stop(SPWM_TypeDef *p_spwm);
N
N/**
N * @brief  LL_SPWM_GET_HARDFAULT
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval fault_info
N */
N#define LL_SPWM_GET_HARDFAULT(p_spwm)             ((((p_spwm)->SPWM_FAULT_INFO >> 16) & 0xFFFF) & \
N                                                   (~((p_spwm)->SPWM_FAULT_INFO >> 0) & 0xFFFF) )
X#define LL_SPWM_GET_HARDFAULT(p_spwm)             ((((p_spwm)->SPWM_FAULT_INFO >> 16) & 0xFFFF) &                                                    (~((p_spwm)->SPWM_FAULT_INFO >> 0) & 0xFFFF) )
N
N/**
N * @brief  LL_SPWM_GET_WORK_STA
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval working state
N */
N#define LL_SPWM_GET_WORK_STA(p_spwm)              ((p_spwm)->SPWM_CON & LL_SPWM_WORK_FLAG)
N
N/**
N * @brief  ll_spwm_match_interrupt_enable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_match_interrupt_enable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_match_interrupt_enable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_MATCH |= LL_SPWM_MATCH_INT_EN;
X    p_spwm->SPWM_MATCH |= (1UL << 18);
N}
N
N/**
N * @brief  ll_spwm_match_interrupt_disable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_match_interrupt_disable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_match_interrupt_disable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_MATCH &= ~LL_SPWM_MATCH_INT_EN;
X    p_spwm->SPWM_MATCH &= ~(1UL << 18);
N}
N
N/**
N * @brief  LL_SPWM_CHECK_MATCH_INTERRUPT_ENABLE
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval interrupt_enable
N */
N#define LL_SPWM_CHECK_MATCH_INTERRUPT_ENABLE(p_spwm)    ((p_spwm)->SPWM_MATCH & LL_SPWM_MATCH_INT_EN)
N
N/**
N * @brief  LL_SPWM_GET_MATCH_PENDING
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval pending
N */
N#define LL_SPWM_GET_MATCH_PENDING(p_spwm)               ((p_spwm)->SPWM_MATCH & LL_SPWM_MATCH_PENDING)
N
N/**
N * @brief  ll_spwm_clear_match_pending
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_clear_match_pending(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_clear_match_pending(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_MATCH |= LL_SPWM_MATCH_PENDING_CLR;
X    p_spwm->SPWM_MATCH |= (1UL << 20);
N}
N
N/**
N * @brief  ll_spwm_hwp_interrupt_enable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_hwp_interrupt_enable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_hwp_interrupt_enable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CON |= LL_SPWM_HWP_INT_EN;
X    p_spwm->SPWM_CON |= (1UL << 10);
N}
N
N/**
N * @brief  ll_spwm_hwp_interrupt_disable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_hwp_interrupt_disable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_hwp_interrupt_disable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CON &= ~LL_SPWM_HWP_INT_EN;
X    p_spwm->SPWM_CON &= ~(1UL << 10);
N}
N
N/**
N * @brief  LL_SPWM_CHECK_HWP_INTERRUPT_ENABLE
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval interrupt_enable
N */
N#define LL_SPWM_CHECK_HWP_INTERRUPT_ENABLE(p_spwm)  ((p_spwm)->SPWM_CON & LL_SPWM_HWP_INT_EN)
N
N/**
N * @brief  LL_SPWM_GET_HWP_PENDING
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval pending
N */
N#define LL_SPWM_GET_HWP_PENDING(p_spwm)             ((p_spwm)->SPWM_CON |= LL_SPWM_HWP_PD)
N
N/**
N * @brief  ll_spwm_clear_hwp_pending
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_clear_hwp_pending(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_clear_hwp_pending(SPWM_TypeDef *p_spwm) {
N    LL_SPWM_REG_OPT((p_spwm)->SPWM_CON |= LL_SPWM_CLR_HWP_PD);
X    do { ((SPWM_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x5000) + 0x280))->SPWM_CON |= (1UL << 24); __asm("NOP"); (p_spwm)->SPWM_CON |= (1UL << 17); ((SPWM_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x5000) + 0x280))->SPWM_CON &= ~(1UL << 24);} while(0);
N}
N
N/**
N * @brief  ll_spwm_dataerr_interrupt_enable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_dataerr_interrupt_enable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_dataerr_interrupt_enable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CON |= LL_SPWM_DATAERR_INT_EN_ALL;
X    p_spwm->SPWM_CON |= (1UL << 12);
N}
N
N/**
N * @brief  ll_spwm_dataerr_interrupt_disable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_dataerr_interrupt_disable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_dataerr_interrupt_disable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CON &= ~LL_SPWM_DATAERR_INT_EN_ALL;
X    p_spwm->SPWM_CON &= ~(1UL << 12);
N}
N
N/**
N * @brief  LL_SPWM_CHECK_DATAERR_INTERRUPT_ENABLE
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval interrupt_enable
N */
N#define LL_SPWM_CHECK_DATAERR_INTERRUPT_ENABLE(p_spwm)  ((p_spwm)->SPWM_CON & LL_SPWM_DATAERR_INT_EN_ALL)
N
N/**
N * @brief  LL_SPWM_GET_DATAERR_PENDING
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval pending
N */
N#define LL_SPWM_GET_DATAERR_PENDING(p_spwm)             ((p_spwm)->SPWM_CON & LL_SPWM_DATAERR_PD_ALL)
N
N/**
N * @brief  ll_spwm_clear_dataerr_pending
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_clear_dataerr_pending(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_clear_dataerr_pending(SPWM_TypeDef *p_spwm) {
N    LL_SPWM_REG_OPT((p_spwm)->SPWM_CON |= LL_SPWM_CLR_DATAERR_PD_ALL);
X    do { ((SPWM_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x5000) + 0x280))->SPWM_CON |= (1UL << 24); __asm("NOP"); (p_spwm)->SPWM_CON |= (1UL << 19); ((SPWM_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x5000) + 0x280))->SPWM_CON &= ~(1UL << 24);} while(0);
N}
N
N/**
N * @brief  ll_spwm_load_data0_interrupt_enable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_load_data0_interrupt_enable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_load_data0_interrupt_enable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CNT0 |= LL_SPWM_LOAD_INT_EN;
X    p_spwm->SPWM_CNT0 |= (1UL << 18);
N}
N
N/**
N * @brief  ll_spwm_load_data0_interrupt_disable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_load_data0_interrupt_disable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_load_data0_interrupt_disable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CNT0 &= ~LL_SPWM_LOAD_INT_EN;
X    p_spwm->SPWM_CNT0 &= ~(1UL << 18);
N}
N
N/**
N * @brief  ll_spwm_load_data1_interrupt_enable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_load_data1_interrupt_enable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_load_data1_interrupt_enable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CNT1 |= LL_SPWM_LOAD_INT_EN;
X    p_spwm->SPWM_CNT1 |= (1UL << 18);
N}
N
N/**
N * @brief  ll_spwm_load_data1_interrupt_disable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_load_data1_interrupt_disable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_load_data1_interrupt_disable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CNT1 &= ~LL_SPWM_LOAD_INT_EN;
X    p_spwm->SPWM_CNT1 &= ~(1UL << 18);
N}
N
N/**
N * @brief  ll_spwm_load_data2_interrupt_enable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_load_data2_interrupt_enable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_load_data2_interrupt_enable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CNT2 |= LL_SPWM_LOAD_INT_EN;
X    p_spwm->SPWM_CNT2 |= (1UL << 18);
N}
N
N/**
N * @brief  ll_spwm_load_data2_interrupt_disable
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_load_data2_interrupt_disable(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_load_data2_interrupt_disable(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CNT2 &= ~LL_SPWM_LOAD_INT_EN;
X    p_spwm->SPWM_CNT2 &= ~(1UL << 18);
N}
N
N/**
N * @brief  LL_SPWM_CHECK_LOAD_INTERRUPT_ENABLE
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @param  n     : 0/1/2 for spwm A/B/C
N * @retval interrupt_enable
N */
N#define LL_SPWM_CHECK_LOAD_INTERRUPT_ENABLE(p_spwm, n)      ((p_spwm)->SPWM_CNT##n & LL_SPWM_LOAD_INT_EN)
N
N/**
N * @brief  LL_SPWM_GET_LOAD_PENDING
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @param  n     : 0/1/2 for spwm A/B/C
N * @retval pending
N */
N#define LL_SPWM_GET_LOAD_PENDING(p_spwm, n)                 ((p_spwm)->SPWM_CNT##n & LL_SPWM_LOAD_PD)
N
N/**
N * @brief  ll_spwm_clear_load_data0_pending
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_clear_load_data0_pending(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_clear_load_data0_pending(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CNT0 |= LL_SPWM_CLR_LOAD_PD;
X    p_spwm->SPWM_CNT0 |= (1UL << 20);
N}
N
N/**
N * @brief  ll_spwm_clear_load_data1_pending
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_clear_load_data1_pending(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_clear_load_data1_pending(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CNT1 |= LL_SPWM_CLR_LOAD_PD;
X    p_spwm->SPWM_CNT1 |= (1UL << 20);
N}
N
N/**
N * @brief  ll_spwm_clear_load_data2_pending
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_clear_load_data2_pending(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_clear_load_data2_pending(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_CNT2 |= LL_SPWM_CLR_LOAD_PD;
X    p_spwm->SPWM_CNT2 |= (1UL << 20);
N}
N
N/**
N * @brief  ll_spwm_fill_databuf0
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @param  dat   : spwm data
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_fill_databuf0(SPWM_TypeDef *p_spwm, s16 dat) {
Xstatic __inline void ll_spwm_fill_databuf0(SPWM_TypeDef *p_spwm, s16 dat) {
N    p_spwm->SPWM_DATABUF0 = dat;
N}
N
N/**
N * @brief  ll_spwm_fill_databuf1
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @param  dat   : spwm data
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_fill_databuf1(SPWM_TypeDef *p_spwm, s16 dat) {
Xstatic __inline void ll_spwm_fill_databuf1(SPWM_TypeDef *p_spwm, s16 dat) {
N    p_spwm->SPWM_DATABUF1 = dat;
N}
N
N/**
N * @brief  ll_spwm_fill_databuf2
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @param  dat   : spwm data
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_fill_databuf2(SPWM_TypeDef *p_spwm, s16 dat) {
Xstatic __inline void ll_spwm_fill_databuf2(SPWM_TypeDef *p_spwm, s16 dat) {
N    p_spwm->SPWM_DATABUF2 = dat;
N}
N
N/**
N * @brief  ll_spwm_clear_databuf
N * @param  p_spwm: pointer to the hardware SPWM_TypeDef
N * @retval none
N */
N__STATIC_INLINE void ll_spwm_clear_databuf(SPWM_TypeDef *p_spwm) {
Xstatic __inline void ll_spwm_clear_databuf(SPWM_TypeDef *p_spwm) {
N    p_spwm->SPWM_DATAUSE0 = 0;
N    p_spwm->SPWM_DATAUSE1 = 0;
N    p_spwm->SPWM_DATAUSE2 = 0;
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_SPWM_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 43 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_eflash.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_eflash.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_eflash.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.2
N  * @date    04-08-2019
N  * @brief   This file contains all the EFLASH LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_EFLASH_H
N#define __TX_PHE_LL_EFLASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup eflash_interface_gr EFLASH Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup EFLASH_LL_Driver EFLASH LL Driver
N  * @ingroup  eflash_interface_gr
N  * @brief Mainly the driver part of the EFLASH module, which includes \b EFLASH \b Register 
N  * \b Constants, \b EFLASH \b Exported \b Constants, \b EFLASH \b Exported \b Struct, \b EFLASH
N  * \b Data \b transfers \b functions, \b EFLASH \b Initialization \b and \b EFLASH \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N     
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N     
N/** @defgroup EFLASH_LL_Register_Constants EFLASH LL Register Constants
N  * @ingroup  EFLASH_LL_Driver
N  * @brief    EFLASH LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the EFLASH 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the EFLASH register, mainly for convenience. Understand the 
N    configuration of the EFLASH.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N
N/***** CTRLR0 Register *****/
N/*! eflash_program_clk_sel : TYPE_ENUM_LL_EF_PG_CLK_SEL
N */
N#define LL_EF_PG_CLK_SEL(n)                     (((n)&0x3) << 16)
N/*! directly output, not use prefetch & cache
N */
N#define LL_EF_DIRCTLY_OUT                       (1UL << 7)
N/*! Program/Erase Request buffer mode
N */
N#define LL_EF_BLK_REQ_MODE_EN                   (1UL << 5)
N/*! Program/Sector Erase auto write back to cache
N */
N#define LL_EF_CACHE_WRITEBACK_EN                (1UL << 4)
N/*! Little-endian mode 
N */
N#define LL_EF_DATA_LITTLE_ENDIAN_EN             (1UL << 3)
N/*! Prefetch Enable
N */
N#define LL_EF_PREFETCH_EN                       (1UL << 2)
N/*! cache enable
N */
N#define LL_EF_CACHE_EN                          (1UL << 0)
N
N
N/***** KST Register *****/
N/*! CRC DMA Kick Start EN 
N */
N#define LL_EF_CRC_DMA_KST_EN                    (1UL << 26)
N/*! Cache Clear Kick Start EN
N */
N#define LL_EF_CACHE_CLR_KST_EN                  (1UL << 20)
N/*! Deep Standby Kick Start EN
N */
N#define LL_EF_DSTANDBY_KST_EN                   (1UL << 19)
N/*! Wakeup Kick Start EN
N */
N#define LL_EF_WAKEUP_KST_EN                     (1UL << 18)
N/*! CRC DMA Kick Start
N */
N#define LL_EF_CRC_DMA_KST                       (1UL << 10)
N/*! Cache Clear Kick Start 
N */
N#define LL_EF_CACHE_CLR_KST                     (1UL << 4)
N/*! Deep Standby Kick Start
N */
N#define LL_EF_DSTANDBY_KST                      (1UL << 3)
N/*! Wakeup Kick Start
N */
N#define LL_EF_WAKEUP_KST                        (1UL << 2)
N
N
N/***** DONE Register *****/
N/*! CRC done flag
N */
N#define LL_EF_CRC_DONE                          (1UL << 10)
N/*! Chip erase error flag
N */
N#define LL_EF_CHIP_ERASE_ERR                    (1UL << 9)
N/*! Sector erase error flag 
N */
N#define LL_EF_SECTOR_ERASE_ERR                  (1UL << 8)
N/*! Program finished done flag 
N */
N#define LL_EF_PROG_DONE                         (1UL << 6)
N/*! Program FIFO Done flag 
N */
N#define LL_EF_PROG_FIFO_EMPTY                   (1UL << 5)
N/*! Cache Clear Done flag 
N */
N#define LL_EF_CACHE_CLR_DONE                    (1UL << 4)
N/*! Deep Standby Done flag 
N */
N#define LL_EF_DSTANDBY_DONE                     (1UL << 3)
N/*! Wakeup Done flag 
N */
N#define LL_EF_WAKEUP_DONE                       (1UL << 2)
N/*! Chip Erase Done flag 
N */
N#define LL_EF_CHIP_ERASE_DONE                   (1UL << 1)
N/*! Sector Erase Done flag 
N */
N#define LL_EF_SECT_ERASE_DONE                   (1UL << 0)
N/*! eflash busy flag 
N */
N#define LL_EF_BUSY_MASK                         (LL_EF_SECT_ERASE_DONE  |\
N                                                 LL_EF_CHIP_ERASE_DONE  |\
N                                                 LL_EF_CACHE_CLR_DONE   |\
N                                                 LL_EF_PROG_DONE        |\
N                                                 LL_EF_PROG_FIFO_EMPTY)
X#define LL_EF_BUSY_MASK                         (LL_EF_SECT_ERASE_DONE  |                                                 LL_EF_CHIP_ERASE_DONE  |                                                 LL_EF_CACHE_CLR_DONE   |                                                 LL_EF_PROG_DONE        |                                                 LL_EF_PROG_FIFO_EMPTY)
N
N
N/***** PROG_ADDR Register *****/
N/*! Program Burst Mode 
N */
N#define LL_EF_PROG_BURST_MODE_EN                (1UL << 30)
N/*! Program Byte num 
N */
N#define LL_EF_PROG_BYTE(n)                      (((n)&0x3) << 24)
N/*! Program Address 
N */
N#define LL_EF_PROG_BYTE_ADDR(n)                 (((n)&0xFFFFFF) << 0)
N
N
N/***** PROG_DATA Register *****/
N/*! Eflash programming data, need to configure the address before proceeding 
N */
N#define LL_EF_PROG_DATA(n)                      (((n)&0xFFFFFFFF) << 0)
N
N
N/***** ERASE_CTRL Register *****/
N/*! Chip full erase trigger, write "1" trigger, you need to configure the password
N */
N#define LL_EF_CHIP_ERASE_KST                    (1UL << 31)
N/*! Sector erase trigger, write "1" trigger,need to configure the password
N */
N#define LL_EF_SECTOR_ERASE_KST                  (1UL << 30)
N/*! Erase sector selection, range: 0-259  
N                                   0-255 is the sector of the main area, 
N                                   256-259 is the area of the nvr 
N*/
N#define LL_EF_ERASE_SECTOR_ADDR(n)              (((n)&0x1FF) << 0)
N
N
N/***** TIME_REG0 Register *****/
N/*! WEb low to PROG2 high hold min time is 15ns
N */
N#define LL_EF_REG0_PGH(n)                       (((n)&0xF) << 16)
N/*! BYTE/Address/data setup min time is 15ns 
N */
N#define LL_EF_REG0_ADS(n)                       (((n)&0xF) << 12)
N/*! BYTE/Address/data hold min time is 15ns 
N */
N#define LL_EF_REG0_ADH(n)                       (((n)&0xF) << 8)
N/*! Latency to next operation after PROG/ERASE low min time is 100ns 
N */
N#define LL_EF_REG0_RW(n)                        (((n)&0xF) << 4)
N/*! Read Cycle Min Time is 25/30ns 
N */
N#define LL_EF_REG0_RC(n)                        (((n)&0xF) << 0)
N
N
N/***** TIME_REG1 Register *****/
N/*! 1ms time configuration value, in units of 1us 
N */
N#define LL_EF_REG1_MS(n)                        (((n)&0x7FF) << 8)
N /*! 1us time configuration value, the system default is 26MHz 
N  */
N#define LL_EF_REG1_US(n)                        (((n)&0xFF) << 0)
N
N
N/***** CRC_DMA Register *****/
N/*! unit: 4byte 
N */
N#define LL_EF_CRC_DMA_LEN(n)                    (((n)&0xFFFF) << 16)
N/*! word address, phyic addr 
N */
N#define LL_EF_CRC_DMA_ADDR(n)                   (((n)&0xFFFF) << 0)
N
N
N/* start of eflash security area , not opened */
N/***** EFLASH_STA Register *****/
N/*! sector erase enable 
N */
N#define LL_EF_SECTOR_ERASE_EN                   (1UL << 10)
N/*! 1:128kB, 0:124kB 
N */
N#define LL_EF_128KB_MODE                        (1UL << 8)
N/*! 1 means cfg is all '1' 
N */
N#define LL_EF_MAIN_CFG_EMPTY                    (1UL << 7)
N/*! 1 means cfg is right, CRC ok 
N */
N#define LL_EF_MAIN_CFG_OK                       (1UL << 6)
N/*! 1 means NVR3 UUID CRC OK 
N */
N#define LL_EF_UUID_OK                           (1UL << 5)
N/*! 1 means chip is protected, can't read eflash code 
N */
N#define LL_EF_PROTECT_EN                        (1UL << 4)
N/*! 0 means enter eflash write mode 
N */
N#define LL_EF_WRITE_MODE_DIS                    (1UL << 3)
N/*! 1 means enter eflash normal mode 
N */
N#define LL_EF_NOR_MODE_EN                       (1UL << 2)
N/*! 1 means enter eflash spec erase mode, erase main/nvr 
N */
N#define LL_EF_SPEC_ERASE_MODE_EN                (1UL << 1)
N/*! 1 means eflash NVR4 is all '1' 
N */
N#define LL_EF_BLANK_CHIP_FLAG                   (1UL << 0)
N
N
N/***** PERMISSION0 Register *****/
N/*! eflash nvr0/1/2 write permisson : bit field for sector permission 
N */
N#define LL_EF_NVR_PERMISSION(n)                 (((n)&0x7) << 0)
N
N
N/***** PERMISSION1 Register *****/
N/*! eflash main array write permisson : bit field for sector permission 
N */
N#define LL_EF_MAIN_PERMISSION(n)                (((n)) << 0)
N
N
N/**
N  * @}
N  */
N
N/** @defgroup EFLASH_LL_Exported_Constants EFLASH LL Exported Constants
N  * @ingroup  EFLASH_LL_Driver
N  * @brief    EFLASH LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N/*! eflash sector size 
N */
N#define LL_EF_SECTOR_SIZE           512
N/*! eflash sector numbers 
N */
N#define LL_EF_SECTOR_NUMBERS        256
N/*! eflash sector numbers 
N */
N#define LL_EF_NVR_SECTOR_NUMBERS    3
N/*! eflash base address 
N */
N#define LL_EF_STADDR                0x08000000
N/*! eflash end address 
N */
N#define LL_EF_ENDADDR               (LL_EF_STADDR + LL_EF_SECTOR_NUMBERS*LL_EF_SECTOR_SIZE)
N/*! eflash NVR base address 
N */
N#define LL_EF_NVR_STADDR            0x08020000
N/*! eflash NVR end address 
N */
N#define LL_EF_NVR_ENDADDR           (LL_EF_NVR_STADDR + LL_EF_NVR_SECTOR_NUMBERS*LL_EF_SECTOR_SIZE)
N/*! eflash chip infor & param base address 
N */
N#define LL_EF_CHIP_PARAM_STADDR     0x08020600
N/*! eflash password for main 
N */
N#define LL_EF_MAIN_PASSWORD         0x20170230
N/*! eflash password for nvr 
N */
N#define LL_EF_NVR_PASSWORD          0x20150931
N
N
N
N/***** LL API *****/
N
N
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief EFLASH proramming clock selection
N  */
Ntypedef enum {
N    /*! EFLASH proram clk : rc 8Mhz 
N     */
N    LL_EF_PG_CLK_IRC8M   = 0,
N    /*! EFLASH proram clk : sys pll 
N     */
N    LL_EF_PG_CLK_SYS_PLL = 1,
N    /*! EFLASH proram clk : adc pll 
N     */
N    LL_EF_PG_CLK_ADC_PLL = 2,
N    /*! EFLASH proram clk : osc 26Mhz
N     */
N    LL_EF_PG_CLK_HXOSC   = 3,
N} TYPE_ENUM_LL_EF_PG_CLK_SEL;
N
N/**
N  * @}
N  */
N
N/** @defgroup EFLASH_LL_Exported_Struct EFLASH LL Exported Struct
N  * @ingroup  EFLASH_LL_Driver
N  * @brief    EFLASH LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the EFLASH registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_eflash_init. Function, you can configure the EFLASH module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief configuration structure for saradc/fsaradc calibration
N  */
Ntypedef struct __ll_eflash_adc_calibration {
N    /*! gain = gain_act/2
N     */
N    u16 gain;
N    /*! dc offset 
N     */
N    u16 dc_offset;
N} TYPE_LL_EFLASH_ADC_CALIBRATION;
N
N/**
N  * @brief configuration structure for chip infor & param
N  */
Ntypedef struct __ll_eflash_chip_param {
N    /*! uuid
N     */
N    u32                             uuid[3];
N    /*! fadc_calibration 
N     */
N    TYPE_LL_EFLASH_ADC_CALIBRATION  fadc_cab;
N    /*!  temperature sensor offset :
N     *      floor((0.00499*25+1.34125)/(3.0/4096)) - ts_adc_reg_data 
N     */
N    u32                             temperature_offset;
N    /*! chip id
N     */
N    u32                             chip_id;
N    /*! 
N     */
N    u32                             reserved;
N    /*! eflash size : unit sector(512B)
N     */
N    u16                             eflash_size;
N    /*! sram size : unit sector(512B)
N     */
N    u16                             sram_size;
N    /*! crc32
N     */
N    u32                             crc32;
N    /*! fsaradc coef
N     */
N    u32                             fsaradc_coef[16];
N    /*! crc32
N     */
N    u32                             crc32_fsaradc_coef;
N    /*! saradc_calibration 
N     */
N    TYPE_LL_EFLASH_ADC_CALIBRATION  saradc_cab[14];
N    /*! crc32
N     */
N    u32                             crc32_saradc_cab;
N} TYPE_LL_EFLASH_CHIP_PARAM;
N
N/**
N  * @brief configuration structure for low layer eflash configure
N  */
Ntypedef struct __ll_eflash_cfg {
N    /*! eflash program clk sel TYPE_ENUM_LL_EF_PG_CLK_SEL 
N     */
N    TYPE_ENUM_LL_EF_PG_CLK_SEL  pgclk_src_sel;
N    /*! eflash clk 
N     */
N    u32                         clk;
N    /*! eflash data little endian mode enable 
N     */
N    bool                        data_endian_lit_en;
N    /*! eflash erase & program cmd cache enable 
N     */
N    bool                        cmd_cache_en;
N    /*! eflash prefetch enable 
N     */
N    bool                        prefetch_en;
N    /*! eflash cache enable 
N     */
N    bool                        cache_en;
N    /*! read direct from eflash, skip cache & prefetch 
N     */
N    bool                        read_directly_en;
N} TYPE_LL_EFLASH_CFG;
N
N/**
N  * @brief initialization structure for low layer EFLASH 
N  */ 
Ntypedef struct __ll_eflash_init {
N    u8 reserved;
N} TYPE_LL_EFLASH_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup EFLASH_LL_Interrupt EFLASH LL Interrupt Handle function
N  * @brief   EFLASH LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the EFLASH  
N    Interrupt Handle function.
N
N    how to use?
N
N    The EFLASH interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the EFLASH in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup EFLASH_LL_Inti_Cfg EFLASH LL Initialization And Configuration
N  * @brief    EFLASH LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the EFLASH data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  ll_eflash_init
N  * @param  p_ef     : EFLASH_TypeDef pointer to eflash hardware register
N  * @param  p_init   : TYPE_LL_EFLASH_INIT pointer to eflash init stuct
N  * @retval None
N  * @note eflash clk : 26Mhz safty, but Need to be set to 8M on the FPGA
N  */
Nvoid ll_eflash_init(EFLASH_TypeDef *p_ef, TYPE_LL_EFLASH_INIT *p_init);
N
N/**
N  * @brief  ll_eflash_deinit
N  * @param  p_ef     : EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  * @note eflash clk : 26Mhz safty, but Need to be set to 8M on the FPGA
N  */
Nvoid ll_eflash_deinit(EFLASH_TypeDef *p_ef);
N
N/**
N  * @brief  ll_eflash_config
N  * @param  p_ef     : EFLASH_TypeDef pointer to eflash hardware register
N  * @param  p_cfg    : TYPE_LL_EFLASH_CFG pointer to eflash init stuct
N  * @retval None
N  * @note eflash clk : 26Mhz safty, but Need to be set to 8M on the FPGA
N  */
Nvoid ll_eflash_config(EFLASH_TypeDef *p_ef, TYPE_LL_EFLASH_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup EFLASH_LL_Data_Transfers EFLASH LL Data transfers functions
N  * @brief    EFLASH LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the EFLASH data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  ll_eflash_erase_chip
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  * @note eflash clk 26Mhz safty, but Need to be set to 8M on the FPGA
N  */
Nvoid ll_eflash_erase_chip(EFLASH_TypeDef *p_ef);
N
N/**
N  * @brief  ll_eflash_erase_chip
N  * @param  p_ef        : EFLASH_TypeDef pointer to eflash hardware register
N  * @param  sector_index: 0 ~ 255, one sector is 512Byte
N  * @retval None
N  */
Nvoid ll_eflash_erase_sector(EFLASH_TypeDef *p_ef, u16 sector_index);
N
N/**
N  * @brief  ll_eflash_prog_word
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @param  addr: Write data address in eflash, logical addr
N  * @param  data: Write data to eflash
N  * @retval None
N  */
Nvoid ll_eflash_prog_word(EFLASH_TypeDef *p_ef, u32 addr, u32 data);
N
N/**
N  * @brief  ll_eflash_erase_sector_nvr
N  * @param  p_ef        : EFLASH_TypeDef pointer to eflash hardware register
N  * @param  sector_index: LL_EF_NVR_SECTOR_NUMBERS, one sector is 512Byte
N  * @retval None
N  */
Nvoid ll_eflash_erase_sector_nvr(EFLASH_TypeDef *p_ef, u16 sector_index);
N
N/**
N  * @brief  ll_eflash_prog_word
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @param  addr: Write data address in NVR,logical addr
N  * @param  data: Write data to eflash
N  * @retval None
N  */
Nvoid ll_eflash_prog_word_nvr(EFLASH_TypeDef *p_ef, u32 addr, u32 data);
N
N#if 0
S/**
S  * @brief  ll_eflash_crc32 : x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1
S  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
S  * @param  addr: 4byte unit
S  * @param  len :  4byte unit
S  * @retval crc32 result
S  */
Su32 ll_eflash_crc32(EFLASH_TypeDef *p_ef, u32 addr, u32 len);
N#endif
N
N/**
N  * @brief  ll_eflash_main_lock
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @param  lock: 1=lock
N  * @retval None
N  */
N__STATIC_INLINE void ll_eflash_main_lock(EFLASH_TypeDef *p_ef, bool lock) {
Xstatic __inline void ll_eflash_main_lock(EFLASH_TypeDef *p_ef, bool lock) {
N    p_ef->MAIN_PASSWORD = lock ? 0 :LL_EF_MAIN_PASSWORD;
X    p_ef->MAIN_PASSWORD = lock ? 0 :0x20170230;
N}
N
N/**
N  * @brief  ll_eflash_nvr_lock
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @param  lock: 1=lock
N  * @retval None
N  */
N__STATIC_INLINE void ll_eflash_nvr_lock(EFLASH_TypeDef *p_ef, bool lock) {
Xstatic __inline void ll_eflash_nvr_lock(EFLASH_TypeDef *p_ef, bool lock) {
N    p_ef->NVR_PASSWORD = lock ? 0 :LL_EF_NVR_PASSWORD;
X    p_ef->NVR_PASSWORD = lock ? 0 :0x20150931;
N}
N
N/**
N  * @brief  ll_eflash_clear_cache
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  */
N__STATIC_INLINE void ll_eflash_clear_cache(EFLASH_TypeDef *p_ef) {
Xstatic __inline void ll_eflash_clear_cache(EFLASH_TypeDef *p_ef) {
N    p_ef->KST |= LL_EF_CACHE_CLR_KST | LL_EF_CACHE_CLR_KST_EN;
X    p_ef->KST |= (1UL << 4) | (1UL << 20);
N    while(0 == (p_ef->DONE & LL_EF_CACHE_CLR_DONE));
X    while(0 == (p_ef->DONE & (1UL << 4)));
N}
N
N/**
N  * @brief  ll_eflash_cache_enable
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  */
N__STATIC_INLINE void ll_eflash_cache_enable(EFLASH_TypeDef *p_ef) {
Xstatic __inline void ll_eflash_cache_enable(EFLASH_TypeDef *p_ef) {
N    p_ef->CTRLR0 |= LL_EF_CACHE_EN;
X    p_ef->CTRLR0 |= (1UL << 0);
N}
N
N/**
N  * @brief  ll_eflash_cache_disable
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  */
N__STATIC_INLINE void ll_eflash_cache_disable(EFLASH_TypeDef *p_ef) {
Xstatic __inline void ll_eflash_cache_disable(EFLASH_TypeDef *p_ef) {
N    p_ef->CTRLR0 &= ~LL_EF_CACHE_EN;
X    p_ef->CTRLR0 &= ~(1UL << 0);
N}
N
N/**
N  * @brief  ll_eflash_prefetch_enable
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  */
N__STATIC_INLINE void ll_eflash_prefetch_enable(EFLASH_TypeDef *p_ef) {
Xstatic __inline void ll_eflash_prefetch_enable(EFLASH_TypeDef *p_ef) {
N    p_ef->CTRLR0 |= LL_EF_PREFETCH_EN;
X    p_ef->CTRLR0 |= (1UL << 2);
N}
N
N/**
N  * @brief  ll_eflash_prefetch_disable
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  */
N__STATIC_INLINE void ll_eflash_prefetch_disable(EFLASH_TypeDef *p_ef) {
Xstatic __inline void ll_eflash_prefetch_disable(EFLASH_TypeDef *p_ef) {
N    p_ef->CTRLR0 &= ~LL_EF_PREFETCH_EN;
X    p_ef->CTRLR0 &= ~(1UL << 2);
N}
N
N/**
N  * @brief  ll_eflash_read_directly_enable
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  */
N__STATIC_INLINE void ll_eflash_read_directly_enable(EFLASH_TypeDef *p_ef) {
Xstatic __inline void ll_eflash_read_directly_enable(EFLASH_TypeDef *p_ef) {
N    p_ef->CTRLR0 = (p_ef->CTRLR0 & ~(LL_EF_PREFETCH_EN | LL_EF_CACHE_EN)) | LL_EF_DIRCTLY_OUT;
X    p_ef->CTRLR0 = (p_ef->CTRLR0 & ~((1UL << 2) | (1UL << 0))) | (1UL << 7);
N}
N
N/**
N  * @brief  LL_EFLASH_DATA
N  * @param  addr: EFLASH main phy address (start form 0)
N  * @retval None
N  */
N#define LL_EFLASH_DATA(addr)                      (*((volatile u32 *)((addr)+LL_EF_STADDR)))
N
N/**
N  * @brief  LL_EFLASH_NVR_DATA
N  * @param  addr: EFLASH main nvr address (start form 0)
N  * @retval None
N  */
N#define LL_EFLASH_NVR_DATA(addr)                  (*((volatile u32 *)((addr)+LL_EF_NVR_STADDR)))
N
N/**
N  * @brief  LL_EFLASH_IS_BUSY
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  */
N#define LL_EFLASH_IS_BUSY(p_ef)                   ((LL_EF_BUSY_MASK == (p_ef->DONE & LL_EF_BUSY_MASK)) ? 0 : 1)
N
N/**
N  * @brief  Wait for the eflash to complete
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  */
N__STATIC_INLINE void ll_eflash_wait_busy(EFLASH_TypeDef *p_ef) {
Xstatic __inline void ll_eflash_wait_busy(EFLASH_TypeDef *p_ef) {
N    while(LL_EF_BUSY_MASK != (p_ef->DONE & LL_EF_BUSY_MASK));
X    while(((1UL << 0) | (1UL << 1) | (1UL << 4) | (1UL << 6) | (1UL << 5)) != (p_ef->DONE & ((1UL << 0) | (1UL << 1) | (1UL << 4) | (1UL << 6) | (1UL << 5))));
N}
N
N/**
N  * @brief  LL_EFLASH_IS_SECTOR_ERASE_BUSY
N  * @param  p_ef: EFLASH_TypeDef pointer to eflash hardware register
N  * @retval None
N  */
N#define LL_EFLASH_IS_SECTOR_ERASE_BUSY(p_ef)      (!(p_ef->DONE & LL_EF_SECT_ERASE_DONE))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_EFLASH_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 44 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_wdt.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_wdt.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_wdt.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the WDT LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_WDT_H
N#define __TX_PHE_LL_WDT_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup wdt_interface_gr WDT Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup WDT_LL_Driver WDT LL Driver
N  * @ingroup  wdt_interface_gr
N  * @brief Mainly the driver part of the WDT module, which includes \b WDT \b Register 
N  * \b Constants, \b WDT \b Exported \b Constants, \b WDT \b Exported \b Struct, \b WDT
N  * \b Data \b transfers \b functions, \b WDT \b Initialization \b and \b WDT \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup WDT_LL_Register_Constants WDT LL Register Constants
N  * @ingroup  WDT_LL_Driver
N  * @brief    WDT LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the WDT 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the WDT register, mainly for convenience. Understand the 
N    configuration of the WDT.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N
N/***** WDT_CR Register *****/
N/*! TYPE_ENUM_LL_WDT_RPL : Reset pulse length.  
N *  Writes have no effect when the configuration parameter WDT_HC_RPL is 1, making
N *  the register bits read-only. This is used to select the number of pclk cycles for which
N *  the system reset stays asserted. The range of values available is 2 to 256 pclk
N *  cycles.  
N *  000 - 2 pclk cycles  
N *  001 - 4 pclk cycles  
N *  010 - 8 pclk cycles  
N *  011 - 16 pclk cycles  
N *  100 - 32 pclk cycles  
N *  101 - 64 pclk cycles  
N *  110 - 128 pclk cycles  
N *  111 - 256 pclk cycles  
N *  @note:
N *      When WDT_SYNC_CLK_MOPE_ENABLE = 1, the total reset pulse
N *      length also includes the reset synchronization delay and the time
N *      taken for pclk to be made available. For details, refer to "System
N *      Resets" on page 35.
N */
N#define LL_WDT_RPL(n)                             (((n)&0x7) << 2)
N/*! Response mode: TYPE_ENUM_LL_WDT_RMODE
N *  Writes have no effect when the parameter WDT_HC_RMOD = 1, thus this register
N *  becomes read-only. Selects the output response generated to a timeout.  
N *  0 = Generate a system reset.  
N *  1 = First generate an interrupt and if it is not cleared by the time a second timeout
N *  occurs then generate a system reset
N */
N#define LL_WDT_RMODE(n)                           (((n)&0x1) << 1)
N/*! WDT enable.  
N *  When the configuration parameter WDT_ALWAYS_EN = 0, this bit can be set;
N *  otherwise, it is read-only. This bit is used to enable and disable the DW_apb_wdt.
N *  When disabled, the counter does not decrement. Thus, no interrupts or system
N *  resets are generated.  
N *  The DW_apb_wdt is used to prevent system lock-up. To prevent a software bug from
N *  disabling the DW_apb_wdt, once this bit has been enabled, it can be cleared only by
N *  a system reset.  
N *  0 = WDT disabled.  
N *  1 = WDT enabled.  
N */
N#define LL_WDT_EN                                 (1UL << 0)
N
N
N/***** WDT_TORR Register *****/
N/*! Timeout period for initialization.
N *  Writes to these register bits have no effect when the configuration parameter
N *  WDT_HC_TOP = 1 or WDT_ALWAYS_EN = 1. Used to select the timeout period that
N *  the watchdog counter restarts from for the first counter restart (kick). This register
N *  should be written after reset and before the WDT is enabled.
N *  A change of the TOP_INIT is seen only once the WDT has been enabled, and any
N *  change after the first kick is not seen as subsequent kicks use the period specified by
N *  the TOP bits.
N *  The range of values is limited by the WDT_CNT_WIDTH. If TOP_INIT is programmed
N *  to select a range that is greater than the counter width, the timeout period is
N *  truncated to fit to the counter width. This affects only the non-user specified values as
N *  users are limited to these boundaries during configuration.  
N *  The range of values available for a 32-bit watchdog counter are:  
N *  Where i = TOP_INIT and  
N *  t = timeout period  
N *  For i = 0 to 15  
N *  if WDT_USE_FIX_TOP==1  
N *  t = 2(16 + i)  
N *  else  
N *  t = WDT_USER_TOP_INIT_(i)  
N *  Reset Value: Configuration parameter WDT_DFLT_TOP_INIT
N *  @note: These bits exist only when the configuration parameter WDT_DUAL_TOP =
N *  1, otherwise, they are fixed at zero.
N */
N#define LL_WDT_TOP_INIT(n)                        (((n)&0xF) << 4)
N/*! Timeout period.
N *  Writes have no effect when the configuration parameter WDT_HC_TOP = 1, thus
N *  making this register read-only. This field is used to select the timeout period from
N *  which the watchdog counter restarts. A change of the timeout period takes effect only
N *  after the next counter restart (kick).
N *  The range of values is limited by the WDT_CNT_WIDTH. If TOP is programmed to
N *  select a range that is greater than the counter width, the timeout period is truncated
N *  to fit to the counter width. This affects only the non-user specified values as users are
N *  limited to these boundaries during configuration.  
N *  The range of values available for a 32-bit watchdog counter are:  
N *  Where i = TOP and  
N *  t = timeout period  
N *  For i = 0 to 15  
N *  if WDT_USE_FIX_TOP==1  
N *  t = 2(16 + i)  
N *  else  
N *  t = WDT_USER_TOP_(i)  
N */
N#define LL_WDT_TOP(n)                             (((n)&0xF) << 0)
N
N
N/***** WDT_CCVR Register *****/
N/*! This register, when read, is the current value of the internal
N *  counter. This value is read coherently when ever it is read, which
N *  is relevant when the APB_DATA_WIDTH is less than the counter
N *  width.
N */
N
N
N/***** WDT_CRR Register *****/
N/*! This register is used to restart the WDT counter. As a safety feature to prevent
N *  accidental restarts, the value 0x76 must be written. A restart also clears the WDT
N *  interrupt. Reading this register returns zero.
N */
N#define LL_WDT_CNT_RESTART_KEY                    (((0x76)))
N
N
N/***** WDT_STAT Register *****/
N/*! This register shows the interrupt status of the WDT.  
N *  1 = Interrupt is active regardless of polarity.  
N *  0 = Interrupt is inactive.  
N */
N#define LL_WDT_INT_PENDING                        (1UL << 0)
N
N
N/***** WDT_EOI Register *****/
N/*! Clears the watchdog interrupt. This can be used to clear the interrupt without restarting
N *  the watchdog counter. 
N */
N#define LL_WDT_INT_PEND_CLR                       (1UL << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup WDT_LL_Exported_Constants WDT LL Exported Constants
N  * @ingroup  WDT_LL_Driver
N  * @brief    WDT LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N/**
N  * @brief Enumeration constant for low layer WDT Reset pulse cycles
N  */
Ntypedef enum {
N    /*! watchdog  Reset pulse cycles : 2
N     */
N    LL_WDT_RPL_2PCLK = 0,
N    /*! watchdog  Reset pulse cycles : 4
N     */
N    LL_WDT_RPL_4PCLK,
N    /*! watchdog  Reset pulse cycles : 8
N     */
N    LL_WDT_RPL_8PCLK,
N    /*! watchdog  Reset pulse cycles : 16
N     */
N    LL_WDT_RPL_16PCLK,
N    /*! watchdog  Reset pulse cycles : 32
N     */
N    LL_WDT_RPL_32PCLK,
N    /*! watchdog  Reset pulse cycles : 64
N     */
N    LL_WDT_RPL_64PCLK,
N    /*! watchdog  Reset pulse cycles : 128
N     */
N    LL_WDT_RPL_128PCLK,
N    /*! watchdog  Reset pulse cycles : 256
N     */
N    LL_WDT_RPL_256PCLK,
N} TYPE_ENUM_LL_WDT_RPL;
N
N/**
N  * @brief Enumeration constant for low layer WDT mode selector
N  */
Ntypedef enum {
N    /*! watchdog response : Reset
N     */
N    LL_WDT_RMODE_RST = 0,
N    /*! watchdog response : interrupt, then reset
N     */
N    LL_WDT_RMODE_INT_RST,
N} TYPE_ENUM_LL_WDT_RMODE;
N
N/*! watchdog timeout : 2^n(n > 1) s.
N *  @note : n > 1
N */
N#define LL_WDT_IO_SECOND_2PWR(n)                       (((n)-1) & 0xF)
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N
N
N/**
N  * @}
N  */
N
N/** @defgroup WDT_LL_Exported_Struct WDT LL Exported Struct
N  * @ingroup  WDT_LL_Driver
N  * @brief    WDT LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the WDT registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_wdt_init. Function, you can configure the WDT module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief WDT low layer config struct
N  */
Ntypedef struct __ll_wdt_cfg {
N    /*! watchdog timeout period , ref LL_WDT_TOP_INIT  & LL_WDT_TOP, the clock is RC32KHZ
N     */
N    u8                      timeout;
N    /*! watchdog mode, LL_WDT_RMOD(int_en) will be used
N     */
N    TYPE_ENUM_LL_WDT_RMODE  mode;
N} TYPE_LL_WDT_CFG;
N
N/**
N  * @brief WDT low layer init struct
N  */
Ntypedef struct __ll_wdt_init {
N    u8 reserved;
N} TYPE_LL_WDT_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup WDT_LL_Interrupt WDT LL Interrupt Handle function
N  * @brief   WDT LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the WDT  
N    Interrupt Handle function.
N
N    how to use?
N
N    The WDT interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the WDT in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup WDT_LL_Inti_Cfg WDT LL Initialization And Configuration
N  * @brief    WDT LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the WDT data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  wdt_init
N  * @param  p_wdt : pointer to the hardware WDT_TypeDef
N  * @param  p_init: pointer to the init stuct TYPE_LL_WDT_INIT
N  * @retval None
N  */
Nvoid ll_wdt_init(WDT_TypeDef *p_wdt, TYPE_LL_WDT_INIT *p_init);
N
N/**
N  * @brief  wdt_deinit
N  * @param  p_wdt: pointer to the hardware WDT_TypeDef
N  * @retval None
N  */
Nvoid ll_wdt_deinit(WDT_TypeDef *p_wdt);
N
N/**
N  * @brief  watchdog config
N  * @param  p_wdt : pointer to the hardware WDT_TypeDef
N  * @param  p_cfg : pointer to the init stuct TYPE_LL_WDT_CFG
N  * @retval None
N  */
Nvoid ll_wdt_config(WDT_TypeDef *p_wdt, TYPE_LL_WDT_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup WDT_LL_Data_Transfers WDT LL Data transfers functions
N  * @brief    WDT LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the WDT data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  wdt_start
N  * @param  p_wdt : pointer to the hardware WDT_TypeDef
N  * @retval None
N  */
Nvoid ll_wdt_start(WDT_TypeDef *p_wdt);
N
N/**
N  * @brief  wdt stop
N  * @param  p_wdt: pointer to the hardware WDT_TypeDef
N  * @retval None
N  */
Nvoid ll_wdt_stop(WDT_TypeDef *p_wdt);
N
N/**
N * @brief  LL_WDT_GET_INTERRUPT_PENDING
N * @param  p_wdt: pointer to the hardware WDT_TypeDef *p_wdt
N * @retval pending
N */
N#define LL_WDT_GET_PENDING(p_wdt)            (p_wdt->WDT_STAT & LL_WDT_INT_PENDING)
N
N/**
N  * @brief  ll_wdt_clear_interrupt_pending : use for clear interrupt pending 
N  * @param  p_wdt: pointer to the hardware WDT_TypeDef *p_wdt
N  * @retval None
N  */
N__STATIC_INLINE void ll_wdt_clear_done_pending(WDT_TypeDef *p_wdt) {
Xstatic __inline void ll_wdt_clear_done_pending(WDT_TypeDef *p_wdt) {
N    p_wdt->WDT_EOI |= LL_WDT_INT_PEND_CLR;
X    p_wdt->WDT_EOI |= (1UL << 0);
N}
N
N/**
N  * @brief  ll_wdt_feed : use for clear watchdog counter
N  * @param  p_wdt: pointer to the hardware WDT_TypeDef *p_wdt
N  * @retval None
N  */
N__STATIC_INLINE void ll_wdt_feed(WDT_TypeDef *p_wdt) {
Xstatic __inline void ll_wdt_feed(WDT_TypeDef *p_wdt) {
N    p_wdt->WDT_CRR = LL_WDT_CNT_RESTART_KEY;
X    p_wdt->WDT_CRR = (((0x76)));
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_WDT_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 45 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_fir.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_fir.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_fir.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the FIR LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_FIR_H
N#define __TX_PHE_LL_FIR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup fir_interface_gr FIR Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup FIR_LL_Driver FIR LL Driver
N  * @ingroup  fir_interface_gr
N  * @brief Mainly the driver part of the FIR module, which includes \b FIR \b Register 
N  * \b Constants, \b FIR \b Exported \b Constants, \b FIR \b Exported \b Struct, \b FIR
N  * \b Data \b transfers \b functions, \b FIR \b Initialization \b and \b FIR \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N    
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N    
N/** @defgroup FIR_LL_Register_Constants FIR LL Register Constants
N  * @ingroup  FIR_LL_Driver
N  * @brief    FIR LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the FIR 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the FIR register, mainly for convenience. Understand the 
N    configuration of the FIR.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** FIR_CH_ENA *****/
N/*! FIR's channel enable bit, each 1 bit represents a channel, representing 
N *  the 0th to 7th channels. 
N */
N#define LL_FIR_CH_ENA(n)                          (((n)&0xFF) << 0)
N
N
N/***** FIR_CPU_KST *****/           
N/*! The triggering of the FIR channel is enabled. Each bit represents a channel, 
N *  which represents the triggering of the channel from channel 0 to channel 7. 
N */
N#define LL_FIR_CPU_KST(n)                         (((n)&0xFF) << 0)
N
N
N/***** FIR_CFG_ADDR *****/        
N/*! The starting address of the FIR configuration information.
N */
N#define LL_FIR_CFG_ADDR(n)                        (((n)&0xFFFFFFFF) << 0)
N
N
N/***** FIR_INT_ENA *****/       
N/*! The FIR channel's interrupt trigger is enabled. Each bit represents a channel,
N *  which represents the trigger enable of the 0th to 7th channels. 
N */
N#define LL_FIR_INT_ENA(n)                         (((n)&0xFF) << 0)
N
N
N/***** FIR_HALF_PND *****/          
N/*! When the output BUFF of the FIR channel of the FIR has filled half of the data, 
N *  the completion flag is written, and 1 is written to the register to clear the pending. 
N */
N#define LL_FIR_HALF_PND(n)                        (((n)&0xFF) << 0)
N
N
N/***** FIR_FULL_PND *****/               
N/*! When the output BUFF of the FIR channel of the FIR has filled the data, the 
N *  completion flag is written, and 1 write to the register clears the pending. 
N */
N#define LL_FIR_FULL_PND(n)                        (((n)&0xFF) << 0)
N
N
N/***** FIR_FILT_PND *****/                   
N/*! When the FIR of the FIR channel N completes filtering, the completion flag is 
N *  written, and a 1 write to the register clears the pending. 
N */
N#define LL_FIR_FILT_PND(n)                        (((n)&0xFF) << 0)
N
N
N/***** FIR_INT_SRCL *****/                
N/*! When each bit represents the interrupt source selection of one channel, it 
N *  represents the 0th to 7th channel, and is used together with SRCH0 in the 
N *  format of{SRCH0, SRCL0}. 
N */
N#define LL_FIR_INT_SRCL(n)                        (((n)&0xFF) << 0)
N
N
N/***** FIR_INT_SRCH *****/             
N/*! When each bit represents the interrupt source selection of one channel, it 
N *  represents the 0th to 7th channel, and is used together with SRCH0 in the 
N *  format of{SRCH0, SRCL0}. 
N */
N#define LL_FIR_INT_SRCH(n)                        (((n)&0xFF) << 0)
N
N
N/***** FIR_DATA_OUT *****/               
N/*! After each calculation of the fir, the calculation saves the register.
N */
N#define LL_FIR_DATA_OUT(n)                        (((n)&0xFFFFFFFF) << 0)
N
N
N/***** FIR_EVSYS_ENA *****/              
N/*! FIR's evsys channel enable bit, each 1 bit represents a channel, representing 
N *  the 0th to 7th channel, used in conjunction with the event trigger, each event 
N *  triggers an FIR, completes an N channel filtering (mainly see Which way of this 
N *  register is enabled). 
N */
N#define LL_FIR_EVSYS_ENA(n)                       (((n)&0xFF) << 0)
N
N
N/**
N  * @}
N  */
N
N/** @defgroup FIR_LL_Exported_Constants FIR LL Exported Constants
N  * @ingroup  FIR_LL_Driver
N  * @brief    FIR LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N/**
N  * @brief Enumeration constant for FIR finished pending status
N  */
Ntypedef enum {
N    /*! Fir idle flag macro definition.
N     */
N    LL_FIR_PNG_IDLE = 0,
N    /*! Fir completes the filter flag macro definition.
N     */
N    LL_FIR_PNG_FILT,
N    /*! Fir completes the definition of the half mark macro.
N     */
N    LL_FIR_PNG_HALF,
N    /*! Fir completes the definition of the full mark macro.
N     */
N    LL_FIR_PNG_FULL,
N} TYPE_ENUM_LL_FIR_PNG;
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for The FIR interrupt source triggers the selection
N  */
Ntypedef enum {
N    /*! Each time the fir is filtered, an interrupt is triggered.
N     */
N    LL_FIR_INTR_SRC_FILT = 0,
N    /*! Fir triggers an interrupt when it calculates half of the output buffer.
N     */
N    LL_FIR_INTR_SRC_HALF,
N    /*! Fir triggers an interrupt when it calculates that the output buffer is full
N     */
N    LL_FIR_INTR_SRC_FULL,
N    /*! Fir triggers an interrupt when it calculates that the output buffer is full and half. 
N     */
N    LL_FIR_INTR_SRC_HALF_FULL,
N} TYPE_ENUM_LL_FIR_INTR_SRC_SEL;
N
N/**
N  * @}
N  */
N
N/** @defgroup FIR_LL_Exported_Struct FIR LL Exported Struct
N  * @ingroup  FIR_LL_Driver
N  * @brief    FIR LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the FIR registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_fir_init. Function, you can configure the FIR module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief FIR interrupt low layer configuration structure
N  */
Ntypedef struct __ll_fir_irq_cfg {
N    /*! There are 8 sets of paths for each set of FIR, and chn is the one that 
N     *  is selected for calculation, ranging from 0 to 7. 
N     */
N    u8                            chn;
N    /*! Select the trigger source for the FIR module interrupt. 
N     */
N    TYPE_ENUM_LL_FIR_INTR_SRC_SEL intr_src_sel; 
N} TYPE_LL_FIR_IRQ_CFG;
N
N/**
N  * @brief FIR param low layer configuration structure
N  */
Ntypedef struct __ll_fir_param_cfg {  
N    /*! The downsampling of the FIR, when the dma_en=1 is valid, 
N     *  internally outputs the downsampled data to the SRAM. 
N     */
N    u8  sample_rate;
N    /*! The position where the FIR's downsampling starts sampling. 
N     *  The default value starts from 0. 
N     */
N    u8  sample_rate_index;
N    /*! Enable the DMA mode of FIR, occupying 1 bit of space. This 
N     *  space allocation is fixed and no change is allowed.
N     */
N    u16 dma_en              : 1,
N    /*! DMA mode selection:
N     *  0: Each time the trigger is triggered, the sample_rate sample 
N     *     is jumped, which is generally used for CPU triggering.
N     *  1: Only one sample is calculated for each trigger, which is 
N     *     generally used for automatic triggering of the ADC. 
N     */
N        dma_mode            : 1,
N    /*! Reserved bits occupy 10bits of space. This space allocation 
N     *  is fixed and no changes are allowed. 
N     */
N        reserved            : 10,
N    /*! The fixed-point number of output data occupies a space range 
N     *  of 5 bits between 0 and 31, and odata_frac_width_l refers to a 
N     *  low 4 bits. This space allocation is fixed and no change is allowed. 
N     */
N        odata_frac_width_l  : 4;
N
N    /*! The fixed-point number of output data occupies a 5-bit space range 
N     *  between 0 and 31, and odata_frac_width_h refers to a maximum of 1 bit. 
N     *  This space allocation is fixed and no change is allowed. 
N     */
N    u16 odata_frac_width_h  : 1,
N    /*! Reserved bits occupy 15bits of space. This space allocation 
N     *  is fixed and no changes are allowed. 
N     */
N        reserved2           : 15;
N    /*! FIR calculates the buffer length of the coefficient in units of 2 bytes.
N     */
N    u16 coef_len;
N
N    /*! The FIR calculates the starting address of the input buffer, which must 
N     *  be 8Byte aligned. 
N     *  @note FIR0's dma_src_addr can only be located in SRAM1.  
N     *        FIR1's dma_src_addr can only be located in SRAM2.  
N     *        FIR2's dma_src_addr can only be located in SRAM3.  
N     *        Statement example:  
N     *        static s16 fir0_ibuf[1024] __attribute__((aligned(8), section("SRAM1"))) ;
N     */
N    u32 dma_src_addr;
N    /*! The FIR calculates the starting address of the output buffer, which must 
N     *  be 8Byte aligned. 
N     *  @note FIR0's dma_dst_addr can only be located in SRAM1.  
N     *        FIR1's dma_dst_addr can only be located in SRAM2.  
N     *        FIR2's dma_dst_addr can only be located in SRAM3.  
N     *        Statement example:  
N     *        static s16 fir0_obuf[1024] __attribute__((aligned(8), section("SRAM1"))) ;
N     */
N    u32 dma_dst_addr;
N    /*! The FIR calculates the starting address of the coefficient, which must 
N     *  be 8Byte aligned. 
N     *  @note FIR0's coef_start_addr can only be located in SRAM1.  
N     *        FIR1's coef_start_addr can only be located in SRAM2.  
N     *        FIR2's coef_start_addr can only be located in SRAM3.  
N     *        Statement example:  
N     *        static s16 fir0_coef[1024] __attribute__((aligned(8), section("SRAM1"))) ;
N     */
N    u32 coef_start_addr;
N    
N    /*! FIR input buffer length, the unit is 2 bytes.
N     */
N    u16 dma_src_points;
N    /*! FIR output buffer length, the unit is 2 bytes.
N     */
N    u16 dma_dst_points;
N
N    /*! The FIR input buffer starts the calculation of the starting position. 
N     */
N    u32 dma_src_index;
N    /*! The FIR output buffer starts the calculation of the starting position. 
N     */
N    u32 dma_dst_index;
N} TYPE_LL_FIR_PARAM_CFG;
N
N/**
N  * @brief FIR low layer configuration structure
N  */
Ntypedef struct __ll_fir_cfg {
N    /*! There are 8 sets of paths for each set of FIR, and chn is the one that 
N     *  is selected for calculation, ranging from 0 to 7. 
N     */
N    u8                            chn;
N    /*! Enable the path between FIR and evsys. 
N     */
N    bool                          evsys_chn_en;
N} TYPE_LL_FIR_CFG;
N
N/**
N  * @brief FIR low layer Initialization structure
N  */
Ntypedef struct __ll_fir_init {
N    /*! The starting sram address of the FIR configuration parameter, which must 
N     *  be 8Byte aligned. 
N     *  @note FIR0's param_start_addr can only be located in SRAM0.  
N     *        FIR1's param_start_addr can only be located in SRAM0.  
N     *        FIR2's param_start_addr can only be located in SRAM0.  
N     *        Statement example:  
N     *        static TYPE_LL_FIR_PARAM_CFG fir_param[max_chn] 
N     *                                     __attribute__((aligned(8), section("SRAM0")));  
N     *        max_chn: max_chn is expressed as the maximum channel value using fir. 
N     *                 For example, if you want to use channel 4 of FIR0 for calculation, 
N     *                 max_chn=5, and the range of n is between 0 and 7.
N     */
N    u32 param_start_addr; 
N    /*! The length of the fir coefficient buffer.
N     */
N    u32 param_buf_len;
N} TYPE_LL_FIR_INIT;
N
N
N/**
N  * @}
N  */
N
N/** @defgroup FIR_LL_Interrupt FIR LL Interrupt Handle function
N  * @brief   FIR LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the FIR  
N    Interrupt Handle function.
N
N    how to use?
N
N    The FIR interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the FIR in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup FIR_LL_Inti_Cfg FIR LL Initialization And Configuration
N  * @brief    FIR LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the FIR data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  FIR module initialization function
N  * @param  p_fir : Select the initialized DFTRAN group pointer
N  * @param  p_init: Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_fir_init(FIR_TypeDef *p_fir, TYPE_LL_FIR_INIT *p_init);
N
N/**
N  * @brief  FIR module detele initialization function
N  * @param  p_fir: Select the initialized FIR group pointer
N  * @retval None
N  */
Nvoid ll_fir_deinit(FIR_TypeDef *p_fir);
N
N/**
N  * @brief  FIR module interrupt configuration
N  * @param  p_fir: Select the initialized FIR group pointer
N  * @param  p_cfg: Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_fir_irq_config(FIR_TypeDef *p_fir, TYPE_LL_FIR_IRQ_CFG *p_cfg);
N
N/**
N  * @brief  FIR module configuration
N  * @param  p_fir: Select the initialized FIR group pointer
N  * @param  p_cfg: Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_fir_config(FIR_TypeDef *p_fir, TYPE_LL_FIR_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup FIR_LL_Data_Transfers FIR LL Data transfers functions
N  * @brief    FIR LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the FIR data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  FIR module start function
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
Nvoid ll_fir_start(FIR_TypeDef *p_fir, u8 chn_bits);
N
N/**
N  * @brief  FIR module stop function
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
Nvoid ll_fir_stop(FIR_TypeDef *p_fir, u8 chn_bits);
N
N/**
N  * @brief  FIR check sample interrupt enable
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png.
N  */
N#define LL_FIR_CHECK_SAMPLE_INTERRUPT_ENABLE(p_fir, chn_bits)     (!((p_fir)->FIR_INT_SRCL & LL_FIR_INT_SRCL(chn_bits)) && \
N                                                                   !((p_fir)->FIR_INT_SRCH & LL_FIR_INT_SRCH(chn_bits)))
X#define LL_FIR_CHECK_SAMPLE_INTERRUPT_ENABLE(p_fir, chn_bits)     (!((p_fir)->FIR_INT_SRCL & LL_FIR_INT_SRCL(chn_bits)) &&                                                                    !((p_fir)->FIR_INT_SRCH & LL_FIR_INT_SRCH(chn_bits)))
N
N/**
N  * @brief  FIR check dma buffer half interrupt enable
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png.
N  */
N#define LL_FIR_CHECK_DMA_HALF_INTERRUPT_ENABLE(p_fir, chn_bits)   ((p_fir)->FIR_INT_SRCL & LL_FIR_INT_SRCL(chn_bits))
N
N/**
N  * @brief  FIR check dma buffer full interrupt enable
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png.
N  */
N#define LL_FIR_CHECK_DMA_FULL_INTERRUPT_ENABLE(p_fir, chn_bits)   ((p_fir)->FIR_INT_SRCH & LL_FIR_INT_SRCH(chn_bits))
N
N/**
N  * @brief  FIR get filter pending
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png.
N  */
N#define LL_FIR_GET_SAMPLE_PENDING(p_fir, chn_bits)          ((p_fir)->FIR_FILT_PND & chn_bits)
N
N/**
N  * @brief  FIR get half pending
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png.
N  */
N#define LL_FIR_GET_DMA_HALF_PENDING(p_fir, chn_bits)        ((p_fir)->FIR_HALF_PND & chn_bits)
N
N/**
N  * @brief  FIR get full pending
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png.
N  */
N#define LL_FIR_GET_DMA_FULL_PENDING(p_fir, chn_bits)        ((p_fir)->FIR_FULL_PND & chn_bits)
N
N/**
N  * @brief  FIR enable interrupt
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None.
N  */
N__STATIC_INLINE void ll_fir_interrupt_enable(FIR_TypeDef *p_fir, u8 chn_bits) {
Xstatic __inline void ll_fir_interrupt_enable(FIR_TypeDef *p_fir, u8 chn_bits) {
N    p_fir->FIR_INT_ENA |= LL_FIR_INT_ENA(chn_bits);
X    p_fir->FIR_INT_ENA |= (((chn_bits)&0xFF) << 0);
N}
N
N/**
N  * @brief  FIR disable interrupt
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
N__STATIC_INLINE void ll_fir_interrupt_disable(FIR_TypeDef *p_fir, u8 chn_bits) {
Xstatic __inline void ll_fir_interrupt_disable(FIR_TypeDef *p_fir, u8 chn_bits) {
N    p_fir->FIR_INT_ENA &= ~(LL_FIR_INT_ENA(chn_bits));
X    p_fir->FIR_INT_ENA &= ~((((chn_bits)&0xFF) << 0));
N}
N
N/**
N  * @brief  FIR clear filter pending
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
N__STATIC_INLINE void ll_fir_clear_sample_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
Xstatic __inline void ll_fir_clear_sample_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
N    p_fir->FIR_FILT_PND |= chn_bits;
N}
N
N/**
N  * @brief  FIR clear half pending
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
N__STATIC_INLINE void ll_fir_clear_dma_half_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
Xstatic __inline void ll_fir_clear_dma_half_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
N    p_fir->FIR_HALF_PND |= chn_bits;
N}
N
N/**
N  * @brief  FIR clear full pending
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
N__STATIC_INLINE void ll_fir_clear_dma_full_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
Xstatic __inline void ll_fir_clear_dma_full_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
N    p_fir->FIR_FULL_PND |= chn_bits;
N}
N
N/**
N  * @brief  FIR wait for filter finished pending function
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None.
N  */
N__STATIC_INLINE void ll_fir_wait_sample_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
Xstatic __inline void ll_fir_wait_sample_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
N    while(chn_bits != (p_fir->FIR_FILT_PND & chn_bits));
N    p_fir->FIR_FILT_PND |= chn_bits;
N}
N
N/**
N  * @brief  FIR wait for half finished pending function
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None.
N  */
N__STATIC_INLINE void ll_fir_wait_half_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
Xstatic __inline void ll_fir_wait_half_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
N    TX_ASSERT((p_fir == FIR0) || (p_fir == FIR1) || (p_fir == FIR2));
X    (((p_fir == ((FIR_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x6000) + 0x0300 + 0x0120))) || (p_fir == ((FIR_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x6000) + 0x0300 + 0x0150))) || (p_fir == ((FIR_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x6000) + 0x0300 + 0x0180)))) ? (void)0U : tx_assert_false((uint8_t *)"..\\..\\..\\..\\Libraries\\Driver\\include\\LL\\tx_phe_ll_fir.h", 630));
N    
N    while(chn_bits != (p_fir->FIR_HALF_PND & chn_bits));
N    p_fir->FIR_HALF_PND |= chn_bits;
N}
N
N/**
N  * @brief  FIR wait for full finished pending function
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None.
N  */
N__STATIC_INLINE void ll_fir_wait_full_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
Xstatic __inline void ll_fir_wait_full_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
N    TX_ASSERT((p_fir == FIR0) || (p_fir == FIR1) || (p_fir == FIR2));
X    (((p_fir == ((FIR_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x6000) + 0x0300 + 0x0120))) || (p_fir == ((FIR_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x6000) + 0x0300 + 0x0150))) || (p_fir == ((FIR_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x6000) + 0x0300 + 0x0180)))) ? (void)0U : tx_assert_false((uint8_t *)"..\\..\\..\\..\\Libraries\\Driver\\include\\LL\\tx_phe_ll_fir.h", 644));
N    
N    while(chn_bits != (p_fir->FIR_FULL_PND & chn_bits));
N    p_fir->FIR_FULL_PND |= chn_bits;
N}
N
N/**
N  * @brief  FIR wait for filter or full finished pending function
N  * @param  p_fir   : Select the initialized FIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png(TYPE_ENUM_LL_FIR_PNG).
N  */
N__STATIC_INLINE TYPE_ENUM_LL_FIR_PNG ll_fir_wait_half_full_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
Xstatic __inline TYPE_ENUM_LL_FIR_PNG ll_fir_wait_half_full_pending(FIR_TypeDef *p_fir, u8 chn_bits) {
N    TYPE_ENUM_LL_FIR_PNG sta = LL_FIR_PNG_IDLE;
N    
N    TX_ASSERT((p_fir == FIR0) || (p_fir == FIR1) || (p_fir == FIR2));
X    (((p_fir == ((FIR_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x6000) + 0x0300 + 0x0120))) || (p_fir == ((FIR_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x6000) + 0x0300 + 0x0150))) || (p_fir == ((FIR_TypeDef *) (((((uint32_t)0x40000000) + 0x30000) + 0x6000) + 0x0300 + 0x0180)))) ? (void)0U : tx_assert_false((uint8_t *)"..\\..\\..\\..\\Libraries\\Driver\\include\\LL\\tx_phe_ll_fir.h", 660));
N    
N    while((chn_bits != (p_fir->FIR_HALF_PND & chn_bits)) &&
N          (chn_bits != (p_fir->FIR_FULL_PND & chn_bits)));
N    if(chn_bits == (p_fir->FIR_HALF_PND & chn_bits)) {
N        p_fir->FIR_HALF_PND |= chn_bits;
N        sta = LL_FIR_PNG_HALF;
N    }
N    if(chn_bits == (p_fir->FIR_FULL_PND & chn_bits)) {
N        p_fir->FIR_FULL_PND |= chn_bits;
N        sta = LL_FIR_PNG_FULL;
N    }
N    
N    return sta;
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_FIR_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 46 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_rms.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_rms.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_rms.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the RMS LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_RMS_H
N#define __TX_PHE_LL_RMS_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup rms_interface_gr RMS Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup RMS_LL_Driver RMS LL Driver
N  * @ingroup  rms_interface_gr
N  * @brief Mainly the driver part of the RMS module, which includes \b RMS \b Register 
N  * \b Constants, \b RMS \b Exported \b Constants, \b RMS \b Exported \b Struct, \b RMS
N  * \b Data \b transfers \b functions, \b RMS \b Initialization \b and \b RMS \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RMS_LL_Register_Constants RMS LL Register Constants
N  * @ingroup  RMS_LL_Driver
N  * @brief    RMS LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the RMS 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the RMS register, mainly for convenience. Understand the 
N    configuration of the RMS.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** RMS_CON *****/
N/*! The RMS calculation completes the flag.
N */
N#define LL_RMS_CON_PEND                           (1UL << 8)
N/*! The RMS enables the interrupt bit.
N
N */
N#define LL_RMS_CON_IE                             (1UL << 4)
N/*! RMS calculation mode selection bit.
N */
N#define LL_RMS_CON_MODE(n)                        (((n)&0x7) << 1)
N/*! RMS module enable bit.
N */
N#define LL_RMS_CON_ENABLE                         (1UL << 0)
N
N
N/***** RMS_LEN *****/
N/*! The RMS calculates the length of the number of samples. */
N#define LL_RMS_LEN(n)                             (((n)&0xFFFF) << 0)
N
N
N/***** RMS_IN_FRAC_WIDTH *****/
N/*! Only valid when LL_RMS_CON_MODE==011, this is LL_RMS_DATA_IN data fractional width.
N */
N#define LL_RMS_IN_FRAC_WIDTH(n)                   (((n)&0x1F) << 0)
N
N
N/***** RMS_OUT_FRAC_WIDTH *****/
N/*! Only valid when LL_RMS_CON_MODE==011, this is LL_RMS_DATA_OUT data fractional width.
N *  The formula is: RMS_OUT_FRAC_WIDTH=(RMS_IN_FRAC_WIDTH+1)/2 
N */
N#define LL_RMS_OUT_FRAC_WIDTH(n)                  (((n)&0x1F) << 0)
N
N
N/***** RMS_DATA_IN *****/
N/*! Only valid when LL_RMS_CON_MODE==011, this is the data we want to sqrt.
N */
N#define LL_RMS_DATA_IN(n)                         (((n)&0xFFFFFFFF) << 0)
N
N
N/***** RMS_DATA_OUTL *****/
N/*! The RMS output data low 32bits, RMS_DATA_OUT[63:0] = { RMS_DATA_OUTH, RMS_DATA_OUTL}.
N */
N#define LL_RMS_DATA_OUTL(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** RMS_DATA_OUTH *****/
N/*! The RMS output data high 32bits, RMS_DATA_OUT[63:0] = { RMS_DATA_OUTH, RMS_DATA_OUTL}.
N */
N#define LL_RMS_DATA_OUTH(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** RMS_DATA_IN_ADR *****/
N/*! In RMS DMA mode, the start address of input buffer, 64 alignment.
N */
N#define LL_RMS_DATA_IN_ADR(n)                     (((n)&0xFFFFFFFF) << 0)
N
N
N/***** RMS_DATA_OUT_ADR *****/
N/*! In RMS DMA mode, the start address of output buffer, 64 alignment.
N */
N#define LL_RMS_DATA_OUT_ADR(n)                    (((n)&0xFFFFFFFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup RMS_LL_Exported_Constants RMS LL Exported Constants
N  * @ingroup  RMS_LL_Driver
N  * @brief    RMS LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N
N
N/**
N  * @brief Enumeration constant for The RMS mode selection
N  */
Ntypedef enum {
N    /*! Read 32-bit data from memory, where the lower 16 bits are imaginary parts, 
N     *  the upper 16 bits are real parts, and then the operation (imaginary part 
N     *  square + real squared) opens the root number, saves the 16-bit result to 
N     *  memory, and continuously calculates RMS_LEN times. 
N     */
N    LL_RMS_MODE_MOLDING = 0,
N    /*! Read RMS_LEN from memory, then 16bits, squares and /RMS_LEN, then open the 
N     *  root number, the final result is 16 bits, save to memory, is to find the 
N     *  root mean square value, pay attention to this mode when RMS_LEN must meet 
N     *  2 n power. 
N     */
N    LL_RMS_MODE_RMS,
N    /*! Read RMS_LEN from memory so many 16bits, find the sum of squares, and finally 
N     *  the result is 64 bits, save to memory. 
N     */
N    LL_RMS_MODE_SUM_SQUARE,
N    /*! Find the root number of RMS0_DATA_IN and store the result in RMS0_DATA_OUT. 
N     *  Perform calculations only once at a time.
N     */
N    LL_RMS_MODE_SQUARE_ROOT,
N    /*! Read RMS_LEN from memory so many 16bits, sum, and finally result 64 bits, 
N     *  save to memory. 
N     */
N    LL_RMS_MODE_SUM,
N    /*! Read 32-bit data from memory, where the lower 16 bits are imaginary parts, 
N     *  the upper 16 bits are real parts, and then the operation (imaginary part 
N     *  square + real squared), the 32-bit result is saved to memory, and the RMS_LEN 
N     *  is continuously operated as many times. 
N     */
N    LL_RMS_MODE_MOLE_SQUARE,
N} TYPE_ENUM_LL_RMS_MODE;
N
N
N/**
N  * @}
N  */
N
N/** @defgroup RMS_LL_Exported_Struct RMS LL Exported Struct
N  * @ingroup  RMS_LL_Driver
N  * @brief    RMS LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the RMS registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_rms_init. Function, you can configure the RMS module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief RMS low layer configuration structure
N  */
Ntypedef struct __ll_rms_cfg {
N    /*! RMS mode selection, a total of 6 calculation modes are supported. For specific 
N     *  mode introduction, please refer to macro TYPE_ENUM_LL_RMS_MODE. 
N     */
N    TYPE_ENUM_LL_RMS_MODE mode;
N    /*! Only valid when mode = LL_RMS_MODE_SQUARE_ROOT, this is input data fractional 
N     *  width. The range of the parameter is between 0 and 31.
N     */
N    u8                    in_frac_width;
N    /*! All modes except mode = LL_RMS_MODE_SQUARE_ROOT are DMA, and len indicates the 
N     *  length of the DMA. 
N     */
N    u16                   dma_points;
N    /*! The starting address of the DMA input buffer, the address is 8Byte aligned. 
N     *  @note RMS0's dma_src_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3.  
N     *        RMS1's dma_src_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3.  
N     *        RMS2's dma_src_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3.  
N     *        Statement example:  
N     *        static s16 rms_ibuf[1024] __attribute__((aligned(8),section("SRAM0")));
N     */
N    u32                   dma_src_addr;
N    /*! The starting address of the DMA output buffer, the address is 8Byte aligned. 
N     *  @note RMS0's dma_dst_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3.  
N     *        RMS1's dma_dst_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3.  
N     *        RMS2's dma_dst_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3.  
N     *        Statement example:  
N     *        static s16 rms_obuf[1024] __attribute__((aligned(8),section("SRAM0")));
N     */
N    u32                   dma_dst_addr;
N} TYPE_LL_RMS_CFG;
N
N/**
N  * @brief RMS low layer Initialization structure
N  */
Ntypedef struct __ll_rms_init {
N    u8 reserved;
N} TYPE_LL_RMS_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup RMS_LL_Interrupt RMS LL Interrupt Handle function
N  * @brief   RMS LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the RMS  
N    Interrupt Handle function.
N
N    how to use?
N
N    The RMS interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the RMS in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup RMS_LL_Inti_Cfg RMS LL Initialization And Configuration
N  * @brief    RMS LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the RMS data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Low layer RMS module initialization
N  * @param  p_rms : The structure pointer of the RMS group (RMS0, RMS1, RMS2) is selected.
N  * @param  p_init: Module configuration structure pointer(TYPE_LL_RMS_INIT)
N  * @retval None
N  */
Nvoid ll_rms_init(RMS_TypeDef *p_rms, TYPE_LL_RMS_INIT *p_init);
N
N/**
N  * @brief  Low layer RMS module detele initialization
N  * @param  p_rms: The structure pointer of the RMS group (RMS0, RMS1, RMS2) is selected.
N  * @retval None
N  */
Nvoid ll_rms_deinit(RMS_TypeDef *p_rms);
N
N/**
N  * @brief  Low layer RMS module configuration
N  * @param  p_rms: The structure pointer of the RMS group (RMS0, RMS1, RMS2) is selected.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_RMS_DMA_CFG)
N  * @retval None
N  */
Nvoid ll_rms_config(RMS_TypeDef *p_rms, TYPE_LL_RMS_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup RMS_LL_Data_Transfers RMS LL Data transfers functions
N  * @brief    RMS LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the RMS data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  RMS module start function
N  * @param  p_rms: Select the initialized RMS group pointer
N  * @retval None
N  */
Nvoid ll_rms_start(RMS_TypeDef *p_rms);
N
N/**
N  * @brief  RMS module stop function
N  * @param  p_rms: Select the initialized RMS group pointer
N  * @retval None
N  */
Nvoid ll_rms_stop(RMS_TypeDef *p_rms);
N
N/**
N  * @brief  RMS get finished pending
N  * @param  p_rms: Select the initialized RMS group pointer
N  * @retval pending value
N  */
N#define LL_RMS_GET_DONE_PENDING(p_rms)            ((p_rms)->CON & LL_RMS_CON_PEND)
N
N/**
N  * @brief  RMS clear finished pending
N  * @param  p_rms: Select the initialized RMS group pointer
N  * @retval pending value
N  */
N__STATIC_INLINE void ll_rms_clear_done_pending(RMS_TypeDef *p_rms) {
Xstatic __inline void ll_rms_clear_done_pending(RMS_TypeDef *p_rms) {
N    p_rms->CON |= LL_RMS_CON_PEND;
X    p_rms->CON |= (1UL << 8);
N}
N
N/**
N  * @brief  RMS get output data frac width
N  * @param  p_rms: Select the initialized RMS group pointer
N  * @retval pending value
N  */
N#define LL_RMS_GET_OUT_FRAC_WIDTH(p_rms)          ((p_rms)->OUT_FRAC_WIDTH)
N
N/**
N  * @brief  RMS Wait for the specified channel to finish computing
N  * @param  p_rms: Select the initialized RMS group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_rms_wait_done_pending(RMS_TypeDef *p_rms) {
Xstatic __inline void ll_rms_wait_done_pending(RMS_TypeDef *p_rms) {
N    while(p_rms->CON & LL_RMS_CON_ENABLE);
X    while(p_rms->CON & (1UL << 0));
N    p_rms->CON |= LL_RMS_CON_PEND;
X    p_rms->CON |= (1UL << 8);
N}
N
N/**
N  * @brief  low layer for setting input data in RMS square root mode.
N  * @param  p_rms: Select the initialized RMS group pointer.
N  * @param  data: The data value that needs to be set.
N  * @retval None
N  */
N__STATIC_INLINE void ll_rms_set_square_root_indata(RMS_TypeDef *p_rms, u32 data) {
Xstatic __inline void ll_rms_set_square_root_indata(RMS_TypeDef *p_rms, u32 data) {
N    p_rms->DATA_IN = data;
N}
N
N/**
N  * @brief  low layer for returning data in RMS square root mode.
N  * @param  p_rms: Select the initialized RMS group pointer.
N  * @retval The calculation results in RMS square root mode.
N  */
N__STATIC_INLINE u64 ll_rms_return_square_root_indata(RMS_TypeDef *p_rms) {
Xstatic __inline u64 ll_rms_return_square_root_indata(RMS_TypeDef *p_rms) {
N    u32 data_outh;
N    ll_rms_wait_done_pending(p_rms);
N    data_outh = p_rms->DATA_OUTH;
N    return (p_rms->DATA_OUTL + ((s64)data_outh << 32));
N}
N
N/**
N  * @brief  low layer for getting data in RMS square root mode.
N  * @param  p_rms   : Select the initialized RMS group pointer.
N  * @param  result_h: The RMS calculation results in a high 32 bit.
N  * @param  result_l: The RMS calculation results in a low 32 bit.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_rms_get_square_root_indata(RMS_TypeDef *p_rms, u32 *result_h, u32 *result_l) {
Xstatic __inline void ll_rms_get_square_root_indata(RMS_TypeDef *p_rms, u32 *result_h, u32 *result_l) {
N    ll_rms_wait_done_pending(p_rms);
N    *result_h = p_rms->DATA_OUTH;
N    *result_l = p_rms->DATA_OUTL;
N}
N
N/**
N  * @brief  low layer for  RMS enable interrupt
N  * @param  p_rms: Select the initialized RMS group pointer.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_rms_interrupt_enable(RMS_TypeDef *p_rms) {
Xstatic __inline void ll_rms_interrupt_enable(RMS_TypeDef *p_rms) {
N    p_rms->CON |= LL_RMS_CON_IE;
X    p_rms->CON |= (1UL << 4);
N}
N
N/**
N  * @brief  low layer for  RMS disable interrupt
N  * @param  p_rms: Select the initialized RMS group pointer.
N  * @retval None.
N  */
N__STATIC_INLINE void ll_rms_interrupt_disable(RMS_TypeDef *p_rms) {
Xstatic __inline void ll_rms_interrupt_disable(RMS_TypeDef *p_rms) {
N    p_rms->CON &= ~(LL_RMS_CON_IE);
X    p_rms->CON &= ~((1UL << 4));
N}
N
N/**
N  * @brief  RMS mode setting
N  * @param  p_rms: Select the initialized RMS group pointer.
N  * @param  mode : RMS mode
N  * @retval None.
N  */
N__STATIC_INLINE void ll_rms_mode_set(RMS_TypeDef *p_rms,
Xstatic __inline void ll_rms_mode_set(RMS_TypeDef *p_rms,
N                                     TYPE_ENUM_LL_RMS_MODE mode) {
N    p_rms->CON &= ~LL_RMS_CON_MODE(0x07);
X    p_rms->CON &= ~(((0x07)&0x7) << 1);
N    p_rms->CON |= LL_RMS_CON_MODE(mode);
X    p_rms->CON |= (((mode)&0x7) << 1);
N}
N
N/**
N  * @brief  RMS input data fractional width setting
N  * @param  p_rms: Select the initialized RMS group pointer.
N  * @param  width: input data fractional width
N  * @retval None.
N  */
N__STATIC_INLINE void ll_rms_in_frac_width_set(RMS_TypeDef *p_rms, u8 width) {
Xstatic __inline void ll_rms_in_frac_width_set(RMS_TypeDef *p_rms, u8 width) {
N    p_rms->IN_FRAC_WIDTH = LL_RMS_IN_FRAC_WIDTH(width);
X    p_rms->IN_FRAC_WIDTH = (((width)&0x1F) << 0);
N}
N
N/**
N  * @brief  RMS length of the DMA setting
N  * @param  p_rms : Select the initialized RMS group pointer.
N  * @param  points: length of the DMA
N  * @retval None.
N  */
N__STATIC_INLINE void ll_rms_dma_points_set(RMS_TypeDef *p_rms, u16 points) {
Xstatic __inline void ll_rms_dma_points_set(RMS_TypeDef *p_rms, u16 points) {
N    p_rms->LEN = LL_RMS_LEN(points);
X    p_rms->LEN = (((points)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  RMS starting address of the DMA input buffer set
N  * @param  p_rms: Select the initialized RMS group pointer.
N  * @param  addr : The starting address of the DMA input buffer
N  * @retval None.
N  */
N__STATIC_INLINE void ll_rms_dma_src_addr_set(RMS_TypeDef *p_rms, u32 addr) {
Xstatic __inline void ll_rms_dma_src_addr_set(RMS_TypeDef *p_rms, u32 addr) {
N    p_rms->DATA_IN_ADR = LL_RMS_DATA_IN_ADR(addr);
X    p_rms->DATA_IN_ADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  RMS starting address of the DMA output buffer set
N  * @param  p_rms: Select the initialized RMS group pointer.
N  * @param  addr : The starting address of the DMA output buffer
N  * @retval None.
N  */
N__STATIC_INLINE void ll_rms_dma_dst_addr_set(RMS_TypeDef *p_rms, u32 addr) {
Xstatic __inline void ll_rms_dma_dst_addr_set(RMS_TypeDef *p_rms, u32 addr) {
N    p_rms->DATA_OUT_ADR = LL_RMS_DATA_OUT_ADR(addr);
X    p_rms->DATA_OUT_ADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_RMS_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 47 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_datadma.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_datadma.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_datadma.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the DATADMA LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_DATADMA_H
N#define __TX_PHE_LL_DATADMA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup datadma_interface_gr DATADMA Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup DATADMA_LL_Driver DATADMA LL Driver
N  * @ingroup  datadma_interface_gr
N  * @brief Mainly the driver part of the DATADMA module, which includes \b DATADMA \b Register 
N  * \b Constants, \b DATADMA \b Exported \b Constants, \b DATADMA \b Exported \b Struct, \b DATADMA
N  * \b Data \b transfers \b functions, \b DATADMA \b Initialization \b and \b DATADMA \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DATADMA_LL_Register_Constants DATADMA LL Register Constants
N  * @ingroup  DATADMA_LL_Driver
N  * @brief    DATADMA LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the DATADMA 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the DATADMA register, mainly for convenience. Understand the 
N    configuration of the DATADMA.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** DATADMA_CON *****/
N/*! Data dma interrupt enable bit
N */
N#define LL_DATADMA_CON_IE                        (1UL << 9)
N/*! Data dma finished pending bit
N */
N#define LL_DATADMA_CON_PEND                      (1UL << 8)
N/*! Data dma mode selection
N */
N#define LL_DATADMA_MODE                          (1UL << 1)
N/*! Data dma module enable bit
N */
N#define LL_DATADMA_ENABLE                        (1UL << 0)
N
N
N/***** DATADMA_SRC_BUF_STADR *****/
N/*! The starting address of the input source data buffer of datadma.
N */
N#define LL_DATADMA_SRC_BUF_STADR(n)              (((n)&0xFFFFFFFF) << 0)
N
N
N/***** DATADMA_SRC_BUF_LEN *****/
N/*! The length of the input source data buffer of datadma.
N */
N#define LL_DATADMA_SRC_BUF_LEN(n)                (((n)&0xFFFF) << 0)
N
N
N/***** DATADMA_DST_DMA_ADR *****/
N/*! The starting address of the dma source data of datadma.
N */
N#define LL_DATADMA_SRC_DMA_ADR(n)                (((n)&0xFFFFFFFF) << 0)
N
N
N/***** DATADMA_DST_DMA_ADR *****/
N/*! The starting address of the dma destination data of datadma.
N */
N#define LL_DATADMA_DEST_DMA_ADR(n)               (((n)&0xFFFFFFFF) << 0)
N
N
N/***** DATADMA_LEN *****/
N/*! The dma length of the datadma.
N */
N#define LL_DATADMA_LEN(n)                        (((n)&0xFFFF) << 0)
N
N
N/**
N  * @}
N  */
N
N/** @defgroup DATADMA_LL_Exported_Constants DATADMA LL Exported Constants
N  * @ingroup  DATADMA_LL_Driver
N  * @brief    DATADMA LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for DATADMA data mode selection
N  */
Ntypedef enum {                     
N    /*! DMA source data address increases to buffer end and return to 
N     *  LL_DATADMA_SRC_BUF_STADR, The buffer of the src_buf_addr 
N     *  specified in the loop acquisition structure TYPE_LL_DATADMA_CFG 
N     *  is defined as src_buf_len. 
N     */
N    LL_DATADMA_LOOP_GET_DATA = 0,  
N    /*! Starting from the address of dma_src_addr specified in the 
N     *  structure TYPE_LL_DATADMA_CFG, the value of the address increases 
N     *  backward, and the end address specified by src_buf_addr does 
N     *  not stop until the length of dma_len. 
N     */
N    LL_DATADMA_INC_GET_DATA,
N} TYPE_ENUM_LL_DATADMA_MODE;
N
N/**
N  * @}
N  */
N
N/** @defgroup DATADMA_LL_Exported_Struct DATADMA LL Exported Struct
N  * @ingroup  DATADMA_LL_Driver
N  * @brief    DATADMA LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the DATADMA registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_datadma_init. Function, you can configure the DATADMA module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief DATADMA low layer configuration structure
N  */
Ntypedef struct __ll_datadma_cfg {
N    /*! Datadma takes the mode selection of the data. There are two modes. For details, 
N     *  please refer to enumeration TYPE_ENUM_LL_DATADMA_MODE. 
N     */
N    TYPE_ENUM_LL_DATADMA_MODE mode;
N    /*! The starting address of the source data buffer. 
N     *  @note The src_buf_addr is aligned in byte and can only be located in
N     *        SRAM0~SRAM9 and SRAM10.  
N     *        Statement example:  
N     *          static u8 buf[1024] __attribute__((section("SRAM0")));
N     */
N    u32                       src_buf_addr;
N    /*! The length of the source data buffer, 8bit is a count unit, Valid range is 0~65535. 
N     */
N    u16                       src_buf_len;
N    /*! The starting address of dma starts from which address in the specified address 
N     *  of dma_src_addr. 
N     *  @note The dma_src_addr is aligned in byte and can only be located in
N     *        SRAM0~SRAM9 and SRAM10.  
N     *        Statement example:  
N     *          static u8 buf[1024] __attribute__((section("SRAM0")));
N     */
N    u32                       dma_src_addr;
N    /*! The starting address of dma starts from which address in the specified address 
N     *  of dma_dst_addr. 
N     *  @note The dma_dst_addr is aligned in byte and can only be located in
N     *        SRAM0~SRAM9 and SRAM10.  
N     *        Statement example:  
N     *          static u8 buf[1024] __attribute__((section("SRAM0")));
N     */
N    u32                       dma_dst_addr;
N    /*! The length of the dma, 8bit is a count unit, Valid range is 0~65535. 
N     */
N    u16                       dma_len;
N} TYPE_LL_DATADMA_CFG;
N
N/**
N  * @brief DATADMA low layer Initialization structure
N  */
Ntypedef struct __ll_datadma_init {
N    u8 reserved;
N} TYPE_LL_DATADMA_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup DATADMA_LL_Interrupt DATADMA LL Interrupt Handle function
N  * @brief   DATADMA LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DATADMA  
N    Interrupt Handle function.
N
N    how to use?
N
N    The DATADMA interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the DATADMA in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup DATADMA_LL_Inti_Cfg DATADMA LL Initialization And Configuration
N  * @brief    DATADMA LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DATADMA data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  DATADMA module initialization function
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @param  p_init   : Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_datadma_init(DATADMA_TypeDef *p_datadma, TYPE_LL_DATADMA_INIT *p_init);
N
N/**
N  * @brief  DATADMA module detele initialization function
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @retval None
N  */
Nvoid ll_datadma_deinit(DATADMA_TypeDef *p_datadma);
N
N/**
N  * @brief  DATADMA module configuration function
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @param  p_cfg    : Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_datadma_config(DATADMA_TypeDef *p_datadma, TYPE_LL_DATADMA_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup DATADMA_LL_Data_Transfers DATADMA LL Data transfers functions
N  * @brief    DATADMA LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DATADMA data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  DATADMA module start function
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @retval None
N  */
Nvoid ll_datadma_start(DATADMA_TypeDef *p_datadma);
N
N/**
N  * @brief  DATADMA module stop function
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @retval None
N  */
Nvoid ll_datadma_stop(DATADMA_TypeDef *p_datadma);
N
N/**
N  * @brief  DATADMA get finished pending
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @retval pending value
N  */
N#define LL_DATADMA_GET_DONE_PENDING(p_datadma)    ((p_datadma)->CON & LL_DATADMA_CON_PEND)
N
N/**
N  * @brief  DATADMA clear pending
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @retval None.
N  */
N__STATIC_INLINE void ll_datadma_clear_done_pending(DATADMA_TypeDef *p_datadma) {
Xstatic __inline void ll_datadma_clear_done_pending(DATADMA_TypeDef *p_datadma) {
N    p_datadma->CON |= LL_DATADMA_CON_PEND;
X    p_datadma->CON |= (1UL << 8);
N}
N
N/**
N  * @brief  DATADMA wait for the specified channel to finish computing
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @retval None.
N  */
N__STATIC_INLINE void ll_datadma_wait_done_pending(DATADMA_TypeDef *p_datadma) {
Xstatic __inline void ll_datadma_wait_done_pending(DATADMA_TypeDef *p_datadma) {
N    while(p_datadma->CON & LL_DATADMA_ENABLE);
X    while(p_datadma->CON & (1UL << 0));
N    p_datadma->CON |= LL_DATADMA_CON_PEND;
X    p_datadma->CON |= (1UL << 8);
N}
N
N/**
N  * @brief  DATADMA enable interrupt
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @retval None.
N  */
N__STATIC_INLINE void ll_datadma_interrupt_enable(DATADMA_TypeDef *p_datadma) {
Xstatic __inline void ll_datadma_interrupt_enable(DATADMA_TypeDef *p_datadma) {
N    p_datadma->CON |= LL_DATADMA_CON_IE;
X    p_datadma->CON |= (1UL << 9);
N}
N
N/**
N  * @brief  DATADMA disable interrupt
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @retval None.
N  */
N__STATIC_INLINE void ll_datadma_interrupt_disable(DATADMA_TypeDef *p_datadma) {
Xstatic __inline void ll_datadma_interrupt_disable(DATADMA_TypeDef *p_datadma) {
N    p_datadma->CON &= ~(LL_DATADMA_CON_IE);
X    p_datadma->CON &= ~((1UL << 9));
N}
N
N/**
N  * @brief  DATADMA dma length setting
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @param  len      : dma length
N  * @retval None.
N  */
N__STATIC_INLINE void ll_datadma_dma_len_set(DATADMA_TypeDef *p_datadma, u32 len) {
Xstatic __inline void ll_datadma_dma_len_set(DATADMA_TypeDef *p_datadma, u32 len) {
N    p_datadma->DMA_LEN = LL_DATADMA_LEN(len);
X    p_datadma->DMA_LEN = (((len)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Datadma destination start address setting
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @param  addr     : destination start address
N  * @retval None.
N  */
N__STATIC_INLINE void ll_datadma_dma_dst_addr_set(DATADMA_TypeDef *p_datadma, u32 addr) {
Xstatic __inline void ll_datadma_dma_dst_addr_set(DATADMA_TypeDef *p_datadma, u32 addr) {
N    p_datadma->DEST_DMA_ADR = LL_DATADMA_DEST_DMA_ADR(addr);
X    p_datadma->DEST_DMA_ADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  Datadma dma source start address setting
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @param  addr     : dma source start address
N  * @retval None.
N  */
N__STATIC_INLINE void ll_datadma_dma_src_addr_set(DATADMA_TypeDef *p_datadma, u32 addr) {
Xstatic __inline void ll_datadma_dma_src_addr_set(DATADMA_TypeDef *p_datadma, u32 addr) {
N    p_datadma->SRC_DMA_ADR = LL_DATADMA_SRC_DMA_ADR(addr);
X    p_datadma->SRC_DMA_ADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  Datadma sets the length of the source buf
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @param  len      : the length of the source buf
N  * @retval None.
N  */
N__STATIC_INLINE void ll_datadma_src_buf_len_set(DATADMA_TypeDef *p_datadma, u32 len) {
Xstatic __inline void ll_datadma_src_buf_len_set(DATADMA_TypeDef *p_datadma, u32 len) {
N    p_datadma->SRC_BUF_LEN = LL_DATADMA_SRC_BUF_LEN(len);
X    p_datadma->SRC_BUF_LEN = (((len)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Datadma source buf start address setting
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @param  addr     : source buf start address
N  * @retval None.
N  */
N__STATIC_INLINE void ll_datadma_src_buf_addr_set(DATADMA_TypeDef *p_datadma, u32 addr) {
Xstatic __inline void ll_datadma_src_buf_addr_set(DATADMA_TypeDef *p_datadma, u32 addr) {
N    p_datadma->SRC_BUF_STADR = LL_DATADMA_SRC_BUF_STADR(addr);
X    p_datadma->SRC_BUF_STADR = (((addr)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  Datadma setting mode
N  * @param  p_datadma: Select the initialized DATADMA group pointer
N  * @param  mode     : takes the mode selection of the data
N  * @retval None.
N  */
N__STATIC_INLINE void ll_datadma_mode_set(DATADMA_TypeDef *p_datadma,
Xstatic __inline void ll_datadma_mode_set(DATADMA_TypeDef *p_datadma,
N                                         TYPE_ENUM_LL_DATADMA_MODE mode) {
N    if(mode == LL_DATADMA_LOOP_GET_DATA) {
N        p_datadma->CON &= ~LL_DATADMA_MODE;
X        p_datadma->CON &= ~(1UL << 1);
N    } else {
N        p_datadma->CON |= LL_DATADMA_MODE;
X        p_datadma->CON |= (1UL << 1);
N    }
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_DATADMA_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 48 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_dmac.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_dmac.h" 1
N
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_dmac.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the DMAC LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_DMAC_H
N#define __TX_PHE_LL_DMAC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup dmac_interface_gr DMAC Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup DMAC_LL_Driver DMAC LL Driver
N  * @ingroup  dmac_interface_gr
N  * @brief Mainly the driver part of the DMAC module, which includes \b DMAC \b Register 
N  * \b Constants, \b DMAC \b Exported \b Constants, \b DMAC \b Exported \b Struct, \b DMAC
N  * \b Data \b transfers \b functions, \b DMAC \b Initialization \b and \b DMAC \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DMAC_LL_Register_Constants DMAC LL Register Constants
N  * @ingroup  DMAC_LL_Driver
N  * @brief    DMAC LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the DMAC 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the DMAC register, mainly for convenience. Understand the 
N    configuration of the DMAC.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** DW_PARAMS Register *****/
N/*! number of channels
N */
N#define LL_DW_PARAMS_NR_CHAN               4
N/*! number of AHB masters
N */
N#define LL_DW_PARAMS_NR_MASTER             2
N
N
N/***** DWC_PARAMS Register *****/
N/*! multi block transfer
N */
N#define LL_DWC_PARAMS_MBLK_EN              11
N
N
N/***** CTLx Register *****/
N/*! irqs enabled
N */
N#define LL_DWC_CTLL_INT_EN                 (1UL << 0)
N/*! The size of each element of destination transmission.
N */
N#define LL_DWC_CTLL_DST_WIDTH(n)           (((n)&0x7) << 1)
N/*! The size of each element of source transmission.
N */
N#define LL_DWC_CTLL_SRC_WIDTH(n)           (((n)&0x7) << 4)
N/*! Indicates destination address how to change on every source transfer.
N */
N#define LL_DWC_CTLL_DST_DIR(n)             (((n)&0x3) << 7)
N/*! Indicates source address how to change on every source transfer.
N */
N#define LL_DWC_CTLL_SRC_DIR(n)             (((n)&0x3) << 9)
N/*! Number of data items to be written to de destination every time. 
N */
N#define LL_DWC_CTLL_DST_MSIZE(n)           (((n)&0x7) << 11)
N/*! Number of data items to be read from the source every time. 
N */
N#define LL_DWC_CTLL_SRC_MSIZE(n)           (((n)&0x7) << 14)
N/*! src gather
N */
N#define LL_DWC_CTLL_S_GATH_EN              (1UL << 17)
N/* dst scatter 
N */
N//#define LL_DWC_CTLL_D_SCAT_EN            (1UL << 18)
N/*! Transfer type and flow control.
N */
N#define LL_DWC_CTLL_FC(n)                  (((n)&0x7) << 20)
N/*! dst master select : 1 for memory, 0 for peripherals
N */
N#define LL_DWC_CTLL_DMS(n)                 (((n)&0x3) << 23)
N/*! src master select : 1 for memory, 0 for peripherals
N */
N#define LL_DWC_CTLL_SMS(n)                 (((n)&0x3) << 25)
N/* dest block chain 
N */
N//#define LL_DWC_CTLL_LLP_D_EN             (1UL << 27)
N/* src block chain 
N */
N//#define LL_DWC_CTLL_LLP_S_EN             (1UL << 28)
N
N
N/***** CTL_HI Register *****/
N/*! Block transfer done
N */
N#define LL_DWC_CTLH_DONE                   (0x00001000)
N/*! Block transfer size. The max block size is 4095.
N */
N#define LL_DWC_CTLH_BLOCK_TS_MASK          (0x00000FFF)
N
N
N/***** CFG_LO Register *****/
N/*! Channel priority mask
N */
N#define LL_DWC_CFGL_CH_PRIOR_MASK          (0x7UL << 5)
N/*! Channel priority
N */
N#define LL_DWC_CFGL_CH_PRIOR(n)            (((n)&0x7) << 5)
N/*! Channle Suspend. Suspends all DMA data transfers from the source until this
N *  bit is cleared.
N */
N#define LL_DWC_CFGL_CH_SUSP                (1UL << 8)
N/*! Indicates if there is data left in the channel FIFO.
N */
N#define LL_DWC_CFGL_FIFO_EMPTY             (1UL << 9)
N/*! Destination software or hardware handshaking select.
N */
N#define LL_DWC_CFGL_HS_DST                 (1UL << 10)
N/*! Source software or hardware handshaking select.
N */
N#define LL_DWC_CFGL_HS_SRC                 (1UL << 11)
N//#define LL_DWC_CFGL_LOCK_CH_LEVEL(n)     (((n)&0x3) << 12)
N//#define LL_DWC_CFGL_LOCK_BUS_LEVEL(n)    (((n)&0x3) << 14)
N//#define LL_DWC_CFGL_LOCK_CH              (1UL << 16)
N//#define LL_DWC_CFGL_LOCK_BUS             (1UL << 17)
N/*! Destination handshaking interface polarity.
N */
N#define LL_DWC_CFGL_HS_DST_POL             (1UL << 18)
N/*! Source handshaking interface polarity.
N */
N#define LL_DWC_CFGL_HS_SRC_POL             (1UL << 19)
N/*! Maximum AMBA burst length that is used for DMA transfers on this channel.
N */
N#define LL_DWC_CFGL_MAX_BURST(n)           (((n)&0x2FF) << 20)
N/*! Automatic source reload.
N */
N#define LL_DWC_CFGL_RELOAD_SAR             (1UL << 30)
N/*! Automatic desination reload.
N */
N#define LL_DWC_CFGL_RELOAD_DAR             (1UL << 31)
N
N
N/***** CFG_HI Register *****/
N/*! Flow control mode.
N */
N#define LL_DWC_CFGH_FCMODE                 (1UL << 0)
N/*! FIFO mode select.
N */
N#define LL_DWC_CFGH_FIFO_MODE              (1UL << 1)
N/*! Protection control.
N */
N#define LL_DWC_CFGH_PROTCTL(n)             (((n)&0x7) << 2)
N//#define LL_DWC_CFGH_DS_UPD_EN            (1UL << 5)
N//#define LL_DWC_CFGH_SS_UPD_EN            (1UL << 6)
N/*! Assigns a hardware handshaking interface to the source of channel.
N */
N#define LL_DWC_CFGH_SRC_PER(n)             (((n)&0xF) << 7)
N/*! Assigns a hardware handshaking interface to the destination of channel.
N */
N#define LL_DWC_CFGH_DST_PER(n)             (((n)&0xF) << 11)
N
N
N/***** SGR Register *****/
N/*! Source gather interval.
N */
N#define LL_DWC_SGR_SGI(n)                  (((n)&0xFFFFF) << 0)
N/*! Source gather count.
N */
N#define LL_DWC_SGR_SGC(n)                  (((n)&0xF) << 20)
N
N
N/***** DSR Register *****/
N//#define LL_DWC_DSR_DSI(x)                (((n)&0xFFFFF) << 0)
N//#define LL_DWC_DSR_DSC(x)                (((n)&0xF) << 20)
N
N
N/***** DmaCfgReg Register *****/
N/*! dmac enable.
N */
N#define LL_DW_CFG_DMA_EN                   (1UL << 0)
N
N/***** ChEnRegL/MaskTfrL/MaskErrL/MaskDstTranL/MaskSrcTranL/MaskBlockL/ Register *****/
N/*! Source gather count.
N */
N#define LL_DMAC_WRITE_EN(n)                (BIT(n+8) | BIT(n))
N/*! Source gather count.
N */
N#define LL_DMAC_WRITE_DIS(n)               (BIT(n+8))
N
N/**
N  * @}
N  */
N
N/** @defgroup DMAC_LL_Exported_Constants DMAC LL Exported Constants
N  * @ingroup  DMAC_LL_Driver
N  * @brief    DMAC LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N/*! max dmac hardware channel
N */
N#define LL_MAX_DMAC_CHN                 4
N/*! max dmac hardware channel mask
N */
N#define LL_MAX_DMAC_CHN_MASK            0xF
N
N
N/***** LL API *****/
N
N
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Number of data items to be transferred(of width TR_WIDTH).
N  */
Ntypedef enum {
N    /*! damc data width : 1byte
N     */
N    LL_DW_DMAC_MSIZE_1,
N    /*! damc data width : 4byte
N     */
N
N    LL_DW_DMAC_MSIZE_4,
N    /*! damc data width : 8byte
N     */
N    LL_DW_DMAC_MSIZE_8,
N    // The following MSIZE is not supported.
N//    DW_DMAC_MSIZE_16,
N//    DW_DMAC_MSIZE_32,
N//    DW_DMAC_MSIZE_64,
N//    DW_DMAC_MSIZE_128,
N//    DW_DMAC_MSIZE_256,
N} TYPE_ENUM_LL_DMAC_MSIZE;
N
N/**
N  * @brief The size of each element of destination transmission. The unit is bit.
N  */
Ntypedef enum {
N    /*! damc xfer width : 8 bit
N     */
N    LL_DW_DMAC_TR_8,
N    /*! damc xfer width : 16bit
N     */
N    LL_DW_DMAC_TR_16,
N    /*! damc xfer width : 32bit
N     */
N    LL_DW_DMAC_TR_32,
N    // The following TR_WIDTH is not supported.
N//    DW_DMAC_TR_64,
N//    DW_DMAC_TR_128,
N//    DW_DMAC_TR_256,
N} TYPE_ENUM_LL_DMAC_TR_WIDTH;
N
N/**
N  * @brief Indicates destination address how to change on every source transfer.
N  */
Ntypedef enum {
N    /*! Increment
N     */
N    LL_DW_DMAC_ADDR_INC,
N    /*! Decrement
N     */
N    LL_DW_DMAC_ADDR_DEC,
N    /*! No change
N     */
N    LL_DW_DMAC_ADDR_NO_CHANGE,
N} TYPE_ENUM_LL_DMAC_ADDR_DIR;
N
N/**
N  * @brief flow controller
N@verbatim   
N-------------------------------------------------------------------------------
NCTLL.TT_FC Field        Transfer Type                   Flow Controller    
N-------------------------------------------------------------------------------
N      000               Memory to Memory                DW_anb_dmac
N      001               Memory to Peripheral            DW_anb_dmac
N      010               Peripheral to Memory            DW_anb_dmac
N      011               Peripheral to Peripheral        DW_anb_dmac
N      100               Peripheral to Memory            Peripheral
N      101               Peripheral to Peripheral        Source Peripheral
N      110               Memory to Peripheral            Peripheral
N      111               Peripheral to Peripheral        Destination Peripheral
N@endverbatim
N  */
Ntypedef enum {
N    /*! Memory to Memory
N     */
N    LL_DW_DMA_FC_D_M2M,
N    /*! Memory to Peripheral
N     */
N    LL_DW_DMA_FC_D_M2P,
N    /*! Peripheral to Memory
N     */
N    LL_DW_DMA_FC_D_P2M,
N    /*! Peripheral to Peripheral
N     */
N    LL_DW_DMA_FC_D_P2P,
N    /*! EFLASH : Memory to Memory
N     */
N    LL_DW_DMA_FC_D_M2M_EFLASH,
N    // The following flow control is not supported.
N//  DW_DMA_FC_P_P2M,
N//  DW_DMA_FC_SP_P2P,
N//  DW_DMA_FC_P_M2P,
N//  DW_DMA_FC_DP_P2P,
N} TYPE_ENUM_LL_DMAC_FC;
N
N/**
N  * @brief hardware handshaking interface(DMAC req channel)
N  */
Ntypedef enum {
N    /*! Peripheral channel : MEMORY
N     */
N    LL_DMA_CH_MEMORY    = 0,
N    /*! Peripheral channel : I2C0_TX
N     */
N    LL_DMA_CH_I2C0_TX   = 0,
N    /*! Peripheral channel : I2C0_RX 
N     */
N    LL_DMA_CH_I2C0_RX   = 1,
N    /*! Peripheral channel : I2C1_TX 
N     */
N    LL_DMA_CH_I2C1_TX   = 2,
N    /*! Peripheral channel : I2C1_RX 
N     */
N    LL_DMA_CH_I2C1_RX   = 3,
N    /*! Peripheral channel : SPI0_TX
N     */
N    LL_DMA_CH_SPI0_TX   = 4,
N    /*! Peripheral channel : SPI0_RX 
N     */
N    LL_DMA_CH_SPI0_RX   = 5,
N    /*! Peripheral channel : SPI1_TX 
N     */
N    LL_DMA_CH_SPI1_TX   = 6,
N    /*! Peripheral channel : SPI1_RX 
N     */
N    LL_DMA_CH_SPI1_RX   = 7,
N    /*! Peripheral channel : USART0_TX
N     */
N    LL_DMA_CH_USART0_TX = 8,
N    /*! Peripheral channel : USART0_RX
N     */
N    LL_DMA_CH_USART0_RX = 9,
N    /*! Peripheral channel : USART1_TX 
N     */
N    LL_DMA_CH_USART1_TX = 10,
N    /*! Peripheral channel : USART1_RX 
N     */
N    LL_DMA_CH_USART1_RX = 11,
N    /*! Peripheral channel : USART2_TX 
N     */
N    LL_DMA_CH_USART2_TX = 12,
N    /*! Peripheral channel : USART2_RX
N     */
N    LL_DMA_CH_USART2_RX = 13,
N} TYPE_ENUM_LL_DMAC_PER_INTERFACE;
N
N
N/**
N  * @}
N  */
N
N/** @defgroup DMAC_LL_Exported_Struct DMAC LL Exported Struct
N  * @ingroup  DMAC_LL_Driver
N  * @brief    DMAC LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the DMAC registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_dmac_init. Function, you can configure the DMAC module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief Peripheral attributes
N  */
Ntypedef struct __ll_dmac_flow_attr {
N    /*! DMAC Peripheral address
N     *  @note The addr is aligned in 4bytes and can only be located in
N     *        EFLASH/SRAM0/SRAM10/SRAM1/SRAM2/SRAM3.  
N     *        Statement example:  
N     *          static u8 buf[1024] __attribute__(section("SRAM0"));
N     */
N    u32                             addr;
N    /*! DMAC Peripheral address direction : TYPE_ENUM_LL_DMAC_ADDR_DIR
N     */
N    TYPE_ENUM_LL_DMAC_ADDR_DIR      addr_dir;
N    /*! DMAC Peripheral TYPE_ENUM_LL_DMAC_PER_INTERFACE
N     */
N    TYPE_ENUM_LL_DMAC_PER_INTERFACE interface_chn;
N} TYPE_LL_DMAC_FLOW_ATTR;
N
N/**
N  * @brief DMAC interrupt configuration type.
N  */
Ntypedef struct __ll_dmac_irq_cfg {
N    /*! DMAC channel number 
N     */
N    u32  chn;
N    /*! DMAC interrupt enable
N     */
N    bool intr_en;
N    /*! true means mask, false means unmask.
N     */
N    bool xfer_cplt_intr_dis;
N    /*! true means mask, false means unmask.
N     */
N    bool block_intr_dis;
N    /*! true means mask, false means unmask. 
N     */
N    bool src_xfer_cplt_intr_dis;
N    /*! true means mask, false means unmask.
N     */
N    bool dst_xfer_cplt_intr_dis;
N    /*! true means mask, false means unmask. 
N     */
N    bool xfer_err_intr_dis;
N} TYPE_LL_DMAC_IRQ_CFG;
N
N/**
N  * @brief DMAC configure the structure type.
N  */
Ntypedef struct __ll_dmac_cfg {
N    /*! DMAC channel number 
N     */
N    u32                         chn;
N    /*! Source Peripheral attributes
N     */
N    TYPE_LL_DMAC_FLOW_ATTR      src;
N    /*! Destination Peripheral attributes 
N     */
N    TYPE_LL_DMAC_FLOW_ATTR      dst;
N    /*! DMAC flow control 
N     */
N    TYPE_ENUM_LL_DMAC_FC        flow_ctrl;
N    /*! The width of each element of the DMA.
N     */
N    TYPE_ENUM_LL_DMAC_TR_WIDTH  element_per_width;
N    /*! The number of data transmissions.  Must not be greater than 4095.
N     */
N    u32                         element_num;
N} TYPE_LL_DMAC_CFG;
N
N/**
N  * @brief DMAC initialize stuctor.
N  */
Ntypedef struct __ll_dmac_init {
N    u8  reserved;
N} TYPE_LL_DMAC_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup DMAC_LL_Interrupt DMAC LL Interrupt Handle function
N  * @brief   DMAC LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DMAC  
N    Interrupt Handle function.
N
N    how to use?
N
N    The DMAC interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the DMAC in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup DMAC_LL_Inti_Cfg DMAC LL Initialization And Configuration
N  * @brief    DMAC LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DMAC data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  ll_dmac_init
N  * @param  p_dmac : pointer to the hardware DMAC_TypeDef
N  * @param  p_init : pointer to the init stuct TYPE_LL_DMAC_INIT
N  * @retval None
N  */
Nvoid ll_dmac_init(DMAC_TypeDef * p_dmac, TYPE_LL_DMAC_INIT *p_init);
N
N/**
N  * @brief  ll_dmac_deinit
N  * @param  p_dmac : pointer to the hardware DMAC_TypeDef
N  * @retval None
N  */
Nvoid ll_dmac_deinit(DMAC_TypeDef * p_dmac);
N
N/**
N  * @brief  DMAC channel interrupt configuration.
N  * @param  p_dmac: DMAC module pointer.
N  * @param  p_cfg :  DMAC interrupt configuration pointer.
N  * @retval None
N  */
Nvoid ll_dmac_irq_config(DMAC_TypeDef *p_dmac, TYPE_LL_DMAC_IRQ_CFG *p_cfg);
N
N/**
N  * @brief  DMAC module configuration function.
N  * @param  p_dmac: DMAC module pointer.DMAC_TypeDef
N  * @param  p_cfg :  DMAC configuration structure pointer.TYPE_LL_DMAC_CFG
N  * @retval None
N  */
Nvoid ll_dmac_config(DMAC_TypeDef *p_dmac, TYPE_LL_DMAC_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup DMAC_LL_Data_Transfers DMAC LL Data transfers functions
N  * @brief    DMAC LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the DMAC data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Start a specific DMA channel.
N  * @param  p_dmac: DMAC module pointer.
N  * @param  chn   : DMAC channel number.
N  * @retval None
N  */
Nvoid ll_dmac_start(DMAC_TypeDef *p_dmac, u32 chn);
N
N/**
N  * @brief  Disable a specific DMA channel.
N  * @param  p_dmac: DMAC module pointer.
N  * @param  chn   : DMAC channel number.
N  * @retval None
N  */
Nvoid ll_dmac_stop(DMAC_TypeDef *p_dmac, u32 chn);
N
N/**
N  * @brief  Wait for the DMAC channel to end the operation.
N  * @param  p_dmac: DMAC module pointer.
N  * @param  chn   : DMAC channel number.
N  * @retval Returns true if the DMAC channel is normal and false if it
N  *         represents an error in the DMAC channel.
N  */
Nbool ll_dmac_wait_completed(DMAC_TypeDef *p_dmac, u32 chn);
N
N/**
N  * @brief  DMAC's gather function settings
N  * @param  p_dmac: DMAC module pointer
N  * @param  chn   : DMAC channel number
N  * @param  sgc   : The amount of data continuously acquired
N  * @param  sgi   : Interval of data
N  * @retval None
N  * @note   The amount of data that sgc and sgi together is taken as a unit.
N  *         The sgi data will be discarded.
N  */
Nvoid ll_dmac_src_gather_config(DMAC_TypeDef *p_dmac, u32 chn, u32 sgc, u32 sgi);
N
N/**
N  * @brief  Return the DMA xfered length when dma is complete or abort
N  * @param  p_dmac: DMAC module pointer
N  * @param  chn   : DMAC channel number
N  * @retval DMA xfered length, 0 will set when both src&dst dma address both not change
N  */
Nuint32_t ll_dma_get_xfer_len(DMAC_TypeDef *p_dmac, u8 chn);
N
N/**
N  * @brief  Whether a DMAC channel is idle.
N  * @param  p_dmac: DMAC module pointer.
N  * @param  chn   : DMAC channel number.
N  * @retval Returns true for idle and false for occupied.
N  */
N__STATIC_INLINE bool ll_dmac_is_channel_free(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline bool ll_dmac_is_channel_free(DMAC_TypeDef *p_dmac, u32 chn) {
N    return p_dmac->ChEnRegL & BIT(chn) ? false : true;
X    return p_dmac->ChEnRegL & ((uint32_t)1<<(chn)) ? false : true;
N}
N
N/**
N * @brief  ll_dmac_xfer_interrupt_enable
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_xfer_interrupt_enable(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_xfer_interrupt_enable(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->MaskTfrL = LL_DMAC_WRITE_EN(chn);
X    p_dmac->MaskTfrL = (((uint32_t)1<<(chn+8)) | ((uint32_t)1<<(chn)));
N}
N
N/**
N * @brief  ll_dmac_xfer_interrupt_disable
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_xfer_interrupt_disable(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_xfer_interrupt_disable(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->MaskTfrL = LL_DMAC_WRITE_DIS(chn);
X    p_dmac->MaskTfrL = (((uint32_t)1<<(chn+8)));
N}
N
N/**
N * @brief  LL_DMAC_CHECK_XFER_INTERRUPT_ENABLE
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval interrupt_enable 
N */
N#define LL_DMAC_CHECK_XFER_INTERRUPT_ENABLE(p_dmac, chn)    ((p_dmac)->MaskTfrL & BIT(chn))
N
N/**
N * @brief  LL_DMAC_GET_XFER_PENDING
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval pending 
N */
N#define LL_DMAC_GET_XFER_PENDING(p_dmac, chn)               ((p_dmac)->RawTfrL & BIT(chn))
N
N/**
N * @brief  ll_dmac_clear_xfer_pending
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_clear_xfer_pending(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_clear_xfer_pending(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->ClearTfrL = BIT(chn);
X    p_dmac->ClearTfrL = ((uint32_t)1<<(chn));
N}
N
N/**
N * @brief  ll_dmac_block_interrupt_enable
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_block_interrupt_enable(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_block_interrupt_enable(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->MaskBlockL = LL_DMAC_WRITE_EN(chn);
X    p_dmac->MaskBlockL = (((uint32_t)1<<(chn+8)) | ((uint32_t)1<<(chn)));
N}
N
N/**
N * @brief  ll_dmac_block_interrupt_disable
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_block_interrupt_disable(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_block_interrupt_disable(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->MaskBlockL = LL_DMAC_WRITE_DIS(chn);
X    p_dmac->MaskBlockL = (((uint32_t)1<<(chn+8)));
N}
N
N/**
N * @brief  LL_DMAC_CHECK_BLOCK_INTERRUPT_ENABLE
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval interrupt_enable 
N */
N#define LL_DMAC_CHECK_BLOCK_INTERRUPT_ENABLE(p_dmac, chn)   ((p_dmac)->MaskBlockL & BIT(chn))
N
N/**
N * @brief  LL_DMAC_GET_BLOCK_PENDING
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval pending
N */
N#define LL_DMAC_GET_BLOCK_PENDING(p_dmac, chn)              ((p_dmac)->RawBlockL & BIT(chn))
N
N/**
N * @brief  ll_dmac_clear_block_pending
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_clear_block_pending(DMAC_TypeDef *p_dmac, u32 chn) {    
Xstatic __inline void ll_dmac_clear_block_pending(DMAC_TypeDef *p_dmac, u32 chn) {    
N    p_dmac->ClearBlockL = BIT(chn);
X    p_dmac->ClearBlockL = ((uint32_t)1<<(chn));
N}
N
N/**
N * @brief  ll_dmac_src_xfer_interrupt_enable
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_src_xfer_interrupt_enable(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_src_xfer_interrupt_enable(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->MaskSrcTranL = LL_DMAC_WRITE_EN(chn);
X    p_dmac->MaskSrcTranL = (((uint32_t)1<<(chn+8)) | ((uint32_t)1<<(chn)));
N}
N
N/**
N * @brief  ll_dmac_src_xfer_interrupt_disable
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_src_xfer_interrupt_disable(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_src_xfer_interrupt_disable(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->MaskSrcTranL = LL_DMAC_WRITE_DIS(chn);
X    p_dmac->MaskSrcTranL = (((uint32_t)1<<(chn+8)));
N}
N
N/**
N * @brief  LL_DMAC_CHECK_SRC_XFER_INTERRUPT_ENABLE
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval interrupt_enable 
N */
N#define LL_DMAC_CHECK_SRC_XFER_INTERRUPT_ENABLE(p_dmac, chn)    ((p_dmac)->MaskSrcTranL & BIT(chn))
N
N/**
N * @brief  LL_DMAC_GET_SRC_XFER_PENDING
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval pending
N */
N#define LL_DMAC_GET_SRC_XFER_PENDING(p_dmac, chn)               ((p_dmac)->RawSrcTranL & BIT(chn))
N
N/**
N * @brief  ll_dmac_clear_src_xfer_pending
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_clear_src_xfer_pending(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_clear_src_xfer_pending(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->ClearSrcTranL = BIT(chn);
X    p_dmac->ClearSrcTranL = ((uint32_t)1<<(chn));
N}
N
N/**
N * @brief  ll_dmac_dst_xfer_interrupt_enable
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_dst_xfer_interrupt_enable(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_dst_xfer_interrupt_enable(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->MaskDstTranL = LL_DMAC_WRITE_EN(chn);
X    p_dmac->MaskDstTranL = (((uint32_t)1<<(chn+8)) | ((uint32_t)1<<(chn)));
N}
N
N/**
N * @brief  ll_dmac_dst_xfer_interrupt_disable
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_dst_xfer_interrupt_disable(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_dst_xfer_interrupt_disable(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->MaskDstTranL = LL_DMAC_WRITE_DIS(chn);
X    p_dmac->MaskDstTranL = (((uint32_t)1<<(chn+8)));
N}
N
N/**
N * @brief  LL_DMAC_CHECK_DST_XFER_INTERRUPT_ENABLE
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval interrupt_enable 
N */
N#define LL_DMAC_CHECK_DST_XFER_INTERRUPT_ENABLE(p_dmac, chn)    ((p_dmac)->MaskDstTranL & BIT(chn))
N
N/**
N * @brief  LL_DMAC_GET_DST_XFER_PENDING
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval pending
N */
N#define LL_DMAC_GET_DST_XFER_PENDING(p_dmac, chn)               ((p_dmac)->RawDstTranL & BIT(chn))
N
N/**
N * @brief  ll_dmac_clear_dst_xfer_pending
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_clear_dst_xfer_pending(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_clear_dst_xfer_pending(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->ClearDstTranL = BIT(chn);
X    p_dmac->ClearDstTranL = ((uint32_t)1<<(chn));
N}
N
N/**
N * @brief  ll_dmac_xfer_err_interrupt_enable
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_xfer_err_interrupt_enable(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_xfer_err_interrupt_enable(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->MaskErrL = LL_DMAC_WRITE_EN(chn);
X    p_dmac->MaskErrL = (((uint32_t)1<<(chn+8)) | ((uint32_t)1<<(chn)));
N}
N
N/**
N * @brief  ll_dmac_xfer_err_interrupt_disable
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_xfer_err_interrupt_disable(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_xfer_err_interrupt_disable(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->MaskErrL = LL_DMAC_WRITE_DIS(chn);
X    p_dmac->MaskErrL = (((uint32_t)1<<(chn+8)));
N}
N
N/**
N * @brief  LL_DMAC_CHECK_XFER_ERR_INTERRUPT_ENABLE
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval interrupt_enable 
N */
N#define LL_DMAC_CHECK_XFER_ERR_INTERRUPT_ENABLE(p_dmac, chn)    ((p_dmac)->MaskErrL & BIT(chn))
N
N/**
N * @brief  LL_DMAC_GET_XFER_ERR_PENDING
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval pending
N */
N#define LL_DMAC_GET_XFER_ERR_PENDING(p_dmac, chn)               ((p_dmac)->RawErrL & BIT(chn))
N
N/**
N * @brief  ll_dmac_clear_xfer_err_pending
N * @param  p_dmac: DMAC module pointer. DMAC_TypeDef
N * @param  chn   : DMAC channel number.
N * @retval none
N */
N__STATIC_INLINE void ll_dmac_clear_xfer_err_pending(DMAC_TypeDef *p_dmac, u32 chn) {
Xstatic __inline void ll_dmac_clear_xfer_err_pending(DMAC_TypeDef *p_dmac, u32 chn) {
N    p_dmac->ClearErrL = BIT(chn);
X    p_dmac->ClearErrL = ((uint32_t)1<<(chn));
N}
N
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_DMAC_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 49 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_crc.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_crc.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_crc.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the CRC LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_CRC_H
N#define __TX_PHE_LL_CRC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup crc_interface_gr CRC Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup CRC_LL_Driver CRC LL Driver
N  * @ingroup  crc_interface_gr
N  * @brief Mainly the driver part of the CRC module, which includes \b CRC \b Register 
N  * \b Constants, \b CRC \b Exported \b Constants, \b CRC \b Exported \b Struct, \b CRC
N  * \b Data \b transfers \b functions, \b CRC \b Initialization \b and \b CRC \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CRC_LL_Register_Constants CRC LL Register Constants
N  * @ingroup  CRC_LL_Driver
N  * @brief    CRC LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the CRC 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the CRC register, mainly for convenience. Understand the 
N    configuration of the CRC.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** CRC_CFG Register *****/
N/*! CRC interrupt enable 
N */
N#define LL_CRC_INT_EN                          (1UL << 0)
N/*! CRC shift bit direction 
N */
N#define LL_CRC_BIT_ORDER_LEFT                  (1UL << 1)
N#define LL_CRC_BIT_ORDER_RIGHT                 (0UL << 1)
N/*! CRC POLY width: 5/7/8/16/32 
N */
N#define LL_CRC_POLY_BITS(n)                    (((n)&0x3F) << 8)
N/*! CRC DMA data wait clock every time 
N */
N#define LL_CRC_DMAWAIT_CLOCK(n)                (((n)&0x7) << 16)
N
N
N/***** CRC_KST Register *****/
N/*! CRC pending clear 
N */
N#define LL_CRC_DMA_PENDING_CLR                 (1UL << 0)
N
N
N/***** CRC_STA Register *****/
N/*! CRC pending 
N */
N#define LL_CRC_DMA_PENDING                     (1UL << 0) 
N
N
N/***** CRC_INIT Register *****/
N/***** CRC_INV Register *****/
N/***** CRC_POLY Register *****/
N/***** CRC_DMA_ADDR Register *****/
N/***** CRC_DMA_LEN Register *****/
N/***** CRC_CRC_OUT Register *****/
N
N
N/**
N  * @}
N  */
N
N/** @defgroup CRC_LL_Exported_Constants CRC LL Exported Constants
N  * @ingroup  CRC_LL_Driver
N  * @brief    CRC LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N/**
N  * @brief CRC poly shift dir enum
N  */
Ntypedef enum {
N    /*! CRC poly shift bit direction : right
N     */
N    LL_CRC_POLY_SHIFT_RIGHT = 0,
N    /*! CRC poly shift bit direction : left
N     */
N    LL_CRC_POLY_SHIFT_LEFT  = 1,
N} TYPE_ENUM_LL_CRC_POLY_SHIFT_DIR;
N
N/**
N  * @brief CRC poly width enum
N  */
Ntypedef enum {
N    /*! CRC poly bit width : 5
N     */
N    LL_CRC_POLY_5BIT  = 5,
N    /*! CRC poly bit width : 7
N     */
N    LL_CRC_POLY_7BIT  = 7,
N    /*! CRC poly bit width : 8
N     */
N    LL_CRC_POLY_8BIT  = 8,
N    /*! CRC poly bit width : 16
N     */
N    LL_CRC_POLY_16BIT = 16,
N    /*! CRC poly bit width : 32
N     */
N    LL_CRC_POLY_32BIT = 32,
N} TYPE_ENUM_LL_CRC_POLY_WIDTH;
N
N
N/***** LL API AND DRIVER API *****/
N
N
N/**
N  * @}
N  */
N
N/** @defgroup CRC_LL_Exported_Struct CRC LL Exported Struct
N  * @ingroup  CRC_LL_Driver
N  * @brief    CRC LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the CRC registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_crc_init. Function, you can configure the CRC module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief CRC config struct
N  */
Ntypedef struct __ll_crc_cfg {
N    /*! crc init.
N     */
N    u32                             init_val;
N    /*! crc poly.
N     */
N    u32                             poly;
N    /*! crc poly bit 5/7/8/16/32.
N     */
N    TYPE_ENUM_LL_CRC_POLY_WIDTH     poly_bits;
N    /*! crc poly shift dir: 0 for right, 1 for left.
N     */
N    TYPE_ENUM_LL_CRC_POLY_SHIFT_DIR poly_shift_dir;
N    /*! crc wait clocks (for CRC32 run speed limit to 32Mhz).
N     */
N    u32                             crc32_wait_clks;
N    /*! crc out value invert.
N     */
N    u32                             out_invert;
N} TYPE_LL_CRC_CFG;
N
N/**
N  * @brief CRC init struct
N  */
Ntypedef struct __ll_crc_init {
N    u8  reserved;
N} TYPE_LL_CRC_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup CRC_LL_Interrupt CRC LL Interrupt Handle function
N  * @brief   CRC LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the CRC  
N    Interrupt Handle function.
N
N    how to use?
N
N    The CRC interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the CRC in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup CRC_LL_Inti_Cfg CRC LL Initialization And Configuration
N  * @brief    CRC LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the CRC data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  crc_init
N  * @param  p_crc : pointer to the hardware CRC_TypeDef
N  * @param  p_init: pointer to the init stuct TYPE_LL_CRC_INIT
N  * @retval None
N  */
Nvoid ll_crc_init(CRC_TypeDef *p_crc, TYPE_LL_CRC_INIT *p_init);
N
N/**
N  * @brief  crc_deinit
N  * @param  p_crc : pointer to the hardware CRC_TypeDef
N  * @retval None
N  */
Nvoid ll_crc_deinit(CRC_TypeDef *p_crc);
N
N/**
N  * @brief  ll_crc_config & start crc calc
N  * @param  p_crc : pointer to the hardware CRC_TypeDef
N  * @param  p_cfg : pointer to the init stuct TYPE_LL_CRC_CFG
N  * @retval None
N  */
Nvoid ll_crc_config(CRC_TypeDef *p_crc, TYPE_LL_CRC_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup CRC_LL_Data_Transfers CRC LL Data transfers functions
N  * @brief    CRC LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the CRC data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  crc_start
N  * @param  p_crc: pointer to the hardware CRC_TypeDef
N  * @param  addr : CRC calc start address 32bit align
N  * @param  len  : CRC calc len , unit : 1byte
N  * @note   The dma_addr is aligned in 4bytes and can only be located in
N  *         SRAM0/SRAM10.  
N  *         Statement example: tatic u8 buf[1024] __attribute__((aligned(4),section("SRAM0")));
N  * @retval None
N  */
Nvoid ll_crc_start(CRC_TypeDef *p_crc, u32 addr, u32 len);
N
N/**
N  * @brief  crc wait
N  * @param  p_crc: pointer to the hardware CRC_TypeDef
N  * @retval None
N  */
Nvoid ll_crc_wait_done_pending(CRC_TypeDef *p_crc);
N
N/**
N  * @brief  crc stop
N  * @param  p_crc: pointer to the hardware CRC_TypeDef
N  * @retval None
N  */
Nvoid ll_crc_stop(CRC_TypeDef *p_crc);
N
N/**
N  * @brief  Get crc result
N  * @param  p_crc: pointer to the hardware CRC_TypeDef
N  * @retval crc result
N  */
N#define LL_CRC_GET_CHECK_VAL(p_crc)             ((p_crc)->CRC_OUT)
N
N/**
N  * @brief  LL_CRC_CHECK_INTERRUPT_ENABLE
N  * @param  p_crc: pointer to the hardware CRC_TypeDef
N  * @retval interrupt_enable
N  */
N#define LL_CRC_CHECK_INTERRUPT_ENABLE(p_crc)    ((p_crc)->CRC_CFG & LL_CRC_INT_EN)
N
N/**
N  * @brief  Get crc pending
N  * @param  p_crc: pointer to the hardware CRC_TypeDef
N  * @retval pending
N  */
N#define LL_CRC_GET_DONE_PENDING(p_crc)          ((p_crc)->CRC_STA & LL_CRC_DMA_PENDING)
N
N/**
N  * @brief  clear crc pending
N  * @param  p_crc: pointer to the hardware CRC_TypeDef
N  * @retval none
N  */
N__STATIC_INLINE void ll_crc_clear_done_pending(CRC_TypeDef *p_crc) {
Xstatic __inline void ll_crc_clear_done_pending(CRC_TypeDef *p_crc) {
N    p_crc->CRC_KST = LL_CRC_DMA_PENDING_CLR;
X    p_crc->CRC_KST = (1UL << 0);
N}
N
N/**
N  * @brief  ll_crc_interrupt_enable
N  * @param  p_crc: pointer to the hardware CRC_TypeDef
N  * @retval none
N  */
N__STATIC_INLINE void ll_crc_interrupt_enable(CRC_TypeDef *p_crc) {
Xstatic __inline void ll_crc_interrupt_enable(CRC_TypeDef *p_crc) {
N    p_crc->CRC_CFG |= LL_CRC_INT_EN;
X    p_crc->CRC_CFG |= (1UL << 0);
N}
N
N/**
N  * @brief  ll_crc_interrupt_disable
N  * @param  p_crc: pointer to the hardware CRC_TypeDef
N  * @retval none
N  */
N__STATIC_INLINE void ll_crc_interrupt_disable(CRC_TypeDef *p_crc) {
Xstatic __inline void ll_crc_interrupt_disable(CRC_TypeDef *p_crc) {
N    p_crc->CRC_CFG &= ~LL_CRC_INT_EN;
X    p_crc->CRC_CFG &= ~(1UL << 0);
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_CRC_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 50 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_hcc.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_hcc.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_hcc.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the HCC LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_HCC_H
N#define __TX_PHE_LL_HCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup hcc_interface_gr HCC Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup HCC_LL_Driver HCC LL Driver
N  * @ingroup  hcc_interface_gr
N  * @brief Mainly the driver part of the HCC module, which includes \b HCC \b Register 
N  * \b Constants, \b HCC \b Exported \b Constants, \b HCC \b Exported \b Struct, \b HCC
N  * \b Data \b transfers \b functions, \b HCC \b Initialization \b and \b HCC \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup HCC_LL_Register_Constants HCC LL Register Constants
N  * @ingroup  HCC_LL_Driver
N  * @brief    HCC LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the HCC 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the HCC register, mainly for convenience. Understand the 
N    configuration of the HCC.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** CRC_CFG Register *****/
N/*! HC done Pending, write 1 to clear
N */
N#define LL_HCC_PENDING                     (1UL << 31)
N/*! HC number = 2*Len
N */
N#define LL_HCC_DMA_LEN(n)                  (((n)&0x3F) << 8)
N/*! HC range calc enable
N */
N#define LL_HCC_RAG_EN                      (1UL << 3)
N/*! HC phase calc enable
N */
N#define LL_HCC_PHS_EN                      (1UL << 2)
N/*! HC interrupt enable
N */
N#define LL_HCC_INT_EN                      (1UL << 1)
N/*! HC Write 1 to start HC, auto clear
N */
N#define LL_HCC_START                       (1UL << 0)
N
N
N/**
N  * @}
N  */
N
N/** @defgroup HCC_LL_Exported_Constants HCC LL Exported Constants
N  * @ingroup  HCC_LL_Driver
N  * @brief    HCC LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N  
N/***** LL API AND DRIVER API *****/
N
N
N
N/**
N  * @}
N  */
N
N/** @defgroup HCC_LL_Exported_Struct HCC LL Exported Struct
N  * @ingroup  HCC_LL_Driver
N  * @brief    HCC LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the HCC registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_hcc_init. Function, you can configure the HCC module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief Define the complex type, consistent with the HCC module  
N  *        The imaginary part and the real part data are all 16bit signed numbers, among
N  *        which there are 15bit fixed-point decimals.
N  */
Ntypedef struct __ll_hcc_complex_data {
N    /*! Buffer image part, signed 
N     */
N    s16 img;
N    /*! Buffer real part, signed 
N     */
N    s16 real;
N} TYPE_LL_HCC_COMPLEX_DATA;
N
N/**
N  * @brief Defines the integer and fractional parts of the range, consistent
N  *        with the HCC module.  
N  *        The range data is a 12-bit unsigned number with 8 bits fixed-point
N  *        decimals.
N  */
Ntypedef struct __ll_hcc_rag_split_coeff {
N    /*! Decimal part 
N     */
N    u16 frac            : 8,
N    /*! Integer part 
N     */
N        integer         : 4;
N} TYPE_LL_HCC_RAG_SPLIT_COEFF;
N
N/**
N  * @brief Use union to define the range data type, consistent with the hcc
N  *        module.
N  */
Ntypedef union __ll_hcc_range_data {
N    /*! One overall 12bit data 
N     */
N    u16                         coeff : 12;
N    /*! Range split coeff 
N     */
N    TYPE_LL_HCC_RAG_SPLIT_COEFF spilt_coeff;
N} TYPE_LL_HCC_RANGE_DATA;
N
N/**
N  * @brief Define hcc configuration structure type
N  */
Ntypedef struct __ll_hcc_cfg {
N    /*! FFT buf start address, requires 8byte alignment.  
N     *  permission : SRAM0/4/5/6/7/8/9
N     *  @note usage : 
N     *        s16 fft_buf[256] __attribute__((aligned(8), section("SRAM0")));
N     */
N    u32  dma_fft_start_addr;
N    /*! PHASE buf start address, requires 8byte alignment.  
N     *  permission : SRAM0/10
N     */
N    u32  dma_phase_start_addr;
N    /*! RANGE buf start address, requires 8byte alignment.  
N     *  permission : SRAM0/10
N     */
N    u32  dma_range_start_addr;
N    /*! HC number is the actual number of dma calculations. The HCC number must 
N     *  be an even number.
N     */
N    u32  dma_points;
N    /*! If range_enable is true, use a custom range coefficient. If range_enable
N     *  is false, it means that there is no range coefficient.
N     */
N    bool range_enable;
N    /*! If phase_enable is true, it means that you use a custom phase coefficient.
N     *  If phase_enable is false, it means that there is no phase coefficient
N     *  (corresponding to 0 in the imaginary part of the phase and 1<<15 in the
N     *  real part).
N     */
N    bool phase_enable;
N} TYPE_LL_HCC_CFG;
N
N/**
N  * @brief Define hcc init structure type
N  */
Ntypedef struct __ll_hcc_init {
N    u8 reserved;
N} TYPE_LL_HCC_INIT;
N
N
N/**
N  * @}
N  */
N
N/** @defgroup HCC_LL_Interrupt HCC LL Interrupt Handle function
N  * @brief   HCC LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the HCC  
N    Interrupt Handle function.
N
N    how to use?
N
N    The HCC interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the HCC in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup HCC_LL_Inti_Cfg HCC LL Initialization And Configuration
N  * @brief    HCC LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the HCC data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  hcc_init
N  * @param  p_hcc : pointer to the hardware HCC_TypeDef
N  * @param  p_init: pointer to the init stuct TYPE_LL_HCC_INIT
N  * @retval None
N  */
Nvoid ll_hcc_init(HCC_TypeDef *p_hcc, TYPE_LL_HCC_INIT *p_init);
N
N/**
N  * @brief  hcc_deinit
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval None
N  */
Nvoid ll_hcc_deinit(HCC_TypeDef *p_hcc);
N
N/**
N  * @brief  ll_hcc_config
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @param  p_cfg: pointer to the init stuct TYPE_LL_HCC_CFG
N  * @retval None
N  */
Nvoid ll_hcc_config(HCC_TypeDef *p_hcc, TYPE_LL_HCC_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup HCC_LL_Data_Transfers HCC LL Data transfers functions
N  * @brief    HCC LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the HCC data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  hcc_start
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval None
N  */
Nvoid ll_hcc_start(HCC_TypeDef *p_hcc);
N
N/**
N  * @brief  Wait for the module to finish computing
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval None
N  */
Nvoid ll_hcc_wait_done_pending(HCC_TypeDef *p_hcc);
N
N/**
N  * @brief  hcc stop
N  * @param  p_hcc : pointer to the hardware HCC_TypeDef
N  * @retval None
N  */
Nvoid ll_hcc_stop(HCC_TypeDef *p_hcc);
N
N/**
N  * @brief  Get the result of the calculation
N  * @param  p_hcc   : pointer to the hardware HCC_TypeDef
N  * @param  p_result: The complex pointer to save the result.The output results
N  *                   are 16bit signed numbers, including 15bit fixed-point decimals
N  * @retval None
N  * @note
N  *     HCC_RESULT_REAL = SUM(range*(fft_real*phs_real - fft_img*phs_img))
N  *     HCC_RESULT_IMG= SUM(range*(fft_img*phs_real + fft_real*phs_img))
N  */
Nvoid ll_hcc_get_result(HCC_TypeDef *p_hcc, TYPE_LL_HCC_COMPLEX_DATA *p_result);
N
N/**
N  * @brief  LL_HCC_CHECK_INTERRUPT_ENABLE
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval interrupt_enable
N  */
N#define LL_HCC_CHECK_INTERRUPT_ENABLE(p_hcc)    ((p_hcc)->HCC_CONTROL & LL_HCC_INT_EN)
N
N/**
N  * @brief  Get hcc pending
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval pending
N  */
N#define LL_HCC_GET_DONE_PENDING(p_hcc)          ((p_hcc)->HCC_CONTROL & LL_HCC_PENDING)
N
N/**
N  * @brief  clear hcc pending
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_clear_pending(HCC_TypeDef *p_hcc) {
Xstatic __inline void ll_hcc_clear_pending(HCC_TypeDef *p_hcc) {
N    p_hcc->HCC_CONTROL |= LL_HCC_PENDING;
X    p_hcc->HCC_CONTROL |= (1UL << 31);
N}
N
N/**
N  * @brief  ll_hcc_interrupt_enable
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_interrupt_enable(HCC_TypeDef *p_hcc) {
Xstatic __inline void ll_hcc_interrupt_enable(HCC_TypeDef *p_hcc) {
N    p_hcc->HCC_CONTROL |= LL_HCC_INT_EN;
X    p_hcc->HCC_CONTROL |= (1UL << 1);
N}
N
N/**
N  * @brief  ll_hcc_interrupt_disable
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_interrupt_disable(HCC_TypeDef *p_hcc) {
Xstatic __inline void ll_hcc_interrupt_disable(HCC_TypeDef *p_hcc) {
N    p_hcc->HCC_CONTROL &= ~LL_HCC_INT_EN;
X    p_hcc->HCC_CONTROL &= ~(1UL << 1);
N}
N
N/**
N  * @brief  HCC does not use the input range factor
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_range_disable(HCC_TypeDef *p_hcc) {
Xstatic __inline void ll_hcc_range_disable(HCC_TypeDef *p_hcc) {
N    p_hcc->HCC_CONTROL &= ~LL_HCC_RAG_EN;
X    p_hcc->HCC_CONTROL &= ~(1UL << 3);
N}
N
N/**
N  * @brief  HCC uses the input range factor
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_range_enable(HCC_TypeDef *p_hcc) {
Xstatic __inline void ll_hcc_range_enable(HCC_TypeDef *p_hcc) {
N    p_hcc->HCC_CONTROL |= LL_HCC_RAG_EN;
X    p_hcc->HCC_CONTROL |= (1UL << 3);
N}
N
N/**
N  * @brief  HCC does not use the input phase factor
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_phase_disable(HCC_TypeDef *p_hcc) {
Xstatic __inline void ll_hcc_phase_disable(HCC_TypeDef *p_hcc) {
N    p_hcc->HCC_CONTROL &= ~LL_HCC_PHS_EN;
X    p_hcc->HCC_CONTROL &= ~(1UL << 2);
N}
N
N/**
N  * @brief  HCC uses the input phase factor
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_phase_enable(HCC_TypeDef *p_hcc) {
Xstatic __inline void ll_hcc_phase_enable(HCC_TypeDef *p_hcc) {
N    p_hcc->HCC_CONTROL |= LL_HCC_PHS_EN;
X    p_hcc->HCC_CONTROL |= (1UL << 2);
N}
N
N/**
N  * @brief  HCC sets the start address of the FFT coefficient
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @param  addr : start address of the FFT coefficient
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_fft_start_addr_set(HCC_TypeDef *p_hcc, u32 addr) {
Xstatic __inline void ll_hcc_fft_start_addr_set(HCC_TypeDef *p_hcc, u32 addr) {
N    p_hcc->HCC_STADR_FFT = addr;
N}
N
N/**
N  * @brief  HCC sets the start address of the phase coefficient
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @param  addr : start address of the phase coefficient
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_phase_start_addr_set(HCC_TypeDef *p_hcc, u32 addr) {
Xstatic __inline void ll_hcc_phase_start_addr_set(HCC_TypeDef *p_hcc, u32 addr) {
N    p_hcc->HCC_STADR_PHS = addr;
N}
N
N/**
N  * @brief  HCC sets the start address of the range coefficient
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @param  addr : start address of the range coefficient
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_range_start_addr_set(HCC_TypeDef *p_hcc, u32 addr) {
Xstatic __inline void ll_hcc_range_start_addr_set(HCC_TypeDef *p_hcc, u32 addr) {
N    p_hcc->HCC_STADR_RAG = addr;
N}
N
N/**
N  * @brief  The HCC module sets the dma length
N  * @param  p_hcc: pointer to the hardware HCC_TypeDef
N  * @param  len  : dma length
N  * @retval none
N  */
N__STATIC_INLINE void ll_hcc_dma_len_set(HCC_TypeDef *p_hcc, u32 len) {
Xstatic __inline void ll_hcc_dma_len_set(HCC_TypeDef *p_hcc, u32 len) {
N    p_hcc->HCC_CONTROL &= ~LL_HCC_DMA_LEN(0x3F);
X    p_hcc->HCC_CONTROL &= ~(((0x3F)&0x3F) << 8);
N    p_hcc->HCC_CONTROL |= LL_HCC_DMA_LEN(len);
X    p_hcc->HCC_CONTROL |= (((len)&0x3F) << 8);
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_HCC_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 51 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_arctan.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_arctan.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_arctan.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the ARCTAN LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_ARCTAN_H
N#define __TX_PHE_LL_ARCTAN_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup arctan_interface_gr ARCTAN Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup ARCTAN_LL_Driver ARCTAN LL Driver
N  * @ingroup  arctan_interface_gr
N  * @brief Mainly the driver part of the ARCTAN module, which includes \b ARCTAN \b Register 
N  * \b Constants, \b ARCTAN \b Exported \b Constants, \b ARCTAN \b Exported \b Struct, \b ARCTAN
N  * \b Data \b transfers \b functions, \b ARCTAN \b Initialization \b and \b ARCTAN \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup ARCTAN_LL_Register_Constants ARCTAN LL Register Constants
N  * @ingroup  ARCTAN_LL_Driver
N  * @brief    ARCTAN LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the ARCTAN 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the ARCTAN register, mainly for convenience. Understand the 
N    configuration of the ARCTAN.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** ARCTAN_CON *****/
N/*! ARCTAN interrupt enable bit.
N */
N#define LL_ARCTAN_CON_IE                          (1UL << 9)
N/*! ARCTAN calculates the completion flag.
N */
N#define LL_ARCTAN_CON_PEND                        (1UL << 8)
N/*! ARCTAN dma mode enable bit.
N */
N#define LL_ARCTAN_CON_DMA_EN                      (1UL << 2)
N/*! ARCTAN data storage format selection.
N */
N#define LL_ARCTAN_CON_SAVE_TOGETHER               (1UL << 1)
N/*! The enable bit of the ARCTAN module.
N */
N#define LL_ARCTAN_CON_ENABLE                      (1UL << 0)
N
N
N/***** ARCTAN_DMA0_STADR *****/
N/*! The starting address of the dma of the cos data in ARCTAN.
N */
N#define LL_ARCTAN_DMA0_START(n)                   (((n)&0xFFFFFFFF) << 0)
N
N
N/***** ARCTAN_DMA1_STADR *****/
N/*! The starting address of the dma of the sin data in ARCTAN.
N */
N#define LL_ARCTAN_DMA1_START(n)                   (((n)&0xFFFFFFFF) << 0)
N
N
N/***** ARCTAN_DMA2_STADR *****/
N/*! The starting address of the dma of the output data in ARCTAN.
N */
N#define LL_ARCTAN_DMA2_START(n)                   (((n)&0xFFFFFFFF) << 0)
N
N
N/***** ARCTAN_DMA_LEN *****/
N/*! The length of the dma in ARCTAN.
N */
N#define LL_ARCTAN_DMA_LEN(n)                      (((n)&0xFFFF) << 0)
N
N
N/***** ARCTAN_IN *****/
N/*! Data input of CPU mode cos in ARCTAN.
N */
N#define LL_ARCTAN_IN_COS(n)                       (((n)&0xFFFF) << 16)
N/*! Data input of CPU mode sin in ARCTAN.
N */
N#define LL_ARCTAN_IN_SIN(n)                       (((n)&0xFFFF) << 0)
N
N
N/***** ARCTAN_OUT *****/
N/*! The result data is calculated in CPU mode in ARCTAN.
N */
N#define LL_ARCTAN_OUT(n)                          (((n)&0xFFFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup ARCTAN_LL_Exported_Constants ARCTAN LL Exported Constants
N  * @ingroup  ARCTAN_LL_Driver
N  * @brief    ARCTAN LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for ARCTAN mode selection.
N  */
Ntypedef enum {
N    /*! In CPU mode, the user needs to call the function ll_arctan_set_input_data() 
N     *  to input the calculated data. Once ll_arctan_start() is calculated once, it 
N     *  is obtained by the function ll_arctan_get_result() or ll_arctan_return_result(). 
N     */
N    LL_ARCTAN_MODE_CPU = 0,
N    /*! In the CPU mode, the user needs to configure cos_dma_src_addr, sin_dma_src_addr, 
N     *  dma_dst_addr, and dma_len, and call ll_arctan_start() to calculate. 
N     */
N    LL_ARCTAN_MODE_DMA,
N} TYPE_ENUM_LL_ARCTAN_MODE;
N
N/**
N  * @brief Enumeration constant for ARCTAN dma data selection.
N  */
Ntypedef enum {
N    /*! Cos and sin saved in memory dividually, cos is stored in cos_dma_src_addr, sin is 
N     *  stored in sin_dma_src_addr. 
N     */
N    LL_ARCTAN_DATA_MODE_SEPARATE = 0,
N    /*! Cos and sin saved in memory together, stored in the format { cos[32:16], sin[15:0] }, 
N     *  the user needs to store it in the space specified by cossin_dma_src_addr. 
N     */
N    LL_ARCTAN_DATA_MODE_TOGETHER,
N} TYPE_ENUM_LL_ARCTAN_DATA_MODE;
N
N/**
N  * @}
N  */
N
N/** @defgroup ARCTAN_LL_Exported_Struct ARCTAN LL Exported Struct
N  * @ingroup  ARCTAN_LL_Driver
N  * @brief    ARCTAN LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the ARCTAN registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_arctan_init. Function, you can configure the ARCTAN module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief ARCTAN low layer configuration structure
N  * @note  1. If cos=0, sin=0, then the module's calculation result is 0;  
N  *        2. If cos=0, sin! =0, then the calculation result of the module is PI/2, which is 16384;  
N  *        3. The calculation result range of the module is between 0~2PI, which is between 0 and 65535.  
N  */
Ntypedef struct __ll_arctan_cfg {
N    /*! ARCTAN calculation mode, CPU mode and DMA mode, please refer to the comment 
N     *  in enumeration TYPE_ENUM_LL_ARCTAN_MODE for details. 
N     */
N    TYPE_ENUM_LL_ARCTAN_MODE      work_mode;
N    /*! ARCTAN DMA mode data storage format, please refer to the annotation in the 
N     *  enumeration TYPE_ENUM_LL_ARCTAN_DATA. 
N     */
N    TYPE_ENUM_LL_ARCTAN_DATA_MODE mode;
N    union {
N        /*! mode = LL_ARCTAN_DATA_SEPARATE, The starting address of the cos buffer 
N         *  is stored in cos_dma_src_addr, 8 byte aligned.The real part data is a 16-bit 
N         *  signed number with 15 bit fixed point.
N         *  @note ARCTAN0's cos_dma_src_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM4/SRAM5.  
N         *        ARCTAN1's cos_dma_src_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM6/SRAM7.  
N         *        ARCTAN2's cos_dma_src_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM8/SRAM9.  
N         *        Statement example:  
N         *        static s16 arctan_cos_buf[1024] __attribute__((aligned(8),section("SRAM0")));
N         */
N        u32                       cos_dma_src_addr;
N        /*! mode = LL_ARCTAN_DATA_TOGETHER, The starting address of the cos and sin buffer 
N         *  is stored in cossin_dma_src_addr, stored in the format { cos[32:16], sin[15:0] },
N         *  8 byte aligned. The data is a 16-bit signed number with 15 bit fixed point.
N         *  @note ARCTAN0's cossin_dma_src_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM4/SRAM5.  
N         *        ARCTAN1's cossin_dma_src_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM6/SRAM7.  
N         *        ARCTAN2's cossin_dma_src_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM8/SRAM9.  
N         *        Statement example:  
N         *        static s16 arctan_cossin_buf[1024] __attribute__((aligned(8),section("SRAM1")));
N         */
N        u32                       cossin_dma_src_addr;
N    };
N    /*! The starting address of the sin buffer is stored in sin_dma_src_addr, 8 byte aligned.
N     *  The data is a 16-bit signed number with 15 bit fixed point.
N     *  @note ARCTAN0's sin_dma_src_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM4/SRAM5.  
N     *        ARCTAN1's sin_dma_src_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM6/SRAM7.  
N     *        ARCTAN2's sin_dma_src_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM8/SRAM9.  
N     *        Statement example:  
N     *        static s16 arctan_sin_buf[1024] __attribute__((aligned(8),section("SRAM1")));
N     */
N    u32                           sin_dma_src_addr;
N    /*! The starting address of the output buffer is stored in dma_dst_addr, 8 byte aligned.
N     *  The data is a 16-bit unsigned number with 15 bit fixed point.
N     *  @note ARCTAN0's dma_dst_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM4/SRAM5.  
N     *        ARCTAN1's dma_dst_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM6/SRAM7.  
N     *        ARCTAN2's dma_dst_addr can only be located in SRAM1/SRAM2/SRAM3/SRAM8/SRAM9.  
N     *        Statement example:  
N     *        static u16 arctan_obuf[1024] __attribute__((aligned(8),section("SRAM1")));
N     */
N    u32                           dma_dst_addr;
N    /*! The length of the dma is set. 
N     */
N    u32                           dma_points;
N} TYPE_LL_ARCTAN_CFG;
N
N/**
N  * @brief ARCTAN low layer Initialization structure
N  */
Ntypedef struct __ll_arctan_init {
N    u8 reserved;
N} TYPE_LL_ARCTAN_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup ARCTAN_LL_Interrupt ARCTAN LL Interrupt Handle function
N  * @brief   ARCTAN LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the ARCTAN  
N    Interrupt Handle function.
N
N    how to use?
N
N    The ARCTAN interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the ARCTAN in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup ARCTAN_LL_Inti_Cfg ARCTAN LL Initialization And Configuration
N  * @brief    ARCTAN LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the ARCTAN data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  ARCTAN module initialization function
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @param  p_init  : Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_arctan_init(ARCTAN_TypeDef *p_arctan, TYPE_LL_ARCTAN_INIT *p_init);
N
N/**
N  * @brief  ARCTAN module detele initialization function
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @retval None
N  */
Nvoid ll_arctan_deinit(ARCTAN_TypeDef *p_arctan);
N
N/**
N  * @brief  ARCTAN module configuration function
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @param  p_cfg   : Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_arctan_config(ARCTAN_TypeDef *p_arctan, TYPE_LL_ARCTAN_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup ARCTAN_LL_Data_Transfers ARCTAN LL Data transfers functions
N  * @brief    ARCTAN LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the ARCTAN data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  ARCTAN module start function
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @retval None
N  */
Nvoid ll_arctan_start(ARCTAN_TypeDef *p_arctan);
N
N/**
N  * @brief  ARCTAN module stop function
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @retval None
N  */
Nvoid ll_arctan_stop(ARCTAN_TypeDef *p_arctan);
N
N/**
N  * @brief  ARCTAN get finished pending
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @retval pending value
N  */
N#define LL_ARCTAN_GET_DONE_PENDING(p_arctan)      ((p_arctan)->CON & LL_ARCTAN_CON_PEND)
N
N/**
N  * @brief  ARCTAN clear pending
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @retval None.
N  */
N__STATIC_INLINE void ll_arctan_clear_done_pending(ARCTAN_TypeDef *p_arctan) {
Xstatic __inline void ll_arctan_clear_done_pending(ARCTAN_TypeDef *p_arctan) {
N    p_arctan->CON |= LL_ARCTAN_CON_PEND;
X    p_arctan->CON |= (1UL << 8);
N}
N
N/**
N  * @brief  ARCTAN performs a single calculation.
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @param  cos_data: input cos data vaule
N  * @param  sin_data: input sin data vaule
N  * @retval Returns the result of ARCTAN calculation, 16bit.
N  */
Nu16 ll_arctan_calculate_once(ARCTAN_TypeDef *p_arctan, s16 cos_data, s16 sin_data);
N
N/**
N  * @brief  ARCTAN set input data function
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @param  cos_data: input cos data vaule
N  * @param  sin_data: input sin data vaule
N  * @retval None
N  */
N__STATIC_INLINE void ll_arctan_set_input_data(ARCTAN_TypeDef *p_arctan, u16 cos_data, u16 sin_data) {
Xstatic __inline void ll_arctan_set_input_data(ARCTAN_TypeDef *p_arctan, u16 cos_data, u16 sin_data) {
N    p_arctan->IN = LL_ARCTAN_IN_COS((u32)cos_data) | LL_ARCTAN_IN_SIN(sin_data);
X    p_arctan->IN = ((((u32)cos_data)&0xFFFF) << 16) | (((sin_data)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  ARCTAN Wait for the specified channel to finish computing
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_arctan_wait_done_pending(ARCTAN_TypeDef *p_arctan) {
Xstatic __inline void ll_arctan_wait_done_pending(ARCTAN_TypeDef *p_arctan) {
N    /* After the calculation is completed, pending is set to 1 and enable 
N     * is cleared. So the following 2 statements are equivalent
N     */
N    while(p_arctan->CON & LL_ARCTAN_CON_ENABLE);
X    while(p_arctan->CON & (1UL << 0));
N    p_arctan->CON |= LL_ARCTAN_CON_PEND;
X    p_arctan->CON |= (1UL << 8);
N}
N
N/**
N  * @brief  Get the ARCTAN calculation result function.
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @param  p_result: Save the 16bit of the arctan calculation result.
N  * @retval None
N  */
N__STATIC_INLINE void ll_arctan_get_result(ARCTAN_TypeDef *p_arctan, u16 *p_result) {
Xstatic __inline void ll_arctan_get_result(ARCTAN_TypeDef *p_arctan, u16 *p_result) {
N    /* After the calculation is completed, pending is set to 1 and enable 
N     * is cleared. So the following 2 statements are equivalent
N     */
N    while(p_arctan->CON & LL_ARCTAN_CON_ENABLE);
X    while(p_arctan->CON & (1UL << 0));
N    p_arctan->CON |= LL_ARCTAN_CON_PEND;
X    p_arctan->CON |= (1UL << 8);
N    
N    *p_result = p_arctan->OUT;
N}
N
N/**
N  * @brief  Returns the ARCTAN calculation result function.
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @retval Returns the result of ARCTAN calculation, 16bit.
N  */
N__STATIC_INLINE u16 ll_arctan_return_result(ARCTAN_TypeDef *p_arctan) {
Xstatic __inline u16 ll_arctan_return_result(ARCTAN_TypeDef *p_arctan) {
N    /* After the calculation is completed, pending is set to 1 and enable 
N     * is cleared. So the following 2 statements are equivalent
N     */
N    while(p_arctan->CON & LL_ARCTAN_CON_ENABLE);
X    while(p_arctan->CON & (1UL << 0));
N    p_arctan->CON |= LL_ARCTAN_CON_PEND;
X    p_arctan->CON |= (1UL << 8);
N    
N    return p_arctan->OUT;
N}
N
N/**
N  * @brief  ARCTAN enable interrupt
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_arctan_interrupt_enable(ARCTAN_TypeDef *p_arctan) {
Xstatic __inline void ll_arctan_interrupt_enable(ARCTAN_TypeDef *p_arctan) {
N    p_arctan->CON |= LL_ARCTAN_CON_IE;
X    p_arctan->CON |= (1UL << 9);
N}
N
N/**
N  * @brief  ARCTAN disable interrupt
N  * @param  p_arctan: Select the initialized ARCTAN group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_arctan_interrupt_disable(ARCTAN_TypeDef *p_arctan) {
Xstatic __inline void ll_arctan_interrupt_disable(ARCTAN_TypeDef *p_arctan) {
N    p_arctan->CON &= ~(LL_ARCTAN_CON_IE);
X    p_arctan->CON &= ~((1UL << 9));
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_ARCTAN_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 52 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_iir.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_iir.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_iir.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the IIR LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_IIR_H
N#define __TX_PHE_LL_IIR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup iir_interface_gr IIR Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup IIR_LL_Driver IIR LL Driver
N  * @ingroup  iir_interface_gr
N  * @brief Mainly the driver part of the IIR module, which includes \b IIR \b Register 
N  * \b Constants, \b IIR \b Exported \b Constants, \b IIR \b Exported \b Struct, \b IIR
N  * \b Data \b transfers \b functions, \b IIR \b Initialization \b and \b IIR \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N 
N/** @defgroup IIR_LL_Register_Constants IIR LL Register Constants
N  * @ingroup  IIR_LL_Driver
N  * @brief    IIR LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the IIR 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the IIR register, mainly for convenience. Understand the 
N    configuration of the IIR.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** IIR_CH_ENA0 *****/
N/*! IIR's channel enable bit, each 1 bit represents a channel, representing the 0th 
N *  to 31st channel. 
N */
N#define LL_IIR_CH_ENA0(n)                         (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_CPU_KST0 *****/
N/*! The triggering of IIR is enabled. Each 1 bit represents the trigger of one channel, 
N *  representing the 0th to 31st channel. 
N */
N#define LL_IIR_CPU_KST0(n)                        (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_CFG_ADDR *****/
N/*! The start address of the IIR configuration information storage, such as TXF6200 is 
N *  fixed in SRAM11 (0x20019000). 
N */
N#define LL_IIR_CFG_ADDR(n)                        (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_INT_ENA0 *****/
N/*! The interrupt of the IIR's 0th to 31st channel is enabled. 
N */
N#define LL_IIR_INT_ENA0(n)                        (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_HALF_PND0 *****/
N/*! When the output BUFF of the Nth channel of the IIR has filled half of the data, the 
N *  completion flag is displayed, representing the 0th to 31st channel, and the write 1 
N *  clear pending. 
N */
N#define LL_IIR_HALF_PND0(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_FULL_PND0 *****/
N/*! When the output BUFF of the Nth channel of the IIR is already filled with data, the 
N *  completion flag is displayed, representing the 0th to 31st channel, and the write 1 
N *  clear.
N */
N#define LL_IIR_FULL_PND0(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_FILT_PND0 *****/
N/*! When the Nth channel of the IIR completes the filtering, the completion flag is displayed, 
N *  representing the 0th to 31st channel, and the 1 clearing is performed. 
N */
N#define LL_IIR_FILT_PND0(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_INT_SRCL0 *****/
N/*! When each bit represents the interrupt source selection of one channel, it represents 
N *  the 0th to 31st channel, and is used together with SRCH0, the format is {SRCH0, SRCL0}. 
N */
N#define LL_IIR_INT_SRCL0(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_INT_SRCH0 *****/
N/*! When every 2 bits represents the interrupt source selection of one channel, it represents 
N *  the 0th to 31st channel and is used together with SRCH0 in the format of {SRCH0, SRCL0}. 
N */
N#define LL_IIR_INT_SRCH0(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_DATA_OUT *****/
N/*! When the IIR is only working all the way, the calculation result of the module is output. 
N */
N#define LL_IIR_DATA_OUT(n)                        ((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_EVSYS_ENA0 *****/
N/*! IIR's evsys channel enable bit, each 1 bit represents a channel, representing the 0th to 
N *  31st channel, used in conjunction with the event trigger, each event triggers an IIR, completes 
N *  an N channel filtering (mainly see Which way of this register is enabled). 
N */
N#define LL_IIR_EVSYS_ENA0(n)                      (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_CH_ENA1 *****/
N/*! IIR's channel enable bit, each 1 bit represents a channel, representing the 32th to 63st channel. 
N */
N#define LL_IIR_CH_ENA1(n)                         (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_CPU_KST1 *****/
N/*! The triggering of IIR is enabled. Each 1 bit represents the trigger of one channel, representing 
N *  the 32th to 63st channel. 
N */
N#define LL_IIR_CPU_KST1(n)                        (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_INT_ENA1 *****/
N/*! The interrupt of the IIR's 32th to 63st channel is enabled. 
N */
N#define LL_IIR_INT_ENA1(n)                        (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_HALF_PND1 *****/
N/*! When the output BUFF of the Nth channel of the IIR has filled half of the data, the 
N *  completion flag is displayed, representing the 32th to 63st channel, and the write 1 
N *  clear pending. 
N */
N#define LL_IIR_HALF_PND1(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_FULL_PND1 *****/
N/*! When the output BUFF of the Nth channel of the IIR is already filled with data, the 
N *  completion flag is displayed, representing the 32th to 63st channel, and the write 1 
N *  clear.
N */
N#define LL_IIR_FULL_PND1(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_FILT_PND1 *****/
N/*! When the Nth channel of the IIR completes the filtering, the completion flag is displayed, 
N *  representing the 32th to 63st channel, and the 1 clearing is performed. 
N */
N#define LL_IIR_FILT_PND1(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_INT_SRCL1 *****/
N/*! When each bit represents the interrupt source selection of one channel, it represents 
N *  the 32th to 63st channel, and is used together with SRCH0, the format is {SRCH0, SRCL0}. 
N */
N#define LL_IIR_INT_SRCL1(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_INT_SRCH1 *****/
N/*! When every 2 bits represents the interrupt source selection of one channel, it represents 
N *  the 32th to 63st channel and is used together with SRCH0 in the format of {SRCH0, SRCL0}. 
N */
N#define LL_IIR_INT_SRCH1(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IIR_EVSYS_ENA1 *****/
N/*! IIR's evsys channel enable bit, each 1 bit represents a channel, representing the 32th to 
N *  63st channel, used in conjunction with the event trigger, each event triggers an IIR, completes 
N *  an N channel filtering (mainly see Which way of this register is enabled). 
N */
N#define LL_IIR_EVSYS_ENA1(n)                      (((n)&0xFFFFFFFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup IIR_LL_Exported_Constants IIR LL Exported Constants
N  * @ingroup  IIR_LL_Driver
N  * @brief    IIR LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for IIR finished pending status
N  */
Ntypedef enum {
N    /*! IIR idle flag macro definition.
N     */
N    LL_IIR_PNG_IDLE = 0,
N    /*! IIR completes the filter flag macro definition.
N     */
N    LL_IIR_PNG_FILT,
N    /*! IIR completes the definition of the half mark macro.
N     */
N    LL_IIR_PNG_HALF,
N    /*! IIR completes the definition of the full mark macro.
N     */
N    LL_IIR_PNG_FULL,
N} TYPE_ENUM_LL_IIR_PNG;
N
N/**
N  * @brief Enumeration constant for The IIR interrupt source triggers the selection
N  */
Ntypedef enum {
N    /*! Each time the IIR is filtered, an interrupt is triggered.
N     */
N    LL_IIR_INTR_SRC_FILT = 0,
N    /*! IIR triggers an interrupt when it calculates half of the output buffer.
N     */
N    LL_IIR_INTR_SRC_HALF,
N    /*! IIR triggers an interrupt when it calculates that the output buffer is full
N     */
N    LL_IIR_INTR_SRC_FULL,
N    /*! IIR triggers an interrupt when it calculates that the output buffer is full and half. 
N     */
N    LL_IIR_INTR_SRC_HALF_FULL,
N} TYPE_ENUM_LL_IIR_INTR_SRC_SEL;
N
N
N/**
N  * @}
N  */
N
N/** @defgroup IIR_LL_Exported_Struct IIR LL Exported Struct
N  * @ingroup  IIR_LL_Driver
N  * @brief    IIR LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the IIR registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_iir_init. Function, you can configure the IIR module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief IIR interrupt low layer configuration structure
N  */
Ntypedef struct __ll_iir_irq_cfg {  
N    /*! There are 8 sets of paths for each set of IIR, and chn is the one that 
N     *  is selected for calculation, ranging from 0 to 7. 
N     */
N    u8                            chn;
N    /*! Select the trigger source for the IIR module interrupt. 
N     */
N    TYPE_ENUM_LL_IIR_INTR_SRC_SEL intr_src_sel; 
N} TYPE_LL_IIR_IRQ_CFG;
N
N/**
N  * @brief Channel configuration information, consistent with the definition
N  *        of spec.
N  */
Ntypedef struct __ll_iir_param_cfg {
N    /*! Output data downsampling count. This value represents a point written
N     *  to the output buf for each number of points calculated.
N     */
N    u8  sample_rate;
N    /*! Down-sampling status counter, initialized with a value of 0.
N     */
N    u8  sample_rate_sta;
N    /*! DMA enable bit
N     */
N    u16 dma_en                  : 1,
N        reserved_0              : 11,
N    /*! The number of right-shifted output results, 5bit unsigned number. Here
N     *  is the low 4bit.
N     */
N        odata_sft_bit_low       : 4;
N    
N    /*! The number of right-shifted output results, 5bit unsigned number. Here
N     *  is the highest bit.
N     */
N    u32 odata_sft_bit_high      : 1,
N        reserved_1              : 7,
N    /*! Accumulator output right shift number of bits.
N     */
N        feedback_sft_bit        : 5,
N        reserved_2              : 19;
N        
N    /*! IIR input data buf start address. All input IIR data requirements are
N     *  16-bit signed numbers. Each IIR module has a total of 64 channels, which 
N     *  must be 2Byte aligned. 
N     *  @note IIR0's dma_src_addr can only be located in SRAM1.  
N     *        IIR1's dma_src_addr can only be located in SRAM2.  
N     *        IIR2's dma_src_addr can only be located in SRAM3.  
N     *        Statement example:  
N     *        static s16 iir0_ibuf[1024] __attribute__((section("SRAM1")));
N     */
N    u32 dma_src_addr;
N
N    /*! IIR output data buf start address. All output IIR data requirements are
N     *  16-bit signed numbers. Each IIR module has a total of 64 channels, which 
N     *  must be 2Byte aligned. 
N     *  @note IIR0's dma_dst_addr can only be located in SRAM1.  
N     *        IIR1's dma_dst_addr can only be located in SRAM2.  
N     *        IIR2's dma_dst_addr can only be located in SRAM3.  
N     *        Statement example:  
N     *        static s16 iir0_obuf[1024] __attribute__((section("SRAM1")));
N     */
N    u32 dma_dst_addr;
N    /*! The IIR coefficient structure buf start address. Each IIR module has a
N     *  total of 64 channels, which must be 2Byte aligned. 
N     *  @note IIR0's coef_start_addr can only be located in SRAM14.  
N     *        IIR1's coef_start_addr can only be located in SRAM15.  
N     *        IIR2's coef_start_addr can only be located in SRAM16.  
N     *        Statement example:  
N     *        static TYPE_LL_IIR_COEFF_CFG iir0_coeff_cfg __attribute__((section("SRAM14")));
N     */
N    u32 coef_start_addr;
N    /*! IIR input data buf length.
N     */
N    u16 dma_src_points;
N    /*! IIR output data buf length.
N     */
N    u16 dma_dst_points;
N    /*! IIR calculates the starting address of the fetched data. The address
N     *  must be inside the IIR input buf.
N     */
N    u32 dma_src_index;
N    /*! The starting address of the output of the IIR calculation result. The
N     *  address must be inside IIR output buf.
N     */
N    u32 dma_dst_index;
N} TYPE_LL_IIR_PARAM_CFG;
N
N/**
N  * @brief coefficient information, consistent with the definition of spec.  
N  *        All IIR coefficients are signed 16-bit fixed-point numbers. The
N  *        calculation of the coefficient can refer to digital biquad filter.
N  * @note  The array of channel coefficients of the IIR0 module can only be
N  *        placed in SRAM14.  
N  *        The array of channel coefficients of the IIR1 module can only be
N  *        placed in SRAM15.  
N  *        The array of channel coefficients of the IIR2 module can only be
N  *        placed in SRAM16.
N  */
Ntypedef struct __ll_iir_coeff_cfg {
N    /*! The number of left-shifting IIR b coefficients. The valid range of this
N     *  value is 0~16.
N     */
N    u16 scale      : 5,
N        reserved_0 : 11;
N    /*! IIR b0 coefficient
N     */
N    s16 b0_coef;
N    /*! IIR b1 coefficient
N     */
N    s16 b1_coef;
N    /*! IIR b2 coefficient
N     */
N    s16 b2_coef;
N    /*! The IIR a1 coefficient is the standard calculated a1 coefficient multiplied
N     *  by -1.
N     */
N    s16 a1_coef;
N    /*! The IIR a2 coefficient is the standard calculated a2 coefficient multiplied
N     *  by -1.
N     */
N    s16 a2_coef;
N    u32 reserved_1;
N    /*! IIR calculates historical value, only needs to be set to 0 at
N     *  initialization.
N     */
N    s64 psum[2];
N} TYPE_LL_IIR_COEFF_CFG;
N
N/**
N  * @brief This structure is used to configure the interrupt enable and the interrupt
N  *        source selection for a particular channel of a particular IIR module.
N  */
Ntypedef struct __ll_iir_cfg {
N    /*! The specific channel number of the IIR module. Each IIR module has 64 channels
N     *  (0~63).
N     */
N    u8                            chn;
N    /*! Enable the path between IIR and evsys. 
N     */
N    bool                          evsys_chn_en;
N} TYPE_LL_IIR_CFG;
N
N/**
N  * @brief Low layer, specifies the IIR module initialization, used only for the reset 
N  *        IIR module and configuration information start address.
N  */
Ntypedef struct __ll_iir_init {
N    /*! The starting sram address of the IIR configuration parameter, which must 
N     *  be 8Byte aligned. 
N     *  @note IIR0's param_start_addr can only be located in SRAM11.  
N     *        IIR1's param_start_addr can only be located in SRAM12.  
N     *        IIR2's param_start_addr can only be located in SRAM13.  
N     *        Statement example:  
N     *        static TYPE_LL_IIR_PARAM_CFG iir_param[max_chn] 
N     *                                     __attribute__((aligned(8), section("SRAM11")));  
N     *        max_chn: max_chn is expressed as the maximum channel value using iir. 
N     *                 For example, if you want to use channel 4 of IIR0 for calculation, 
N     *                 max_chn=5, and the range of n is between 0 and 7.
N     */
N    u32 param_start_addr;
N    /*! The length of the iir coefficient buffer.
N     */
N    u32 param_buf_len;
N} TYPE_LL_IIR_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup IIR_LL_Interrupt IIR LL Interrupt Handle function
N  * @brief   IIR LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the IIR  
N    Interrupt Handle function.
N
N    how to use?
N
N    The IIR interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the IIR in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup IIR_LL_Inti_Cfg IIR LL Initialization And Configuration
N  * @brief    IIR LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the IIR data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  IIR module initialization function
N  * @param  p_iir: Select the initialized DFTRAN group pointer
N  * @param  p_init: Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_iir_init(IIR_TypeDef *p_iir, TYPE_LL_IIR_INIT *p_init);
N
N/**
N  * @brief  IIR module detele initialization function
N  * @param  p_iir: Select the initialized IIR group pointer
N  * @retval None
N  */
Nvoid ll_iir_deinit(IIR_TypeDef *p_iir);
N
N/**
N  * @brief  IIR module interrupt configuration
N  * @param  p_iir: Select the initialized IIR group pointer
N  * @param  p_cfg: Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_iir_irq_config(IIR_TypeDef *p_iir, TYPE_LL_IIR_IRQ_CFG *p_cfg);
N
N/**
N  * @brief  IIR module configuration
N  * @param  p_iir: Select the initialized IIR group pointer
N  * @param  p_cfg: Module configuration structure pointer
N  * @retval None
N  */
Nvoid ll_iir_config(IIR_TypeDef *p_iir, TYPE_LL_IIR_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup IIR_LL_Data_Transfers IIR LL Data transfers functions
N  * @brief    IIR LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the IIR data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  IIR module channel start function.
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
Nvoid ll_iir_start(IIR_TypeDef *p_iir, u64 chn_bits);
N    
N/**
N  * @brief  IIR module channel stop function.
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
Nvoid ll_iir_stop(IIR_TypeDef *p_iir, u64 chn_bits);
N
N/**
N  * @brief  IIR check sample interrupt enable
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png.
N  */
N#define LL_IIR_CHECK_SAMPLE_INTERRUPT_ENABLE(p_iir, chn_bits)     (!((p_iir)->IIR_INT_SRCL0 & LL_IIR_INT_SRCL0(chn_bits)) && \
N                                                                   !((p_iir)->IIR_INT_SRCH0 & LL_IIR_INT_SRCH0(chn_bits)) && \
N                                                                   !((p_iir)->IIR_INT_SRCL1 & LL_IIR_INT_SRCL1(chn_bits)) && \
N                                                                   !((p_iir)->IIR_INT_SRCH1 & LL_IIR_INT_SRCH1(chn_bits)))
X#define LL_IIR_CHECK_SAMPLE_INTERRUPT_ENABLE(p_iir, chn_bits)     (!((p_iir)->IIR_INT_SRCL0 & LL_IIR_INT_SRCL0(chn_bits)) &&                                                                    !((p_iir)->IIR_INT_SRCH0 & LL_IIR_INT_SRCH0(chn_bits)) &&                                                                    !((p_iir)->IIR_INT_SRCL1 & LL_IIR_INT_SRCL1(chn_bits)) &&                                                                    !((p_iir)->IIR_INT_SRCH1 & LL_IIR_INT_SRCH1(chn_bits)))
N
N/**
N  * @brief  IIR check dma buffer half interrupt enable
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png.
N  */
N#define LL_IIR_CHECK_DMA_HALF_INTERRUPT_ENABLE(p_iir, chn_bits)   ((p_iir)->IIR_INT_SRCL0 & LL_IIR_INT_SRCL0(chn_bits) || \
N                                                                   (p_iir)->IIR_INT_SRCL1 & LL_IIR_INT_SRCL1(chn_bits))
X#define LL_IIR_CHECK_DMA_HALF_INTERRUPT_ENABLE(p_iir, chn_bits)   ((p_iir)->IIR_INT_SRCL0 & LL_IIR_INT_SRCL0(chn_bits) ||                                                                    (p_iir)->IIR_INT_SRCL1 & LL_IIR_INT_SRCL1(chn_bits))
N
N/**
N  * @brief  IIR check dma buffer full interrupt enable
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png.
N  */
N#define LL_IIR_CHECK_DMA_FULL_INTERRUPT_ENABLE(p_iir, chn_bits)   ((p_iir)->IIR_INT_SRCH0 & LL_IIR_INT_SRCH0(chn_bits) || \
N                                                                   (p_iir)->IIR_INT_SRCH1 & LL_IIR_INT_SRCH1(chn_bits))
X#define LL_IIR_CHECK_DMA_FULL_INTERRUPT_ENABLE(p_iir, chn_bits)   ((p_iir)->IIR_INT_SRCH0 & LL_IIR_INT_SRCH0(chn_bits) ||                                                                    (p_iir)->IIR_INT_SRCH1 & LL_IIR_INT_SRCH1(chn_bits))
N
N/**
N  * @brief  IIR module get filter pending
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bit : Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
N#define LL_IIR_GET_SAMPLE_PENDING(p_iir, chn_bit)                 ((((u64)(p_iir)->IIR_FILT_PND1 << 32) | (p_iir)->IIR_FILT_PND0) & chn_bit)
N
N/**
N  * @brief  IIR module get dma buffer half pending
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bit : Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
N#define LL_IIR_GET_DMA_HALF_PENDING(p_iir, chn_bit)               ((((u64)(p_iir)->IIR_HALF_PND1 << 32) | (p_iir)->IIR_HALF_PND0) & chn_bit)
N
N/**
N  * @brief  IIR module get dma buffer full pending
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bit : Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
N#define LL_IIR_GET_DMA_FULL_PENDING(p_iir, chn_bit)               ((((u64)(p_iir)->IIR_FULL_PND1 << 32) | (p_iir)->IIR_FULL_PND0) & chn_bit)
N
N/**
N  * @brief  IIR module enable interrupt function.
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
N__STATIC_INLINE void ll_iir_interrupt_enable(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline void ll_iir_interrupt_enable(IIR_TypeDef *p_iir, u64 chn_bits) {
N    p_iir->IIR_INT_ENA0 |= LL_IIR_INT_ENA0(chn_bits);
X    p_iir->IIR_INT_ENA0 |= (((chn_bits)&0xFFFFFFFF) << 0);
N    p_iir->IIR_INT_ENA1 |= LL_IIR_INT_ENA1(chn_bits >> 32);
X    p_iir->IIR_INT_ENA1 |= (((chn_bits >> 32)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  IIR module disable interrupt function.
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None
N  */
N__STATIC_INLINE void ll_iir_interrupt_disable(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline void ll_iir_interrupt_disable(IIR_TypeDef *p_iir, u64 chn_bits) {
N    p_iir->IIR_INT_ENA0 &= ~(LL_IIR_INT_ENA0(chn_bits));
X    p_iir->IIR_INT_ENA0 &= ~((((chn_bits)&0xFFFFFFFF) << 0));
N    p_iir->IIR_INT_ENA1 &= ~(LL_IIR_INT_ENA1(chn_bits >> 32));
X    p_iir->IIR_INT_ENA1 &= ~((((chn_bits >> 32)&0xFFFFFFFF) << 0));
N}
N
N/**
N  * @brief  IIR get filter pending
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: The IIR channel number that was started.
N  * @retval Returns the status value of png.
N  */
N__STATIC_INLINE u64 ll_iir_get_sample_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline u64 ll_iir_get_sample_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
N    u32 pnd1 = p_iir->IIR_FILT_PND1;
N    u32 pnd0 = p_iir->IIR_FILT_PND0;
N    return (((u64)pnd1 << 32) | pnd0) & chn_bits;
N}
N
N
N/**
N  * @brief  IIR get half pending
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: The IIR channel number that was started.
N  * @retval Returns the status value of png.
N  */
N__STATIC_INLINE u64 ll_iir_get_dma_half_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline u64 ll_iir_get_dma_half_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
N    u32 pnd1 = p_iir->IIR_HALF_PND1;
N    u32 pnd0 = p_iir->IIR_HALF_PND0;
N    return (((u64)pnd1 << 32) | pnd0) & chn_bits;
N}
N
N/**
N  * @brief  IIR get full pending
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: The IIR channel number that was started.
N  * @retval Returns the status value of png.
N  */
N__STATIC_INLINE u64 ll_iir_get_dma_full_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline u64 ll_iir_get_dma_full_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
N    u32 pnd1 = p_iir->IIR_FULL_PND1;
N    u32 pnd0 = p_iir->IIR_FULL_PND0;
N    return (((u64)pnd1 << 32) | pnd0) & chn_bits;
N}
N
N/**
N  * @brief  IIR clear filter pending
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: The IIR channel number that was started.
N  * @retval Returns the status value of png.
N  */
N__STATIC_INLINE void ll_iir_clear_sample_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline void ll_iir_clear_sample_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
N    p_iir->IIR_FILT_PND0 |= LL_IIR_FILT_PND0(chn_bits);
X    p_iir->IIR_FILT_PND0 |= (((chn_bits)&0xFFFFFFFF) << 0);
N    p_iir->IIR_FILT_PND1 |= LL_IIR_FILT_PND1(chn_bits >> 32);
X    p_iir->IIR_FILT_PND1 |= (((chn_bits >> 32)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  IIR clear half pending
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: The IIR channel number that was started.
N  * @retval Returns the status value of png.
N  */
N__STATIC_INLINE void ll_iir_clear_dma_half_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline void ll_iir_clear_dma_half_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
N    p_iir->IIR_HALF_PND0 |= LL_IIR_HALF_PND0(chn_bits);
X    p_iir->IIR_HALF_PND0 |= (((chn_bits)&0xFFFFFFFF) << 0);
N    p_iir->IIR_HALF_PND1 |= LL_IIR_HALF_PND1(chn_bits >> 32);
X    p_iir->IIR_HALF_PND1 |= (((chn_bits >> 32)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  IIR clear full pending
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: The IIR channel number that was started.
N  * @retval Returns the status value of png.
N  */
N__STATIC_INLINE void ll_iir_clear_dma_full_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline void ll_iir_clear_dma_full_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
N    p_iir->IIR_FULL_PND0 |= LL_IIR_FULL_PND0(chn_bits);
X    p_iir->IIR_FULL_PND0 |= (((chn_bits)&0xFFFFFFFF) << 0);
N    p_iir->IIR_FULL_PND1 |= LL_IIR_FULL_PND1(chn_bits >> 32);
X    p_iir->IIR_FULL_PND1 |= (((chn_bits >> 32)&0xFFFFFFFF) << 0);
N}
N
N/**
N  * @brief  IIR wait for filter finished pending function
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None.
N  */
N__STATIC_INLINE void ll_iir_wait_sample_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline void ll_iir_wait_sample_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
N    if(chn_bits & 0xFFFFFFFF) {
N        while(chn_bits != (p_iir->IIR_FILT_PND0 & chn_bits));
N        p_iir->IIR_FILT_PND0 |= LL_IIR_FILT_PND0(chn_bits);
X        p_iir->IIR_FILT_PND0 |= (((chn_bits)&0xFFFFFFFF) << 0);
N    } 
N    if((chn_bits >> 32) & 0xFFFFFFFF) {
N        while((chn_bits >> 32) != (p_iir->IIR_FILT_PND1 & (chn_bits >> 32)));
N        p_iir->IIR_FILT_PND1 |= LL_IIR_FILT_PND1(chn_bits >> 32);
X        p_iir->IIR_FILT_PND1 |= (((chn_bits >> 32)&0xFFFFFFFF) << 0);
N    }
N}
N
N/**
N  * @brief  IIR wait for half finished pending function
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None.
N  */
N__STATIC_INLINE void ll_iir_wait_dma_half_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline void ll_iir_wait_dma_half_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
N    if(chn_bits & 0xFFFFFFFF) {
N        while(chn_bits != (p_iir->IIR_HALF_PND0 & chn_bits));
N        p_iir->IIR_HALF_PND0 |= LL_IIR_HALF_PND0(chn_bits);
X        p_iir->IIR_HALF_PND0 |= (((chn_bits)&0xFFFFFFFF) << 0);
N    } 
N    if((chn_bits >> 32) & 0xFFFFFFFF) {
N        while((chn_bits >> 32) != (p_iir->IIR_HALF_PND1 & (chn_bits >> 32)));
N        p_iir->IIR_HALF_PND1 |= LL_IIR_HALF_PND1(chn_bits >> 32);
X        p_iir->IIR_HALF_PND1 |= (((chn_bits >> 32)&0xFFFFFFFF) << 0);
N    }
N}
N
N/**
N  * @brief  IIR wait for full finished pending function
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval None.
N  */
N__STATIC_INLINE void ll_iir_wait_dma_full_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline void ll_iir_wait_dma_full_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
N    if(chn_bits & 0xFFFFFFFF) {
N        while(chn_bits != (p_iir->IIR_FULL_PND0 & chn_bits));
N        p_iir->IIR_FULL_PND0 |= LL_IIR_FULL_PND0(chn_bits);
X        p_iir->IIR_FULL_PND0 |= (((chn_bits)&0xFFFFFFFF) << 0);
N    }
N    if((chn_bits >> 32) & 0xFFFFFFFF) {
N        while((chn_bits >> 32) != (p_iir->IIR_FULL_PND1 & (chn_bits >> 32)));
N        p_iir->IIR_FULL_PND1 |= LL_IIR_FULL_PND1(chn_bits >> 32);
X        p_iir->IIR_FULL_PND1 |= (((chn_bits >> 32)&0xFFFFFFFF) << 0);
N    }
N}
N
N/**
N  * @brief  IIR wait for filter or full finished pending function
N  * @param  p_iir   : Select the initialized IIR group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.  
N  * @retval Returns the status value of png(TYPE_ENUM_LL_IIR_PNG).
N  */
N__STATIC_INLINE TYPE_ENUM_LL_IIR_PNG ll_iir_wait_dma_half_full_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
Xstatic __inline TYPE_ENUM_LL_IIR_PNG ll_iir_wait_dma_half_full_pending(IIR_TypeDef *p_iir, u64 chn_bits) {
N    TYPE_ENUM_LL_IIR_PNG sta = LL_IIR_PNG_IDLE;
N
N    if(chn_bits & 0xFFFFFFFF) {
N        while((chn_bits != (p_iir->IIR_HALF_PND0 & chn_bits)) &&
N              (chn_bits != (p_iir->IIR_FULL_PND0 & chn_bits)));
N        if(chn_bits == (p_iir->IIR_HALF_PND0 & chn_bits)) {
N            p_iir->IIR_HALF_PND0 |= LL_IIR_HALF_PND0(chn_bits);
X            p_iir->IIR_HALF_PND0 |= (((chn_bits)&0xFFFFFFFF) << 0);
N            sta = LL_IIR_PNG_HALF;
N        }
N        if(chn_bits == (p_iir->IIR_FULL_PND0 & chn_bits)) {
N            p_iir->IIR_FULL_PND0 |= LL_IIR_FULL_PND0(chn_bits);
X            p_iir->IIR_FULL_PND0 |= (((chn_bits)&0xFFFFFFFF) << 0);
N            sta = LL_IIR_PNG_FULL;
N        }
N    } 
N    if((chn_bits >> 32) & 0xFFFFFFFF) {
N        while(((chn_bits >> 32) != (p_iir->IIR_HALF_PND1 & (chn_bits >> 32))) &&
N              ((chn_bits >> 32) != (p_iir->IIR_FULL_PND1 & (chn_bits >> 32))));
N        if((chn_bits >> 32) == (p_iir->IIR_HALF_PND1 & (chn_bits >> 32))) {
N            p_iir->IIR_HALF_PND1 |= LL_IIR_HALF_PND1(chn_bits >> 32);
X            p_iir->IIR_HALF_PND1 |= (((chn_bits >> 32)&0xFFFFFFFF) << 0);
N            sta = LL_IIR_PNG_HALF;
N        }
N        if((chn_bits >> 32) == (p_iir->IIR_FULL_PND1 & (chn_bits >> 32))) {
N            p_iir->IIR_FULL_PND1 |= LL_IIR_FULL_PND1(chn_bits >> 32);
X            p_iir->IIR_FULL_PND1 |= (((chn_bits >> 32)&0xFFFFFFFF) << 0);
N            sta = LL_IIR_PNG_FULL;
N        }
N    }
N
N    return sta;
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_IIR_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 53 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_spi.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_spi.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_spi.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.1
N  * @date    03-08-2018
N  * @brief   This file contains all the SPI LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_SPI_H
N#define __TX_PHE_LL_SPI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup spi_interface_gr SPI Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup SPI_LL_Driver SPI LL Driver
N  * @ingroup  spi_interface_gr
N  * @brief Mainly the driver part of the SPI module, which includes \b SPI \b Register 
N  * \b Constants, \b SPI \b Exported \b Constants, \b SPI \b Exported \b Struct, \b SPI
N  * \b Data \b transfers \b functions, \b SPI \b Initialization \b and \b SPI \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SPI_LL_Register_Constants SPI LL Register Constants
N  * @ingroup  SPI_LL_Driver
N  * @brief    SPI LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the SPI 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the SPI register, mainly for convenience. Understand the 
N    configuration of the SPI.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** CFG *****/
N/*! The IRQ generated when the CS of the SPI slave changes from low to high.
N */
N#define LL_SPI_CFG_END_IRQ_EN                       (1UL << 27)
N/*! The number of clocks that the SPI data receives is delayed relative to CLK. 
N */
N#define LL_SPI_CFG_RXSEL(n)                         (((n)&0x07) << 24)
N/*! SPI Clock Divider. The frequency of the CLK is derived from the following
N *  equation:
N *          Fclk = APB_CLK/((DIV_CNT+1)*2)
N */
N#define LL_SPI_CFG_DIV_CNT(n)                       (((n)&0xFF) << 16)
N/*! SPI TX DRQ Enable, trigger DRQ when SPI TX FIFO is half empty. Just for 
N *  DMAC use.
N */
N#define LL_SPI_CFG_TDRQ_EN                          (1UL << 15)
N/*! SPI RX DRQ Enable, trigger DRQ when SPI RX FIFO is half full. Just for 
N *  DMAC use.
N */
N#define LL_SPI_CFG_RDRQ_EN                          (1UL << 14)
N/*! SPI TX IRQ Enable, trigger SPI TX IRQ when SPI TX FIFO is half empty.
N */
N#define LL_SPI_CFG_TIRQ_EN                          (1UL << 13)
N/*! SPI RX IRQ Enable, trigger SPI RX IRQ when SPI RX FIFO is half full.
N */
N#define LL_SPI_CFG_RIRQ_EN                          (1UL << 12)
N/*! SPI tx fifo enable. The tx function can only be used normally after tx
N *  fifo is enabled.
N */
N#define LL_SPI_CFG_TX_FIFO_EN                       (1UL << 9)
N/*! SPI rx fifo enable. The rx function can only be used normally after rx
N *  fifo is enabled.
N */
N#define LL_SPI_CFG_RX_FIFO_EN                       (1UL << 8)
N/*! SPI frame data format setting.
N */
N#define LL_SPI_CFG_DFS_SET(n)                       (((n)&0x03) << 6)
N/*! Wire mode setting of the SPI data line.
N */
N#define LL_SPI_CFG_WIRE_MODE_SET(n)                 (((n)&0x03) << 4)
N#define LL_SPI_CFG_WIRE_MODE_GET(n)                 (((n) >> 4) & 0x03)
N#define LL_SPI_CFG_WIRE_MODE_MASK                   (0x03UL << 4)
N/*! SPI mode setting
N */
N#define LL_SPI_CFG_SPI_MODE_SET(n)                  (((n)&0x03) << 2)
N/*! Enable the SPI slave
N */
N#define LL_SPI_CFG_SLAVE_EN                         (1UL << 0)
N
N
N/***** CTL *****/
N/*! SPI CS pin control output, this bit is valid only in master mode
N */
N#define LL_SPI_CTL_CS_HIGH                          (1UL << 3)
N/*! Enable the SPI tx function.
N */
N#define LL_SPI_CTL_TX_EN                            (1UL << 1)
N/*! Enable the SPI rx function.
N */
N#define LL_SPI_CTL_RX_EN                            (1UL << 0)
N
N
N/***** STA *****/
N/*! Trigger SPI Transfer End pending when SPI slave CS from low to high.
N *  Writing 1 to this bit will clear it, otherwise unchanged.
N */
N#define LL_SPI_STA_END_PENDING                      (1UL << 10)
N/*! Trigger SPI TX IRQ pending when SPI tx fifo is half empty. Writing 1 to
N *  this bit will clear it, otherwise unchanged.
N */
N#define LL_SPI_STA_TX_IRQ_PENDING                   (1UL << 9)
N/*! Trigger SPI RX IRQ pending when SPI rx fifo is half full. Writing 1 to
N *  this bit will clear it, otherwise unchanged.
N */
N#define LL_SPI_STA_RX_IRQ_PENDING                   (1UL << 8)
N/*! When spi tx fifo is full, the pending is 1, otherwise it is 0.
N */
N#define LL_SPI_STA_TX_FIFO_FULL_PENDING             (1UL << 7)
N/*! When spi tx fifo is empty, the pending is 1, otherwise it is 0.
N */
N#define LL_SPI_STA_TX_FIFO_EMPTY_PENDING            (1UL << 6)
N/*! When spi rx fifo is full, the pending is 1, otherwise it is 0.
N */
N#define LL_SPI_STA_RX_FIFO_FULL_PENDING             (1UL << 5)
N/*! When spi rx fifo is empty, the pending is 1, otherwise it is 0.
N */
N#define LL_SPI_STA_RX_FIFO_EMPTY_PENDING            (1UL << 4)
N/*! This bit set when SPI tx fifl is wrote overflow. Writing 1 to this bit
N *  will clear it, otherwise unchanged.
N */
N#define LL_SPI_STA_TX_FIFO_ERR_PENDING              (1UL << 3)
N/*! This bit set when SPI rx fifl is wrote overflow. Writing 1 to this bit
N *  will clear it, otherwise unchanged.
N */
N#define LL_SPI_STA_RX_FIFO_ERR_PENDING              (1UL << 2)
N/*! SPI busy status bit
N */
N#define LL_SPI_STA_BUSY_PENDING                     (1UL << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_Exported_Constants SPI LL Exported Constants
N  * @ingroup  SPI_LL_Driver
N  * @brief    SPI LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief SPI data frame size enum type, consistent with the spec definition.  
N  *        The spi data frame size represents the number of bits of data sent
N  *        by the spi module each time.
N  */
Ntypedef enum {
N    /*! The SPI module has a frame size of 8 bits.
N     */
N    LL_SPI_8_BIT                        = 0,
N    /*! The SPI module has a frame size of 16 bits.
N     */
N    LL_SPI_16_BIT                       = 1,
N    /*! The SPI module has a frame size of 24 bits, but the SPI module 
N     *  performs data operations in word units.
N     */
N    LL_SPI_24_BIT                       = 2,
N    /*! The SPI module has a frame size of 32 bits.
N     */
N    LL_SPI_32_BIT                       = 3,
N} TYPE_ENUM_LL_SPI_FRAME_SIZE;
N
N/**
N  * @brief SPI wire mode enum type, consistent with the spec definition
N  */
Ntypedef enum {
N    /*! The effective bus of the SPI module is CS, CLK, MOSI, MISO.
N     */
N    LL_SPI_NORMAL_MODE                  = 0,
N    /*! The SPI module implements the MOSI and MISO functions with one IO.
N     *  @note When the SPI module is used as the master, the active bus is CS,
N     *        CLK, and MOSI. When the SPI module is used as the slave, the
N     *        active bus is CS, CLK, and MISO.
N     */
N    LL_SPI_THREE_WIRE_MODE              = 1,
N    /*! The active bus of the SPI module is CS, CLK, IO0, IO1. Among them IO0
N     *  and IO1 are bidirectional IO.
N     */
N    LL_SPI_DUAL_MODE                    = 2,
N    /*! The active bus of the SPI module is CS, CLK, IO0, IO1, IO2, IO3. Among
N     *  them, IO0 to IO4 are bidirectional IO.
N     */
N    LL_SPI_QUAD_MODE                    = 3,
N} TYPE_ENUM_LL_SPI_WIRE_MODE;
N
N/**
N  * @brief SPI mode enum type, consistent with the spec definition.
N  * @note SPI_MODE_0 represents the first valid rising edge to start data acquisition.  
N  *       SPI_MODE_1 represents the second valid falling edge to start data acquisition.  
N  *       SPI_MODE_2 represents the first valid falling edge to start data acquisition.  
N  *       SPI_MODE_3 represents the second valid rising edge to start data acquisition.
N  */
Ntypedef enum {
N    /*! CPOL = 0, CPHA = 0
N     */
N    LL_SPI_MODE_0                       = 0,
N    /*! CPOL = 0, CPHA = 1
N     */
N    LL_SPI_MODE_1                       = 1,
N    /*! CPOL = 1, CPHA = 0
N     */
N    LL_SPI_MODE_2                       = 2,
N    /*! CPOL = 1, CPHA = 1
N     */
N    LL_SPI_MODE_3                       = 3,
N} TYPE_ENUM_LL_SPI_MODE;
N
N/**
N  * @brief SPI module IO mapping enumeration
N  */
Ntypedef enum {
N    /*! Select the pin of the SPI0 io map0
N     */
N    LL_SPI0_IOMAP0,
N    /*! Select the pin of the SPI0 io map1
N     */
N    LL_SPI0_IOMAP1,
N    /*! Select the pin of the SPI0 MCP io map0
N     */
N    LL_SPI0_MCP_IOMAP0,
N    /*! Select the pin of the SPI0 MCP io map1
N     */
N    LL_SPI0_MCP_IOMAP1,
N    /*! Select the pin of the SPI1 io map0
N     */
N    LL_SPI1_IOMAP0,
N    /*! Select the pin of the SPI1 io map1
N     */
N    LL_SPI1_IOMAP1,
N} TYPE_ENUM_LL_SPI_IO_MAP;
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_Exported_Struct SPI LL Exported Struct
N  * @ingroup  SPI_LL_Driver
N  * @brief    SPI LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the SPI registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_spi_init. Function, you can configure the SPI module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief SPI low layer initialization structure
N  */
Ntypedef struct __ll_spi_init {
N    /*! SPI clock divider ratio.
N     * @note SPI_CLK = APB_CLK/((clk_div_cnt+1)*2)
N     */
N    u32                         clk_div_cnt;
N    /*! Configure the number of bits of data sent by the SPI module each time.
N     */
N    TYPE_ENUM_LL_SPI_FRAME_SIZE frame_size;
N    /*! Configure the bus mode of the SPI module.
N     */
N    TYPE_ENUM_LL_SPI_MODE       spi_mode;
N    /*! If the SPI module is acting as a slave, the flag needs to be set to 
N     *  true.
N     */
N    bool                        slave_mode_en;
N    /*! Configure the SPI module's wire mode.
N     */
N    TYPE_ENUM_LL_SPI_WIRE_MODE  wire_mode;
N    /*! IO map selection for SPI
N     *  @note The correspondence table of IO_MAP is as follows:
N     *        |      | IO map enum        | CS/CLK/IO0/IO1/IO2/IO3  |
N     *        | :--- | :----------------- | :---------------------- |
N     *        | SPI0 | LL_SPI0_IOMAP0     | PA0/PA1/PA2/PA3/PA4/PA5 |
N     *        | ^    | LL_SPI0_IOMAP1     | PA0/PA1/PA2/PA3         |
N     *        | ^    | LL_SPI0_MCP_IOMAP0 | PA0/PD1/PD0/PA1         |
N     *        | ^    | LL_SPI0_MCP_IOMAP1 | PA0/PD1/PD0/PA1/PA2/PD2 |
N     *        | SPI1 | LL_SPI1_IOMAP0     | PD0/PD1/PD2/PD3/PD4/PD5 |
N     *        | ^    | LL_SPI1_IOMAP1     | PD0/PD1/PD2/PD3         |
N     */
N    TYPE_ENUM_LL_SPI_IO_MAP     io_map;
N} TYPE_LL_SPI_INIT;
N
N/**
N  * @brief SPI module interrupt low layer configuration structure
N  */
Ntypedef struct __ll_spi_irq_cfg {
N    /*! The spi module tx interrupt enable.
N     */
N    bool                       tx_intr_en;
N    /*! The spi module rx interrupt enable.
N     */
N    bool                       rx_intr_en;
N    /*! The interrupt is enabled when the SPI slave CS goes from low to high. 
N     */
N    bool                       slave_cs_rising_intr_en;
N} TYPE_LL_SPI_IRQ_CFG;
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_Interrupt SPI LL Interrupt Handle function
N  * @brief   SPI LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SPI  
N    Interrupt Handle function.
N
N    how to use?
N
N    The SPI interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the SPI in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup SPI_LL_Inti_Cfg SPI LL Initialization And Configuration
N  * @brief    SPI LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SPI data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/** 
N  * @brief  Low layer SPI initialization function
N  * @param  p_spi : SPI module pointer
N  * @param  p_init: SPI initialization struct pointer
N  * @retval None.
N  */
Nvoid ll_spi_init(SPI_TypeDef *p_spi, TYPE_LL_SPI_INIT *p_init);
N
N/**
N  * @brief  SPI module detele initialization function
N  * @param  p_spi: Select the initialized SPI module pointer
N  * @retval None
N  */
Nvoid ll_spi_deinit(SPI_TypeDef *p_spi);
N
N/**
N  * @brief  Low layer SPI io map init function
N  * @param  p_spi : SPI module pointer
N  * @param  io_map: SPI module IO mapping
N  * @retval None
N  */
Nvoid ll_spi_io_map(SPI_TypeDef *p_spi, TYPE_ENUM_LL_SPI_IO_MAP io_map);
N
N/** 
N  * @brief  Low layer SPI interrupt config function
N  * @param  p_spi: SPI module pointer
N  * @param  p_cfg: SPI Configuration struct pointer
N  * @retval None.
N  */
Nvoid ll_spi_irq_config(SPI_TypeDef *p_spi, TYPE_LL_SPI_IRQ_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup SPI_LL_Data_Transfers SPI LL Data transfers functions
N  * @brief    SPI LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SPI data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  The SPI module gets the current wire mode
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
NTYPE_ENUM_LL_SPI_WIRE_MODE ll_spi_get_wire_mode(SPI_TypeDef *p_spi);
N
N/**
N  * @brief  The SPI module set the current wire mode
N  * @param  p_spi        : SPI module pointer
N  * @param  wire_mode_sel: SPI wire mode \ref TYPE_ENUM_LL_SPI_WIRE_MODE
N  * @retval None
N  */
Nvoid ll_spi_set_wire_mode(SPI_TypeDef *p_spi, TYPE_ENUM_LL_SPI_WIRE_MODE wire_mode_sel);
N
N/**
N  * @brief  The SPI write a data function.
N  * @param  p_spi: SPI module pointer.
N  * @param  data : The data sent.
N  * @retval None
N  */
N#define LL_SPI_WRITE_DATA(p_spi, data)              ((p_spi)->WDATA = (data))
N
N/**
N  * @brief  The SPI read a data function.
N  * @param  p_spi: SPI module pointer.
N  * @retval The data read by the SPI.
N  */
N#define LL_SPI_READ_DATA(p_spi)                     ((p_spi)->RDATA)
N
N/**
N  * @brief  Pull down the chip select(CS) pins of the SPI module.
N  * @param  p_spi: SPI module pointer.
N  * @retval None
N  * @note   Only valid in master mode.
N  */
N__STATIC_INLINE void ll_spi_set_cs(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_set_cs(SPI_TypeDef *p_spi) {
N    p_spi->CTL |= LL_SPI_CTL_CS_HIGH;
X    p_spi->CTL |= (1UL << 3);
N}
N
N/**
N  * @brief  Pull up the chip select(CS) pins of the SPI module.
N  * @param  p_spi: SPI module pointer.
N  * @retval None
N  * @note   Only valid in master mode.
N  */
N__STATIC_INLINE void ll_spi_clear_cs(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_clear_cs(SPI_TypeDef *p_spi) {
N    p_spi->CTL &= ~(LL_SPI_CTL_CS_HIGH);
X    p_spi->CTL &= ~((1UL << 3));
N}
N
N/**
N  * @brief  Check SPI RX interrupt enable
N  * @param  p_spi: SPI module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_SPI_CHECK_RX_INTERRUPT_ENABLE(p_spi)     ((p_spi)->CFG & LL_SPI_CFG_RIRQ_EN)
N
N/**
N  * @brief  Check SPI TX interrupt enable
N  * @param  p_spi: SPI module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_SPI_CHECK_TX_INTERRUPT_ENABLE(p_spi)     ((p_spi)->CFG & LL_SPI_CFG_TIRQ_EN)
N
N/**
N  * @brief  Check SPI END interrupt enable
N  * @param  p_spi: SPI module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_SPI_CHECK_END_INTERRUPT_ENABLE(p_spi)    ((p_spi)->CFG & LL_SPI_CFG_END_IRQ_EN)
N
N/**
N  * @brief  Whether the SPI slave communication ends
N  * @param  p_spi: SPI module pointer
N  * @retval Return 0 means SPI communication is not over, returning other
N  *         values means SPI communication is completed.
N  */
N#define LL_SPI_GET_END_PENDING(p_spi)               ((p_spi)->STA & LL_SPI_STA_END_PENDING)
N
N/**
N  * @brief  SPI clears end pending.
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_clear_end_pending(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_clear_end_pending(SPI_TypeDef *p_spi) {
N    (p_spi)->STA |= LL_SPI_STA_END_PENDING;
X    (p_spi)->STA |= (1UL << 10);
N}
N
N/**
N  * @brief  Check SPI tx irq pending
N  * @param  p_spi: SPI module pointer
N  * @retval Return to SPI tx irq pending
N  */
N#define LL_SPI_GET_TX_IRQ_PENDING(p_spi)            ((p_spi)->STA & LL_SPI_STA_TX_IRQ_PENDING)
N
N/**
N  * @brief  clear SPI tx irq pending
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_clear_tx_irq_pending(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_clear_tx_irq_pending(SPI_TypeDef *p_spi) {
N    (p_spi)->STA |= LL_SPI_STA_TX_IRQ_PENDING;
X    (p_spi)->STA |= (1UL << 9);
N}
N
N/**
N  * @brief  Check SPI rx irq pending
N  * @param  p_spi: SPI module pointer
N  * @retval Return to SPI rx irq pending
N  */
N#define LL_SPI_GET_RX_IRQ_PENDING(p_spi)            ((p_spi)->STA & LL_SPI_STA_RX_IRQ_PENDING)
N
N/**
N  * @brief  clear SPI rx irq pending
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_clear_rx_irq_pending(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_clear_rx_irq_pending(SPI_TypeDef *p_spi) {
N    (p_spi)->STA |= LL_SPI_STA_RX_IRQ_PENDING;
X    (p_spi)->STA |= (1UL << 8);
N}
N
N/**
N  * @brief  Check SPI tx fifo full state
N  * @param  p_spi: SPI module pointer
N  * @retval Return SPI tx fifo full pending
N  */
N#define LL_SPI_GET_TX_FIFO_FULL_PENDING(p_spi)      ((p_spi)->STA & LL_SPI_STA_TX_FIFO_FULL_PENDING)
N
N/**
N  * @brief  Check SPI rx fifo empty state
N  * @param  p_spi: SPI module pointer
N  * @retval Return SPI rx fifo empty pending
N  */
N#define LL_SPI_GET_RX_FIFO_EMPTY_PENDING(p_spi)     ((p_spi)->STA & LL_SPI_STA_RX_FIFO_EMPTY_PENDING)
N
N/**
N  * @brief  Check SPI tx fifo err pending
N  * @param  p_spi: SPI module pointer
N  * @retval Return SPI tx fifo err pending
N  */
N#define LL_SPI_GET_TX_FIFO_ERR_PENDING(p_spi)       ((p_spi)->STA & LL_SPI_STA_TX_FIFO_ERR_PENDING)
N
N/**
N  * @brief  Clear SPI tx fifo err pending
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_clear_tx_fifo_err_pending(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_clear_tx_fifo_err_pending(SPI_TypeDef *p_spi) {
N    (p_spi)->STA |= LL_SPI_STA_TX_FIFO_ERR_PENDING;
X    (p_spi)->STA |= (1UL << 3);
N}
N
N/**
N  * @brief  Check SPI rx fifo err pending
N  * @param  p_spi: SPI module pointer
N  * @retval Return SPI rx fifo err pending
N  */
N#define LL_SPI_GET_RX_FIFO_ERR_PENDING(p_spi)       ((p_spi)->STA & LL_SPI_STA_RX_FIFO_ERR_PENDING)
N
N/**
N  * @brief  Clear SPI rx fifo err pending
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_clear_rx_fifo_err_pending(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_clear_rx_fifo_err_pending(SPI_TypeDef *p_spi) {
N    (p_spi)->STA |= LL_SPI_STA_RX_FIFO_ERR_PENDING;
X    (p_spi)->STA |= (1UL << 2);
N}
N
N/**
N  * @brief  SPI module busy state function
N  * @param  p_spi: SPI module pointer
N  * @retval Return 0 means the SPI module is in the idle state, and returning
N  *         other values means the SPI module is in the busy state.
N  */
N#define LL_SPI_GET_BUSY_PENDING(p_spi)              ((p_spi)->STA & LL_SPI_STA_BUSY_PENDING)
N
N/**
N  * @brief  SPI enable receive interruption.
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_receive_interrupt_enable(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_receive_interrupt_enable(SPI_TypeDef *p_spi) {
N    p_spi->CFG |= LL_SPI_CFG_RIRQ_EN;
X    p_spi->CFG |= (1UL << 12);
N}
N
N/**
N  * @brief  SPI disable receive interruption.
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_receive_interrupt_disable(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_receive_interrupt_disable(SPI_TypeDef *p_spi) {
N    p_spi->CFG &= ~(LL_SPI_CFG_RIRQ_EN);
X    p_spi->CFG &= ~((1UL << 12));
N}
N
N/**
N  * @brief  SPI enable send interruption.
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_send_interrupt_enable(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_send_interrupt_enable(SPI_TypeDef *p_spi) {
N    p_spi->CFG |= LL_SPI_CFG_TIRQ_EN;
X    p_spi->CFG |= (1UL << 13);
N}
N
N/**
N  * @brief  SPI disable receive interruption.
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_send_interrupt_disable(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_send_interrupt_disable(SPI_TypeDef *p_spi) {
N    p_spi->CFG &= ~(LL_SPI_CFG_TIRQ_EN);
X    p_spi->CFG &= ~((1UL << 13));
N}
N
N/**
N  * @brief  SPI enable receive interruption.
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_slave_cs_rising_interrupt_enable(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_slave_cs_rising_interrupt_enable(SPI_TypeDef *p_spi) {
N    p_spi->CFG |= LL_SPI_CFG_END_IRQ_EN;
X    p_spi->CFG |= (1UL << 27);
N}
N
N/**
N  * @brief  SPI disable receive interruption.
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_slave_cs_rising_interrupt_disable(SPI_TypeDef *p_spi) {
Xstatic __inline void ll_spi_slave_cs_rising_interrupt_disable(SPI_TypeDef *p_spi) {
N    p_spi->CFG &= ~(LL_SPI_CFG_END_IRQ_EN);
X    p_spi->CFG &= ~((1UL << 27));
N}
N
N/**
N  * @brief  Start the tx function of the spi module
N  * @param  p_spi: SPI module pointer
N  * @param  num:   The number of frames to send.
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_start_tx(SPI_TypeDef *p_spi, u32 num)
Xstatic __inline void ll_spi_start_tx(SPI_TypeDef *p_spi, u32 num)
N{
N    p_spi->CTL     |= LL_SPI_CTL_TX_EN; //Enable the SPI tx function
X    p_spi->CTL     |= (1UL << 1); 
N    p_spi->TX_BC    = num;              //Set the number of frames to send
N    p_spi->TX_START = 0x0000;           //Start the TX function
N}
N
N/**
N  * @brief  Start the rx function of the spi module
N  * @param  p_spi: SPI module pointer
N  * @param  num:   The number of frames to send.
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_start_rx(SPI_TypeDef *p_spi, u32 num)
Xstatic __inline void ll_spi_start_rx(SPI_TypeDef *p_spi, u32 num)
N{
N    p_spi->CTL     |= LL_SPI_CTL_RX_EN; //Enable the SPI rx function
X    p_spi->CTL     |= (1UL << 0); 
N    p_spi->RX_BC    = num;              //Set the number of frames to receive
N    p_spi->RX_START = 0x0000;           //Start the RX function
N}
N
N/**
N  * @brief  Disable the SPI module
N  * @param  p_spi: SPI module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_spi_disable(SPI_TypeDef *p_spi)
Xstatic __inline void ll_spi_disable(SPI_TypeDef *p_spi)
N{
N    p_spi->CTL &= ~(LL_SPI_CTL_TX_EN | LL_SPI_CTL_RX_EN);
X    p_spi->CTL &= ~((1UL << 1) | (1UL << 0));
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_SPI_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 54 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_fadc.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_fadc.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_fadc.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.2
N  * @date    04-08-2019
N  * @brief   This file contains all the FADC LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_FADC_H
N#define __TX_PHE_LL_FADC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup fadc_interface_gr FADC Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup FADC_LL_Driver FADC LL Driver
N  * @ingroup  fadc_interface_gr
N  * @brief Mainly the driver part of the FADC module, which includes \b FADC \b Register 
N  * \b Constants, \b FADC \b Exported \b Constants, \b FADC \b Exported \b Struct, \b FADC
N  * \b Data \b transfers \b functions, \b FADC \b Initialization \b and \b FADC \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N 
N/** @defgroup FADC_LL_Register_Constants FADC LL Register Constants
N  * @ingroup  FADC_LL_Driver
N  * @brief    FADC LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the FADC 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the FADC register, mainly for convenience. Understand the 
N    configuration of the FADC.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** FADCCON0 *****/
N/*! ADC system clock domain data path enable signal. 
N */
N#define LL_FADC_CON0_EN                           (1UL << 0)
N
N
N/***** FADCACSCON *****/
N/*! Fadc special function register address. Sfr is in the adc high-speed clock domain,
N *  so it needs to synchronize the interface to operate. 
N */
N#define LL_FADC_ACS_ADDR(n)                       (((n)&0x3F) << 2)
N/*! The fadc special function register read and write operation selection bit.
N *  0: Read operation; 1: Write operation. 
N */
N#define LL_FADC_RW                                (1UL << 1)
N/*! Read and write work status bits. 0: Read and write idle; 1: Read and write busy. 
N */
N#define LL_FADC_ON                                (1UL << 0)
N
N
N/***** FADCACSDAT *****/
N/*! The special register of the specified address is read and written according to the 
N *  value of acs_addr in FADCACSCON.
N *  Read operation: return the value of the corresponding special register;
N *  Write operation: Write data to a special register of the specified address. 
N */
N#define LL_FADC_ACS_DATA(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** FADCINT0 *****/
N/*! After the 0~15 ADC completes a sample conversion, the interrupt enable signal is 
N *  triggered, and each bit represents a path. 0: Off interrupt, 1: Open interrupt. 
N */
N#define LL_FADC_SMP_DONE_INT_EN(n)                (((n)&0xFFFF) << 0)
N
N
N/***** FADCINT1 *****/
N/*! The 0~15 ADC DMA data FIFO is full, triggering the interrupt enable signal, and 
N *  each bit represents a path. 0: Off interrupt, 1: Open interrupt. 
N */
N#define LL_FADC_DMA_FULL_INT_EN(n)                (((n)&0xFFFF) << 16)
N/*! The 0~15 ADC DMA data FIFO is half full, triggering the interrupt enable signal, 
N *  and each bit represents a path. 0: Off interrupt, 1: Open interrupt. 
N */
N#define LL_FADC_DMA_HALF_INT_EN(n)                (((n)&0xFFFF) << 0)
N
N
N/***** FADCSMPFLAG *****/
N/*! Clear the 0~15 smp_done_flag, write 1 clear flag, and each bit represents a path.
N */
N#define LL_FADC_CLR_SMP_DONE_FLAG(n)              (((n)&0xFFFF) << 16)
N/*! The 0~15 ADC completes the flag after a sample conversion, and each bit represents a path.
N */
N#define LL_FADC_SMP_DONE_FLAG(n)                  (((n)&0xFFFF) << 0)
N
N
N/***** FADCDMAFLAG0 *****/
N/*! Clear the 0~15 smp_half_flag, write 1 clear flag, and each bit represents a path.
N */
N#define LL_FADC_CLR_DMA_HALF_FLAG(n)              (((n)&0xFFFF) << 16)
N/*! The 0~15 DMA data FIFO half flag bit. The size of the FIFO is determined by the 
N * register FADCDMALENn, and each bit represents a path. 
N */
N#define LL_FADC_DMA_HALF_FLAG(n)                  (((n)&0xFFFF) << 0)
N
N
N/***** FADCDMAFLAG1 *****/
N/*! Clear the 0~15 smp_full_flag, write 1 clear flag, and each bit represents a path.
N */
N#define LL_FADC_CLR_DMA_FULL_FLAG(n)              (((n)&0xFFFF) << 16)
N/*! The 0~15 DMA data FIFO full flag bit. The size of the FIFO is determined by the 
N * register FADCDMALENn, and each bit represents a path. 
N */
N#define LL_FADC_DMA_FULL_FLAG(n)                  (((n)&0xFFFF) << 0)
N
N
N/***** FADCDMAADDR 0 ~ 15 *****/
N/*! The Nth FADC DMA data FIFO start address, N means 0 ~ 15. 
N */
N#define LL_FADC_DMA_ADDR(n)                       (((n)&0xFFFFFFFF) << 0)
N
N
N/***** FADCDMALEN 0 ~ 15 *****/
N/*! The Nth ADC data DMA is enabled. , N means 0 ~ 15.
N */
N#define LL_FADC_DMA_EN                            (1UL << 13)
N/*! The 0th ADC data DMA FIFO length, N means 0 ~ 15. 
N */
N#define LL_FADC_DMA_LEN(n)                        (((n)&0x1FFF) << 0)
N
N
N/***** FADCPPROC0CON 0 ~ 15 *****/
N/*! Used for the 0th channel ADC data dc_offset elimination. The input data is 
N *  subtracted from this value as output data. 
N */
N#define LL_FADC_DC_OFFSET(n)                      (((n)&0xFFF) << 6)
N/*! Fadc sample extraction selection. 
N */
N#define LL_FADC_DOMNSAMPLE_SEL(n)                 (((n)&0x7) << 3)
N/*! Average selection of FADC data. 
N */
N#define LL_FADC_AVERAGE_SEL(n)                    (((n)&0x3) << 1)
N/*! The FADC data is enabled on average.
N */
N#define LL_FADC_AVERAGE_EN                        (1UL << 0)
N
N
N/***** FADCPPROC1CON 0 ~ 15 *****/
N/*! The nth ADC data quantization coefficient. 
N */
N#define LL_FADC_QUANTIFY_COEF(n)                  (((n)&0xFFFF) << 4)
N/*! FADC data quantization bit width selection. 
N */
N#define LL_FADC_DECIMAL_WIDTH(n)                  (((n)&0x7) << 1)
N/*! FADC data quantization is enabled. 
N */
N#define LL_FADC_QUANTIFY_EN                       (1UL << 0)
N
N
N/***** FADCRES 0 ~ 7 *****/
N/*! The conversion result of the first SOC. 
N */
N#define LL_FADC_RES0(n)                           (((n)&0xFFFF) << 16)
N/*! The conversion result of the 0th SOC.
N */
N#define LL_FADC_RES1(n)                           (((n)&0xFFFF) << 0)
N
N
N/***** FADCSFRANACON0 *****/                                    
N/*! Select the ADC analog module part of the control bits using software 
N *  register control or hardware control. 
N */
N#define LL_FADC_ANA_CTRL_SEL(i)                   (((i)&0x1) << 12)
N/*!  */
N#define LL_FADC_ANA_CMPBSEN(i)                    (((i)&0x1) << 11)
N/*!  */
N#define LL_FADC_ANA_TVS2(i)                       (((i)&0x1) << 10)
N/*!  */
N#define LL_FADC_ANA_TVS1(i)                       (((i)&0x1) << 9)
N/*!  */
N#define LL_FADC_ANA_TVS0(i)                       (((i)&0x1) << 8)
N/*!  */
N#define LL_FADC_ANA_CHSEL(i)                      (((i)&0x1) << 7)
N/*!  */
N#define LL_FADC_ANA_TRIM(i)                       (((i)&0x1) << 6)
N/*!  */
N#define LL_FADC_ANA_ENVTS(i)                      (((i)&0x1) << 5)
N/*!  */
N#define LL_FADC_ANA_ENSYNS(i)                     (((i)&0x1) << 4)
N/*!  */
N#define LL_FADC_ANA_CMPEN(i)                      (((i)&0x1) << 3)
N/*!  */
N#define LL_FADC_ANA_BUFFEN(i)                     (((i)&0x1) << 2)
N/*!  */
N#define LL_FADC_ANA_BIASEN(i)                     (((i)&0x1) << 1)
N/*!  */
N#define LL_FADC_ANA_ADCEN(i)                      (((i)&0x1) << 0)
N
N 
N/***** FADCSFRANACON1 *****/
N/*!  */
N#define LL_FADC_ANA_SIOB(i)                       (((i)&0x1) << 29)
N/*!  */
N#define LL_FADC_ANA_S2B(i)                        (((i)&0x1) << 28)
N/*!  */
N#define LL_FADC_ANA_S1B(i)                        (((i)&0x1) << 27)
N/*!  */
N#define LL_FADC_ANA_S0B(i)                        (((i)&0x1) << 26)
N/*!  */
N#define LL_FADC_ANA_VCMIBEN(i)                    (((i)&0x1) << 25)
N/*!  */
N#define LL_FADC_ANA_ENSHTB(i)                     (((i)&0x1) << 24)
N/*!  */
N#define LL_FADC_ANA_ENSHB(i)                      (((i)&0x1) << 23)
N/*!  */
N#define LL_FADC_ANA_ENS2DB(n)                     (((n)&0x7F) << 16)
N/*!  */
N#define LL_FADC_ANA_SIOA(i)                       (((i)&0x1) << 13)
N/*!  */
N#define LL_FADC_ANA_S2A(i)                        (((i)&0x1) << 12)
N/*!  */
N#define LL_FADC_ANA_S1A(i)                        (((i)&0x1) << 11)
N/*!  */
N#define LL_FADC_ANA_S0A(i)                        (((i)&0x1) << 10)
N/*!  */
N#define LL_FADC_ANA_VCMIAEN(i)                    (((i)&0x1) << 9)
N/*!  */
N#define LL_FADC_ANA_ENSHTA(i)                     (((i)&0x1) << 8)
N/*!  */
N#define LL_FADC_ANA_ENSHA(i)                      (((i)&0x1) << 7)
N/*!  */
N#define LL_FADC_ANA_ENS2DA(n)                     (((n)&0x7F) << 0)
N
N
N/***** FADCSFRADCCON0 *****/
N/*! Offset binary data is inverted.
N */
N#define LL_FADC_DATINV_EN(i)                      (((i)&0x1) << 25)
N/*! Adc data format selection.
N */
N#define LL_FADC_DATFMT_SEL(i)                     (((i)&0x1) << 24)
N/*! After the SOC is triggered, the channel switching delay.
N */
N#define LL_FADC_SOC_ONDLY_TIME(n)                 (((n)&0x7F) << 17)
N/*! The time required for a single ADC conversion, configuration  
N *  time = Tadc_clk* (convt_time+1). 
N */
N#define LL_FADC_CONVT_TIME(n)                     (((n)&0x3F) << 11)
N/*! The ADC simulation module starts up to normal settling time, configuration  
N *  time = Tadc_clk* (convt_time+1). 
N */
N#define LL_FADC_STABLE_TIME(n)                    (((n)&0x1F) << 6)
N/*! Polling mode polls the number of slots configured. 
N */
N#define LL_FADC_POLLING_SLOTCON(n)                (((n)&0xF) << 2)
N/*! Polling mode settings. 
N */
N#define LL_FADC_POLLING_MODE(i)                   (((i)&0x1) << 1)
N/*! The ADC conversion module is enabled. 
N */
N#define LL_FADC_M_EN(i)                           (((i)&0x1) << 0)
N
N
N/***** FADCSFRSOCCON 0 ~ 7 *****/
N/*! The 2n+1th SOC trigger source selection.
N */ 
N#define LL_FADC_TRISEL1(n)                        (((n)&0xF) << 27)
N/*! The 2n+1th SOC sampling window time control. Configuration  
N *  time = Tadc_clk*(smp_win+1). 
N */ 
N#define LL_FADC_SMP_WIN1(n)                       (((n)&0x7F) << 20)
N/*! The analog input channel selection of the 2n+1th SOC.
N */
N#define LL_FADC_CHSEL1(n)                         (((n)&0xF) << 16)
N/*! The 2n SOC trigger source selection.
N */
N#define LL_FADC_TRISEL0(n)                        (((n)&0xF) << 11)
N/*! The 2nth SOC sampling window time control. Configuration  
N *  time = Tadc_clk*(smp_win+1). 
N */ 
N#define LL_FADC_SMP_WIN0(n)                       (((n)&0x7F) << 4)
N/*! The analog input channel selection of the 2nth SOC.
N */
N#define LL_FADC_CHSEL0(n)                         (((n)&0xF) << 0)
N
N
N/***** FADCSFRSOCCON8 *****/
N/*! High priority SOC settings.
N */
N#define LL_FADC_SOC_HPRI(n)                       (((n)&0x1F) << 24)
N/*! Simultaneous sampling enable.
N */
N#define LL_FADC_SIMULEN(n)                        (((n)&0xFF) << 16)
N/*! The nth SOC trigger source is enabled. 
N */
N#define LL_FADC_TRI_EN(n)                         (((n)&0xFFFF) << 0)
N
N
N/***** FADCSFRSOCFLAG *****/
N/*! CPU intervention forces the SOC to be triggered.
N */
N#define LL_FADC_FC_TRI(n)                         (((n)&0xFFFF) << 16)
N/*! The nth SOC is triggered and the conversion indication flag is not completed.
N */
N#define LL_FADC_SOC_TRI(n)                        (((n)&0xFFFF) << 0)
N
N
N/***** FADCSFRSOCOVFL *****/
N/*! Clear the corresponding flag of soc_ovf and write 1 to clear.
N */
N#define LL_FADC_CLR_SOC_OVF(n)                    (((n)&0xFFFF) << 16)
N/*! The nth SOC is triggered and the conversion is not completed. At this time, 
N *  the SOC trigger is again caused, resulting in two conversion requests. Only 
N *  one data conversion occurs, and an overflow occurs. This flag is used to 
N *  indicate this situation.  
N *  0: no overflow  
N *  1: overflow occurs  
N */
N#define LL_FADC_SOC_OVF(n)                        (((n)&0xFFFF) << 0)
N
N
N/***** FADCSFRCALIB0 *****/
N/*! The error estimation mode, the error of the final estimated parameter exceeds 
N *  the preset range, which is set to 1. 
N */
N#define LL_FADC_ERR_OFR(i)                        (((i)&0x1) << 30)
N/*! The error estimation mode estimates the completion flag.  
N *  0: Not completed  
N *  1: Completed  
N */
N#define LL_FADC_CALIB_FLAG(i)                     (((i)&0x1) << 29)
N/*! Clear the err_ofr flag and write 1 to clear.
N */
N#define LL_FADC_ERR_OFR_CLR(i)                    (((i)&0x1) << 28)
N/*! Clear the calib_flag flag and write 1 to clear.
N */
N#define LL_FADC_CLR_CALIB_FLAG(i)                 (((i)&0x1) << 27)
N/*! Error estimation mode work start signal,  
N *  0: Do not start  
N *  1: Start  
N */
N#define LL_FADC_CALIB_TRI(i)                      (((i)&0x1) << 26)
N/*! Estimated result check number control. 
N */
N#define LL_FADC_RES_CHECK_CNT(n)                  (((n)&0xF) << 22)
N/*! Error estimation mode, error estimation deviation control.
N */
N#define LL_FADC_ERR_RANGE(n)                      (((n)&0x1F) << 17)
N/*! The number of iterations is set.
N */
N#define LL_FADC_ITER_TIME(n)                      (((n)&0x3F) << 11)
N/*! Error estimation mode, iterative step selection, the default is 1/64.
N */
N#define LL_FADC_WSTENSIZE(n)                      (((n)&0x3FF) << 1)
N/*! ADC calibration module working mode selection,  
N *  0: error estimation mode  
N *  1: data calibration mode  
N */
N#define LL_FADC_CALIB_WMODE(i)                    (((i)&0x1) << 0)
N
N
N/***** FADCSFRCALIB1 *****/
N/*! Data calibration mode, final data output selection,  
N *  0: Output the calibrated data  
N *  1: Output the data before calibration  
N */
N#define LL_FADC_CALIB_NORM_OUTSEL(i)              (((i)&0x1) << 8)
N/*! The error estimation mode presets the maximum value of the error of the 
N *  final estimated parameter. If the final estimated parameter exceeds the 
N *  preset value, it indicates that the error estimation result is not satisfactory. 
N */
N#define LL_FADC_MAX_OFR_CON(n)                    (((n)&0xFF) << 0)
N
N
N/***** FADCSFRWCOEF0 *****/
N/*! Channel 0, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF0(n)                         (((n)&0x3FFF) << 0)
N
N
N/***** FADCSFRWCOEF1 *****/
N/*! Channel 1, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF1(n)                         (((n)&0x3FFF) << 0)
N
N
N/***** FADCSFRWCOEF2 *****/
N/*! Channel 2, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF2(n)                         (((n)&0x7FFF) << 0)
N
N
N/***** FADCSFRWCOEF3 *****/
N/*! Channel 3, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF3(n)                         (((n)&0x7FFF) << 0)
N
N
N/***** FADCSFRWCOEF4 *****/
N/*! Channel 4, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF4(n)                         (((n)&0xFFFF) << 0)
N
N
N/***** FADCSFRWCOEF5 *****/
N/*! Channel 5, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF5(n)                         (((n)&0x1FFFF) << 0)
N
N
N/***** FADCSFRWCOEF6 *****/
N/*! Channel 6, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF6(n)                         (((n)&0x3FFFF) << 0)
N
N
N/***** FADCSFRWCOEF7 *****/
N/*! Channel 7, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF7(n)                         (((n)&0x7FFFF) << 0)
N
N
N/***** FADCSFRWCOEF8 *****/
N/*! Channel 8, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF8(n)                         (((n)&0x7FFFF) << 0)
N
N
N/***** FADCSFRWCOEF9 *****/
N/*! Channel 9, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF9(n)                         (((n)&0xFFFFF) << 0)
N
N
N/***** FADCSFRWCOEF10 *****/
N/*! Channel 10, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF10(n)                        (((n)&0x1FFFFF) << 0)
N
N
N/***** FADCSFRWCOEF11 *****/
N/*! Channel 11, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF11(n)                        (((n)&0x3FFFFF) << 0)
N
N
N/***** FADCSFRWCOEF12 *****/
N/*! Channel 12, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF12(n)                        (((n)&0x7FFFFF) << 0)
N
N
N/***** FADCSFRWCOEF13 *****/
N/*! Channel 13, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF13(n)                        (((n)&0xFFFFFF) << 0)
N
N
N/***** FADCSFRWCOEF14 *****/
N/*! Channel 14, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF14(n)                        (((n)&0x1FFFFFF) << 0)
N
N
N/***** FADCSFRWCOEF15 *****/
N/*! Channel 15, error estimation mode, estimated parameters will be saved in this register 
N *  calibration mode, and the parameters obtained by the error estimation mode need to be 
N *  written to this register in advance. 
N */
N#define LL_FADC_WCOEF15(n)                        (((n)&0x1FFFFFF) << 0)
N
N
N/***** FADCSFRSOCTIMER 0 ~ 15 *****/
N/*! Controls whether or not to generate using a counter.
N */
N#define LL_FADC_TIMER_EN(i)                       (((i)&0x1) << 18)
N/*! Generates a counter for the soc trigger source.
N */
N#define LL_FADC_TIMER(n)                          (((n)&0x3FFFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup FADC_LL_Exported_Constants FADC LL Exported Constants
N  * @ingroup  FADC_LL_Driver
N  * @brief    FADC LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N/*! The default value of the FADC reference voltage. 
N */
N#define LL_FADC_VREF_VAL                          (1.500)
N/*! The default value of the FADC VCM voltage.
N */
N#define LL_FADC_VCM_VAL                           (1.500)
N
N/* Macro definition of the FADC high speed clock domain register. */
N#define FADCSFRANACON0                            0x00
N#define FADCSFRANACON1                            0x01
N#define FADCSFRADCCON0                            0x02
N#define FADCSFRSOCCON0                            0x03
N#define FADCSFRSOCCON1                            0x04
N#define FADCSFRSOCCON2                            0x05
N#define FADCSFRSOCCON3                            0x06
N#define FADCSFRSOCCON4                            0x07
N#define FADCSFRSOCCON5                            0x08
N#define FADCSFRSOCCON6                            0x09
N#define FADCSFRSOCCON7                            0x0a
N#define FADCSFRSOCCON8                            0x0b
N#define FADCSFRSOCFLAG                            0x0c
N#define FADCSFRSOCOVFL                            0x0d
N#define FADCSFRCALIB0                             0x0e
N#define FADCSFRCALIB1                             0x0f
N#define FADCSFRWCOEF0                             0x10
N#define FADCSFRWCOEF1                             0x11
N#define FADCSFRWCOEF2                             0x12
N#define FADCSFRWCOEF3                             0x13
N#define FADCSFRWCOEF4                             0x14
N#define FADCSFRWCOEF5                             0x15
N#define FADCSFRWCOEF6                             0x16
N#define FADCSFRWCOEF7                             0x17
N#define FADCSFRWCOEF8                             0x18
N#define FADCSFRWCOEF9                             0x19
N#define FADCSFRWCOEF10                            0x1a
N#define FADCSFRWCOEF11                            0x1b
N#define FADCSFRWCOEF12                            0x1c
N#define FADCSFRWCOEF13                            0x1d
N#define FADCSFRWCOEF14                            0x1e
N#define FADCSFRWCOEF15                            0x1f
N#define FADCSFRSOCTIMER0                          0x20
N#define FADCSFRSOCTIMER1                          0x21
N#define FADCSFRSOCTIMER2                          0x22
N#define FADCSFRSOCTIMER3                          0x23
N#define FADCSFRSOCTIMER4                          0x24
N#define FADCSFRSOCTIMER5                          0x25
N#define FADCSFRSOCTIMER6                          0x26
N#define FADCSFRSOCTIMER7                          0x27
N#define FADCSFRSOCTIMER8                          0x28
N#define FADCSFRSOCTIMER9                          0x29
N#define FADCSFRSOCTIMER10                         0x2a
N#define FADCSFRSOCTIMER11                         0x2b
N#define FADCSFRSOCTIMER12                         0x2c
N#define FADCSFRSOCTIMER13                         0x2d
N#define FADCSFRSOCTIMER14                         0x2e
N#define FADCSFRSOCTIMER15                         0x2f
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for The FADC down sample selection
N  */
Ntypedef enum {
N    /*! No extraction is performed and each sample is processed.
N     */
N    LL_FADC_DOWNSAMPLE_NONE = 0,
N    /*! One out of every 2 sample values in the FADC is taken.
N     */
N    LL_FADC_DOWNSAMPLE_2,
N    /*! One out of every 3 sample values in the FADC is taken.
N     */
N    LL_FADC_DOWNSAMPLE_3,
N    /*! One out of every 4 sample values in the FADC is taken.
N     */
N    LL_FADC_DOWNSAMPLE_4,
N    /*! One out of every 5 sample values in the FADC is taken.
N     */
N    LL_FADC_DOWNSAMPLE_5,
N    /*! One out of every 6 sample values in the FADC is taken.
N     */
N    LL_FADC_DOWNSAMPLE_6,
N    /*! One out of every 7 sample values in the FADC is taken.
N     */
N    LL_FADC_DOWNSAMPLE_7,
N    /*! One out of every 8 sample values in the FADC is taken.
N     */
N    LL_FADC_DOWNSAMPLE_8,
N} TYPE_ENUM_LL_FADC_DOWNSAMPLE;
N
N/**
N  * @brief Enumeration constant for The average selection of FADC data.
N  */
Ntypedef enum {
N    /*! The 2 sample data were averaged.
N     */
N    LL_FADC_AVERAGE_2 = 0,
N    /*! The 4 sample data were averaged.
N     */
N    LL_FADC_AVERAGE_4,
N    /*! The 8 sample data were averaged.
N     */
N    LL_FADC_AVERAGE_8,
N} TYPE_ENUM_LL_FADC_AVERAGE;
N
N/**
N  * @brief Enumeration constant for The FADC data quantization bit width selection.
N  */
Ntypedef enum {
N    /*! The quantization bit width retains 0 decimal places.
N     */
N    LL_FADC_DECIMAL_WIDTH_0 = 0,
N    /*! The quantization bit width retains 1 decimal places.
N     */
N    LL_FADC_DECIMAL_WIDTH_1,
N    /*! The quantization bit width retains 2 decimal places.
N     */
N    LL_FADC_DECIMAL_WIDTH_2,
N    /*! The quantization bit width retains 3 decimal places.
N     */
N    LL_FADC_DECIMAL_WIDTH_3,
N    /*! The quantization bit width retains 4 decimal places.
N     */
N    LL_FADC_DECIMAL_WIDTH_4,
N    /*! The quantization bit width retains 5 decimal places.
N     */
N    LL_FADC_DECIMAL_WIDTH_5,
N    /*! The quantization bit width retains 6 decimal places.
N     */
N    LL_FADC_DECIMAL_WIDTH_6,
N    /*! The quantization bit width retains 7 decimal places.
N     */
N    LL_FADC_DECIMAL_WIDTH_7,
N} TYPE_ENUM_LL_FADC_DECI_W;
N
Ntypedef enum {
N    /*! Fadc analog pathway A group of SARADC0.
N     */
N    LL_FADC_CHNA_SARADC0 = 0,
N    /*! Fadc analog pathway A group of SARADC1.
N     */
N    LL_FADC_CHNA_SARADC1,
N    /*! Fadc analog pathway A group of SARADC2. 
N     */
N    LL_FADC_CHNA_SARADC2,
N    /*! Fadc analog pathway A group of SARADC3. 
N     */
N    LL_FADC_CHNA_SARADC3,
N    /*! Fadc analog pathway A group of SARADC4. 
N     */
N    LL_FADC_CHNA_SARADC4,
N    /*! Fadc analog pathway A group of SARADC5. 
N     */
N    LL_FADC_CHNA_SARADC5,
N    /*! Fadc analog pathway A group of SARADC6. 
N     */
N    LL_FADC_CHNA_SARADC6,        
N    /*! Fadc analog pathway A group of pathway reserved. 
N     */
N    LL_FADC_CHNA_RESERVED,        
N    /*! Fadc analog pathway B group of SARADC13. 
N     */
N    LL_FADC_CHNB_SARADC13,
N    /*! Fadc analog pathway B group of SARADC12. 
N     */
N    LL_FADC_CHNB_SARADC12,
N    /*! Fadc analog pathway B group of SARADC11. 
N     */
N    LL_FADC_CHNB_SARADC11,
N    /*! Fadc analog pathway B group of SARADC10. 
N     */
N    LL_FADC_CHNB_SARADC10,
N    /*! Fadc analog pathway B group of SARADC9. 
N     */
N    LL_FADC_CHNB_SARADC9,
N    /*! Fadc analog pathway B group of SARADC8. 
N     */
N    LL_FADC_CHNB_SARADC8,
N    /*! Fadc analog pathway B group of SARADC7. 
N     */
N    LL_FADC_CHNB_SARADC7,
N    /*! Fadc analog pathway B group of pathway reserved. 
N     */
N    LL_FADC_CHNB_RESERVED,
N} TYPE_ENUM_LL_FADC_ADC_SEL;
N
N
N/**
N  * @brief Enumeration constant for The Fadc trigger source selection.
N  */
Ntypedef enum {
N    /*! The trigger source selection of fadc: no.
N     */
N    LL_FADC_TRI_NO = 0,
N    /*! The trigger source selection of fadc: svpwm.
N     */
N    LL_FADC_TRI_SVPWM,
N    /*! The trigger source selection of fadc: spwm and spwm0_a. 
N     */
N    LL_FADC_TRI_EPWM0_A_SPWM,
N    /*! The trigger source selection of fadc: spwm1_a. 
N     */
N    LL_FADC_TRI_EPWM1_A,
N    /*! The trigger source selection of fadc: spwm2_a. 
N     */
N    LL_FADC_TRI_EPWM2_A,
N    /*! The trigger source selection of fadc: spwm3_a. 
N     */
N    LL_FADC_TRI_EPWM3_A,
N    /*! The trigger source selection of fadc: spwm4_a. 
N     */
N    LL_FADC_TRI_EPWM4_A,
N    /*! The trigger source selection of fadc: spwm5_a. 
N     */
N    LL_FADC_TRI_EPWM5_A,
N    /*! The trigger source selection of fadc: spwm6_a. 
N     */
N    LL_FADC_TRI_EPWM6_A,
N    /*! The trigger source selection of fadc: spwm0_b. 
N     */
N    LL_FADC_TRI_EPWM0_B,
N    /*! The trigger source selection of fadc: spwm1_b. 
N     */
N    LL_FADC_TRI_EPWM1_B,
N    /*! The trigger source selection of fadc: spwm2_b. 
N     */
N    LL_FADC_TRI_EPWM2_B,
N    /*! The trigger source selection of fadc: spwm3_b. 
N     */
N    LL_FADC_TRI_EPWM3_B,
N    /*! The trigger source selection of fadc: spwm4_b. 
N     */
N    LL_FADC_TRI_EPWM4_B,
N    /*! The trigger source selection of fadc: spwm5_b. 
N     */
N    LL_FADC_TRI_EPWM5_B,
N    /*! The trigger source selection of fadc: spwm6_b. 
N     */
N    LL_FADC_TRI_EPWM6_B,
N} TYPE_ENUM_LL_FADC_TRI_SEL;
N
N/**
N  * @}
N  */
N
N/** @defgroup FADC_LL_Exported_Struct FADC LL Exported Struct
N  * @ingroup  FADC_LL_Driver
N  * @brief    FADC LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the FADC registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_fadc_init. Function, you can configure the FADC module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief FADC low layer configuration structure
N  */
Ntypedef struct __ll_fadc_irq_cfg {
N    /*! Chn is the one that is selected for calculation, ranging from 0 to 16. 
N     */
N    u8                           chn;
N    /*! Enable an interrupt every time the sample is completed.
N     */
N    bool                         sample_intr_en;
N    /*! Enables an interrupt when the DMA buffer reaches half.
N     */
N    bool                         dma_half_intr_en;
N    /*! Enables an interrupt when the DMA buffer is full.
N     */
N    bool                         dma_full_intr_en;
N} TYPE_FADC_IRQ_CFG;
N
N/**
N  * @brief FADC low layer configuration structure
N  */
Ntypedef struct __ll_fadc_cfg {
N    /*! Chn is the one that is selected for calculation, ranging from 0 to 16. 
N     */
N    u8                           chn;
N    /*! FADC DMA function enable bit.
N     */
N    bool                         dma_en;
N    /*! FADC DMA length setting.
N     */
N    u16                          dma_len;
N    /*! The starting address of the DMA input buffer, the address is 8Byte aligned. 
N     *  @note FADC's dma_addr can only be located in SRAM0/SRAM1/SRAM2/SRAM3/SRAM10.  
N     *        Statement example:
N     *        static s16 fadc_buf[2048] __attribute__((aligned(8),section("SRAM0")));
N     */
N    u32                          dma_addr;
N    /*! The ADC data dc_offset is eliminated and the value is subtracted from 
N     *  the input data as output data. 
N     */
N    u16                          dc_offset;
N    /*! For sample selection of FADC, please refer to enumeration TYPE_ENUM_LL_FADC_DOWNSMP. 
N     */
N    TYPE_ENUM_LL_FADC_DOWNSAMPLE downsample_sel;
N    /*! FADC data average enable bit.
N     */
N    bool                         average_en;
N    /*! Average selection of FADC data, please refer to enumeration TYPE_ENUM_LL_FADC_AVERAGE. 
N     */
N    TYPE_ENUM_LL_FADC_AVERAGE    average_sel;
N    /*! FADC data quantization enable.
N     */
N    bool                         quantify_en;
N    /*! Set the FADC data quantization coefficient, [1,16,15] stand for [0,1]. 
N     */
N    u16                          quantify_coef;
N    /*! FADC data quantization bit width selection, please refer to enumeration TYPE_ENUM_LL_FADC_DECI_W. 
N     */
N    TYPE_ENUM_LL_FADC_DECI_W     decimal_width;
N    
N    /*! Fadc soc selects the external trigger source. For specific options, please refer to 
N     *  the macro TYPE_ENUM_LL_FADC_TRI_SEL.
N     *  @note The corresponding relationship is shown in the following table:
N     *        
N     *         trigger_sel                 trigger module   
N     *        
N     *         LL_FADC_TRI_NO                   NO          
N     *        
N     *         LL_FADC_TRI_SVPWM               SVPWM        
N     *        
N     *         LL_FADC_TRI_EPWM0_A_SPWM   SPWM and EPWM0_a  
N     *        
N     *         LL_FADC_TRI_EPWM1_A            EPWM1_a       
N     *        
N     *         LL_FADC_TRI_EPWM2_A            EPWM2_a       
N     *        
N     *         LL_FADC_TRI_EPWM3_A            EPWM3_a       
N     *        
N     *         LL_FADC_TRI_EPWM4_A            EPWM4_a       
N     *        
N     *         LL_FADC_TRI_EPWM5_A            EPWM5_a       
N     *        
N     *         LL_FADC_TRI_EPWM6_A            EPWM6_a       
N     *        
N     *         LL_FADC_TRI_EPWM0_B            EPWM0_b       
N     *        
N     *         LL_FADC_TRI_EPWM1_B            EPWM1_b       
N     *        
N     *         LL_FADC_TRI_EPWM2_B            EPWM2_b       
N     *        
N     *         LL_FADC_TRI_EPWM3_B            EPWM3_b       
N     *        
N     *         LL_FADC_TRI_EPWM4_B            EPWM4_b       
N     *        
N     *         LL_FADC_TRI_EPWM5_B            EPWM5_b       
N     *        
N     *         LL_FADC_TRI_EPWM6_B            EPWM6_b       
N     *        
N     */
N    TYPE_ENUM_LL_FADC_TRI_SEL    trigger_sel;
N    /*! Select the analog path for fadc. There are a total of 14 analog channels, divided 
N     *  into two A and B, each with 7 channels.
N     *  @note The mapping relationship between the variable adc_chn_sel configuration item 
N     *        and the actual chip's external pin map is as follows:
N     *        
N     *          adc_chn_sel              The external pin of the chip 
N     *        
N     *          LL_FADC_CHNA_SARADC0             PIN_SARADC0          
N     *        
N     *          LL_FADC_CHNA_SARADC1             PIN_SARADC1          
N     *        
N     *          LL_FADC_CHNA_SARADC2             PIN_SARADC2          
N     *        
N     *          LL_FADC_CHNA_SARADC3             PIN_SARADC3          
N     *        
N     *          LL_FADC_CHNA_SARADC4             PIN_SARADC4          
N     *        
N     *          LL_FADC_CHNA_SARADC5             PIN_SARADC5          
N     *        
N     *          LL_FADC_CHNA_SARADC6             PIN_SARADC6          
N     *        
N     *          LL_FADC_CHNA_RESERVED                 NO              
N     *        
N     *          LL_FADC_CHNB_SARADC13            PIN_SARADC13         
N     *        
N     *          LL_FADC_CHNB_SARADC12            PIN_SARADC12         
N     *        
N     *          LL_FADC_CHNB_SARADC11            PIN_SARADC11         
N     *        
N     *          LL_FADC_CHNB_SARADC10            PIN_SARADC10         
N     *        
N     *          LL_FADC_CHNB_SARADC9             PIN_SARADC9          
N     *        
N     *          LL_FADC_CHNB_SARADC8             PIN_SARADC8          
N     *        
N     *          LL_FADC_CHNB_SARADC7             PIN_SARADC7          
N     *        
N     *          LL_FADC_CHNB_RESERVED                 NO              
N     *        
N     */
N    TYPE_ENUM_LL_FADC_ADC_SEL    adc_chn_sel;
N    /*! Enable the timer inside the fadc. 
N     */
N    bool                         timer_en;
N    /*! Configure the counting period of the timer inside the fadc. The timer is used to 
N     *  trigger FADC, and the sampling rate is calculated as fadc_clk/timer_period.
N     */
N    u32                          timer_period;
N} TYPE_LL_FADC_CFG;
N
N/**
N  * @brief FADC low layer Initialization structure
N  */
Ntypedef struct __ll_fadc_init {
N    /*! Configure the division ratio of the FADC operating clock, Fadc and epwm share an adpll, 
N     *  the default configuration is 180M.
N     */
N    u8  fadc_adpll_div_val;
N    /*! FADC conversion high priority configuration.
N     *  @note soc_hpri_val indicates that the priority of the configuration SOC0~SOC(soc_hpri_val-1) 
N     *        is higher than SOCn~SOC15. If the configuration is 0, the default mode is used to 
N     *        perform the round-robin conversion.
N     */
N    u8  soc_hpri_val;
N} TYPE_LL_FADC_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup FADC_LL_Interrupt FADC LL Interrupt Handle function
N  * @brief   FADC LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the FADC  
N    Interrupt Handle function.
N
N    how to use?
N
N    The FADC interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the FADC in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup FADC_LL_Inti_Cfg FADC LL Initialization And Configuration
N  * @brief    FADC LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the FADC data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  Low layer FADC module initialization
N  * @param  p_fadc: The structure pointer of the FADC group (FADC0, FADC1, FADC2) is selected.
N  * @param  p_init: Module configuration structure pointer(TYPE_LL_FADC_INIT)
N  * @retval None
N  */
Nvoid ll_fadc_init(FADC_TypeDef *p_fadc, TYPE_LL_FADC_INIT *p_init);
N
N/**
N  * @brief  Low layer FADC module detele initialization
N  * @param  p_fadc: The structure pointer of the FADC group (FADC0, FADC1, FADC2) is selected.
N  * @retval None
N  */
Nvoid ll_fadc_deinit(FADC_TypeDef *p_fadc);
N
N/**
N  * @brief  Low layer FADC module irq configuration
N  * @param  p_fadc: The structure pointer of the FADC group (FADC0, FADC1, FADC2) is selected.
N  * @param  p_cfg : Module irq configuration structure pointer(TYPE_FADC_IRQ_CFG)
N  * @retval None
N  */
Nvoid ll_fadc_irq_config(FADC_TypeDef *p_fadc, TYPE_FADC_IRQ_CFG *p_cfg);
N
N/**
N  * @brief  Low layer FADC module configuration
N  * @param  p_fadc: The structure pointer of the FADC group (FADC0, FADC1, FADC2) is selected.
N  * @param  p_cfg : Module configuration structure pointer(TYPE_LL_FADC_DMA_CFG)
N  * @retval None
N  */
Nvoid ll_fadc_config(FADC_TypeDef *p_fadc, TYPE_LL_FADC_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup FADC_LL_Data_Transfers FADC LL Data transfers functions
N  * @brief    FADC LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the FADC data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  FADC module start function
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
Nvoid ll_fadc_start(FADC_TypeDef *p_fadc, u16 chn_bits);
N
N/**
N  * @brief  FADC module CPU force kick one time function
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
Nvoid ll_fadc_kick_one(FADC_TypeDef *p_fadc, u16 chn_bits);
N
N/**
N  * @brief  FADC module stop function
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
Nvoid ll_fadc_stop(FADC_TypeDef *p_fadc, u16 chn_bits);
N
N/**
N  * @brief  Set the value of dc offset for fadc.
N  * @param  p_fadc       : Select the initialized FADC group pointer
N  * @param  chn          : Set the number of chn.
N  * @param  dc_offset_val: The value of dc offset.
N  * @retval None
N  */
Nvoid ll_fadc_set_dc_offset(FADC_TypeDef *p_fadc, u16 chn, u16 dc_offset_val);
N
N/**
N  * @brief  Set the value of quantify for fadc.
N  * @param  p_fadc          : Select the initialized FADC group pointer
N  * @param  chn             : Set the number of chn.
N  * @param  quantify_val    : The value of quantify.
N  * @param  decimal_width   : specify Quantify output data remain how many decimal width rang:[0,6]
N  * @retval None
N  */
Nvoid ll_fadc_set_quantify(FADC_TypeDef *p_fadc, u16 chn, u16 quantify_val, u8 decimal_width);
N
N/**
N  * @brief  Set the value of quantify for fadc.
N  * @param  p_fadc      : Select the initialized FADC group pointer
N  * @param  chn         : Set the number of chn.
N  * @param  average_val : The value of quantify.
N  * @retval None
N  */
Nvoid ll_fadc_set_average(FADC_TypeDef             *p_fadc, 
N                         u16                       chn, 
N                         TYPE_ENUM_LL_FADC_AVERAGE average_val);
N
N/**
N  * @brief  Set the value of downsample for fadc.
N  * @param  p_fadc        : Select the initialized FADC group pointer
N  * @param  chn           : Set the number of chn.
N  * @param  downsample_val: The value of downsample.
N  * @retval None
N  */
Nvoid ll_fadc_set_downsample(FADC_TypeDef                *p_fadc, 
N                            u16                          chn, 
N                            TYPE_ENUM_LL_FADC_DOWNSAMPLE downsample_val);
N
N/**
N  * @brief  Set the value of timer peroid for fadc.
N  * @param  p_fadc          : Select the initialized FADC group pointer
N  * @param  chn             : Set the number of chn.
N  * @param  timer_period_val: The value of timer peroid.
N  * @retval None
N  */
Nvoid ll_fadc_set_timer_peroid(FADC_TypeDef *p_fadc, u16 chn, u32 timer_period_val);
N
N/**
N  * @brief  Enable the timer module of the fadc.
N  * @param  p_fadc: Select the initialized FADC group pointer
N  * @param  chn   : Set the number of chn.
N  * @retval None
N  */
Nvoid ll_fadc_timer_enable(FADC_TypeDef *p_fadc, u16 chn);
N
N/**
N  * @brief  Disable the timer module of the fadc.
N  * @param  p_fadc: Select the initialized FADC group pointer
N  * @param  chn   : Set the number of chn.
N  * @retval None
N  */
Nvoid ll_fadc_timer_disable(FADC_TypeDef *p_fadc, u16 chn);
N
N/**
N  * @brief  Low layer synchronous sampling enable function of fadc.
N  * @param  p_fadc: The structure pointer of the FADC group (FADC0, FADC1, FADC2) is selected.
N  * @param  chn   : Set the number of synchronous sampling channel.
N  * @retval None
N  */
Nvoid ll_fadc_sync_sample_enable(FADC_TypeDef *p_fadc, u8 chn);
N
N/**
N  * @brief  Low layer synchronous sampling disable function of fadc.
N  * @param  p_fadc: The structure pointer of the FADC group (FADC0, FADC1, FADC2) is selected.
N  * @param  chn   : Set the number of synchronous sampling channel.
N  * @retval None
N  */
Nvoid ll_fadc_sync_sample_disable(FADC_TypeDef *p_fadc, u8 chn);
N
N/**
N  * @brief  FADC module write SFR register function
N  * @param  addr: The address of the SFR register.
N  * @param  data: The value of the SFR register.
N  * @retval None
N  */
Nvoid ll_fadc_wr_sfr(u8 addr, u32 data);
N
N/**
N  * @brief  FADC module read SFR register function
N  * @param  addr: The address of the SFR register.
N  * @retval The value of the SFR register.
N  */
Nu32 ll_fadc_rd_sfr(u8 addr);
N
N/**
N  * @brief  The FADC check sample interrupt_enable.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N#define LL_FADC_CHECK_SAMPLE_INTERRUPT_ENABLE(p_fadc, chn_bits)   ((p_fadc)->FADCINT0 & LL_FADC_SMP_DONE_INT_EN(chn_bits))
N
N/**
N  * @brief  The FADC check dma buffer half interrupt_enable.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N#define LL_FADC_CHECK_DMA_HALF_INTERRUPT_ENABLE(p_fadc, chn_bits) ((p_fadc)->FADCINT1 & LL_FADC_DMA_HALF_INT_EN(chn_bits))
N
N/**
N  * @brief  The FADC check dma buffer full interrupt_enable.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N#define LL_FADC_CHECK_DMA_FULL_INTERRUPT_ENABLE(p_fadc, chn_bits) ((p_fadc)->FADCINT1 & LL_FADC_DMA_FULL_INT_EN(chn_bits))
N
N/**
N  * @brief  The FADC gets a flag for the completion of the sample.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N#define LL_FADC_GET_SAMPLE_PENDING(p_fadc, chn_bits)              ((p_fadc)->FADCSMPFLAG & chn_bits)
N
N/**
N  * @brief  The FADC gets the flag that the sample buf is half done.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N#define LL_FADC_GET_DMA_HALF_PENDING(p_fadc, chn_bits)            ((p_fadc)->FADCDMAFLAG0 & chn_bits)
N
N/**
N  * @brief  FADC gets the flag that the sample buffer is full.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N#define LL_FADC_GET_DMA_FULL_PENDING(p_fadc, chn_bits)            ((p_fadc)->FADCDMAFLAG1 & chn_bits)
N
N/**
N  * @brief  FADC gets the sampling overflow flag.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N#define LL_FADC_GET_SOC_OVERFLOW(p_fadc, chn_bits)                (ll_fadc_rd_sfr(FADCSFRSOCOVFL) & chn_bits)
N
N/**
N  * @brief  FADC clears the flag for one sample completion.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_clear_sample_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_clear_sample_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    p_fadc->FADCSMPFLAG |= LL_FADC_CLR_SMP_DONE_FLAG(chn_bits);
X    p_fadc->FADCSMPFLAG |= (((chn_bits)&0xFFFF) << 16);
N}
N
N/**
N  * @brief  FADC clears the flag that the sample buf is half done.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_clear_dma_half_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_clear_dma_half_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    p_fadc->FADCDMAFLAG0 |= LL_FADC_CLR_DMA_HALF_FLAG(chn_bits);
X    p_fadc->FADCDMAFLAG0 |= (((chn_bits)&0xFFFF) << 16);
N}
N
N/**
N  * @brief  FADC clears the flag that the sample buffer is full.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_clear_dma_full_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_clear_dma_full_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    p_fadc->FADCDMAFLAG1 |= LL_FADC_CLR_DMA_FULL_FLAG(chn_bits);
X    p_fadc->FADCDMAFLAG1 |= (((chn_bits)&0xFFFF) << 16);
N}
N
N/**
N  * @brief  Fadc enables a single interrupt to be completed.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_sample_interrupt_enable(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_sample_interrupt_enable(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    p_fadc->FADCINT0 |= LL_FADC_SMP_DONE_INT_EN(chn_bits);
X    p_fadc->FADCINT0 |= (((chn_bits)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Fadc disables a single interrupt to be completed.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_sample_interrupt_disable(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_sample_interrupt_disable(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    p_fadc->FADCINT0 &= ~(LL_FADC_SMP_DONE_INT_EN(chn_bits));
X    p_fadc->FADCINT0 &= ~((((chn_bits)&0xFFFF) << 0));
N}
N
N/**
N  * @brief  Fadc enables half of the buffer to be interrupted.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_dma_half_interrupt_enable(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_dma_half_interrupt_enable(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    p_fadc->FADCINT1 |= LL_FADC_DMA_HALF_INT_EN(chn_bits);
X    p_fadc->FADCINT1 |= (((chn_bits)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  Fadc disables half of the buffer to be interrupted.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_dma_half_interrupt_disable(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_dma_half_interrupt_disable(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    p_fadc->FADCINT1 &= ~(LL_FADC_DMA_HALF_INT_EN(chn_bits));
X    p_fadc->FADCINT1 &= ~((((chn_bits)&0xFFFF) << 0));
N}
N
N/**
N  * @brief  The fadc enables the buffer to be full.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_dma_full_interrupt_enable(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_dma_full_interrupt_enable(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    p_fadc->FADCINT1 |= LL_FADC_DMA_FULL_INT_EN(chn_bits);
X    p_fadc->FADCINT1 |= (((chn_bits)&0xFFFF) << 16);
N}
N
N/**
N  * @brief  The fadc disables the buffer to be full.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_dma_full_interrupt_disable(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_dma_full_interrupt_disable(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    p_fadc->FADCINT1 &= ~(LL_FADC_DMA_FULL_INT_EN(chn_bits));
X    p_fadc->FADCINT1 &= ~((((chn_bits)&0xFFFF) << 16));
N}
N
N/**
N  * @brief  FADC clears the sample overflow flag.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_clear_soc_overflow(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_clear_soc_overflow(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    ll_fadc_wr_sfr(FADCSFRSOCOVFL, (ll_fadc_rd_sfr(FADCSFRSOCOVFL) | 
X    ll_fadc_wr_sfr(0x0d, (ll_fadc_rd_sfr(0x0d) | 
N                   LL_FADC_CLR_SOC_OVF(chn_bits)));
X                   (((chn_bits)&0xFFFF) << 16)));
N}
N
N/**
N  * @brief  FADC waits for one sample to complete.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_wait_sample_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_wait_sample_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    while(chn_bits != (p_fadc->FADCSMPFLAG & chn_bits));
N    p_fadc->FADCSMPFLAG |= LL_FADC_CLR_SMP_DONE_FLAG(chn_bits);
X    p_fadc->FADCSMPFLAG |= (((chn_bits)&0xFFFF) << 16);
N}
N
N/**
N  * @brief  The FADC waits for half of the sample buffer.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_wait_dma_half_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_wait_dma_half_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    while(chn_bits != (p_fadc->FADCDMAFLAG0 & chn_bits));
N    p_fadc->FADCDMAFLAG0 |= LL_FADC_CLR_DMA_HALF_FLAG(chn_bits);
X    p_fadc->FADCDMAFLAG0 |= (((chn_bits)&0xFFFF) << 16);
N}
N
N/**
N  * @brief  FADC waits for the sample buffer to be full.
N  * @param  p_fadc  : Select the initialized FADC group pointer
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT () 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_fadc_wait_dma_full_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
Xstatic __inline void ll_fadc_wait_dma_full_pending(FADC_TypeDef *p_fadc, u16 chn_bits) {
N    while(chn_bits != (p_fadc->FADCDMAFLAG1 & chn_bits));
N    p_fadc->FADCDMAFLAG1 |= LL_FADC_CLR_DMA_FULL_FLAG(chn_bits);
X    p_fadc->FADCDMAFLAG1 |= (((chn_bits)&0xFFFF) << 16);
N}
N
N/**
N  * @brief  The FADC takes the data of one sample.
N  * @param  p_fadc: Select the initialized FADC group pointer
N  * @param  chn   : The number of channels to get the fadc data.
N  * @retval None
N  */
N__STATIC_INLINE s16 ll_fadc_get_result(FADC_TypeDef *p_fadc, u8 chn) {
Xstatic __inline s16 ll_fadc_get_result(FADC_TypeDef *p_fadc, u8 chn) {
N    TX_ASSERT(chn <= 15);
X    ((chn <= 15) ? (void)0U : tx_assert_false((uint8_t *)"..\\..\\..\\..\\Libraries\\Driver\\include\\LL\\tx_phe_ll_fadc.h", 1442));
N    
N    return p_fadc->FADCRES[chn];
N}
N
N/**
N  * @brief  The FADC gets the acquired data value and the float type returns.
N  * @param  p_fadc: Select the initialized FADC group pointer
N  * @param  chn   : The number of channels to get the fadc data.
N  * @retval None
N  */
N//__STATIC_INLINE float ll_fadc_get_result_float(FADC_TypeDef *p_fadc, u8 chn) {
N//	float fadc_result_f; 
N//	TX_ASSERT(chn <= 15);
N//	
N//	fadc_result_f = (float)(p_fadc->FADCRES[chn])*LL_FADC_VREF_VAL/32768.0 + LL_FADC_VCM_VAL;
N//	
N//	return fadc_result_f;
N//}
N__STATIC_INLINE float ll_fadc_get_result_float(FADC_TypeDef *p_fadc, u8 chn) {
Xstatic __inline float ll_fadc_get_result_float(FADC_TypeDef *p_fadc, u8 chn) {
N    float fadc_result_f; 
N    TX_ASSERT(chn <= 15);
X    ((chn <= 15) ? (void)0U : tx_assert_false((uint8_t *)"..\\..\\..\\..\\Libraries\\Driver\\include\\LL\\tx_phe_ll_fadc.h", 1463));
N    
N    fadc_result_f = (float)(p_fadc->FADCRES[chn])*3.3/32768.0 + 3;
N    
N    return fadc_result_f;
N}
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_FADC_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 55 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_qei.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_qei.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_qei.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the QEI LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_QEI_H
N#define __TX_PHE_LL_QEI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N#include "arm_math.h"
L 1 "..\..\..\..\Libraries\CMSIS\DSP\Include\arm_math.h" 1
N/* ----------------------------------------------------------------------
N * Project:      CMSIS DSP Library
N * Title:        arm_math.h
N * Description:  Public header file for CMSIS DSP Library
N *
N * $Date:        27. January 2017
N * $Revision:    V.1.5.1
N *
N * Target Processor: Cortex-M cores
N * -------------------------------------------------------------------- */
N/*
N * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N/**
N   \mainpage CMSIS DSP Software Library
N   *
N   * Introduction
N   * ------------
N   *
N   * This user manual describes the CMSIS DSP software library,
N   * a suite of common signal processing functions for use on Cortex-M processor based devices.
N   *
N   * The library is divided into a number of functions each covering a specific category:
N   * - Basic math functions
N   * - Fast math functions
N   * - Complex math functions
N   * - Filters
N   * - Matrix functions
N   * - Transforms
N   * - Motor control functions
N   * - Statistical functions
N   * - Support functions
N   * - Interpolation functions
N   *
N   * The library has separate functions for operating on 8-bit integers, 16-bit integers,
N   * 32-bit integer and 32-bit floating-point values.
N   *
N   * Using the Library
N   * ------------
N   *
N   * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> folder.
N   * - arm_cortexM7lfdp_math.lib (Cortex-M7, Little endian, Double Precision Floating Point Unit)
N   * - arm_cortexM7bfdp_math.lib (Cortex-M7, Big endian, Double Precision Floating Point Unit)
N   * - arm_cortexM7lfsp_math.lib (Cortex-M7, Little endian, Single Precision Floating Point Unit)
N   * - arm_cortexM7bfsp_math.lib (Cortex-M7, Big endian and Single Precision Floating Point Unit on)
N   * - arm_cortexM7l_math.lib (Cortex-M7, Little endian)
N   * - arm_cortexM7b_math.lib (Cortex-M7, Big endian)
N   * - arm_cortexM4lf_math.lib (Cortex-M4, Little endian, Floating Point Unit)
N   * - arm_cortexM4bf_math.lib (Cortex-M4, Big endian, Floating Point Unit)
N   * - arm_cortexM4l_math.lib (Cortex-M4, Little endian)
N   * - arm_cortexM4b_math.lib (Cortex-M4, Big endian)
N   * - arm_cortexM3l_math.lib (Cortex-M3, Little endian)
N   * - arm_cortexM3b_math.lib (Cortex-M3, Big endian)
N   * - arm_cortexM0l_math.lib (Cortex-M0 / Cortex-M0+, Little endian)
N   * - arm_cortexM0b_math.lib (Cortex-M0 / Cortex-M0+, Big endian)
N   * - arm_ARMv8MBLl_math.lib (ARMv8M Baseline, Little endian)
N   * - arm_ARMv8MMLl_math.lib (ARMv8M Mainline, Little endian)
N   * - arm_ARMv8MMLlfsp_math.lib (ARMv8M Mainline, Little endian, Single Precision Floating Point Unit)
N   * - arm_ARMv8MMLld_math.lib (ARMv8M Mainline, Little endian, DSP instructions)
N   * - arm_ARMv8MMLldfsp_math.lib (ARMv8M Mainline, Little endian, DSP instructions, Single Precision Floating Point Unit)
N   *
N   * The library functions are declared in the public file <code>arm_math.h</code> which is placed in the <code>Include</code> folder.
N   * Simply include this file and link the appropriate library in the application and begin calling the library functions. The Library supports single
N   * public header file <code> arm_math.h</code> for Cortex-M cores with little endian and big endian. Same header file will be used for floating point unit(FPU) variants.
N   * Define the appropriate pre processor MACRO ARM_MATH_CM7 or ARM_MATH_CM4 or  ARM_MATH_CM3 or
N   * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
N   * For ARMv8M cores define pre processor MACRO ARM_MATH_ARMV8MBL or ARM_MATH_ARMV8MML.
N   * Set Pre processor MACRO __DSP_PRESENT if ARMv8M Mainline core supports DSP instructions.
N   * 
N   *
N   * Examples
N   * --------
N   *
N   * The library ships with a number of examples which demonstrate how to use the library functions.
N   *
N   * Toolchain Support
N   * ------------
N   *
N   * The library has been developed and tested with MDK-ARM version 5.14.0.0
N   * The library is being tested in GCC and IAR toolchains and updates on this activity will be made available shortly.
N   *
N   * Building the Library
N   * ------------
N   *
N   * The library installer contains a project file to re build libraries on MDK-ARM Tool chain in the <code>CMSIS\\DSP_Lib\\Source\\ARM</code> folder.
N   * - arm_cortexM_math.uvprojx
N   *
N   *
N   * The libraries can be built by opening the arm_cortexM_math.uvprojx project in MDK-ARM, selecting a specific target, and defining the optional pre processor MACROs detailed above.
N   *
N   * Pre-processor Macros
N   * ------------
N   *
N   * Each library project have differant pre-processor macros.
N   *
N   * - UNALIGNED_SUPPORT_DISABLE:
N   *
N   * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory access
N   *
N   * - ARM_MATH_BIG_ENDIAN:
N   *
N   * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default library builds for little endian targets.
N   *
N   * - ARM_MATH_MATRIX_CHECK:
N   *
N   * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
N   *
N   * - ARM_MATH_ROUNDING:
N   *
N   * Define macro ARM_MATH_ROUNDING for rounding on support functions
N   *
N   * - ARM_MATH_CMx:
N   *
N   * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for building library on Cortex-M3 target
N   * and ARM_MATH_CM0 for building library on Cortex-M0 target, ARM_MATH_CM0PLUS for building library on Cortex-M0+ target, and
N   * ARM_MATH_CM7 for building the library on cortex-M7.
N   *
N   * - ARM_MATH_ARMV8MxL:
N   *
N   * Define macro ARM_MATH_ARMV8MBL for building the library on ARMv8M Baseline target, ARM_MATH_ARMV8MBL for building library
N   * on ARMv8M Mainline target.
N   *
N   * - __FPU_PRESENT:
N   *
N   * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro for floating point libraries.
N   *
N   * - __DSP_PRESENT:
N   *
N   * Initialize macro __DSP_PRESENT = 1 when ARMv8M Mainline core supports DSP instructions.
N   *
N   * <hr>
N   * CMSIS-DSP in ARM::CMSIS Pack
N   * -----------------------------
N   *
N   * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directories:
N   * |File/Folder                   |Content                                                                 |
N   * |------------------------------|------------------------------------------------------------------------|
N   * |\b CMSIS\\Documentation\\DSP  | This documentation                                                     |
N   * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                               |
N   * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library functions      |
N   * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                                |
N   *
N   * <hr>
N   * Revision History of CMSIS-DSP
N   * ------------
N   * Please refer to \ref ChangeLog_pg.
N   *
N   * Copyright Notice
N   * ------------
N   *
N   * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
N   */
N
N
N/**
N * @defgroup groupMath Basic Math Functions
N */
N
N/**
N * @defgroup groupFastMath Fast Math Functions
N * This set of functions provides a fast approximation to sine, cosine, and square root.
N * As compared to most of the other functions in the CMSIS math library, the fast math functions
N * operate on individual values and not arrays.
N * There are separate functions for Q15, Q31, and floating-point data.
N *
N */
N
N/**
N * @defgroup groupCmplxMath Complex Math Functions
N * This set of functions operates on complex data vectors.
N * The data in the complex arrays is stored in an interleaved fashion
N * (real, imag, real, imag, ...).
N * In the API functions, the number of samples in a complex array refers
N * to the number of complex values; the array contains twice this number of
N * real values.
N */
N
N/**
N * @defgroup groupFilters Filtering Functions
N */
N
N/**
N * @defgroup groupMatrix Matrix Functions
N *
N * This set of functions provides basic matrix math operations.
N * The functions operate on matrix data structures.  For example,
N * the type
N * definition for the floating-point matrix structure is shown
N * below:
N * <pre>
N *     typedef struct
N *     {
N *       uint16_t numRows;     // number of rows of the matrix.
N *       uint16_t numCols;     // number of columns of the matrix.
N *       float32_t *pData;     // points to the data of the matrix.
N *     } arm_matrix_instance_f32;
N * </pre>
N * There are similar definitions for Q15 and Q31 data types.
N *
N * The structure specifies the size of the matrix and then points to
N * an array of data.  The array is of size <code>numRows X numCols</code>
N * and the values are arranged in row order.  That is, the
N * matrix element (i, j) is stored at:
N * <pre>
N *     pData[i*numCols + j]
N * </pre>
N *
N * \par Init Functions
N * There is an associated initialization function for each type of matrix
N * data structure.
N * The initialization function sets the values of the internal structure fields.
N * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
N * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
N *
N * \par
N * Use of the initialization function is optional. However, if initialization function is used
N * then the instance structure cannot be placed into a const data section.
N * To place the instance structure in a const data
N * section, manually initialize the data structure.  For example:
N * <pre>
N * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
N * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
N * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
N * </pre>
N * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
N * specifies the number of columns, and <code>pData</code> points to the
N * data array.
N *
N * \par Size Checking
N * By default all of the matrix functions perform size checking on the input and
N * output matrices.  For example, the matrix addition function verifies that the
N * two input matrices and the output matrix all have the same number of rows and
N * columns.  If the size check fails the functions return:
N * <pre>
N *     ARM_MATH_SIZE_MISMATCH
N * </pre>
N * Otherwise the functions return
N * <pre>
N *     ARM_MATH_SUCCESS
N * </pre>
N * There is some overhead associated with this matrix size checking.
N * The matrix size checking is enabled via the \#define
N * <pre>
N *     ARM_MATH_MATRIX_CHECK
N * </pre>
N * within the library project settings.  By default this macro is defined
N * and size checking is enabled.  By changing the project settings and
N * undefining this macro size checking is eliminated and the functions
N * run a bit faster.  With size checking disabled the functions always
N * return <code>ARM_MATH_SUCCESS</code>.
N */
N
N/**
N * @defgroup groupTransforms Transform Functions
N */
N
N/**
N * @defgroup groupController Controller Functions
N */
N
N/**
N * @defgroup groupStats Statistics Functions
N */
N/**
N * @defgroup groupSupport Support Functions
N */
N
N/**
N * @defgroup groupInterpolation Interpolation Functions
N * These functions perform 1- and 2-dimensional interpolation of data.
N * Linear interpolation is used for 1-dimensional data and
N * bilinear interpolation is used for 2-dimensional data.
N */
N
N/**
N * @defgroup groupExamples Examples
N */
N#ifndef _ARM_MATH_H
N#define _ARM_MATH_H
N
N/* Compiler specific diagnostic adjustment */
N#if   defined ( __CC_ARM )
X#if   1L
N
N#elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
S
S#elif defined ( __GNUC__ )
S#pragma GCC diagnostic push
S#pragma GCC diagnostic ignored "-Wsign-conversion"
S#pragma GCC diagnostic ignored "-Wconversion"
S#pragma GCC diagnostic ignored "-Wunused-parameter"
S
S#elif defined ( __ICCARM__ )
S
S#elif defined ( __TI_ARM__ )
S
S#elif defined ( __CSMC__ )
S
S#elif defined ( __TASKING__ )
S
S#else
S  #error Unknown compiler
N#endif
N
N
N#define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
N
N#if defined(ARM_MATH_CM7)
X#if 0L
S  #include "core_cm7.h"
S  #define ARM_MATH_DSP
S#elif defined (ARM_MATH_CM4)
X#elif 0L
S  #include "core_cm4.h"
S  #define ARM_MATH_DSP
N#elif defined (ARM_MATH_CM3)
X#elif 1L
N  #include "core_cm3.h"
L 1 "..\..\..\..\Libraries\CMSIS\Core\Include\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
S#define __CORE_CM3_H_GENERIC
S
S#include <stdint.h>
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/**
S  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
S  CMSIS violates the following MISRA-C:2004 rules:
S
S   \li Required Rule 8.5, object/function definition in header file.<br>
S     Function definitions in header files are used to allow 'inlining'.
S
S   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
S     Unions are used for effective representation of core registers.
S
S   \li Advisory Rule 19.7, Function-like macro defined.<br>
S     Function-like macros are used to allow more efficient code.
S */
S
S
S/*******************************************************************************
S *                 CMSIS definitions
S ******************************************************************************/
S/**
S  \ingroup Cortex_M3
S  @{
S */
S
S#include "cmsis_version.h"
S 
S/*  CMSIS CM3 definitions */
S#define __CM3_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
S#define __CM3_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
S#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) | \
S                                    __CM3_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) |                                     __CM3_CMSIS_VERSION_SUB           )   
S
S#define __CORTEX_M                (3U)                                   /*!< Cortex-M Core */
S
S/** __FPU_USED indicates whether an FPU is used or not.
S    This core does not support an FPU at all
S*/
S#define __FPU_USED       0U
S
S#if defined ( __CC_ARM )
S  #if defined __TARGET_FPU_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#endif
S
S#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
S
S#ifndef __CORE_CM3_H_DEPENDANT
S#define __CORE_CM3_H_DEPENDANT
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* check device defines and use defaults */
S#if defined __CHECK_DEVICE_DEFINES
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200U
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
S#endif
S
S/* IO definitions (access restrictions to peripheral registers) */
S/**
S    \defgroup CMSIS_glob_defs CMSIS Global Defines
S
S    <strong>IO Type Qualifiers</strong> are used
S    \li to specify the access to peripheral variables.
S    \li for automatic generation of peripheral register debug information.
S*/
S#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
S#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions */
S#endif
S#define     __O     volatile             /*!< Defines 'write only' permissions */
S#define     __IO    volatile             /*!< Defines 'read / write' permissions */
S
S/* following defines should be used for structure members */
S#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
S#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
S#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
S
S/*@} end of group Cortex_M3 */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S  - Core Debug Register
S  - Core MPU Register
S ******************************************************************************/
S/**
S  \defgroup CMSIS_core_register Defines and Type Definitions
S  \brief Type definitions and defines for Cortex-M processor based devices.
S*/
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_CORE  Status and Control Registers
S  \brief      Core Register type definitions.
S  @{
S */
S
S/**
S  \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} APSR_Type;
S
S/* APSR Register Definitions */
S#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
S#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
S
S#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
S#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
S
S#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
S#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
S
S#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
S#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
S
S#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
S#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
S
S
S/**
S  \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} IPSR_Type;
S
S/* IPSR Register Definitions */
S#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
S#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
S    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
S    uint32_t _reserved1:8;               /*!< bit: 16..23  Reserved */
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
S    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} xPSR_Type;
S
S/* xPSR Register Definitions */
S#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
S#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
S
S#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
S#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
S
S#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
S#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
S
S#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
S#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
S
S#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
S#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
S
S#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
S#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
S
S#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
S#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
S
S#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
S#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
S
S#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
S#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
S    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} CONTROL_Type;
S
S/* CONTROL Register Definitions */
S#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
S#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
S
S#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
S#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
S
S/*@} end of group CMSIS_CORE */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
S  \brief      Type definitions for the NVIC Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
S        uint32_t RESERVED0[24U];
S  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
S        uint32_t RSERVED1[24U];
S  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
S        uint32_t RESERVED2[24U];
S  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
S        uint32_t RESERVED3[24U];
S  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
S        uint32_t RESERVED4[56U];
S  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
S        uint32_t RESERVED5[644U];
S  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
S}  NVIC_Type;
S
S/* Software Triggered Interrupt Register Definitions */
S#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
S#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
S
S/*@} end of group CMSIS_NVIC */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCB     System Control Block (SCB)
S  \brief    Type definitions for the System Control Block Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
S  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
S  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
S  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
S  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
S  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
S  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
S  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
S  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
S  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
S  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
S  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
S  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
S  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
S  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
S  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
S  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
S  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
S  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
S        uint32_t RESERVED0[5U];
S  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
S} SCB_Type;
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
S#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
S
S/* SCB Vector Table Offset Register Definitions */
S#if defined (__CM3_REV) && (__CM3_REV < 0x0201U)                   /* core r2p1 */
S#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
S#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
S
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
S#else
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
S#endif
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
S#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
S#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
S#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
S
S#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
S#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
S#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
S
S#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
S#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
S#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
S
S#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
S#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
S
S#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
S#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
S
S#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
S#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
S
S#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
S#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
S
S#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
S#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
S
S#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
S#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
S
S#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
S#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
S
S#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
S#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
S
S#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
S#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
S
S#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
S#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
S
S#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
S#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
S
S#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
S#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
S
S/* SCB Configurable Fault Status Register Definitions */
S#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
S#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
S
S#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
S#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
S
S#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
S#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
S
S/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
S#define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB CFSR (MMFSR): MMARVALID Position */
S#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
S
S#define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB CFSR (MMFSR): MSTKERR Position */
S#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
S
S#define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
S#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
S
S#define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB CFSR (MMFSR): DACCVIOL Position */
S#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
S
S#define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB CFSR (MMFSR): IACCVIOL Position */
S#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
S
S/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
S#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
S#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
S
S#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
S#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
S
S#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
S#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
S
S#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
S#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
S
S#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
S#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
S
S#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
S#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
S
S/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
S#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
S#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
S
S#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
S#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
S
S#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
S#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
S
S#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
S#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
S
S#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
S#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
S
S#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
S#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
S
S/* SCB Hard Fault Status Register Definitions */
S#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
S#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
S
S#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
S#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
S
S#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
S#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
S
S/* SCB Debug Fault Status Register Definitions */
S#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
S#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
S
S#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
S#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
S
S#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
S#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
S
S#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
S#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
S
S#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
S#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
S  \brief    Type definitions for the System Control and ID Register not in the SCB
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control and ID Register not in the SCB.
S */
Stypedef struct
S{
S        uint32_t RESERVED0[1U];
S  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
S#if defined (__CM3_REV) && (__CM3_REV >= 0x200U)
S  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
S#else
S        uint32_t RESERVED1[1U];
S#endif
S} SCnSCB_Type;
S
S/* Interrupt Controller Type Register Definitions */
S#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
S#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
S
S/* Auxiliary Control Register Definitions */
S
S#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
S#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
S
S#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
S#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
S
S#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
S#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
S
S/*@} end of group CMSIS_SCnotSCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
S  \brief    Type definitions for the System Timer Registers.
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
S  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
S  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
S  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
S */
Stypedef struct
S{
S  __OM  union
S  {
S    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
S    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
S    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
S  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
S        uint32_t RESERVED0[864U];
S  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
S        uint32_t RESERVED1[15U];
S  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
S        uint32_t RESERVED2[15U];
S  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
S        uint32_t RESERVED3[29U];
S  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
S  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
S  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
S        uint32_t RESERVED4[43U];
S  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
S  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
S        uint32_t RESERVED5[6U];
S  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
S  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
S  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
S  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
S  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
S  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
S  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
S  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
S  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
S  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
S  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
S  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
S} ITM_Type;
S
S/* ITM Trace Privilege Register Definitions */
S#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
S#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
S
S/* ITM Trace Control Register Definitions */
S#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
S#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
S
S#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
S#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
S
S#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
S#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
S
S#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
S#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
S
S#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
S#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
S
S#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
S#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
S
S#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
S#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
S
S#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
S#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
S
S#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
S#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
S
S/* ITM Integration Write Register Definitions */
S#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
S#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
S
S/* ITM Integration Read Register Definitions */
S#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
S#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
S
S/* ITM Integration Mode Control Register Definitions */
S#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
S#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
S
S/* ITM Lock Status Register Definitions */
S#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
S#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
S
S#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
S#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
S
S#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
S#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
S
S/*@}*/ /* end of group CMSIS_ITM */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
S  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
S  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
S  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
S  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
S  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
S  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
S  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
S  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
S  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
S  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
S  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
S        uint32_t RESERVED0[1U];
S  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
S  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
S  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
S        uint32_t RESERVED1[1U];
S  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
S  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
S  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
S        uint32_t RESERVED2[1U];
S  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
S  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
S  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
S} DWT_Type;
S
S/* DWT Control Register Definitions */
S#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
S#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
S
S#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
S#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
S
S#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
S#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
S
S#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
S#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
S
S#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
S#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
S
S#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
S#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
S
S#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
S#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
S
S#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
S#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
S
S#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
S#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
S
S#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
S#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
S
S#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
S#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
S
S#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
S#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
S
S#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
S#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
S
S#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
S#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
S
S#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
S#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
S
S#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
S#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
S
S#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
S#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
S
S#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
S#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
S
S/* DWT CPI Count Register Definitions */
S#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
S#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
S
S/* DWT Exception Overhead Count Register Definitions */
S#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
S#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
S
S/* DWT Sleep Count Register Definitions */
S#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
S#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
S
S/* DWT LSU Count Register Definitions */
S#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
S#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
S
S/* DWT Folded-instruction Count Register Definitions */
S#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
S#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
S
S/* DWT Comparator Mask Register Definitions */
S#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
S#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
S
S/* DWT Comparator Function Register Definitions */
S#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
S#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
S
S#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
S#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
S
S#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
S#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
S
S#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
S#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
S
S#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
S#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
S
S#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
S#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
S
S#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
S#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
S
S#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
S#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
S
S#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
S#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
S
S/*@}*/ /* end of group CMSIS_DWT */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
S  \brief    Type definitions for the Trace Port Interface (TPI)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Trace Port Interface Register (TPI).
S */
Stypedef struct
S{
S  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
S  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
S        uint32_t RESERVED0[2U];
S  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
S        uint32_t RESERVED1[55U];
S  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
S        uint32_t RESERVED2[131U];
S  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
S  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
S  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
S        uint32_t RESERVED3[759U];
S  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
S  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
S  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
S        uint32_t RESERVED4[1U];
S  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
S  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
S  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
S        uint32_t RESERVED5[39U];
S  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
S  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
S        uint32_t RESERVED7[8U];
S  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
S  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
S} TPI_Type;
S
S/* TPI Asynchronous Clock Prescaler Register Definitions */
S#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
S#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
S
S/* TPI Selected Pin Protocol Register Definitions */
S#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
S#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
S
S/* TPI Formatter and Flush Status Register Definitions */
S#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
S#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
S
S#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
S#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
S
S#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
S#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
S
S#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
S#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
S
S/* TPI Formatter and Flush Control Register Definitions */
S#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
S#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
S
S#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
S#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
S
S/* TPI TRIGGER Register Definitions */
S#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
S#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
S
S/* TPI Integration ETM Data Register Definitions (FIFO0) */
S#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
S#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
S
S#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
S#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
S
S#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
S#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
S
S#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
S#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
S
S#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
S#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
S
S#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
S#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
S
S#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
S#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
S
S/* TPI ITATBCTR2 Register Definitions */
S#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
S#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
S
S/* TPI Integration ITM Data Register Definitions (FIFO1) */
S#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
S#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
S
S#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
S#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
S
S#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
S#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
S
S#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
S#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
S
S#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
S#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
S
S#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
S#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
S
S#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
S#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
S
S/* TPI ITATBCTR0 Register Definitions */
S#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
S#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
S
S/* TPI Integration Mode Control Register Definitions */
S#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
S#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
S
S/* TPI DEVID Register Definitions */
S#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
S#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
S
S#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
S#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
S
S#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
S#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
S
S#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
S#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
S
S#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
S#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
S
S#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
S#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
S
S/* TPI DEVTYPE Register Definitions */
S#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
S#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
S
S#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
S#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
S
S/*@}*/ /* end of group CMSIS_TPI */
S
S
S#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
S  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
S  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
S  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
S#endif
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
S  \brief    Type definitions for the Core Debug Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Core Debug Register (CoreDebug).
S */
Stypedef struct
S{
S  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
S  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
S  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
S  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
S} CoreDebug_Type;
S
S/* Debug Halting Control and Status Register Definitions */
S#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
S#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
S
S#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
S#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
S
S#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
S#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
S
S#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
S#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
S
S#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
S#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
S
S#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
S#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
S
S#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
S#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
S
S#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
S#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
S
S#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
S#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
S
S#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
S#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
S
S#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
S#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
S
S#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
S#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
S
S/* Debug Core Register Selector Register Definitions */
S#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
S#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
S
S#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
S#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
S
S/* Debug Exception and Monitor Control Register Definitions */
S#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
S#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
S
S#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
S#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
S
S#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
S#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
S
S#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
S#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
S
S#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
S#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
S
S#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
S#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
S
S#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
S#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
S
S#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
S#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
S
S#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
S#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
S
S#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
S#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
S
S#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
S#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
S
S#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
S#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
S
S#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
S#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
S
S/*@} end of group CMSIS_CoreDebug */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_bitfield     Core register bit field macros
S  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
S  @{
S */
S
S/**
S  \brief   Mask and shift a bit field value for use in a register bit range.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
S  \return           Masked and shifted value.
S*/
S#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
S
S/**
S  \brief     Mask and shift a register value to extract a bit filed value.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
S  \return           Masked and shifted bit field value.
S*/
S#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
S
S/*@} end of group CMSIS_core_bitfield */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_base     Core Definitions
S  \brief      Definitions for base addresses, unions, and structures.
S  @{
S */
S
S/* Memory mapping of Core Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
S#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
S#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
S#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
S#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
S
S#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
S#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
S#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
S#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
S#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
S#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
S#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
S#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
S
S#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
S#endif
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Debug Functions
S  - Core Register Access Functions
S ******************************************************************************/
S/**
S  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
S  \brief    Functions that manage interrupts and exceptions via the NVIC.
S  @{
S */
S
S#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
S#else
S  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
S  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
S  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
S  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
S  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
S  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
S  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
S  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
S  #define NVIC_GetActive              __NVIC_GetActive
S  #define NVIC_SetPriority            __NVIC_SetPriority
S  #define NVIC_GetPriority            __NVIC_GetPriority
S  #define NVIC_SystemReset            __NVIC_SystemReset
S#endif /* CMSIS_NVIC_VIRTUAL */
S
S#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S   #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S#else
S  #define NVIC_SetVector              __NVIC_SetVector
S  #define NVIC_GetVector              __NVIC_GetVector
S#endif  /* (CMSIS_VECTAB_VIRTUAL) */
S
S#define NVIC_USER_IRQ_OFFSET          16
S
S
S
S/**
S  \brief   Set Priority Grouping
S  \details Sets the priority grouping field using the required unlock sequence.
S           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
S           Only values from 0..7 are used.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S  \param [in]      PriorityGroup  Priority grouping field.
S */
S__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
S{
S  uint32_t reg_value;
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
S
S  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
S  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
S  reg_value  =  (reg_value                                   |
S                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
S                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
S  SCB->AIRCR =  reg_value;
S}
S
S
S/**
S  \brief   Get Priority Grouping
S  \details Reads the priority grouping field from the NVIC Interrupt Controller.
S  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
S */
S__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
S{
S  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
S}
S
S
S/**
S  \brief   Enable Interrupt
S  \details Enables a device specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S  }
S}
S
S
S/**
S  \brief   Get Interrupt Enable status
S  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
S  \param [in]      IRQn  Device specific interrupt number.
S  \return             0  Interrupt is not enabled.
S  \return             1  Interrupt is enabled.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return((uint32_t)(((NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S  }
S  else
S  {
S    return(0U);
S  }
S}
S
S
S/**
S  \brief   Disable Interrupt
S  \details Disables a device specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S    __DSB();
S    __ISB();
S  }
S}
S
S
S/**
S  \brief   Get Pending Interrupt
S  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
S  \param [in]      IRQn  Device specific interrupt number.
S  \return             0  Interrupt status is not pending.
S  \return             1  Interrupt status is pending.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S  }
S  else
S  {
S    return(0U);
S  }
S}
S
S
S/**
S  \brief   Set Pending Interrupt
S  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S  }
S}
S
S
S/**
S  \brief   Clear Pending Interrupt
S  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
S  \param [in]      IRQn  Device specific interrupt number.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S  }
S}
S
S
S/**
S  \brief   Get Active Interrupt
S  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
S  \param [in]      IRQn  Device specific interrupt number.
S  \return             0  Interrupt status is not active.
S  \return             1  Interrupt status is active.
S  \note    IRQn must not be negative.
S */
S__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S  }
S  else
S  {
S    return(0U);
S  }
S}
S
S
S/**
S  \brief   Set Interrupt Priority
S  \details Sets the priority of a device specific interrupt or a processor exception.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S  \param [in]      IRQn  Interrupt number.
S  \param [in]  priority  Priority to set.
S  \note    The priority cannot be set for every processor exception.
S */
S__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if ((int32_t)(IRQn) >= 0)
S  {
S    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
S  }
S  else
S  {
S    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
S  }
S}
S
S
S/**
S  \brief   Get Interrupt Priority
S  \details Reads the priority of a device specific interrupt or a processor exception.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S  \param [in]   IRQn  Interrupt number.
S  \return             Interrupt Priority.
S                      Value is aligned automatically to the implemented priority bits of the microcontroller.
S */
S__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if ((int32_t)(IRQn) >= 0)
S  {
S    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
S  }
S  else
S  {
S    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
S  }
S}
S
S
S/**
S  \brief   Encode Priority
S  \details Encodes the priority for an interrupt with the given priority group,
S           preemptive priority value, and subpriority value.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S  \param [in]     PriorityGroup  Used priority group.
S  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
S  \param [in]       SubPriority  Subpriority value (starting from 0).
S  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
S */
S__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
S  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
S
S  return (
S           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
S           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
S         );
S}
S
S
S/**
S  \brief   Decode Priority
S  \details Decodes an interrupt priority value with a given priority group to
S           preemptive priority value and subpriority value.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
S  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
S  \param [in]     PriorityGroup  Used priority group.
S  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
S  \param [out]     pSubPriority  Subpriority value (starting from 0).
S */
S__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
S  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
S
S  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
S  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
S}
S
S
S/**
S  \brief   Set Interrupt Vector
S  \details Sets an interrupt vector in SRAM based interrupt vector table.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S           VTOR must been relocated to SRAM before.
S  \param [in]   IRQn      Interrupt number
S  \param [in]   vector    Address of interrupt handler function
S */
S__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
S{
S  uint32_t *vectors = (uint32_t *)SCB->VTOR;
S  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
S}
S
S
S/**
S  \brief   Get Interrupt Vector
S  \details Reads an interrupt vector from interrupt vector table.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S  \param [in]   IRQn      Interrupt number.
S  \return                 Address of interrupt handler function
S */
S__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
S{
S  uint32_t *vectors = (uint32_t *)SCB->VTOR;
S  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
S}
S
S
S/**
S  \brief   System Reset
S  \details Initiates a system reset request to reset the MCU.
S */
S__STATIC_INLINE void __NVIC_SystemReset(void)
S{
S  __DSB();                                                          /* Ensure all outstanding memory accesses included
S                                                                       buffered write are completed before reset */
S  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
S                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
S                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
S  __DSB();                                                          /* Ensure completion of memory access */
S
S  for(;;)                                                           /* wait until reset */
S  {
S    __NOP();
S  }
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S/* ##########################  FPU functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_FpuFunctions FPU Functions
S  \brief    Function that provides FPU type.
S  @{
S */
S
S/**
S  \brief   get FPU type
S  \details returns the FPU type
S  \returns
S   - \b  0: No FPU
S   - \b  1: Single precision FPU
S   - \b  2: Double + Single precision FPU
S */
S__STATIC_INLINE uint32_t SCB_GetFPUType(void)
S{
S    return 0U;           /* No FPU */
S}
S
S
S/*@} end of CMSIS_Core_FpuFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
S  \brief    Functions that configure the System.
S  @{
S */
S
S#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
S
S/**
S  \brief   System Tick Configuration
S  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
S           Counter is in free running mode to generate periodic interrupts.
S  \param [in]  ticks  Number of ticks between two interrupts.
S  \return          0  Function succeeded.
S  \return          1  Function failed.
S  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S           must contain a vendor-specific implementation of this function.
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
S  {
S    return (1UL);                                                   /* Reload value impossible */
S  }
S
S  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
S  return (0UL);                                                     /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S/* ##################################### Debug In/Output function ########################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_core_DebugFunctions ITM Functions
S  \brief    Functions that access the ITM debug interface.
S  @{
S */
S
Sextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
S#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
S
S
S/**
S  \brief   ITM Send Character
S  \details Transmits a character via the ITM channel 0, and
S           \li Just returns when no debugger is connected that has booked the output.
S           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
S  \param [in]     ch  Character to transmit.
S  \returns            Character to transmit.
S */
S__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
S{
S  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
S      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
S  {
S    while (ITM->PORT[0U].u32 == 0UL)
S    {
S      __NOP();
S    }
S    ITM->PORT[0U].u8 = (uint8_t)ch;
S  }
S  return (ch);
S}
S
S
S/**
S  \brief   ITM Receive Character
S  \details Inputs a character via the external variable \ref ITM_RxBuffer.
S  \return             Received character.
S  \return         -1  No character pending.
S */
S__STATIC_INLINE int32_t ITM_ReceiveChar (void)
S{
S  int32_t ch = -1;                           /* no character available */
S
S  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
S  {
S    ch = ITM_RxBuffer;
S    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
S  }
S
S  return (ch);
S}
S
S
S/**
S  \brief   ITM Check Character
S  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
S  \return          0  No character available.
S  \return          1  Character available.
S */
S__STATIC_INLINE int32_t ITM_CheckChar (void)
S{
S
S  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
S  {
S    return (0);                              /* no character available */
S  }
S  else
S  {
S    return (1);                              /*    character available */
S  }
S}
S
S/*@} end of CMSIS_core_DebugFunctions */
S
S
S
S
S#ifdef __cplusplus
S}
S#endif
S
S#endif /* __CORE_CM3_H_DEPENDANT */
S
N#endif /* __CMSIS_GENERIC */
L 330 "..\..\..\..\Libraries\CMSIS\DSP\Include\arm_math.h" 2
N#elif defined (ARM_MATH_CM0)
S  #include "core_cm0.h"
S  #define ARM_MATH_CM0_FAMILY
S#elif defined (ARM_MATH_CM0PLUS)
S  #include "core_cm0plus.h"
S  #define ARM_MATH_CM0_FAMILY
S#elif defined (ARM_MATH_ARMV8MBL)
S  #include "core_armv8mbl.h"
S  #define ARM_MATH_CM0_FAMILY
S#elif defined (ARM_MATH_ARMV8MML)
S  #include "core_armv8mml.h"
S  #if (defined (__DSP_PRESENT) && (__DSP_PRESENT == 1))
S    #define ARM_MATH_DSP
S  #endif
S#else
S  #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_CM0PLUS, ARM_MATH_CM0, ARM_MATH_ARMV8MBL, ARM_MATH_ARMV8MML"
N#endif
N
N#undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
N#include "string.h"
N#include "math.h"
L 1 "D:\Tools\KIEIL\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
N#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF static inline
N#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 1L
N/*
N * Functions new in C99.
N */
Nextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Xextern __declspec(__nothrow) double exp2(double  );  
Nextern _ARMABI float exp2f(float /*x*/);
Xextern __declspec(__nothrow) float exp2f(float  );
N_ARMDEFLD1(exp2);
X__declspec(__nothrow) long double exp2l(long double );
Nextern _ARMABI double fdim(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fdim(double  , double  );
Nextern _ARMABI float fdimf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fdimf(float  , float  );
N_ARMDEFLD2(fdim);
X__declspec(__nothrow) long double fdiml(long double , long double );
N#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
N#endif
N#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
N#endif
N#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
N#endif
Nextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Xextern __declspec(__nothrow) double fma(double  , double  , double  );
Nextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
Xextern __declspec(__nothrow) float fmaf(float  , float  , float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
N    { return (long double)fma((double)__x, (double)__y, (double)__z); }
Xinline __declspec(__nothrow) long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
N#endif
Nextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmax(double  , double  );
Nextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fmaxf(float  , float  );
N_ARMDEFLD2(fmax);
X__declspec(__nothrow) long double fmaxl(long double , long double );
Nextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmin(double  , double  );
Nextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fminf(float  , float  );
N_ARMDEFLD2(fmin);
X__declspec(__nothrow) long double fminl(long double , long double );
Nextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Xextern __declspec(__nothrow) double log2(double  );  
Nextern _ARMABI float log2f(float /*x*/);
Xextern __declspec(__nothrow) float log2f(float  );
N_ARMDEFLD1(log2);
X__declspec(__nothrow) long double log2l(long double );
Nextern _ARMABI long lrint(double /*x*/);
Xextern __declspec(__nothrow) long lrint(double  );
Nextern _ARMABI long lrintf(float /*x*/);
Xextern __declspec(__nothrow) long lrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
N    { return lrint((double)__x); }
Xinline __declspec(__nothrow) long lrintl(long double __x)     { return lrint((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llrint(double /*x*/);
Xextern __declspec(__nothrow) long long llrint(double  );
Nextern _ARMABI __LONGLONG llrintf(float /*x*/);
Xextern __declspec(__nothrow) long long llrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
N    { return llrint((double)__x); }
Xinline __declspec(__nothrow) long long llrintl(long double __x)     { return llrint((double)__x); }
N#endif
Nextern _ARMABI long lround(double /*x*/);
Xextern __declspec(__nothrow) long lround(double  );
Nextern _ARMABI long lroundf(float /*x*/);
Xextern __declspec(__nothrow) long lroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
N    { return lround((double)__x); }
Xinline __declspec(__nothrow) long lroundl(long double __x)     { return lround((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llround(double /*x*/);
Xextern __declspec(__nothrow) long long llround(double  );
Nextern _ARMABI __LONGLONG llroundf(float /*x*/);
Xextern __declspec(__nothrow) long long llroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
N    { return llround((double)__x); }
Xinline __declspec(__nothrow) long long llroundl(long double __x)     { return llround((double)__x); }
N#endif
Nextern _ARMABI_PURE double nan(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nan(const char * );
Nextern _ARMABI_PURE float nanf(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nanf(const char * );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
N    { return (long double)nan(__t); }
Xinline __declspec(__nothrow) __attribute__((const)) long double nanl(const char *__t)     { return (long double)nan(__t); }
N#endif
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
N#endif 
Nextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nearbyint(double  );
Nextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nearbyintf(float  );
N_ARMDEFLD1(nearbyint);
X__declspec(__nothrow) long double nearbyintl(long double );
Nextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Nextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
N    { return (long double)remquo((double)__x, (double)__y, __q); }
Xinline long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
N#endif
Nextern _ARMABI_FPEXCEPT double round(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double round(double  );
Nextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float roundf(float  );
N_ARMDEFLD1(round);
X__declspec(__nothrow) long double roundl(long double );
Nextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Xextern __declspec(__nothrow) double tgamma(double  );  
Nextern _ARMABI float tgammaf(float /*x*/);
Xextern __declspec(__nothrow) float tgammaf(float  );
N_ARMDEFLD1(tgamma);
X__declspec(__nothrow) long double tgammal(long double );
Nextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double trunc(double  );
Nextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float truncf(float  );
N_ARMDEFLD1(trunc);
X__declspec(__nothrow) long double truncl(long double );
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 0L && ((!0L || 1L) || 0L)
S  extern "C++" {
S    inline int (fpclassify)(double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(double __x) { return isfinite(__x); }
S    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(double __x) { return isinf(__x); }
S    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(double __x) { return isnan(__x); }
S    inline bool (isnormal)(double __x) { return isnormal(__x); }
S    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
S
S  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 0L && !0L
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    #ifndef __ARMCOMPILER_LIBCXX
S      using ::std::abs;
S    #endif
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S      /* New in C99. */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
S
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      using ::std::fpclassify;
S      using ::std::isfinite;
S      using ::std::isgreater;
S      using ::std::isgreaterequal;
S      using ::std::isinf;
S      using ::std::isless;
S      using ::std::islessequal;
S      using ::std::islessgreater;
S      using ::std::isnan;
S      using ::std::isnormal;
S      using ::std::isunordered;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 351 "..\..\..\..\Libraries\CMSIS\DSP\Include\arm_math.h" 2
N#ifdef   __cplusplus
Sextern "C"
S{
N#endif
N
N
N  /**
N   * @brief Macros required for reciprocal calculation in Normalized LMS
N   */
N
N#define DELTA_Q31          (0x100)
N#define DELTA_Q15          0x5
N#define INDEX_MASK         0x0000003F
N#ifndef PI
N  #define PI               3.14159265358979f
N#endif
N
N  /**
N   * @brief Macros required for SINE and COSINE Fast math approximations
N   */
N
N#define FAST_MATH_TABLE_SIZE  512
N#define FAST_MATH_Q31_SHIFT   (32 - 10)
N#define FAST_MATH_Q15_SHIFT   (16 - 10)
N#define CONTROLLER_Q31_SHIFT  (32 - 9)
N#define TABLE_SPACING_Q31     0x400000
N#define TABLE_SPACING_Q15     0x80
N
N  /**
N   * @brief Macros required for SINE and COSINE Controller functions
N   */
N  /* 1.31(q31) Fixed value of 2/360 */
N  /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
N#define INPUT_SPACING         0xB60B61
N
N  /**
N   * @brief Macro for Unaligned Support
N   */
N#ifndef UNALIGNED_SUPPORT_DISABLE
N    #define ALIGN4
N#else
S  #if defined  (__GNUC__)
S    #define ALIGN4 __attribute__((aligned(4)))
S  #else
S    #define ALIGN4 __align(4)
S  #endif
N#endif   /* #ifndef UNALIGNED_SUPPORT_DISABLE */
N
N  /**
N   * @brief Error status returned by some functions in the library.
N   */
N
N  typedef enum
N  {
N    ARM_MATH_SUCCESS = 0,                /**< No error */
N    ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
N    ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
N    ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation. */
N    ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
N    ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
N    ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
N  } arm_status;
N
N  /**
N   * @brief 8-bit fractional data type in 1.7 format.
N   */
N  typedef int8_t q7_t;
N
N  /**
N   * @brief 16-bit fractional data type in 1.15 format.
N   */
N  typedef int16_t q15_t;
N
N  /**
N   * @brief 32-bit fractional data type in 1.31 format.
N   */
N  typedef int32_t q31_t;
N
N  /**
N   * @brief 64-bit fractional data type in 1.63 format.
N   */
N  typedef int64_t q63_t;
N
N  /**
N   * @brief 32-bit floating-point type definition.
N   */
N  typedef float float32_t;
N
N  /**
N   * @brief 64-bit floating-point type definition.
N   */
N  typedef double float64_t;
N
N  /**
N   * @brief definition to read/write two 16 bit values.
N   */
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __SIMD32_TYPE int32_t __packed
N  #define CMSIS_UNUSED __attribute__((unused))
N  #define CMSIS_INLINE __attribute__((always_inline))
N
N#elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
S  #define __SIMD32_TYPE int32_t
S  #define CMSIS_UNUSED __attribute__((unused))
S  #define CMSIS_INLINE __attribute__((always_inline))
S
S#elif defined ( __GNUC__ )
S  #define __SIMD32_TYPE int32_t
S  #define CMSIS_UNUSED __attribute__((unused))
S  #define CMSIS_INLINE __attribute__((always_inline))
S
S#elif defined ( __ICCARM__ )
S  #define __SIMD32_TYPE int32_t __packed
S  #define CMSIS_UNUSED
S  #define CMSIS_INLINE
S
S#elif defined ( __TI_ARM__ )
S  #define __SIMD32_TYPE int32_t
S  #define CMSIS_UNUSED __attribute__((unused))
S  #define CMSIS_INLINE
S
S#elif defined ( __CSMC__ )
S  #define __SIMD32_TYPE int32_t
S  #define CMSIS_UNUSED
S  #define CMSIS_INLINE
S
S#elif defined ( __TASKING__ )
S  #define __SIMD32_TYPE __unaligned int32_t
S  #define CMSIS_UNUSED
S  #define CMSIS_INLINE
S
S#else
S  #error Unknown compiler
N#endif
N
N#define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
N#define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
N#define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
N#define __SIMD64(addr)        (*(int64_t **) & (addr))
N
N/* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
N#if !defined (ARM_MATH_DSP)
X#if !0L
N  /**
N   * @brief definition to pack two 16 bit values.
N   */
N#define __PKHBT(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0x0000FFFF) | \
N                                    (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
X#define __PKHBT(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0x0000FFFF) |                                     (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
N#define __PKHTB(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0xFFFF0000) | \
N                                    (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
X#define __PKHTB(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0xFFFF0000) |                                     (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
N
N/* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
N#endif /* !defined (ARM_MATH_DSP) */
N
N   /**
N   * @brief definition to pack four 8 bit values.
N   */
N#ifndef ARM_MATH_BIG_ENDIAN
N
N#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
N                                (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
N                                (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
N                                (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
X#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) |                                 (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) |                                 (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) |                                 (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
N#else
S
S#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
S                                (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
S                                (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
S                                (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
X#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) |                                 (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) |                                 (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) |                                 (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
S
N#endif
N
N
N  /**
N   * @brief Clips Q63 to Q31 values.
N   */
N  CMSIS_INLINE __STATIC_INLINE q31_t clip_q63_to_q31(
X  __attribute__((always_inline)) static __inline q31_t clip_q63_to_q31(
N  q63_t x)
N  {
N    return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
N      ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
N  }
N
N  /**
N   * @brief Clips Q63 to Q15 values.
N   */
N  CMSIS_INLINE __STATIC_INLINE q15_t clip_q63_to_q15(
X  __attribute__((always_inline)) static __inline q15_t clip_q63_to_q15(
N  q63_t x)
N  {
N    return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
N      ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
N  }
N
N  /**
N   * @brief Clips Q31 to Q7 values.
N   */
N  CMSIS_INLINE __STATIC_INLINE q7_t clip_q31_to_q7(
X  __attribute__((always_inline)) static __inline q7_t clip_q31_to_q7(
N  q31_t x)
N  {
N    return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
N      ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
N  }
N
N  /**
N   * @brief Clips Q31 to Q15 values.
N   */
N  CMSIS_INLINE __STATIC_INLINE q15_t clip_q31_to_q15(
X  __attribute__((always_inline)) static __inline q15_t clip_q31_to_q15(
N  q31_t x)
N  {
N    return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
N      ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
N  }
N
N  /**
N   * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
N   */
N
N  CMSIS_INLINE __STATIC_INLINE q63_t mult32x64(
X  __attribute__((always_inline)) static __inline q63_t mult32x64(
N  q63_t x,
N  q31_t y)
N  {
N    return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
N            (((q63_t) (x >> 32) * y)));
N  }
N
N/*
N  #if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
N  #define __CLZ __clz
N  #endif
N */
N/* note: function can be removed when all toolchain support __CLZ for Cortex-M0 */
N#if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__))  )
X#if 0L && ((0L)  )
S  CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
S  q31_t data);
S
S  CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
S  q31_t data)
S  {
S    uint32_t count = 0;
S    uint32_t mask = 0x80000000;
S
S    while ((data & mask) == 0)
S    {
S      count += 1u;
S      mask = mask >> 1u;
S    }
S
S    return (count);
S  }
N#endif
N
N  /**
N   * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
N   */
N
N  CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q31(
X  __attribute__((always_inline)) static __inline uint32_t arm_recip_q31(
N  q31_t in,
N  q31_t * dst,
N  q31_t * pRecipTable)
N  {
N    q31_t out;
N    uint32_t tempVal;
N    uint32_t index, i;
N    uint32_t signBits;
N
N    if (in > 0)
N    {
N      signBits = ((uint32_t) (__CLZ( in) - 1));
X      signBits = ((uint32_t) (__clz( in) - 1));
N    }
N    else
N    {
N      signBits = ((uint32_t) (__CLZ(-in) - 1));
X      signBits = ((uint32_t) (__clz(-in) - 1));
N    }
N
N    /* Convert input sample to 1.31 format */
N    in = (in << signBits);
N
N    /* calculation of index for initial approximated Val */
N    index = (uint32_t)(in >> 24);
N    index = (index & INDEX_MASK);
X    index = (index & 0x0000003F);
N
N    /* 1.31 with exp 1 */
N    out = pRecipTable[index];
N
N    /* calculation of reciprocal value */
N    /* running approximation for two iterations */
N    for (i = 0u; i < 2u; i++)
N    {
N      tempVal = (uint32_t) (((q63_t) in * out) >> 31);
N      tempVal = 0x7FFFFFFFu - tempVal;
N      /*      1.31 with exp 1 */
N      /* out = (q31_t) (((q63_t) out * tempVal) >> 30); */
N      out = clip_q63_to_q31(((q63_t) out * tempVal) >> 30);
N    }
N
N    /* write output */
N    *dst = out;
N
N    /* return num of signbits of out = 1/in value */
N    return (signBits + 1u);
N  }
N
N
N  /**
N   * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q15(
X  __attribute__((always_inline)) static __inline uint32_t arm_recip_q15(
N  q15_t in,
N  q15_t * dst,
N  q15_t * pRecipTable)
N  {
N    q15_t out = 0;
N    uint32_t tempVal = 0;
N    uint32_t index = 0, i = 0;
N    uint32_t signBits = 0;
N
N    if (in > 0)
N    {
N      signBits = ((uint32_t)(__CLZ( in) - 17));
X      signBits = ((uint32_t)(__clz( in) - 17));
N    }
N    else
N    {
N      signBits = ((uint32_t)(__CLZ(-in) - 17));
X      signBits = ((uint32_t)(__clz(-in) - 17));
N    }
N
N    /* Convert input sample to 1.15 format */
N    in = (in << signBits);
N
N    /* calculation of index for initial approximated Val */
N    index = (uint32_t)(in >>  8);
N    index = (index & INDEX_MASK);
X    index = (index & 0x0000003F);
N
N    /*      1.15 with exp 1  */
N    out = pRecipTable[index];
N
N    /* calculation of reciprocal value */
N    /* running approximation for two iterations */
N    for (i = 0u; i < 2u; i++)
N    {
N      tempVal = (uint32_t) (((q31_t) in * out) >> 15);
N      tempVal = 0x7FFFu - tempVal;
N      /*      1.15 with exp 1 */
N      out = (q15_t) (((q31_t) out * tempVal) >> 14);
N      /* out = clip_q31_to_q15(((q31_t) out * tempVal) >> 14); */
N    }
N
N    /* write output */
N    *dst = out;
N
N    /* return num of signbits of out = 1/in value */
N    return (signBits + 1);
N  }
N
N
N  /*
N   * @brief C custom defined intrinisic function for only M0 processors
N   */
N#if defined(ARM_MATH_CM0_FAMILY)
X#if 0L
S  CMSIS_INLINE __STATIC_INLINE q31_t __SSAT(
S  q31_t x,
S  uint32_t y)
S  {
S    int32_t posMax, negMin;
S    uint32_t i;
S
S    posMax = 1;
S    for (i = 0; i < (y - 1); i++)
S    {
S      posMax = posMax * 2;
S    }
S
S    if (x > 0)
S    {
S      posMax = (posMax - 1);
S
S      if (x > posMax)
S      {
S        x = posMax;
S      }
S    }
S    else
S    {
S      negMin = -posMax;
S
S      if (x < negMin)
S      {
S        x = negMin;
S      }
S    }
S    return (x);
S  }
N#endif /* end of ARM_MATH_CM0_FAMILY */
N
N
N  /*
N   * @brief C custom defined intrinsic function for M3 and M0 processors
N   */
N/* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
N#if !defined (ARM_MATH_DSP)
X#if !0L
N
N  /*
N   * @brief C custom defined QADD8 for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __QADD8(
X  __attribute__((always_inline)) static __inline uint32_t __QADD8(
N  uint32_t x,
N  uint32_t y)
N  {
N    q31_t r, s, t, u;
N
N    r = __SSAT(((((q31_t)x << 24) >> 24) + (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
X    r = __ssat(((((q31_t)x << 24) >> 24) + (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
N    s = __SSAT(((((q31_t)x << 16) >> 24) + (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
X    s = __ssat(((((q31_t)x << 16) >> 24) + (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
N    t = __SSAT(((((q31_t)x <<  8) >> 24) + (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
X    t = __ssat(((((q31_t)x <<  8) >> 24) + (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
N    u = __SSAT(((((q31_t)x      ) >> 24) + (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
X    u = __ssat(((((q31_t)x      ) >> 24) + (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
N
N    return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
N  }
N
N
N  /*
N   * @brief C custom defined QSUB8 for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB8(
X  __attribute__((always_inline)) static __inline uint32_t __QSUB8(
N  uint32_t x,
N  uint32_t y)
N  {
N    q31_t r, s, t, u;
N
N    r = __SSAT(((((q31_t)x << 24) >> 24) - (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
X    r = __ssat(((((q31_t)x << 24) >> 24) - (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
N    s = __SSAT(((((q31_t)x << 16) >> 24) - (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
X    s = __ssat(((((q31_t)x << 16) >> 24) - (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
N    t = __SSAT(((((q31_t)x <<  8) >> 24) - (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
X    t = __ssat(((((q31_t)x <<  8) >> 24) - (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
N    u = __SSAT(((((q31_t)x      ) >> 24) - (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
X    u = __ssat(((((q31_t)x      ) >> 24) - (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
N
N    return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
N  }
N
N
N  /*
N   * @brief C custom defined QADD16 for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __QADD16(
X  __attribute__((always_inline)) static __inline uint32_t __QADD16(
N  uint32_t x,
N  uint32_t y)
N  {
N/*  q31_t r,     s;  without initialisation 'arm_offset_q15 test' fails  but 'intrinsic' tests pass! for armCC */
N    q31_t r = 0, s = 0;
N
N    r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
X    r = __ssat(((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
N    s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
X    s = __ssat(((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
N
N    return ((uint32_t)((s << 16) | (r      )));
N  }
N
N
N  /*
N   * @brief C custom defined SHADD16 for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SHADD16(
X  __attribute__((always_inline)) static __inline uint32_t __SHADD16(
N  uint32_t x,
N  uint32_t y)
N  {
N    q31_t r, s;
N
N    r = (((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
N    s = (((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
N
N    return ((uint32_t)((s << 16) | (r      )));
N  }
N
N
N  /*
N   * @brief C custom defined QSUB16 for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB16(
X  __attribute__((always_inline)) static __inline uint32_t __QSUB16(
N  uint32_t x,
N  uint32_t y)
N  {
N    q31_t r, s;
N
N    r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
X    r = __ssat(((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
N    s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
X    s = __ssat(((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
N
N    return ((uint32_t)((s << 16) | (r      )));
N  }
N
N
N  /*
N   * @brief C custom defined SHSUB16 for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SHSUB16(
X  __attribute__((always_inline)) static __inline uint32_t __SHSUB16(
N  uint32_t x,
N  uint32_t y)
N  {
N    q31_t r, s;
N
N    r = (((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
N    s = (((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
N
N    return ((uint32_t)((s << 16) | (r      )));
N  }
N
N
N  /*
N   * @brief C custom defined QASX for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __QASX(
X  __attribute__((always_inline)) static __inline uint32_t __QASX(
N  uint32_t x,
N  uint32_t y)
N  {
N    q31_t r, s;
N
N    r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
X    r = __ssat(((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
N    s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
X    s = __ssat(((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
N
N    return ((uint32_t)((s << 16) | (r      )));
N  }
N
N
N  /*
N   * @brief C custom defined SHASX for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SHASX(
X  __attribute__((always_inline)) static __inline uint32_t __SHASX(
N  uint32_t x,
N  uint32_t y)
N  {
N    q31_t r, s;
N
N    r = (((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
N    s = (((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
N
N    return ((uint32_t)((s << 16) | (r      )));
N  }
N
N
N  /*
N   * @brief C custom defined QSAX for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __QSAX(
X  __attribute__((always_inline)) static __inline uint32_t __QSAX(
N  uint32_t x,
N  uint32_t y)
N  {
N    q31_t r, s;
N
N    r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
X    r = __ssat(((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
N    s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
X    s = __ssat(((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
N
N    return ((uint32_t)((s << 16) | (r      )));
N  }
N
N
N  /*
N   * @brief C custom defined SHSAX for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SHSAX(
X  __attribute__((always_inline)) static __inline uint32_t __SHSAX(
N  uint32_t x,
N  uint32_t y)
N  {
N    q31_t r, s;
N
N    r = (((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
N    s = (((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
N
N    return ((uint32_t)((s << 16) | (r      )));
N  }
N
N
N  /*
N   * @brief C custom defined SMUSDX for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSDX(
X  __attribute__((always_inline)) static __inline uint32_t __SMUSDX(
N  uint32_t x,
N  uint32_t y)
N  {
N    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
N                       ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
N  }
N
N  /*
N   * @brief C custom defined SMUADX for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SMUADX(
X  __attribute__((always_inline)) static __inline uint32_t __SMUADX(
N  uint32_t x,
N  uint32_t y)
N  {
N    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
N                       ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
N  }
N
N
N  /*
N   * @brief C custom defined QADD for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE int32_t __QADD(
X  __attribute__((always_inline)) static __inline int32_t __QADD(
N  int32_t x,
N  int32_t y)
N  {
N    return ((int32_t)(clip_q63_to_q31((q63_t)x + (q31_t)y)));
N  }
N
N
N  /*
N   * @brief C custom defined QSUB for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE int32_t __QSUB(
X  __attribute__((always_inline)) static __inline int32_t __QSUB(
N  int32_t x,
N  int32_t y)
N  {
N    return ((int32_t)(clip_q63_to_q31((q63_t)x - (q31_t)y)));
N  }
N
N
N  /*
N   * @brief C custom defined SMLAD for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SMLAD(
X  __attribute__((always_inline)) static __inline uint32_t __SMLAD(
N  uint32_t x,
N  uint32_t y,
N  uint32_t sum)
N  {
N    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
N                       ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
N                       ( ((q31_t)sum    )                                  )   ));
N  }
N
N
N  /*
N   * @brief C custom defined SMLADX for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SMLADX(
X  __attribute__((always_inline)) static __inline uint32_t __SMLADX(
N  uint32_t x,
N  uint32_t y,
N  uint32_t sum)
N  {
N    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
N                       ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
N                       ( ((q31_t)sum    )                                  )   ));
N  }
N
N
N  /*
N   * @brief C custom defined SMLSDX for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SMLSDX(
X  __attribute__((always_inline)) static __inline uint32_t __SMLSDX(
N  uint32_t x,
N  uint32_t y,
N  uint32_t sum)
N  {
N    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
N                       ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
N                       ( ((q31_t)sum    )                                  )   ));
N  }
N
N
N  /*
N   * @brief C custom defined SMLALD for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALD(
X  __attribute__((always_inline)) static __inline uint64_t __SMLALD(
N  uint32_t x,
N  uint32_t y,
N  uint64_t sum)
N  {
N/*  return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) + ((q15_t) x * (q15_t) y)); */
N    return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
N                       ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
N                       ( ((q63_t)sum    )                                  )   ));
N  }
N
N
N  /*
N   * @brief C custom defined SMLALDX for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALDX(
X  __attribute__((always_inline)) static __inline uint64_t __SMLALDX(
N  uint32_t x,
N  uint32_t y,
N  uint64_t sum)
N  {
N/*  return (sum + ((q15_t) (x >> 16) * (q15_t) y)) + ((q15_t) x * (q15_t) (y >> 16)); */
N    return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
N                       ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
N                       ( ((q63_t)sum    )                                  )   ));
N  }
N
N
N  /*
N   * @brief C custom defined SMUAD for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SMUAD(
X  __attribute__((always_inline)) static __inline uint32_t __SMUAD(
N  uint32_t x,
N  uint32_t y)
N  {
N    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
N                       ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
N  }
N
N
N  /*
N   * @brief C custom defined SMUSD for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSD(
X  __attribute__((always_inline)) static __inline uint32_t __SMUSD(
N  uint32_t x,
N  uint32_t y)
N  {
N    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) -
N                       ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
N  }
N
N
N  /*
N   * @brief C custom defined SXTB16 for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE uint32_t __SXTB16(
X  __attribute__((always_inline)) static __inline uint32_t __SXTB16(
N  uint32_t x)
N  {
N    return ((uint32_t)(((((q31_t)x << 24) >> 24) & (q31_t)0x0000FFFF) |
N                       ((((q31_t)x <<  8) >>  8) & (q31_t)0xFFFF0000)  ));
N  }
N
N  /*
N   * @brief C custom defined SMMLA for M3 and M0 processors
N   */
N  CMSIS_INLINE __STATIC_INLINE int32_t __SMMLA(
X  __attribute__((always_inline)) static __inline int32_t __SMMLA(
N  int32_t x,
N  int32_t y,
N  int32_t sum)
N  {
N    return (sum + (int32_t) (((int64_t) x * y) >> 32));
N  }
N
N#if 0
S  /*
S   * @brief C custom defined PKHBT for unavailable DSP extension
S   */
S  CMSIS_INLINE __STATIC_INLINE uint32_t __PKHBT(
S  uint32_t x,
S  uint32_t y,
S  uint32_t leftshift)
S  {
S    return ( ((x             ) & 0x0000FFFFUL) |
S             ((y << leftshift) & 0xFFFF0000UL)  );
S  }
S
S  /*
S   * @brief C custom defined PKHTB for unavailable DSP extension
S   */
S  CMSIS_INLINE __STATIC_INLINE uint32_t __PKHTB(
S  uint32_t x,
S  uint32_t y,
S  uint32_t rightshift)
S  {
S    return ( ((x              ) & 0xFFFF0000UL) |
S             ((y >> rightshift) & 0x0000FFFFUL)  );
S  }
N#endif
N
N/* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
N#endif /* !defined (ARM_MATH_DSP) */
N
N
N  /**
N   * @brief Instance structure for the Q7 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;        /**< number of filter coefficients in the filter. */
N    q7_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N  } arm_fir_instance_q7;
N
N  /**
N   * @brief Instance structure for the Q15 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
N    q15_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N  } arm_fir_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
N    q31_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps. */
N  } arm_fir_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of filter coefficients in the filter. */
N    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
N  } arm_fir_instance_f32;
N
N
N  /**
N   * @brief Processing function for the Q7 FIR filter.
N   * @param[in]  S          points to an instance of the Q7 FIR filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_q7(
N  const arm_fir_instance_q7 * S,
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q7 FIR filter.
N   * @param[in,out] S          points to an instance of the Q7 FIR structure.
N   * @param[in]     numTaps    Number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of samples that are processed.
N   */
N  void arm_fir_init_q7(
N  arm_fir_instance_q7 * S,
N  uint16_t numTaps,
N  q7_t * pCoeffs,
N  q7_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR filter.
N   * @param[in]  S          points to an instance of the Q15 FIR structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_q15(
N  const arm_fir_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q15 FIR filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_fast_q15(
N  const arm_fir_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 FIR filter.
N   * @param[in,out] S          points to an instance of the Q15 FIR filter structure.
N   * @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greater than or equal to 4.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of samples that are processed at a time.
N   * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARGUMENT_ERROR if
N   * <code>numTaps</code> is not a supported value.
N   */
N  arm_status arm_fir_init_q15(
N  arm_fir_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 FIR filter.
N   * @param[in]  S          points to an instance of the Q31 FIR filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_q31(
N  const arm_fir_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q31 FIR structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_fast_q31(
N  const arm_fir_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 FIR filter.
N   * @param[in,out] S          points to an instance of the Q31 FIR structure.
N   * @param[in]     numTaps    Number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of samples that are processed at a time.
N   */
N  void arm_fir_init_q31(
N  arm_fir_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point FIR filter.
N   * @param[in]  S          points to an instance of the floating-point FIR structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_f32(
N  const arm_fir_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point FIR filter.
N   * @param[in,out] S          points to an instance of the floating-point FIR filter structure.
N   * @param[in]     numTaps    Number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of samples that are processed at a time.
N   */
N  void arm_fir_init_f32(
N  arm_fir_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 Biquad cascade filter.
N   */
N  typedef struct
N  {
N    int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q15_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N    int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
N  } arm_biquad_casd_df1_inst_q15;
N
N  /**
N   * @brief Instance structure for the Q31 Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q31_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N    uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
N  } arm_biquad_casd_df1_inst_q31;
N
N  /**
N   * @brief Instance structure for the floating-point Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;       /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_casd_df1_inst_f32;
N
N
N  /**
N   * @brief Processing function for the Q15 Biquad cascade filter.
N   * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df1_q15(
N  const arm_biquad_casd_df1_inst_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format
N   */
N  void arm_biquad_cascade_df1_init_q15(
N  arm_biquad_casd_df1_inst_q15 * S,
N  uint8_t numStages,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  int8_t postShift);
N
N
N  /**
N   * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df1_fast_q15(
N  const arm_biquad_casd_df1_inst_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 Biquad cascade filter
N   * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df1_q31(
N  const arm_biquad_casd_df1_inst_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df1_fast_q31(
N  const arm_biquad_casd_df1_inst_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format
N   */
N  void arm_biquad_cascade_df1_init_q31(
N  arm_biquad_casd_df1_inst_q31 * S,
N  uint8_t numStages,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  int8_t postShift);
N
N
N  /**
N   * @brief Processing function for the floating-point Biquad cascade filter.
N   * @param[in]  S          points to an instance of the floating-point Biquad cascade structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df1_f32(
N  const arm_biquad_casd_df1_inst_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the floating-point Biquad cascade structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   */
N  void arm_biquad_cascade_df1_init_f32(
N  arm_biquad_casd_df1_inst_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief Instance structure for the floating-point matrix structure.
N   */
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    float32_t *pData;     /**< points to the data of the matrix. */
N  } arm_matrix_instance_f32;
N
N
N  /**
N   * @brief Instance structure for the floating-point matrix structure.
N   */
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    float64_t *pData;     /**< points to the data of the matrix. */
N  } arm_matrix_instance_f64;
N
N  /**
N   * @brief Instance structure for the Q15 matrix structure.
N   */
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    q15_t *pData;         /**< points to the data of the matrix. */
N  } arm_matrix_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 matrix structure.
N   */
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    q31_t *pData;         /**< points to the data of the matrix. */
N  } arm_matrix_instance_q31;
N
N
N  /**
N   * @brief Floating-point matrix addition.
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_add_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix addition.
N   * @param[in]   pSrcA  points to the first input matrix structure
N   * @param[in]   pSrcB  points to the second input matrix structure
N   * @param[out]  pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_add_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst);
N
N
N  /**
N   * @brief Q31 matrix addition.
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_add_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point, complex, matrix multiplication.
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_cmplx_mult_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15, complex,  matrix multiplication.
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_cmplx_mult_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pScratch);
N
N
N  /**
N   * @brief Q31, complex, matrix multiplication.
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_cmplx_mult_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix transpose.
N   * @param[in]  pSrc  points to the input matrix
N   * @param[out] pDst  points to the output matrix
N   * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_trans_f32(
N  const arm_matrix_instance_f32 * pSrc,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix transpose.
N   * @param[in]  pSrc  points to the input matrix
N   * @param[out] pDst  points to the output matrix
N   * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_trans_q15(
N  const arm_matrix_instance_q15 * pSrc,
N  arm_matrix_instance_q15 * pDst);
N
N
N  /**
N   * @brief Q31 matrix transpose.
N   * @param[in]  pSrc  points to the input matrix
N   * @param[out] pDst  points to the output matrix
N   * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_trans_q31(
N  const arm_matrix_instance_q31 * pSrc,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix multiplication
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_mult_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix multiplication
N   * @param[in]  pSrcA   points to the first input matrix structure
N   * @param[in]  pSrcB   points to the second input matrix structure
N   * @param[out] pDst    points to output matrix structure
N   * @param[in]  pState  points to the array for storing intermediate results
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_mult_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pState);
N
N
N  /**
N   * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA   points to the first input matrix structure
N   * @param[in]  pSrcB   points to the second input matrix structure
N   * @param[out] pDst    points to output matrix structure
N   * @param[in]  pState  points to the array for storing intermediate results
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_mult_fast_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pState);
N
N
N  /**
N   * @brief Q31 matrix multiplication
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_mult_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_mult_fast_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix subtraction
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_sub_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix subtraction
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_sub_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst);
N
N
N  /**
N   * @brief Q31 matrix subtraction
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_sub_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix scaling.
N   * @param[in]  pSrc   points to the input matrix
N   * @param[in]  scale  scale factor
N   * @param[out] pDst   points to the output matrix
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_scale_f32(
N  const arm_matrix_instance_f32 * pSrc,
N  float32_t scale,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix scaling.
N   * @param[in]  pSrc        points to input matrix
N   * @param[in]  scaleFract  fractional portion of the scale factor
N   * @param[in]  shift       number of bits to shift the result by
N   * @param[out] pDst        points to output matrix
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_scale_q15(
N  const arm_matrix_instance_q15 * pSrc,
N  q15_t scaleFract,
N  int32_t shift,
N  arm_matrix_instance_q15 * pDst);
N
N
N  /**
N   * @brief Q31 matrix scaling.
N   * @param[in]  pSrc        points to input matrix
N   * @param[in]  scaleFract  fractional portion of the scale factor
N   * @param[in]  shift       number of bits to shift the result by
N   * @param[out] pDst        points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_scale_q31(
N  const arm_matrix_instance_q31 * pSrc,
N  q31_t scaleFract,
N  int32_t shift,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief  Q31 matrix initialization.
N   * @param[in,out] S         points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows     number of rows in the matrix.
N   * @param[in]     nColumns  number of columns in the matrix.
N   * @param[in]     pData     points to the matrix data array.
N   */
N  void arm_mat_init_q31(
N  arm_matrix_instance_q31 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  q31_t * pData);
N
N
N  /**
N   * @brief  Q15 matrix initialization.
N   * @param[in,out] S         points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows     number of rows in the matrix.
N   * @param[in]     nColumns  number of columns in the matrix.
N   * @param[in]     pData     points to the matrix data array.
N   */
N  void arm_mat_init_q15(
N  arm_matrix_instance_q15 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  q15_t * pData);
N
N
N  /**
N   * @brief  Floating-point matrix initialization.
N   * @param[in,out] S         points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows     number of rows in the matrix.
N   * @param[in]     nColumns  number of columns in the matrix.
N   * @param[in]     pData     points to the matrix data array.
N   */
N  void arm_mat_init_f32(
N  arm_matrix_instance_f32 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  float32_t * pData);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 PID Control.
N   */
N  typedef struct
N  {
N    q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
N#if !defined (ARM_MATH_DSP)
X#if !0L
N    q15_t A1;
N    q15_t A2;
N#else
S    q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
N#endif
N    q15_t state[3];     /**< The state array of length 3. */
N    q15_t Kp;           /**< The proportional gain. */
N    q15_t Ki;           /**< The integral gain. */
N    q15_t Kd;           /**< The derivative gain. */
N  } arm_pid_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 PID Control.
N   */
N  typedef struct
N  {
N    q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
N    q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
N    q31_t A2;            /**< The derived gain, A2 = Kd . */
N    q31_t state[3];      /**< The state array of length 3. */
N    q31_t Kp;            /**< The proportional gain. */
N    q31_t Ki;            /**< The integral gain. */
N    q31_t Kd;            /**< The derivative gain. */
N  } arm_pid_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point PID Control.
N   */
N  typedef struct
N  {
N    float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
N    float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
N    float32_t A2;          /**< The derived gain, A2 = Kd . */
N    float32_t state[3];    /**< The state array of length 3. */
N    float32_t Kp;          /**< The proportional gain. */
N    float32_t Ki;          /**< The integral gain. */
N    float32_t Kd;          /**< The derivative gain. */
N  } arm_pid_instance_f32;
N
N
N
N  /**
N   * @brief  Initialization function for the floating-point PID Control.
N   * @param[in,out] S               points to an instance of the PID structure.
N   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   */
N  void arm_pid_init_f32(
N  arm_pid_instance_f32 * S,
N  int32_t resetStateFlag);
N
N
N  /**
N   * @brief  Reset function for the floating-point PID Control.
N   * @param[in,out] S  is an instance of the floating-point PID Control structure
N   */
N  void arm_pid_reset_f32(
N  arm_pid_instance_f32 * S);
N
N
N  /**
N   * @brief  Initialization function for the Q31 PID Control.
N   * @param[in,out] S               points to an instance of the Q15 PID structure.
N   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   */
N  void arm_pid_init_q31(
N  arm_pid_instance_q31 * S,
N  int32_t resetStateFlag);
N
N
N  /**
N   * @brief  Reset function for the Q31 PID Control.
N   * @param[in,out] S   points to an instance of the Q31 PID Control structure
N   */
N
N  void arm_pid_reset_q31(
N  arm_pid_instance_q31 * S);
N
N
N  /**
N   * @brief  Initialization function for the Q15 PID Control.
N   * @param[in,out] S               points to an instance of the Q15 PID structure.
N   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   */
N  void arm_pid_init_q15(
N  arm_pid_instance_q15 * S,
N  int32_t resetStateFlag);
N
N
N  /**
N   * @brief  Reset function for the Q15 PID Control.
N   * @param[in,out] S  points to an instance of the q15 PID Control structure
N   */
N  void arm_pid_reset_q15(
N  arm_pid_instance_q15 * S);
N
N
N  /**
N   * @brief Instance structure for the floating-point Linear Interpolate function.
N   */
N  typedef struct
N  {
N    uint32_t nValues;           /**< nValues */
N    float32_t x1;               /**< x1 */
N    float32_t xSpacing;         /**< xSpacing */
N    float32_t *pYData;          /**< pointer to the table of Y values */
N  } arm_linear_interp_instance_f32;
N
N  /**
N   * @brief Instance structure for the floating-point bilinear interpolation function.
N   */
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    float32_t *pData;   /**< points to the data table. */
N  } arm_bilinear_interp_instance_f32;
N
N   /**
N   * @brief Instance structure for the Q31 bilinear interpolation function.
N   */
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q31_t *pData;       /**< points to the data table. */
N  } arm_bilinear_interp_instance_q31;
N
N   /**
N   * @brief Instance structure for the Q15 bilinear interpolation function.
N   */
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q15_t *pData;       /**< points to the data table. */
N  } arm_bilinear_interp_instance_q15;
N
N   /**
N   * @brief Instance structure for the Q15 bilinear interpolation function.
N   */
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q7_t *pData;        /**< points to the data table. */
N  } arm_bilinear_interp_instance_q7;
N
N
N  /**
N   * @brief Q7 vector multiplication.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_mult_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q15 vector multiplication.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_mult_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q31 vector multiplication.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_mult_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Floating-point vector multiplication.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_mult_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix2_instance_q15;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_q15(
N  arm_cfft_radix2_instance_q15 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_q15(
N  const arm_cfft_radix2_instance_q15 * S,
N  q15_t * pSrc);
N
N
N  /**
N   * @brief Instance structure for the Q15 CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix4_instance_q15;
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_q15(
N  arm_cfft_radix4_instance_q15 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix4_q15(
N  const arm_cfft_radix4_instance_q15 * S,
N  q15_t * pSrc);
N
N  /**
N   * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix2_instance_q31;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_q31(
N  arm_cfft_radix2_instance_q31 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_q31(
N  const arm_cfft_radix2_instance_q31 * S,
N  q31_t * pSrc);
N
N  /**
N   * @brief Instance structure for the Q31 CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix4_instance_q31;
N
N/* Deprecated */
N  void arm_cfft_radix4_q31(
N  const arm_cfft_radix4_instance_q31 * S,
N  q31_t * pSrc);
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_q31(
N  arm_cfft_radix4_instance_q31 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N    float32_t onebyfftLen;             /**< value of 1/fftLen. */
N  } arm_cfft_radix2_instance_f32;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_f32(
N  arm_cfft_radix2_instance_f32 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_f32(
N  const arm_cfft_radix2_instance_f32 * S,
N  float32_t * pSrc);
N
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N    float32_t onebyfftLen;             /**< value of 1/fftLen. */
N  } arm_cfft_radix4_instance_f32;
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_f32(
N  arm_cfft_radix4_instance_f32 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix4_f32(
N  const arm_cfft_radix4_instance_f32 * S,
N  float32_t * pSrc);
N
N  /**
N   * @brief Instance structure for the fixed-point CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_q15;
N
Nvoid arm_cfft_q15(
N    const arm_cfft_instance_q15 * S,
N    q15_t * p1,
N    uint8_t ifftFlag,
N    uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the fixed-point CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_q31;
N
Nvoid arm_cfft_q31(
N    const arm_cfft_instance_q31 * S,
N    q31_t * p1,
N    uint8_t ifftFlag,
N    uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_f32;
N
N  void arm_cfft_f32(
N  const arm_cfft_instance_f32 * S,
N  float32_t * p1,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the Q15 RFFT/RIFFT function.
N   */
N  typedef struct
N  {
N    uint32_t fftLenReal;                      /**< length of the real FFT. */
N    uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
N    q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
N    const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
N  } arm_rfft_instance_q15;
N
N  arm_status arm_rfft_init_q15(
N  arm_rfft_instance_q15 * S,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_q15(
N  const arm_rfft_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst);
N
N  /**
N   * @brief Instance structure for the Q31 RFFT/RIFFT function.
N   */
N  typedef struct
N  {
N    uint32_t fftLenReal;                        /**< length of the real FFT. */
N    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
N    q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
N    const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
N  } arm_rfft_instance_q31;
N
N  arm_status arm_rfft_init_q31(
N  arm_rfft_instance_q31 * S,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_q31(
N  const arm_rfft_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst);
N
N  /**
N   * @brief Instance structure for the floating-point RFFT/RIFFT function.
N   */
N  typedef struct
N  {
N    uint32_t fftLenReal;                        /**< length of the real FFT. */
N    uint16_t fftLenBy2;                         /**< length of the complex FFT. */
N    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
N    float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
N    arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
N  } arm_rfft_instance_f32;
N
N  arm_status arm_rfft_init_f32(
N  arm_rfft_instance_f32 * S,
N  arm_cfft_radix4_instance_f32 * S_CFFT,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_f32(
N  const arm_rfft_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst);
N
N  /**
N   * @brief Instance structure for the floating-point RFFT/RIFFT function.
N   */
Ntypedef struct
N  {
N    arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
N    uint16_t fftLenRFFT;             /**< length of the real sequence */
N    float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
N  } arm_rfft_fast_instance_f32 ;
N
Narm_status arm_rfft_fast_init_f32 (
N   arm_rfft_fast_instance_f32 * S,
N   uint16_t fftLen);
N
Nvoid arm_rfft_fast_f32(
N  arm_rfft_fast_instance_f32 * S,
N  float32_t * p, float32_t * pOut,
N  uint8_t ifftFlag);
N
N  /**
N   * @brief Instance structure for the floating-point DCT4/IDCT4 function.
N   */
N  typedef struct
N  {
N    uint16_t N;                          /**< length of the DCT4. */
N    uint16_t Nby2;                       /**< half of the length of the DCT4. */
N    float32_t normalize;                 /**< normalizing factor. */
N    float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
N    float32_t *pCosFactor;               /**< points to the cosFactor table. */
N    arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_f32;
N
N
N  /**
N   * @brief  Initialization function for the floating-point DCT4/IDCT4.
N   * @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure.
N   * @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure.
N   * @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure.
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported transform length.
N   */
N  arm_status arm_dct4_init_f32(
N  arm_dct4_instance_f32 * S,
N  arm_rfft_instance_f32 * S_RFFT,
N  arm_cfft_radix4_instance_f32 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  float32_t normalize);
N
N
N  /**
N   * @brief Processing function for the floating-point DCT4/IDCT4.
N   * @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure.
N   * @param[in]     pState         points to state buffer.
N   * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
N   */
N  void arm_dct4_f32(
N  const arm_dct4_instance_f32 * S,
N  float32_t * pState,
N  float32_t * pInlineBuffer);
N
N
N  /**
N   * @brief Instance structure for the Q31 DCT4/IDCT4 function.
N   */
N  typedef struct
N  {
N    uint16_t N;                          /**< length of the DCT4. */
N    uint16_t Nby2;                       /**< half of the length of the DCT4. */
N    q31_t normalize;                     /**< normalizing factor. */
N    q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
N    q31_t *pCosFactor;                   /**< points to the cosFactor table. */
N    arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_q31;
N
N
N  /**
N   * @brief  Initialization function for the Q31 DCT4/IDCT4.
N   * @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure.
N   * @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure
N   * @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
N   */
N  arm_status arm_dct4_init_q31(
N  arm_dct4_instance_q31 * S,
N  arm_rfft_instance_q31 * S_RFFT,
N  arm_cfft_radix4_instance_q31 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  q31_t normalize);
N
N
N  /**
N   * @brief Processing function for the Q31 DCT4/IDCT4.
N   * @param[in]     S              points to an instance of the Q31 DCT4 structure.
N   * @param[in]     pState         points to state buffer.
N   * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
N   */
N  void arm_dct4_q31(
N  const arm_dct4_instance_q31 * S,
N  q31_t * pState,
N  q31_t * pInlineBuffer);
N
N
N  /**
N   * @brief Instance structure for the Q15 DCT4/IDCT4 function.
N   */
N  typedef struct
N  {
N    uint16_t N;                          /**< length of the DCT4. */
N    uint16_t Nby2;                       /**< half of the length of the DCT4. */
N    q15_t normalize;                     /**< normalizing factor. */
N    q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
N    q15_t *pCosFactor;                   /**< points to the cosFactor table. */
N    arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_q15;
N
N
N  /**
N   * @brief  Initialization function for the Q15 DCT4/IDCT4.
N   * @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure.
N   * @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure.
N   * @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure.
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
N   */
N  arm_status arm_dct4_init_q15(
N  arm_dct4_instance_q15 * S,
N  arm_rfft_instance_q15 * S_RFFT,
N  arm_cfft_radix4_instance_q15 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  q15_t normalize);
N
N
N  /**
N   * @brief Processing function for the Q15 DCT4/IDCT4.
N   * @param[in]     S              points to an instance of the Q15 DCT4 structure.
N   * @param[in]     pState         points to state buffer.
N   * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
N   */
N  void arm_dct4_q15(
N  const arm_dct4_instance_q15 * S,
N  q15_t * pState,
N  q15_t * pInlineBuffer);
N
N
N  /**
N   * @brief Floating-point vector addition.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_add_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q7 vector addition.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_add_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q15 vector addition.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_add_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q31 vector addition.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_add_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Floating-point vector subtraction.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_sub_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q7 vector subtraction.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_sub_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q15 vector subtraction.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_sub_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q31 vector subtraction.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_sub_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Multiplies a floating-point vector by a scalar.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  scale      scale factor to be applied
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_scale_f32(
N  float32_t * pSrc,
N  float32_t scale,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Multiplies a Q7 vector by a scalar.
N   * @param[in]  pSrc        points to the input vector
N   * @param[in]  scaleFract  fractional portion of the scale value
N   * @param[in]  shift       number of bits to shift the result by
N   * @param[out] pDst        points to the output vector
N   * @param[in]  blockSize   number of samples in the vector
N   */
N  void arm_scale_q7(
N  q7_t * pSrc,
N  q7_t scaleFract,
N  int8_t shift,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Multiplies a Q15 vector by a scalar.
N   * @param[in]  pSrc        points to the input vector
N   * @param[in]  scaleFract  fractional portion of the scale value
N   * @param[in]  shift       number of bits to shift the result by
N   * @param[out] pDst        points to the output vector
N   * @param[in]  blockSize   number of samples in the vector
N   */
N  void arm_scale_q15(
N  q15_t * pSrc,
N  q15_t scaleFract,
N  int8_t shift,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Multiplies a Q31 vector by a scalar.
N   * @param[in]  pSrc        points to the input vector
N   * @param[in]  scaleFract  fractional portion of the scale value
N   * @param[in]  shift       number of bits to shift the result by
N   * @param[out] pDst        points to the output vector
N   * @param[in]  blockSize   number of samples in the vector
N   */
N  void arm_scale_q31(
N  q31_t * pSrc,
N  q31_t scaleFract,
N  int8_t shift,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q7 vector absolute value.
N   * @param[in]  pSrc       points to the input buffer
N   * @param[out] pDst       points to the output buffer
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_abs_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Floating-point vector absolute value.
N   * @param[in]  pSrc       points to the input buffer
N   * @param[out] pDst       points to the output buffer
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_abs_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q15 vector absolute value.
N   * @param[in]  pSrc       points to the input buffer
N   * @param[out] pDst       points to the output buffer
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_abs_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q31 vector absolute value.
N   * @param[in]  pSrc       points to the input buffer
N   * @param[out] pDst       points to the output buffer
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_abs_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Dot product of floating-point vectors.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[in]  blockSize  number of samples in each vector
N   * @param[out] result     output result returned here
N   */
N  void arm_dot_prod_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  uint32_t blockSize,
N  float32_t * result);
N
N
N  /**
N   * @brief Dot product of Q7 vectors.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[in]  blockSize  number of samples in each vector
N   * @param[out] result     output result returned here
N   */
N  void arm_dot_prod_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  uint32_t blockSize,
N  q31_t * result);
N
N
N  /**
N   * @brief Dot product of Q15 vectors.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[in]  blockSize  number of samples in each vector
N   * @param[out] result     output result returned here
N   */
N  void arm_dot_prod_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  uint32_t blockSize,
N  q63_t * result);
N
N
N  /**
N   * @brief Dot product of Q31 vectors.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[in]  blockSize  number of samples in each vector
N   * @param[out] result     output result returned here
N   */
N  void arm_dot_prod_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  uint32_t blockSize,
N  q63_t * result);
N
N
N  /**
N   * @brief  Shifts the elements of a Q7 vector a specified number of bits.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_shift_q7(
N  q7_t * pSrc,
N  int8_t shiftBits,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Shifts the elements of a Q15 vector a specified number of bits.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_shift_q15(
N  q15_t * pSrc,
N  int8_t shiftBits,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Shifts the elements of a Q31 vector a specified number of bits.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_shift_q31(
N  q31_t * pSrc,
N  int8_t shiftBits,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Adds a constant offset to a floating-point vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  offset     is the offset to be added
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_offset_f32(
N  float32_t * pSrc,
N  float32_t offset,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Adds a constant offset to a Q7 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  offset     is the offset to be added
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_offset_q7(
N  q7_t * pSrc,
N  q7_t offset,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Adds a constant offset to a Q15 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  offset     is the offset to be added
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_offset_q15(
N  q15_t * pSrc,
N  q15_t offset,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Adds a constant offset to a Q31 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  offset     is the offset to be added
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_offset_q31(
N  q31_t * pSrc,
N  q31_t offset,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Negates the elements of a floating-point vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_negate_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Negates the elements of a Q7 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_negate_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Negates the elements of a Q15 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_negate_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Negates the elements of a Q31 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_negate_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Copies the elements of a floating-point vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_copy_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Copies the elements of a Q7 vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_copy_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Copies the elements of a Q15 vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_copy_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Copies the elements of a Q31 vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_copy_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Fills a constant value into a floating-point vector.
N   * @param[in]  value      input value to be filled
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_fill_f32(
N  float32_t value,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Fills a constant value into a Q7 vector.
N   * @param[in]  value      input value to be filled
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_fill_q7(
N  q7_t value,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Fills a constant value into a Q15 vector.
N   * @param[in]  value      input value to be filled
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_fill_q15(
N  q15_t value,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Fills a constant value into a Q31 vector.
N   * @param[in]  value      input value to be filled
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_fill_q31(
N  q31_t value,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N/**
N * @brief Convolution of floating-point sequences.
N * @param[in]  pSrcA    points to the first input sequence.
N * @param[in]  srcALen  length of the first input sequence.
N * @param[in]  pSrcB    points to the second input sequence.
N * @param[in]  srcBLen  length of the second input sequence.
N * @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1.
N */
N  void arm_conv_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst);
N
N
N  /**
N   * @brief Convolution of Q15 sequences.
N   * @param[in]  pSrcA      points to the first input sequence.
N   * @param[in]  srcALen    length of the first input sequence.
N   * @param[in]  pSrcB      points to the second input sequence.
N   * @param[in]  srcBLen    length of the second input sequence.
N   * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
N   */
N  void arm_conv_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N/**
N * @brief Convolution of Q15 sequences.
N * @param[in]  pSrcA    points to the first input sequence.
N * @param[in]  srcALen  length of the first input sequence.
N * @param[in]  pSrcB    points to the second input sequence.
N * @param[in]  srcBLen  length of the second input sequence.
N * @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1.
N */
N  void arm_conv_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst);
N
N
N  /**
N   * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
N   */
N  void arm_conv_fast_q15(
N          q15_t * pSrcA,
N          uint32_t srcALen,
N          q15_t * pSrcB,
N          uint32_t srcBLen,
N          q15_t * pDst);
N
N
N  /**
N   * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA      points to the first input sequence.
N   * @param[in]  srcALen    length of the first input sequence.
N   * @param[in]  pSrcB      points to the second input sequence.
N   * @param[in]  srcBLen    length of the second input sequence.
N   * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
N   */
N  void arm_conv_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Convolution of Q31 sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
N   */
N  void arm_conv_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N  /**
N   * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
N   */
N  void arm_conv_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N    /**
N   * @brief Convolution of Q7 sequences.
N   * @param[in]  pSrcA      points to the first input sequence.
N   * @param[in]  srcALen    length of the first input sequence.
N   * @param[in]  pSrcB      points to the second input sequence.
N   * @param[in]  srcBLen    length of the second input sequence.
N   * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   */
N  void arm_conv_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Convolution of Q7 sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
N   */
N  void arm_conv_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst);
N
N
N  /**
N   * @brief Partial convolution of floating-point sequences.
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q15 sequences.
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Partial convolution of Q15 sequences.
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_fast_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Partial convolution of Q31 sequences.
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q7 sequences
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N/**
N   * @brief Partial convolution of Q7 sequences.
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR decimator.
N   */
N  typedef struct
N  {
N    uint8_t M;                  /**< decimation factor. */
N    uint16_t numTaps;           /**< number of coefficients in the filter. */
N    q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTaps.*/
N    q15_t *pState;              /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N  } arm_fir_decimate_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR decimator.
N   */
N  typedef struct
N  {
N    uint8_t M;                  /**< decimation factor. */
N    uint16_t numTaps;           /**< number of coefficients in the filter. */
N    q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTaps.*/
N    q31_t *pState;              /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N  } arm_fir_decimate_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR decimator.
N   */
N  typedef struct
N  {
N    uint8_t M;                  /**< decimation factor. */
N    uint16_t numTaps;           /**< number of coefficients in the filter. */
N    float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTaps.*/
N    float32_t *pState;          /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N  } arm_fir_decimate_instance_f32;
N
N
N  /**
N   * @brief Processing function for the floating-point FIR decimator.
N   * @param[in]  S          points to an instance of the floating-point FIR decimator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_decimate_f32(
N  const arm_fir_decimate_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point FIR decimator.
N   * @param[in,out] S          points to an instance of the floating-point FIR decimator structure.
N   * @param[in]     numTaps    number of coefficients in the filter.
N   * @param[in]     M          decimation factor.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N  arm_status arm_fir_decimate_init_f32(
N  arm_fir_decimate_instance_f32 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR decimator.
N   * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_decimate_q15(
N  const arm_fir_decimate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_decimate_fast_q15(
N  const arm_fir_decimate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 FIR decimator.
N   * @param[in,out] S          points to an instance of the Q15 FIR decimator structure.
N   * @param[in]     numTaps    number of coefficients in the filter.
N   * @param[in]     M          decimation factor.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N  arm_status arm_fir_decimate_init_q15(
N  arm_fir_decimate_instance_q15 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 FIR decimator.
N   * @param[in]  S     points to an instance of the Q31 FIR decimator structure.
N   * @param[in]  pSrc  points to the block of input data.
N   * @param[out] pDst  points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   */
N  void arm_fir_decimate_q31(
N  const arm_fir_decimate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q31 FIR decimator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_decimate_fast_q31(
N  arm_fir_decimate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 FIR decimator.
N   * @param[in,out] S          points to an instance of the Q31 FIR decimator structure.
N   * @param[in]     numTaps    number of coefficients in the filter.
N   * @param[in]     M          decimation factor.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N  arm_status arm_fir_decimate_init_q31(
N  arm_fir_decimate_instance_q31 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR interpolator.
N   */
N  typedef struct
N  {
N    uint8_t L;                      /**< upsample factor. */
N    uint16_t phaseLength;           /**< length of each polyphase filter component. */
N    q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
N    q15_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
N  } arm_fir_interpolate_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR interpolator.
N   */
N  typedef struct
N  {
N    uint8_t L;                      /**< upsample factor. */
N    uint16_t phaseLength;           /**< length of each polyphase filter component. */
N    q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
N    q31_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
N  } arm_fir_interpolate_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR interpolator.
N   */
N  typedef struct
N  {
N    uint8_t L;                     /**< upsample factor. */
N    uint16_t phaseLength;          /**< length of each polyphase filter component. */
N    float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*phaseLength. */
N    float32_t *pState;             /**< points to the state variable array. The array is of length phaseLength+numTaps-1. */
N  } arm_fir_interpolate_instance_f32;
N
N
N  /**
N   * @brief Processing function for the Q15 FIR interpolator.
N   * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_interpolate_q15(
N  const arm_fir_interpolate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 FIR interpolator.
N   * @param[in,out] S          points to an instance of the Q15 FIR interpolator structure.
N   * @param[in]     L          upsample factor.
N   * @param[in]     numTaps    number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficient buffer.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N  arm_status arm_fir_interpolate_init_q15(
N  arm_fir_interpolate_instance_q15 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 FIR interpolator.
N   * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_interpolate_q31(
N  const arm_fir_interpolate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 FIR interpolator.
N   * @param[in,out] S          points to an instance of the Q31 FIR interpolator structure.
N   * @param[in]     L          upsample factor.
N   * @param[in]     numTaps    number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficient buffer.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N  arm_status arm_fir_interpolate_init_q31(
N  arm_fir_interpolate_instance_q31 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point FIR interpolator.
N   * @param[in]  S          points to an instance of the floating-point FIR interpolator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_interpolate_f32(
N  const arm_fir_interpolate_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point FIR interpolator.
N   * @param[in,out] S          points to an instance of the floating-point FIR interpolator structure.
N   * @param[in]     L          upsample factor.
N   * @param[in]     numTaps    number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficient buffer.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N  arm_status arm_fir_interpolate_init_f32(
N  arm_fir_interpolate_instance_f32 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the high precision Q31 Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q63_t *pState;           /**< points to the array of state coefficients.  The array is of length 4*numStages. */
N    q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*numStages. */
N    uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
N  } arm_biquad_cas_df1_32x64_ins_q31;
N
N
N  /**
N   * @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cas_df1_32x64_q31(
N  const arm_biquad_cas_df1_32x64_ins_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filter structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     postShift  shift to be applied to the output. Varies according to the coefficients format
N   */
N  void arm_biquad_cas_df1_32x64_init_q31(
N  arm_biquad_cas_df1_32x64_ins_q31 * S,
N  uint8_t numStages,
N  q31_t * pCoeffs,
N  q63_t * pState,
N  uint8_t postShift);
N
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
N    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_df2T_instance_f32;
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 4*numStages. */
N    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_stereo_df2T_instance_f32;
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float64_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
N    float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_df2T_instance_f64;
N
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in]  S          points to an instance of the filter data structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df2T_f32(
N  const arm_biquad_cascade_df2T_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter. 2 channels
N   * @param[in]  S          points to an instance of the filter data structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_stereo_df2T_f32(
N  const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in]  S          points to an instance of the filter data structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df2T_f64(
N  const arm_biquad_cascade_df2T_instance_f64 * S,
N  float64_t * pSrc,
N  float64_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the filter data structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   */
N  void arm_biquad_cascade_df2T_init_f32(
N  arm_biquad_cascade_df2T_instance_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the filter data structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   */
N  void arm_biquad_cascade_stereo_df2T_init_f32(
N  arm_biquad_cascade_stereo_df2T_instance_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the filter data structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   */
N  void arm_biquad_cascade_df2T_init_f64(
N  arm_biquad_cascade_df2T_instance_f64 * S,
N  uint8_t numStages,
N  float64_t * pCoeffs,
N  float64_t * pState);
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of filter stages. */
N    q15_t *pState;                       /**< points to the state variable array. The array is of length numStages. */
N    q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of filter stages. */
N    q31_t *pState;                       /**< points to the state variable array. The array is of length numStages. */
N    q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of filter stages. */
N    float32_t *pState;                   /**< points to the state variable array. The array is of length numStages. */
N    float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_f32;
N
N
N  /**
N   * @brief Initialization function for the Q15 FIR lattice filter.
N   * @param[in] S          points to an instance of the Q15 FIR lattice structure.
N   * @param[in] numStages  number of filter stages.
N   * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
N   * @param[in] pState     points to the state buffer.  The array is of length numStages.
N   */
N  void arm_fir_lattice_init_q15(
N  arm_fir_lattice_instance_q15 * S,
N  uint16_t numStages,
N  q15_t * pCoeffs,
N  q15_t * pState);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR lattice filter.
N   * @param[in]  S          points to an instance of the Q15 FIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_lattice_q15(
N  const arm_fir_lattice_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for the Q31 FIR lattice filter.
N   * @param[in] S          points to an instance of the Q31 FIR lattice structure.
N   * @param[in] numStages  number of filter stages.
N   * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
N   * @param[in] pState     points to the state buffer.   The array is of length numStages.
N   */
N  void arm_fir_lattice_init_q31(
N  arm_fir_lattice_instance_q31 * S,
N  uint16_t numStages,
N  q31_t * pCoeffs,
N  q31_t * pState);
N
N
N  /**
N   * @brief Processing function for the Q31 FIR lattice filter.
N   * @param[in]  S          points to an instance of the Q31 FIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_lattice_q31(
N  const arm_fir_lattice_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N/**
N * @brief Initialization function for the floating-point FIR lattice filter.
N * @param[in] S          points to an instance of the floating-point FIR lattice structure.
N * @param[in] numStages  number of filter stages.
N * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
N * @param[in] pState     points to the state buffer.  The array is of length numStages.
N */
N  void arm_fir_lattice_init_f32(
N  arm_fir_lattice_instance_f32 * S,
N  uint16_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief Processing function for the floating-point FIR lattice filter.
N   * @param[in]  S          points to an instance of the floating-point FIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_lattice_f32(
N  const arm_fir_lattice_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of stages in the filter. */
N    q15_t *pState;                       /**< points to the state variable array. The array is of length numStages+blockSize. */
N    q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array is of length numStages. */
N    q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of stages in the filter. */
N    q31_t *pState;                       /**< points to the state variable array. The array is of length numStages+blockSize. */
N    q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array is of length numStages. */
N    q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of stages in the filter. */
N    float32_t *pState;                   /**< points to the state variable array. The array is of length numStages+blockSize. */
N    float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array is of length numStages. */
N    float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_f32;
N
N
N  /**
N   * @brief Processing function for the floating-point IIR lattice filter.
N   * @param[in]  S          points to an instance of the floating-point IIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_iir_lattice_f32(
N  const arm_iir_lattice_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for the floating-point IIR lattice filter.
N   * @param[in] S          points to an instance of the floating-point IIR lattice structure.
N   * @param[in] numStages  number of stages in the filter.
N   * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length numStages.
N   * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStages+1.
N   * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-1.
N   * @param[in] blockSize  number of samples to process.
N   */
N  void arm_iir_lattice_init_f32(
N  arm_iir_lattice_instance_f32 * S,
N  uint16_t numStages,
N  float32_t * pkCoeffs,
N  float32_t * pvCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 IIR lattice filter.
N   * @param[in]  S          points to an instance of the Q31 IIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_iir_lattice_q31(
N  const arm_iir_lattice_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for the Q31 IIR lattice filter.
N   * @param[in] S          points to an instance of the Q31 IIR lattice structure.
N   * @param[in] numStages  number of stages in the filter.
N   * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length numStages.
N   * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStages+1.
N   * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize.
N   * @param[in] blockSize  number of samples to process.
N   */
N  void arm_iir_lattice_init_q31(
N  arm_iir_lattice_instance_q31 * S,
N  uint16_t numStages,
N  q31_t * pkCoeffs,
N  q31_t * pvCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 IIR lattice filter.
N   * @param[in]  S          points to an instance of the Q15 IIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_iir_lattice_q15(
N  const arm_iir_lattice_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N/**
N * @brief Initialization function for the Q15 IIR lattice filter.
N * @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure.
N * @param[in] numStages  number of stages in the filter.
N * @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages.
N * @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1.
N * @param[in] pState     points to state buffer.  The array is of length numStages+blockSize.
N * @param[in] blockSize  number of samples to process per call.
N */
N  void arm_iir_lattice_init_q15(
N  arm_iir_lattice_instance_q15 * S,
N  uint16_t numStages,
N  q15_t * pkCoeffs,
N  q15_t * pvCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the floating-point LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
N    float32_t mu;        /**< step size that controls filter coefficient updates. */
N  } arm_lms_instance_f32;
N
N
N  /**
N   * @brief Processing function for floating-point LMS filter.
N   * @param[in]  S          points to an instance of the floating-point LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_f32(
N  const arm_lms_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pRef,
N  float32_t * pOut,
N  float32_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for floating-point LMS filter.
N   * @param[in] S          points to an instance of the floating-point LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to the coefficient buffer.
N   * @param[in] pState     points to state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   */
N  void arm_lms_init_f32(
N  arm_lms_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  float32_t mu,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
N    q15_t mu;            /**< step size that controls filter coefficient updates. */
N    uint32_t postShift;  /**< bit shift applied to coefficients. */
N  } arm_lms_instance_q15;
N
N
N  /**
N   * @brief Initialization function for the Q15 LMS filter.
N   * @param[in] S          points to an instance of the Q15 LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to the coefficient buffer.
N   * @param[in] pState     points to the state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   * @param[in] postShift  bit shift applied to coefficients.
N   */
N  void arm_lms_init_q15(
N  arm_lms_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  q15_t mu,
N  uint32_t blockSize,
N  uint32_t postShift);
N
N
N  /**
N   * @brief Processing function for Q15 LMS filter.
N   * @param[in]  S          points to an instance of the Q15 LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_q15(
N  const arm_lms_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pRef,
N  q15_t * pOut,
N  q15_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q31 LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
N    q31_t mu;            /**< step size that controls filter coefficient updates. */
N    uint32_t postShift;  /**< bit shift applied to coefficients. */
N  } arm_lms_instance_q31;
N
N
N  /**
N   * @brief Processing function for Q31 LMS filter.
N   * @param[in]  S          points to an instance of the Q15 LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_q31(
N  const arm_lms_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pRef,
N  q31_t * pOut,
N  q31_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for Q31 LMS filter.
N   * @param[in] S          points to an instance of the Q31 LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to coefficient buffer.
N   * @param[in] pState     points to state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   * @param[in] postShift  bit shift applied to coefficients.
N   */
N  void arm_lms_init_q31(
N  arm_lms_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  q31_t mu,
N  uint32_t blockSize,
N  uint32_t postShift);
N
N
N  /**
N   * @brief Instance structure for the floating-point normalized LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of coefficients in the filter. */
N    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
N    float32_t mu;         /**< step size that control filter coefficient updates. */
N    float32_t energy;     /**< saves previous frame energy. */
N    float32_t x0;         /**< saves previous input sample. */
N  } arm_lms_norm_instance_f32;
N
N
N  /**
N   * @brief Processing function for floating-point normalized LMS filter.
N   * @param[in]  S          points to an instance of the floating-point normalized LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_norm_f32(
N  arm_lms_norm_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pRef,
N  float32_t * pOut,
N  float32_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for floating-point normalized LMS filter.
N   * @param[in] S          points to an instance of the floating-point LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to coefficient buffer.
N   * @param[in] pState     points to state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   */
N  void arm_lms_norm_init_f32(
N  arm_lms_norm_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  float32_t mu,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q31 normalized LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of coefficients in the filter. */
N    q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
N    q31_t mu;             /**< step size that controls filter coefficient updates. */
N    uint8_t postShift;    /**< bit shift applied to coefficients. */
N    q31_t *recipTable;    /**< points to the reciprocal initial value table. */
N    q31_t energy;         /**< saves previous frame energy. */
N    q31_t x0;             /**< saves previous input sample. */
N  } arm_lms_norm_instance_q31;
N
N
N  /**
N   * @brief Processing function for Q31 normalized LMS filter.
N   * @param[in]  S          points to an instance of the Q31 normalized LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_norm_q31(
N  arm_lms_norm_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pRef,
N  q31_t * pOut,
N  q31_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for Q31 normalized LMS filter.
N   * @param[in] S          points to an instance of the Q31 normalized LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to coefficient buffer.
N   * @param[in] pState     points to state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   * @param[in] postShift  bit shift applied to coefficients.
N   */
N  void arm_lms_norm_init_q31(
N  arm_lms_norm_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  q31_t mu,
N  uint32_t blockSize,
N  uint8_t postShift);
N
N
N  /**
N   * @brief Instance structure for the Q15 normalized LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< Number of coefficients in the filter. */
N    q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
N    q15_t mu;             /**< step size that controls filter coefficient updates. */
N    uint8_t postShift;    /**< bit shift applied to coefficients. */
N    q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
N    q15_t energy;         /**< saves previous frame energy. */
N    q15_t x0;             /**< saves previous input sample. */
N  } arm_lms_norm_instance_q15;
N
N
N  /**
N   * @brief Processing function for Q15 normalized LMS filter.
N   * @param[in]  S          points to an instance of the Q15 normalized LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_norm_q15(
N  arm_lms_norm_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pRef,
N  q15_t * pOut,
N  q15_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for Q15 normalized LMS filter.
N   * @param[in] S          points to an instance of the Q15 normalized LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to coefficient buffer.
N   * @param[in] pState     points to state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   * @param[in] postShift  bit shift applied to coefficients.
N   */
N  void arm_lms_norm_init_q15(
N  arm_lms_norm_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  q15_t mu,
N  uint32_t blockSize,
N  uint8_t postShift);
N
N
N  /**
N   * @brief Correlation of floating-point sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N  void arm_correlate_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst);
N
N
N   /**
N   * @brief Correlation of Q15 sequences
N   * @param[in]  pSrcA     points to the first input sequence.
N   * @param[in]  srcALen   length of the first input sequence.
N   * @param[in]  pSrcB     points to the second input sequence.
N   * @param[in]  srcBLen   length of the second input sequence.
N   * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   */
N  void arm_correlate_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch);
N
N
N  /**
N   * @brief Correlation of Q15 sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N
N  void arm_correlate_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst);
N
N
N  /**
N   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N
N  void arm_correlate_fast_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst);
N
N
N  /**
N   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
N   * @param[in]  pSrcA     points to the first input sequence.
N   * @param[in]  srcALen   length of the first input sequence.
N   * @param[in]  pSrcB     points to the second input sequence.
N   * @param[in]  srcBLen   length of the second input sequence.
N   * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   */
N  void arm_correlate_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch);
N
N
N  /**
N   * @brief Correlation of Q31 sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N  void arm_correlate_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N  /**
N   * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N  void arm_correlate_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N /**
N   * @brief Correlation of Q7 sequences.
N   * @param[in]  pSrcA      points to the first input sequence.
N   * @param[in]  srcALen    length of the first input sequence.
N   * @param[in]  pSrcB      points to the second input sequence.
N   * @param[in]  srcBLen    length of the second input sequence.
N   * @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   */
N  void arm_correlate_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Correlation of Q7 sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N  void arm_correlate_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst);
N
N
N  /**
N   * @brief Instance structure for the floating-point sparse FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    float32_t *pState;            /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_f32;
N
N  /**
N   * @brief Instance structure for the Q31 sparse FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q31_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q31;
N
N  /**
N   * @brief Instance structure for the Q15 sparse FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q15_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q7 sparse FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q7_t *pState;                 /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q7;
N
N
N  /**
N   * @brief Processing function for the floating-point sparse FIR filter.
N   * @param[in]  S           points to an instance of the floating-point sparse FIR structure.
N   * @param[in]  pSrc        points to the block of input data.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize   number of input samples to process per call.
N   */
N  void arm_fir_sparse_f32(
N  arm_fir_sparse_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  float32_t * pScratchIn,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point sparse FIR filter.
N   * @param[in,out] S          points to an instance of the floating-point sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     pCoeffs    points to the array of filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     pTapDelay  points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   */
N  void arm_fir_sparse_init_f32(
N  arm_fir_sparse_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 sparse FIR filter.
N   * @param[in]  S           points to an instance of the Q31 sparse FIR structure.
N   * @param[in]  pSrc        points to the block of input data.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize   number of input samples to process per call.
N   */
N  void arm_fir_sparse_q31(
N  arm_fir_sparse_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  q31_t * pScratchIn,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 sparse FIR filter.
N   * @param[in,out] S          points to an instance of the Q31 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     pCoeffs    points to the array of filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     pTapDelay  points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   */
N  void arm_fir_sparse_init_q31(
N  arm_fir_sparse_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 sparse FIR filter.
N   * @param[in]  S            points to an instance of the Q15 sparse FIR structure.
N   * @param[in]  pSrc         points to the block of input data.
N   * @param[out] pDst         points to the block of output data
N   * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
N   * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize    number of input samples to process per call.
N   */
N  void arm_fir_sparse_q15(
N  arm_fir_sparse_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  q15_t * pScratchIn,
N  q31_t * pScratchOut,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 sparse FIR filter.
N   * @param[in,out] S          points to an instance of the Q15 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     pCoeffs    points to the array of filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     pTapDelay  points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   */
N  void arm_fir_sparse_init_q15(
N  arm_fir_sparse_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q7 sparse FIR filter.
N   * @param[in]  S            points to an instance of the Q7 sparse FIR structure.
N   * @param[in]  pSrc         points to the block of input data.
N   * @param[out] pDst         points to the block of output data
N   * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
N   * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize    number of input samples to process per call.
N   */
N  void arm_fir_sparse_q7(
N  arm_fir_sparse_instance_q7 * S,
N  q7_t * pSrc,
N  q7_t * pDst,
N  q7_t * pScratchIn,
N  q31_t * pScratchOut,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q7 sparse FIR filter.
N   * @param[in,out] S          points to an instance of the Q7 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     pCoeffs    points to the array of filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     pTapDelay  points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   */
N  void arm_fir_sparse_init_q7(
N  arm_fir_sparse_instance_q7 * S,
N  uint16_t numTaps,
N  q7_t * pCoeffs,
N  q7_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Floating-point sin_cos function.
N   * @param[in]  theta   input value in degrees
N   * @param[out] pSinVal  points to the processed sine output.
N   * @param[out] pCosVal  points to the processed cos output.
N   */
N  void arm_sin_cos_f32(
N  float32_t theta,
N  float32_t * pSinVal,
N  float32_t * pCosVal);
N
N
N  /**
N   * @brief  Q31 sin_cos function.
N   * @param[in]  theta    scaled input value in degrees
N   * @param[out] pSinVal  points to the processed sine output.
N   * @param[out] pCosVal  points to the processed cosine output.
N   */
N  void arm_sin_cos_q31(
N  q31_t theta,
N  q31_t * pSinVal,
N  q31_t * pCosVal);
N
N
N  /**
N   * @brief  Floating-point complex conjugate.
N   * @param[in]  pSrc        points to the input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_conj_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex conjugate.
N   * @param[in]  pSrc        points to the input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_conj_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q15 complex conjugate.
N   * @param[in]  pSrc        points to the input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_conj_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Floating-point complex magnitude squared
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_squared_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q31 complex magnitude squared
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_squared_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q15 complex magnitude squared
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_squared_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup PID PID Motor Control
N   *
N   * A Proportional Integral Derivative (PID) controller is a generic feedback control
N   * loop mechanism widely used in industrial control systems.
N   * A PID controller is the most commonly used type of feedback controller.
N   *
N   * This set of functions implements (PID) controllers
N   * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
N   * of data and each call to the function returns a single processed value.
N   * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
N   * is the input sample value. The functions return the output value.
N   *
N   * \par Algorithm:
N   * <pre>
N   *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
N   *    A0 = Kp + Ki + Kd
N   *    A1 = (-Kp ) - (2 * Kd )
N   *    A2 = Kd  </pre>
N   *
N   * \par
N   * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative constant
N   *
N   * \par
N   * \image html PID.gif "Proportional Integral Derivative Controller"
N   *
N   * \par
N   * The PID controller calculates an "error" value as the difference between
N   * the measured output and the reference input.
N   * The controller attempts to minimize the error by adjusting the process control inputs.
N   * The proportional value determines the reaction to the current error,
N   * the integral value determines the reaction based on the sum of recent errors,
N   * and the derivative value determines the reaction based on the rate at which the error has been changing.
N   *
N   * \par Instance Structure
N   * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instance data structure.
N   * A separate instance structure must be defined for each PID Controller.
N   * There are separate instance structure declarations for each of the 3 supported data types.
N   *
N   * \par Reset Functions
N   * There is also an associated reset function for each data type which clears the state array.
N   *
N   * \par Initialization Functions
N   * There is also an associated initialization function for each data type.
N   * The initialization function performs the following operations:
N   * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
N   * - Zeros out the values in the state buffer.
N   *
N   * \par
N   * Instance structure cannot be placed into a const data section and it is recommended to use the initialization function.
N   *
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the fixed-point versions of the PID Controller functions.
N   * In particular, the overflow and saturation behavior of the accumulator used in each function must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup PID
N   * @{
N   */
N
N  /**
N   * @brief  Process function for the floating-point PID Control.
N   * @param[in,out] S   is an instance of the floating-point PID Control structure
N   * @param[in]     in  input sample to process
N   * @return out processed output sample.
N   */
N  CMSIS_INLINE __STATIC_INLINE float32_t arm_pid_f32(
X  __attribute__((always_inline)) static __inline float32_t arm_pid_f32(
N  arm_pid_instance_f32 * S,
N  float32_t in)
N  {
N    float32_t out;
N
N    /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
N    out = (S->A0 * in) +
N      (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N
N  }
N
N  /**
N   * @brief  Process function for the Q31 PID Control.
N   * @param[in,out] S  points to an instance of the Q31 PID Control structure
N   * @param[in]     in  input sample to process
N   * @return out processed output sample.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 64-bit accumulator.
N   * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplication results but provides only a single guard bit.
N   * Thus, if the accumulator result overflows it wraps around rather than clip.
N   * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there are four additions.
N   * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format and then saturated to 1.31 format.
N   */
N  CMSIS_INLINE __STATIC_INLINE q31_t arm_pid_q31(
X  __attribute__((always_inline)) static __inline q31_t arm_pid_q31(
N  arm_pid_instance_q31 * S,
N  q31_t in)
N  {
N    q63_t acc;
N    q31_t out;
N
N    /* acc = A0 * x[n]  */
N    acc = (q63_t) S->A0 * in;
N
N    /* acc += A1 * x[n-1] */
N    acc += (q63_t) S->A1 * S->state[0];
N
N    /* acc += A2 * x[n-2]  */
N    acc += (q63_t) S->A2 * S->state[1];
N
N    /* convert output to 1.31 format to add y[n-1] */
N    out = (q31_t) (acc >> 31u);
N
N    /* out += y[n-1] */
N    out += S->state[2];
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N  }
N
N
N  /**
N   * @brief  Process function for the Q15 PID Control.
N   * @param[in,out] S   points to an instance of the Q15 PID Control structure
N   * @param[in]     in  input sample to process
N   * @return out processed output sample.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using a 64-bit internal accumulator.
N   * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30 result.
N   * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
N   * There is no risk of internal overflow with this approach and the full precision of intermediate multiplications is preserved.
N   * After all additions have been performed, the accumulator is truncated to 34.15 format by discarding low 15 bits.
N   * Lastly, the accumulator is saturated to yield a result in 1.15 format.
N   */
N  CMSIS_INLINE __STATIC_INLINE q15_t arm_pid_q15(
X  __attribute__((always_inline)) static __inline q15_t arm_pid_q15(
N  arm_pid_instance_q15 * S,
N  q15_t in)
N  {
N    q63_t acc;
N    q15_t out;
N
N#if defined (ARM_MATH_DSP)
X#if 0L
S    __SIMD32_TYPE *vstate;
S
S    /* Implementation of PID controller */
S
S    /* acc = A0 * x[n]  */
S    acc = (q31_t) __SMUAD((uint32_t)S->A0, (uint32_t)in);
S
S    /* acc += A1 * x[n-1] + A2 * x[n-2]  */
S    vstate = __SIMD32_CONST(S->state);
S    acc = (q63_t)__SMLALD((uint32_t)S->A1, (uint32_t)*vstate, (uint64_t)acc);
N#else
N    /* acc = A0 * x[n]  */
N    acc = ((q31_t) S->A0) * in;
N
N    /* acc += A1 * x[n-1] + A2 * x[n-2]  */
N    acc += (q31_t) S->A1 * S->state[0];
N    acc += (q31_t) S->A2 * S->state[1];
N#endif
N
N    /* acc += y[n-1] */
N    acc += (q31_t) S->state[2] << 15;
N
N    /* saturate the output */
N    out = (q15_t) (__SSAT((acc >> 15), 16));
X    out = (q15_t) (__ssat((acc >> 15), 16));
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N  }
N
N  /**
N   * @} end of PID group
N   */
N
N
N  /**
N   * @brief Floating-point matrix inverse.
N   * @param[in]  src   points to the instance of the input floating-point matrix structure.
N   * @param[out] dst   points to the instance of the output floating-point matrix structure.
N   * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
N   * If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR.
N   */
N  arm_status arm_mat_inverse_f32(
N  const arm_matrix_instance_f32 * src,
N  arm_matrix_instance_f32 * dst);
N
N
N  /**
N   * @brief Floating-point matrix inverse.
N   * @param[in]  src   points to the instance of the input floating-point matrix structure.
N   * @param[out] dst   points to the instance of the output floating-point matrix structure.
N   * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
N   * If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR.
N   */
N  arm_status arm_mat_inverse_f64(
N  const arm_matrix_instance_f64 * src,
N  arm_matrix_instance_f64 * dst);
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup clarke Vector Clarke Transform
N   * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time invariant vector.
N   * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calculate currents
N   * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
N   * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
N   * \image html clarke.gif Stator current space vector and its components in (a,b).
N   * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code>
N   * can be calculated using only <code>Ia</code> and <code>Ib</code>.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html clarkeFormula.gif
N   * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
N   * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Clarke transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup clarke
N   * @{
N   */
N
N  /**
N   *
N   * @brief  Floating-point Clarke transform
N   * @param[in]  Ia       input three-phase coordinate <code>a</code>
N   * @param[in]  Ib       input three-phase coordinate <code>b</code>
N   * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_clarke_f32(
X  __attribute__((always_inline)) static __inline void arm_clarke_f32(
N  float32_t Ia,
N  float32_t Ib,
N  float32_t * pIalpha,
N  float32_t * pIbeta)
N  {
N    /* Calculate pIalpha using the equation, pIalpha = Ia */
N    *pIalpha = Ia;
N
N    /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
N    *pIbeta = ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
N  }
N
N
N  /**
N   * @brief  Clarke transform for Q31 version
N   * @param[in]  Ia       input three-phase coordinate <code>a</code>
N   * @param[in]  Ib       input three-phase coordinate <code>b</code>
N   * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition, hence there is no risk of overflow.
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_clarke_q31(
X  __attribute__((always_inline)) static __inline void arm_clarke_q31(
N  q31_t Ia,
N  q31_t Ib,
N  q31_t * pIalpha,
N  q31_t * pIbeta)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N
N    /* Calculating pIalpha from Ia by equation pIalpha = Ia */
N    *pIalpha = Ia;
N
N    /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
N    product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
N
N    /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
N    product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
N
N    /* pIbeta is calculated by adding the intermediate products */
N    *pIbeta = __QADD(product1, product2);
N  }
N
N  /**
N   * @} end of clarke group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to Q31 vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_q7_to_q31(
N  q7_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup inv_clarke Vector Inverse Clarke Transform
N   * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous stator phases.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html clarkeInvFormula.gif
N   * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
N   * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Clarke transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup inv_clarke
N   * @{
N   */
N
N   /**
N   * @brief  Floating-point Inverse Clarke transform
N   * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
N   * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
N   * @param[out] pIa     points to output three-phase coordinate <code>a</code>
N   * @param[out] pIb     points to output three-phase coordinate <code>b</code>
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_f32(
X  __attribute__((always_inline)) static __inline void arm_inv_clarke_f32(
N  float32_t Ialpha,
N  float32_t Ibeta,
N  float32_t * pIa,
N  float32_t * pIb)
N  {
N    /* Calculating pIa from Ialpha by equation pIa = Ialpha */
N    *pIa = Ialpha;
N
N    /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibeta */
N    *pIb = -0.5f * Ialpha + 0.8660254039f * Ibeta;
N  }
N
N
N  /**
N   * @brief  Inverse Clarke transform for Q31 version
N   * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
N   * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
N   * @param[out] pIa     points to output three-phase coordinate <code>a</code>
N   * @param[out] pIb     points to output three-phase coordinate <code>b</code>
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the subtraction, hence there is no risk of overflow.
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_q31(
X  __attribute__((always_inline)) static __inline void arm_inv_clarke_q31(
N  q31_t Ialpha,
N  q31_t Ibeta,
N  q31_t * pIa,
N  q31_t * pIb)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N
N    /* Calculating pIa from Ialpha by equation pIa = Ialpha */
N    *pIa = Ialpha;
N
N    /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
N    product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
N
N    /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
N    product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
N
N    /* pIb is calculated by subtracting the products */
N    *pIb = __QSUB(product2, product1);
N  }
N
N  /**
N   * @} end of inv_clarke group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to Q15 vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_q7_to_q15(
N  q7_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup park Vector Park Transform
N   *
N   * Forward Park transform converts the input two-coordinate vector to flux and torque components.
N   * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and the <code>Ibeta</code> currents
N   * from the stationary to the moving reference frame and control the spatial relationship between
N   * the stator vector current and rotor flux vector.
N   * If we consider the d axis aligned with the rotor flux, the diagram below shows the
N   * current vector and the relationship from the two reference frames:
N   * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q rotating reference frame"
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html parkFormula.gif
N   * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
N   * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and <code>sinVal</code> are the
N   * cosine and sine values of theta (rotor flux position).
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Park transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup park
N   * @{
N   */
N
N  /**
N   * @brief Floating-point Park transform
N   * @param[in]  Ialpha  input two-phase vector coordinate alpha
N   * @param[in]  Ibeta   input two-phase vector coordinate beta
N   * @param[out] pId     points to output   rotor reference frame d
N   * @param[out] pIq     points to output   rotor reference frame q
N   * @param[in]  sinVal  sine value of rotation angle theta
N   * @param[in]  cosVal  cosine value of rotation angle theta
N   *
N   * The function implements the forward Park transform.
N   *
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_park_f32(
X  __attribute__((always_inline)) static __inline void arm_park_f32(
N  float32_t Ialpha,
N  float32_t Ibeta,
N  float32_t * pId,
N  float32_t * pIq,
N  float32_t sinVal,
N  float32_t cosVal)
N  {
N    /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
N    *pId = Ialpha * cosVal + Ibeta * sinVal;
N
N    /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
N    *pIq = -Ialpha * sinVal + Ibeta * cosVal;
N  }
N
N
N  /**
N   * @brief  Park transform for Q31 version
N   * @param[in]  Ialpha  input two-phase vector coordinate alpha
N   * @param[in]  Ibeta   input two-phase vector coordinate beta
N   * @param[out] pId     points to output rotor reference frame d
N   * @param[out] pIq     points to output rotor reference frame q
N   * @param[in]  sinVal  sine value of rotation angle theta
N   * @param[in]  cosVal  cosine value of rotation angle theta
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition and subtraction, hence there is no risk of overflow.
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_park_q31(
X  __attribute__((always_inline)) static __inline void arm_park_q31(
N  q31_t Ialpha,
N  q31_t Ibeta,
N  q31_t * pId,
N  q31_t * pIq,
N  q31_t sinVal,
N  q31_t cosVal)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N    q31_t product3, product4;                    /* Temporary variables used to store intermediate results */
N
N    /* Intermediate product is calculated by (Ialpha * cosVal) */
N    product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
N
N    /* Intermediate product is calculated by (Ibeta * sinVal) */
N    product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
N
N
N    /* Intermediate product is calculated by (Ialpha * sinVal) */
N    product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
N
N    /* Intermediate product is calculated by (Ibeta * cosVal) */
N    product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
N
N    /* Calculate pId by adding the two intermediate products 1 and 2 */
N    *pId = __QADD(product1, product2);
N
N    /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
N    *pIq = __QSUB(product4, product3);
N  }
N
N  /**
N   * @} end of park group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q7_to_float(
N  q7_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup inv_park Vector Inverse Park transform
N   * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html parkInvFormula.gif
N   * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
N   * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <code>sinVal</code> are the
N   * cosine and sine values of theta (rotor flux position).
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Park transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup inv_park
N   * @{
N   */
N
N   /**
N   * @brief  Floating-point Inverse Park transform
N   * @param[in]  Id       input coordinate of rotor reference frame d
N   * @param[in]  Iq       input coordinate of rotor reference frame q
N   * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
N   * @param[in]  sinVal   sine value of rotation angle theta
N   * @param[in]  cosVal   cosine value of rotation angle theta
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_inv_park_f32(
X  __attribute__((always_inline)) static __inline void arm_inv_park_f32(
N  float32_t Id,
N  float32_t Iq,
N  float32_t * pIalpha,
N  float32_t * pIbeta,
N  float32_t sinVal,
N  float32_t cosVal)
N  {
N    /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
N    *pIalpha = Id * cosVal - Iq * sinVal;
N
N    /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
N    *pIbeta = Id * sinVal + Iq * cosVal;
N  }
N
N
N  /**
N   * @brief  Inverse Park transform for   Q31 version
N   * @param[in]  Id       input coordinate of rotor reference frame d
N   * @param[in]  Iq       input coordinate of rotor reference frame q
N   * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
N   * @param[in]  sinVal   sine value of rotation angle theta
N   * @param[in]  cosVal   cosine value of rotation angle theta
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition, hence there is no risk of overflow.
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_inv_park_q31(
X  __attribute__((always_inline)) static __inline void arm_inv_park_q31(
N  q31_t Id,
N  q31_t Iq,
N  q31_t * pIalpha,
N  q31_t * pIbeta,
N  q31_t sinVal,
N  q31_t cosVal)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N    q31_t product3, product4;                    /* Temporary variables used to store intermediate results */
N
N    /* Intermediate product is calculated by (Id * cosVal) */
N    product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
N
N    /* Intermediate product is calculated by (Iq * sinVal) */
N    product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
N
N
N    /* Intermediate product is calculated by (Id * sinVal) */
N    product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
N
N    /* Intermediate product is calculated by (Iq * cosVal) */
N    product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
N
N    /* Calculate pIalpha by using the two intermediate products 1 and 2 */
N    *pIalpha = __QSUB(product1, product2);
N
N    /* Calculate pIbeta by using the two intermediate products 3 and 4 */
N    *pIbeta = __QADD(product4, product3);
N  }
N
N  /**
N   * @} end of Inverse park group
N   */
N
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q31_to_float(
N  q31_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @ingroup groupInterpolation
N   */
N
N  /**
N   * @defgroup LinearInterpolate Linear Interpolation
N   *
N   * Linear interpolation is a method of curve fitting using linear polynomials.
N   * Linear interpolation works by effectively drawing a straight line between two neighboring samples and returning the appropriate point along that line
N   *
N   * \par
N   * \image html LinearInterp.gif "Linear interpolation"
N   *
N   * \par
N   * A  Linear Interpolate function calculates an output value(y), for the input(x)
N   * using linear interpolation of the input values x0, x1( nearest input values) and the output values y0 and y1(nearest output values)
N   *
N   * \par Algorithm:
N   * <pre>
N   *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
N   *       where x0, x1 are nearest values of input x
N   *             y0, y1 are nearest values to output y
N   * </pre>
N   *
N   * \par
N   * This set of functions implements Linear interpolation process
N   * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
N   * sample of data and each call to the function returns a single processed value.
N   * <code>S</code> points to an instance of the Linear Interpolate function data structure.
N   * <code>x</code> is the input sample value. The functions returns the output value.
N   *
N   * \par
N   * if x is outside of the table boundary, Linear interpolation returns first value of the table
N   * if x is below input range and returns last value of table if x is above range.
N   */
N
N  /**
N   * @addtogroup LinearInterpolate
N   * @{
N   */
N
N  /**
N   * @brief  Process function for the floating-point Linear Interpolation Function.
N   * @param[in,out] S  is an instance of the floating-point Linear Interpolation structure
N   * @param[in]     x  input sample to process
N   * @return y processed output sample.
N   *
N   */
N  CMSIS_INLINE __STATIC_INLINE float32_t arm_linear_interp_f32(
X  __attribute__((always_inline)) static __inline float32_t arm_linear_interp_f32(
N  arm_linear_interp_instance_f32 * S,
N  float32_t x)
N  {
N    float32_t y;
N    float32_t x0, x1;                            /* Nearest input values */
N    float32_t y0, y1;                            /* Nearest output values */
N    float32_t xSpacing = S->xSpacing;            /* spacing between input values */
N    int32_t i;                                   /* Index variable */
N    float32_t *pYData = S->pYData;               /* pointer to output table */
N
N    /* Calculation of index */
N    i = (int32_t) ((x - S->x1) / xSpacing);
N
N    if (i < 0)
N    {
N      /* Iniatilize output for below specified range as least output value of table */
N      y = pYData[0];
N    }
N    else if ((uint32_t)i >= S->nValues)
N    {
N      /* Iniatilize output for above specified range as last output value of table */
N      y = pYData[S->nValues - 1];
N    }
N    else
N    {
N      /* Calculation of nearest input values */
N      x0 = S->x1 +  i      * xSpacing;
N      x1 = S->x1 + (i + 1) * xSpacing;
N
N      /* Read of nearest output values */
N      y0 = pYData[i];
N      y1 = pYData[i + 1];
N
N      /* Calculation of output */
N      y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
N
N    }
N
N    /* returns output value */
N    return (y);
N  }
N
N
N   /**
N   *
N   * @brief  Process function for the Q31 Linear Interpolation Function.
N   * @param[in] pYData   pointer to Q31 Linear Interpolation table
N   * @param[in] x        input sample to process
N   * @param[in] nValues  number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   *
N   */
N  CMSIS_INLINE __STATIC_INLINE q31_t arm_linear_interp_q31(
X  __attribute__((always_inline)) static __inline q31_t arm_linear_interp_q31(
N  q31_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q31_t y;                                     /* output */
N    q31_t y0, y1;                                /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    int32_t index;                               /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    index = ((x & (q31_t)0xFFF00000) >> 20);
N
N    if (index >= (int32_t)(nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else if (index < 0)
N    {
N      return (pYData[0]);
N    }
N    else
N    {
N      /* 20 bits for the fractional part */
N      /* shift left by 11 to keep fract in 1.31 format */
N      fract = (x & 0x000FFFFF) << 11;
N
N      /* Read two nearest output values from the index in 1.31(q31) format */
N      y0 = pYData[index];
N      y1 = pYData[index + 1];
N
N      /* Calculation of y0 * (1-fract) and y is in 2.30 format */
N      y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
N
N      /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
N      y += ((q31_t) (((q63_t) y1 * fract) >> 32));
N
N      /* Convert y to 1.31 format */
N      return (y << 1u);
N    }
N  }
N
N
N  /**
N   *
N   * @brief  Process function for the Q15 Linear Interpolation Function.
N   * @param[in] pYData   pointer to Q15 Linear Interpolation table
N   * @param[in] x        input sample to process
N   * @param[in] nValues  number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   *
N   */
N  CMSIS_INLINE __STATIC_INLINE q15_t arm_linear_interp_q15(
X  __attribute__((always_inline)) static __inline q15_t arm_linear_interp_q15(
N  q15_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q63_t y;                                     /* output */
N    q15_t y0, y1;                                /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    int32_t index;                               /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    index = ((x & (int32_t)0xFFF00000) >> 20);
N
N    if (index >= (int32_t)(nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else if (index < 0)
N    {
N      return (pYData[0]);
N    }
N    else
N    {
N      /* 20 bits for the fractional part */
N      /* fract is in 12.20 format */
N      fract = (x & 0x000FFFFF);
N
N      /* Read two nearest output values from the index */
N      y0 = pYData[index];
N      y1 = pYData[index + 1];
N
N      /* Calculation of y0 * (1-fract) and y is in 13.35 format */
N      y = ((q63_t) y0 * (0xFFFFF - fract));
N
N      /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
N      y += ((q63_t) y1 * (fract));
N
N      /* convert y to 1.15 format */
N      return (q15_t) (y >> 20);
N    }
N  }
N
N
N  /**
N   *
N   * @brief  Process function for the Q7 Linear Interpolation Function.
N   * @param[in] pYData   pointer to Q7 Linear Interpolation table
N   * @param[in] x        input sample to process
N   * @param[in] nValues  number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   */
N  CMSIS_INLINE __STATIC_INLINE q7_t arm_linear_interp_q7(
X  __attribute__((always_inline)) static __inline q7_t arm_linear_interp_q7(
N  q7_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q31_t y;                                     /* output */
N    q7_t y0, y1;                                 /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    uint32_t index;                              /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    if (x < 0)
N    {
N      return (pYData[0]);
N    }
N    index = (x >> 20) & 0xfff;
N
N    if (index >= (nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else
N    {
N      /* 20 bits for the fractional part */
N      /* fract is in 12.20 format */
N      fract = (x & 0x000FFFFF);
N
N      /* Read two nearest output values from the index and are in 1.7(q7) format */
N      y0 = pYData[index];
N      y1 = pYData[index + 1];
N
N      /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
N      y = ((y0 * (0xFFFFF - fract)));
N
N      /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
N      y += (y1 * fract);
N
N      /* convert y to 1.7(q7) format */
N      return (q7_t) (y >> 20);
N     }
N  }
N
N  /**
N   * @} end of LinearInterpolate group
N   */
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for floating-point data.
N   * @param[in] x  input value in radians.
N   * @return  sin(x).
N   */
N  float32_t arm_sin_f32(
N  float32_t x);
N
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for Q31 data.
N   * @param[in] x  Scaled input value in radians.
N   * @return  sin(x).
N   */
N  q31_t arm_sin_q31(
N  q31_t x);
N
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for Q15 data.
N   * @param[in] x  Scaled input value in radians.
N   * @return  sin(x).
N   */
N  q15_t arm_sin_q15(
N  q15_t x);
N
N
N  /**
N   * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
N   * @param[in] x  input value in radians.
N   * @return  cos(x).
N   */
N  float32_t arm_cos_f32(
N  float32_t x);
N
N
N  /**
N   * @brief Fast approximation to the trigonometric cosine function for Q31 data.
N   * @param[in] x  Scaled input value in radians.
N   * @return  cos(x).
N   */
N  q31_t arm_cos_q31(
N  q31_t x);
N
N
N  /**
N   * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
N   * @param[in] x  Scaled input value in radians.
N   * @return  cos(x).
N   */
N  q15_t arm_cos_q15(
N  q15_t x);
N
N
N  /**
N   * @ingroup groupFastMath
N   */
N
N
N  /**
N   * @defgroup SQRT Square Root
N   *
N   * Computes the square root of a number.
N   * There are separate functions for Q15, Q31, and floating-point data types.
N   * The square root function is computed using the Newton-Raphson algorithm.
N   * This is an iterative algorithm of the form:
N   * <pre>
N   *      x1 = x0 - f(x0)/f'(x0)
N   * </pre>
N   * where <code>x1</code> is the current estimate,
N   * <code>x0</code> is the previous estimate, and
N   * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
N   * For the square root function, the algorithm reduces to:
N   * <pre>
N   *     x0 = in/2                         [initial guess]
N   *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
N   * </pre>
N   */
N
N
N  /**
N   * @addtogroup SQRT
N   * @{
N   */
N
N  /**
N   * @brief  Floating-point square root function.
N   * @param[in]  in    input value.
N   * @param[out] pOut  square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
X  __attribute__((always_inline)) static __inline arm_status arm_sqrt_f32(
N  float32_t in,
N  float32_t * pOut)
N  {
N    if (in >= 0.0f)
N    {
N
N#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
X#if   (0U == 1) && 1L
S      *pOut = __sqrtf(in);
S#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
X#elif (0U == 1) && (1L && (5060750 >= 6010050))
S      *pOut = __builtin_sqrtf(in);
S#elif (__FPU_USED == 1) && defined(__GNUC__)
X#elif (0U == 1) && 0L
S      *pOut = __builtin_sqrtf(in);
S#elif (__FPU_USED == 1) && defined ( __ICCARM__ ) && (__VER__ >= 6040000)
X#elif (0U == 1) && 0L && (__VER__ >= 6040000)
S      __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
N#else
N      *pOut = sqrtf(in);
N#endif
N
N      return (ARM_MATH_SUCCESS);
N    }
N    else
N    {
N      *pOut = 0.0f;
N      return (ARM_MATH_ARGUMENT_ERROR);
N    }
N  }
N
N
N  /**
N   * @brief Q31 square root function.
N   * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFFFFFF.
N   * @param[out] pOut  square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N  arm_status arm_sqrt_q31(
N  q31_t in,
N  q31_t * pOut);
N
N
N  /**
N   * @brief  Q15 square root function.
N   * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF.
N   * @param[out] pOut  square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N  arm_status arm_sqrt_q15(
N  q15_t in,
N  q15_t * pOut);
N
N  /**
N   * @} end of SQRT group
N   */
N
N
N  /**
N   * @brief floating-point Circular write function.
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_circularWrite_f32(
X  __attribute__((always_inline)) static __inline void arm_circularWrite_f32(
N  int32_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const int32_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while (i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if (wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = (uint16_t)wOffset;
N  }
N
N
N
N  /**
N   * @brief floating-point Circular Read function.
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_circularRead_f32(
X  __attribute__((always_inline)) static __inline void arm_circularRead_f32(
N  int32_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  int32_t * dst,
N  int32_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while (i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if (dst == (int32_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update rOffset.  Watch out for positive and negative value  */
N      rOffset += bufferInc;
N
N      if (rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N
N  /**
N   * @brief Q15 Circular write function.
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_circularWrite_q15(
X  __attribute__((always_inline)) static __inline void arm_circularWrite_q15(
N  q15_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const q15_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while (i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if (wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = (uint16_t)wOffset;
N  }
N
N
N  /**
N   * @brief Q15 Circular Read function.
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_circularRead_q15(
X  __attribute__((always_inline)) static __inline void arm_circularRead_q15(
N  q15_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  q15_t * dst,
N  q15_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while (i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if (dst == (q15_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      rOffset += bufferInc;
N
N      if (rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N
N  /**
N   * @brief Q7 Circular write function.
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_circularWrite_q7(
X  __attribute__((always_inline)) static __inline void arm_circularWrite_q7(
N  q7_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const q7_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while (i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if (wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = (uint16_t)wOffset;
N  }
N
N
N  /**
N   * @brief Q7 Circular Read function.
N   */
N  CMSIS_INLINE __STATIC_INLINE void arm_circularRead_q7(
X  __attribute__((always_inline)) static __inline void arm_circularRead_q7(
N  q7_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  q7_t * dst,
N  q7_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while (i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if (dst == (q7_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update rOffset.  Watch out for positive and negative value */
N      rOffset += bufferInc;
N
N      if (rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_power_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q63_t * pResult);
N
N
N  /**
N   * @brief  Sum of the squares of the elements of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_power_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_power_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q63_t * pResult);
N
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q7 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_power_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N
N  /**
N   * @brief  Mean value of a Q7 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_mean_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * pResult);
N
N
N  /**
N   * @brief  Mean value of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_mean_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N
N  /**
N   * @brief  Mean value of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_mean_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N
N  /**
N   * @brief  Mean value of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_mean_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N
N  /**
N   * @brief  Variance of the elements of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_var_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N
N  /**
N   * @brief  Variance of the elements of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_var_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N
N  /**
N   * @brief  Variance of the elements of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_var_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N
N  /**
N   * @brief  Root Mean Square of the elements of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_rms_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N
N  /**
N   * @brief  Root Mean Square of the elements of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_rms_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N
N  /**
N   * @brief  Root Mean Square of the elements of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_rms_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N
N  /**
N   * @brief  Standard deviation of the elements of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_std_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N
N  /**
N   * @brief  Standard deviation of the elements of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_std_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N
N  /**
N   * @brief  Standard deviation of the elements of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_std_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N
N  /**
N   * @brief  Floating-point complex magnitude
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q31 complex magnitude
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q15 complex magnitude
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q15 complex dot product
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   * @param[out] realResult  real part of the result returned here
N   * @param[out] imagResult  imaginary part of the result returned here
N   */
N  void arm_cmplx_dot_prod_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  uint32_t numSamples,
N  q31_t * realResult,
N  q31_t * imagResult);
N
N
N  /**
N   * @brief  Q31 complex dot product
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   * @param[out] realResult  real part of the result returned here
N   * @param[out] imagResult  imaginary part of the result returned here
N   */
N  void arm_cmplx_dot_prod_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  uint32_t numSamples,
N  q63_t * realResult,
N  q63_t * imagResult);
N
N
N  /**
N   * @brief  Floating-point complex dot product
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   * @param[out] realResult  real part of the result returned here
N   * @param[out] imagResult  imaginary part of the result returned here
N   */
N  void arm_cmplx_dot_prod_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  uint32_t numSamples,
N  float32_t * realResult,
N  float32_t * imagResult);
N
N
N  /**
N   * @brief  Q15 complex-by-real multiplication
N   * @param[in]  pSrcCmplx   points to the complex input vector
N   * @param[in]  pSrcReal    points to the real input vector
N   * @param[out] pCmplxDst   points to the complex output vector
N   * @param[in]  numSamples  number of samples in each vector
N   */
N  void arm_cmplx_mult_real_q15(
N  q15_t * pSrcCmplx,
N  q15_t * pSrcReal,
N  q15_t * pCmplxDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q31 complex-by-real multiplication
N   * @param[in]  pSrcCmplx   points to the complex input vector
N   * @param[in]  pSrcReal    points to the real input vector
N   * @param[out] pCmplxDst   points to the complex output vector
N   * @param[in]  numSamples  number of samples in each vector
N   */
N  void arm_cmplx_mult_real_q31(
N  q31_t * pSrcCmplx,
N  q31_t * pSrcReal,
N  q31_t * pCmplxDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Floating-point complex-by-real multiplication
N   * @param[in]  pSrcCmplx   points to the complex input vector
N   * @param[in]  pSrcReal    points to the real input vector
N   * @param[out] pCmplxDst   points to the complex output vector
N   * @param[in]  numSamples  number of samples in each vector
N   */
N  void arm_cmplx_mult_real_f32(
N  float32_t * pSrcCmplx,
N  float32_t * pSrcReal,
N  float32_t * pCmplxDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Minimum value of a Q7 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] result     is output pointer
N   * @param[in]  index      is the array index of the minimum value in the input buffer.
N   */
N  void arm_min_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * result,
N  uint32_t * index);
N
N
N  /**
N   * @brief  Minimum value of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output pointer
N   * @param[in]  pIndex     is the array index of the minimum value in the input buffer.
N   */
N  void arm_min_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult,
N  uint32_t * pIndex);
N
N
N  /**
N   * @brief  Minimum value of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output pointer
N   * @param[out] pIndex     is the array index of the minimum value in the input buffer.
N   */
N  void arm_min_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult,
N  uint32_t * pIndex);
N
N
N  /**
N   * @brief  Minimum value of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output pointer
N   * @param[out] pIndex     is the array index of the minimum value in the input buffer.
N   */
N  void arm_min_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult,
N  uint32_t * pIndex);
N
N
N/**
N * @brief Maximum value of a Q7 vector.
N * @param[in]  pSrc       points to the input buffer
N * @param[in]  blockSize  length of the input vector
N * @param[out] pResult    maximum value returned here
N * @param[out] pIndex     index of maximum value returned here
N */
N  void arm_max_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * pResult,
N  uint32_t * pIndex);
N
N
N/**
N * @brief Maximum value of a Q15 vector.
N * @param[in]  pSrc       points to the input buffer
N * @param[in]  blockSize  length of the input vector
N * @param[out] pResult    maximum value returned here
N * @param[out] pIndex     index of maximum value returned here
N */
N  void arm_max_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult,
N  uint32_t * pIndex);
N
N
N/**
N * @brief Maximum value of a Q31 vector.
N * @param[in]  pSrc       points to the input buffer
N * @param[in]  blockSize  length of the input vector
N * @param[out] pResult    maximum value returned here
N * @param[out] pIndex     index of maximum value returned here
N */
N  void arm_max_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult,
N  uint32_t * pIndex);
N
N
N/**
N * @brief Maximum value of a floating-point vector.
N * @param[in]  pSrc       points to the input buffer
N * @param[in]  blockSize  length of the input vector
N * @param[out] pResult    maximum value returned here
N * @param[out] pIndex     index of maximum value returned here
N */
N  void arm_max_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult,
N  uint32_t * pIndex);
N
N
N  /**
N   * @brief  Q15 complex-by-complex multiplication
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_mult_cmplx_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q31 complex-by-complex multiplication
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_mult_cmplx_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Floating-point complex-by-complex multiplication
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_mult_cmplx_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q31 vector.
N   * @param[in]  pSrc       points to the floating-point input vector
N   * @param[out] pDst       points to the Q31 output vector
N   * @param[in]  blockSize  length of the input vector
N   */
N  void arm_float_to_q31(
N  float32_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q15 vector.
N   * @param[in]  pSrc       points to the floating-point input vector
N   * @param[out] pDst       points to the Q15 output vector
N   * @param[in]  blockSize  length of the input vector
N   */
N  void arm_float_to_q15(
N  float32_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q7 vector.
N   * @param[in]  pSrc       points to the floating-point input vector
N   * @param[out] pDst       points to the Q7 output vector
N   * @param[in]  blockSize  length of the input vector
N   */
N  void arm_float_to_q7(
N  float32_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q31_to_q15(
N  q31_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to Q7 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q31_to_q7(
N  q31_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q15_to_float(
N  q15_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q15_to_q31(
N  q15_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to Q7 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q15_to_q7(
N  q15_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @ingroup groupInterpolation
N   */
N
N  /**
N   * @defgroup BilinearInterpolate Bilinear Interpolation
N   *
N   * Bilinear interpolation is an extension of linear interpolation applied to a two dimensional grid.
N   * The underlying function <code>f(x, y)</code> is sampled on a regular grid and the interpolation process
N   * determines values between the grid points.
N   * Bilinear interpolation is equivalent to two step linear interpolation, first in the x-dimension and then in the y-dimension.
N   * Bilinear interpolation is often used in image processing to rescale images.
N   * The CMSIS DSP library provides bilinear interpolation functions for Q7, Q15, Q31, and floating-point data types.
N   *
N   * <b>Algorithm</b>
N   * \par
N   * The instance structure used by the bilinear interpolation functions describes a two dimensional data table.
N   * For floating-point, the instance structure is defined as:
N   * <pre>
N   *   typedef struct
N   *   {
N   *     uint16_t numRows;
N   *     uint16_t numCols;
N   *     float32_t *pData;
N   * } arm_bilinear_interp_instance_f32;
N   * </pre>
N   *
N   * \par
N   * where <code>numRows</code> specifies the number of rows in the table;
N   * <code>numCols</code> specifies the number of columns in the table;
N   * and <code>pData</code> points to an array of size <code>numRows*numCols</code> values.
N   * The data table <code>pTable</code> is organized in row order and the supplied data values fall on integer indexes.
N   * That is, table element (x,y) is located at <code>pTable[x + y*numCols]</code> where x and y are integers.
N   *
N   * \par
N   * Let <code>(x, y)</code> specify the desired interpolation point.  Then define:
N   * <pre>
N   *     XF = floor(x)
N   *     YF = floor(y)
N   * </pre>
N   * \par
N   * The interpolated output point is computed as:
N   * <pre>
N   *  f(x, y) = f(XF, YF) * (1-(x-XF)) * (1-(y-YF))
N   *           + f(XF+1, YF) * (x-XF)*(1-(y-YF))
N   *           + f(XF, YF+1) * (1-(x-XF))*(y-YF)
N   *           + f(XF+1, YF+1) * (x-XF)*(y-YF)
N   * </pre>
N   * Note that the coordinates (x, y) contain integer and fractional components.
N   * The integer components specify which portion of the table to use while the
N   * fractional components control the interpolation processor.
N   *
N   * \par
N   * if (x,y) are outside of the table boundary, Bilinear interpolation returns zero output.
N   */
N
N  /**
N   * @addtogroup BilinearInterpolate
N   * @{
N   */
N
N
N  /**
N  *
N  * @brief  Floating-point bilinear interpolation.
N  * @param[in,out] S  points to an instance of the interpolation structure.
N  * @param[in]     X  interpolation coordinate.
N  * @param[in]     Y  interpolation coordinate.
N  * @return out interpolated value.
N  */
N  CMSIS_INLINE __STATIC_INLINE float32_t arm_bilinear_interp_f32(
X  __attribute__((always_inline)) static __inline float32_t arm_bilinear_interp_f32(
N  const arm_bilinear_interp_instance_f32 * S,
N  float32_t X,
N  float32_t Y)
N  {
N    float32_t out;
N    float32_t f00, f01, f10, f11;
N    float32_t *pData = S->pData;
N    int32_t xIndex, yIndex, index;
N    float32_t xdiff, ydiff;
N    float32_t b1, b2, b3, b4;
N
N    xIndex = (int32_t) X;
N    yIndex = (int32_t) Y;
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if (xIndex < 0 || xIndex > (S->numRows - 1) || yIndex < 0 || yIndex > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* Calculation of index for two nearest points in X-direction */
N    index = (xIndex - 1) + (yIndex - 1) * S->numCols;
N
N
N    /* Read two nearest points in X-direction */
N    f00 = pData[index];
N    f01 = pData[index + 1];
N
N    /* Calculation of index for two nearest points in Y-direction */
N    index = (xIndex - 1) + (yIndex) * S->numCols;
N
N
N    /* Read two nearest points in Y-direction */
N    f10 = pData[index];
N    f11 = pData[index + 1];
N
N    /* Calculation of intermediate values */
N    b1 = f00;
N    b2 = f01 - f00;
N    b3 = f10 - f00;
N    b4 = f00 - f01 - f10 + f11;
N
N    /* Calculation of fractional part in X */
N    xdiff = X - xIndex;
N
N    /* Calculation of fractional part in Y */
N    ydiff = Y - yIndex;
N
N    /* Calculation of bi-linear interpolated output */
N    out = b1 + b2 * xdiff + b3 * ydiff + b4 * xdiff * ydiff;
N
N    /* return to application */
N    return (out);
N  }
N
N
N  /**
N  *
N  * @brief  Q31 bilinear interpolation.
N  * @param[in,out] S  points to an instance of the interpolation structure.
N  * @param[in]     X  interpolation coordinate in 12.20 format.
N  * @param[in]     Y  interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N  CMSIS_INLINE __STATIC_INLINE q31_t arm_bilinear_interp_q31(
X  __attribute__((always_inline)) static __inline q31_t arm_bilinear_interp_q31(
N  arm_bilinear_interp_instance_q31 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q31_t out;                                   /* Temporary output */
N    q31_t acc = 0;                               /* output */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    q31_t x1, x2, y1, y2;                        /* Nearest output values */
N    int32_t rI, cI;                              /* Row and column indices */
N    q31_t *pYData = S->pData;                    /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & (q31_t)0xFFF00000) >> 20);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & (q31_t)0xFFF00000) >> 20);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if (rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* shift left xfract by 11 to keep 1.31 format */
N    xfract = (X & 0x000FFFFF) << 11u;
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[(rI) + (int32_t)nCols * (cI)    ];
N    x2 = pYData[(rI) + (int32_t)nCols * (cI) + 1];
N
N    /* 20 bits for the fractional part */
N    /* shift left yfract by 11 to keep 1.31 format */
N    yfract = (Y & 0x000FFFFF) << 11u;
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[(rI) + (int32_t)nCols * (cI + 1)    ];
N    y2 = pYData[(rI) + (int32_t)nCols * (cI + 1) + 1];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 3.29(q29) format */
N    out = ((q31_t) (((q63_t) x1  * (0x7FFFFFFF - xfract)) >> 32));
N    acc = ((q31_t) (((q63_t) out * (0x7FFFFFFF - yfract)) >> 32));
N
N    /* x2 * (xfract) * (1-yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) x2 * (0x7FFFFFFF - yfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (xfract) >> 32));
N
N    /* y1 * (1 - xfract) * (yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) y1 * (0x7FFFFFFF - xfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (yfract) >> 32));
N
N    /* y2 * (xfract) * (yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) y2 * (xfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (yfract) >> 32));
N
N    /* Convert acc to 1.31(q31) format */
N    return ((q31_t)(acc << 2));
N  }
N
N
N  /**
N  * @brief  Q15 bilinear interpolation.
N  * @param[in,out] S  points to an instance of the interpolation structure.
N  * @param[in]     X  interpolation coordinate in 12.20 format.
N  * @param[in]     Y  interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N  CMSIS_INLINE __STATIC_INLINE q15_t arm_bilinear_interp_q15(
X  __attribute__((always_inline)) static __inline q15_t arm_bilinear_interp_q15(
N  arm_bilinear_interp_instance_q15 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q63_t acc = 0;                               /* output */
N    q31_t out;                                   /* Temporary output */
N    q15_t x1, x2, y1, y2;                        /* Nearest output values */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    int32_t rI, cI;                              /* Row and column indices */
N    q15_t *pYData = S->pData;                    /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & (q31_t)0xFFF00000) >> 20);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & (q31_t)0xFFF00000) >> 20);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if (rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* xfract should be in 12.20 format */
N    xfract = (X & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI)    ];
N    x2 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI) + 1];
N
N    /* 20 bits for the fractional part */
N    /* yfract should be in 12.20 format */
N    yfract = (Y & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI + 1)    ];
N    y2 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI + 1) + 1];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 13.51 format */
N
N    /* x1 is in 1.15(q15), xfract in 12.20 format and out is in 13.35 format */
N    /* convert 13.35 to 13.31 by right shifting  and out is in 1.31 */
N    out = (q31_t) (((q63_t) x1 * (0xFFFFF - xfract)) >> 4u);
N    acc = ((q63_t) out * (0xFFFFF - yfract));
N
N    /* x2 * (xfract) * (1-yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) x2 * (0xFFFFF - yfract)) >> 4u);
N    acc += ((q63_t) out * (xfract));
N
N    /* y1 * (1 - xfract) * (yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) y1 * (0xFFFFF - xfract)) >> 4u);
N    acc += ((q63_t) out * (yfract));
N
N    /* y2 * (xfract) * (yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) y2 * (xfract)) >> 4u);
N    acc += ((q63_t) out * (yfract));
N
N    /* acc is in 13.51 format and down shift acc by 36 times */
N    /* Convert out to 1.15 format */
N    return ((q15_t)(acc >> 36));
N  }
N
N
N  /**
N  * @brief  Q7 bilinear interpolation.
N  * @param[in,out] S  points to an instance of the interpolation structure.
N  * @param[in]     X  interpolation coordinate in 12.20 format.
N  * @param[in]     Y  interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N  CMSIS_INLINE __STATIC_INLINE q7_t arm_bilinear_interp_q7(
X  __attribute__((always_inline)) static __inline q7_t arm_bilinear_interp_q7(
N  arm_bilinear_interp_instance_q7 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q63_t acc = 0;                               /* output */
N    q31_t out;                                   /* Temporary output */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    q7_t x1, x2, y1, y2;                         /* Nearest output values */
N    int32_t rI, cI;                              /* Row and column indices */
N    q7_t *pYData = S->pData;                     /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & (q31_t)0xFFF00000) >> 20);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & (q31_t)0xFFF00000) >> 20);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if (rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* xfract should be in 12.20 format */
N    xfract = (X & (q31_t)0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI)    ];
N    x2 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI) + 1];
N
N    /* 20 bits for the fractional part */
N    /* yfract should be in 12.20 format */
N    yfract = (Y & (q31_t)0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI + 1)    ];
N    y2 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI + 1) + 1];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 16.47 format */
N    out = ((x1 * (0xFFFFF - xfract)));
N    acc = (((q63_t) out * (0xFFFFF - yfract)));
N
N    /* x2 * (xfract) * (1-yfract)  in 2.22 and adding to acc */
N    out = ((x2 * (0xFFFFF - yfract)));
N    acc += (((q63_t) out * (xfract)));
N
N    /* y1 * (1 - xfract) * (yfract)  in 2.22 and adding to acc */
N    out = ((y1 * (0xFFFFF - xfract)));
N    acc += (((q63_t) out * (yfract)));
N
N    /* y2 * (xfract) * (yfract)  in 2.22 and adding to acc */
N    out = ((y2 * (yfract)));
N    acc += (((q63_t) out * (xfract)));
N
N    /* acc in 16.47 format and down shift by 40 to convert to 1.7 format */
N    return ((q7_t)(acc >> 40));
N  }
N
N  /**
N   * @} end of BilinearInterpolate group
N   */
N
N
N/* SMMLAR */
N#define multAcc_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((((q63_t) a) << 32) + ((q63_t) x * y) + 0x80000000LL ) >> 32)
X#define multAcc_32x32_keep32_R(a, x, y)     a = (q31_t) (((((q63_t) a) << 32) + ((q63_t) x * y) + 0x80000000LL ) >> 32)
N
N/* SMMLSR */
N#define multSub_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((((q63_t) a) << 32) - ((q63_t) x * y) + 0x80000000LL ) >> 32)
X#define multSub_32x32_keep32_R(a, x, y)     a = (q31_t) (((((q63_t) a) << 32) - ((q63_t) x * y) + 0x80000000LL ) >> 32)
N
N/* SMMULR */
N#define mult_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((q63_t) x * y + 0x80000000LL ) >> 32)
X#define mult_32x32_keep32_R(a, x, y)     a = (q31_t) (((q63_t) x * y + 0x80000000LL ) >> 32)
N
N/* SMMLA */
N#define multAcc_32x32_keep32(a, x, y) \
N    a += (q31_t) (((q63_t) x * y) >> 32)
X#define multAcc_32x32_keep32(a, x, y)     a += (q31_t) (((q63_t) x * y) >> 32)
N
N/* SMMLS */
N#define multSub_32x32_keep32(a, x, y) \
N    a -= (q31_t) (((q63_t) x * y) >> 32)
X#define multSub_32x32_keep32(a, x, y)     a -= (q31_t) (((q63_t) x * y) >> 32)
N
N/* SMMUL */
N#define mult_32x32_keep32(a, x, y) \
N    a = (q31_t) (((q63_t) x * y ) >> 32)
X#define mult_32x32_keep32(a, x, y)     a = (q31_t) (((q63_t) x * y ) >> 32)
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  /* Enter low optimization region - place directly above function definition */
N  #if defined( ARM_MATH_CM4 ) || defined( ARM_MATH_CM7)
X  #if 0L || 0L
S    #define LOW_OPTIMIZATION_ENTER \
S       _Pragma ("push")         \
S       _Pragma ("O1")
X    #define LOW_OPTIMIZATION_ENTER        _Pragma ("push")                _Pragma ("O1")
N  #else
N    #define LOW_OPTIMIZATION_ENTER
N  #endif
N
N  /* Exit low optimization region - place directly after end of function definition */
N  #if defined ( ARM_MATH_CM4 ) || defined ( ARM_MATH_CM7 )
X  #if 0L || 0L
S    #define LOW_OPTIMIZATION_EXIT \
S       _Pragma ("pop")
X    #define LOW_OPTIMIZATION_EXIT        _Pragma ("pop")
N  #else
N    #define LOW_OPTIMIZATION_EXIT
N  #endif
N
N  /* Enter low optimization region - place directly above function definition */
N  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
N
N  /* Exit low optimization region - place directly after end of function definition */
N  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
N
N#elif defined (__ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
S  #define LOW_OPTIMIZATION_ENTER
S  #define LOW_OPTIMIZATION_EXIT
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined ( __GNUC__ )
S  #define LOW_OPTIMIZATION_ENTER \
S       __attribute__(( optimize("-O1") ))
X  #define LOW_OPTIMIZATION_ENTER        __attribute__(( optimize("-O1") ))
S  #define LOW_OPTIMIZATION_EXIT
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined ( __ICCARM__ )
S  /* Enter low optimization region - place directly above function definition */
S  #if defined ( ARM_MATH_CM4 ) || defined ( ARM_MATH_CM7 )
S    #define LOW_OPTIMIZATION_ENTER \
S       _Pragma ("optimize=low")
X    #define LOW_OPTIMIZATION_ENTER        _Pragma ("optimize=low")
S  #else
S    #define LOW_OPTIMIZATION_ENTER
S  #endif
S
S  /* Exit low optimization region - place directly after end of function definition */
S  #define LOW_OPTIMIZATION_EXIT
S
S  /* Enter low optimization region - place directly above function definition */
S  #if defined ( ARM_MATH_CM4 ) || defined ( ARM_MATH_CM7 )
S    #define IAR_ONLY_LOW_OPTIMIZATION_ENTER \
S       _Pragma ("optimize=low")
X    #define IAR_ONLY_LOW_OPTIMIZATION_ENTER        _Pragma ("optimize=low")
S  #else
S    #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #endif
S
S  /* Exit low optimization region - place directly after end of function definition */
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined ( __TI_ARM__ )
S  #define LOW_OPTIMIZATION_ENTER
S  #define LOW_OPTIMIZATION_EXIT
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined ( __CSMC__ )
S  #define LOW_OPTIMIZATION_ENTER
S  #define LOW_OPTIMIZATION_EXIT
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined ( __TASKING__ )
S  #define LOW_OPTIMIZATION_ENTER
S  #define LOW_OPTIMIZATION_EXIT
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
N#endif
N
N
N#ifdef   __cplusplus
S}
N#endif
N
N/* Compiler specific diagnostic adjustment */
N#if   defined ( __CC_ARM )
X#if   1L
N
N#elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
S
S#elif defined ( __GNUC__ )
S#pragma GCC diagnostic pop
S
S#elif defined ( __ICCARM__ )
S
S#elif defined ( __TI_ARM__ )
S
S#elif defined ( __CSMC__ )
S
S#elif defined ( __TASKING__ )
S
S#else
S  #error Unknown compiler
N#endif
N
N#endif /* _ARM_MATH_H */
N
N/**
N *
N * End of file.
N */
L 29 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_qei.h" 2
N
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup qei_interface_gr QEI Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup QEI_LL_Driver QEI LL Driver
N  * @ingroup  qei_interface_gr
N  * @brief Mainly the driver part of the QEI module, which includes \b QEI \b Register 
N  * \b Constants, \b QEI \b Exported \b Constants, \b QEI \b Exported \b Struct, \b QEI
N  * \b Data \b transfers \b functions, \b QEI \b Initialization \b and \b QEI \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup QEI_LL_Register_Constants QEI LL Register Constants
N  * @ingroup  QEI_LL_Driver
N  * @brief    QEI LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the QEI 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the QEI register, mainly for convenience. Understand the 
N    configuration of the QEI.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** QEICON *****/
N/*! index match value use.
N */
N#define LL_QEI_IMV_USE_A(n)                         (((n)&0x1) << 19)
N/*! index match value use.
N */
N#define LL_QEI_IMV_USE_B(n)                         (((n)&0x1) << 18)
N/*! TYPE_ENUM_LL_QEI_ROTATE_SPEED_MODE
N */
N#define LL_QEI_ROTATE_SPEED_MODE(n)                 (((n)&0x1) << 17)
N/*! ROTATE_SPEED_EN.
N */
N#define LL_QEI_ROTATE_SPEED_EN                      (1UL << 16)
N/*! index match value .
N */
N#define LL_QEI_IMV_A(n)                             (((n)&0x1) << 15)
N/*! index match value .
N */
N#define LL_QEI_IMV_B(n)                             (((n)&0x1) << 14)
N/*! phase select TYPE_ENUM_LL_QEI_PHASE_SEL
N */
N#define LL_QEI_PH_X2(n)                             (((n)&0x1) << 13)
N/*! idle enable  .
N */
N#define LL_QEI_IDL_EN                               (1UL << 12)
N/*! direct up(1) or dn(0) :TYPE_ENUM_LL_QEI_DIRECTION 
N */
N#define LL_QEI_UPDN                                 (1UL << 11)
N/*! QEI mode :TYPE_ENUM_LL_QEI_MODE
N */
N#define LL_QEI_MODE(n)                              (((n)&0x7) << 8)
N/*! index match value select: 1:register, 0:hardware 
N */
N#define LL_QEI_IMVS(n)                              (((n)&0x1) << 7)
N/*! direct up(1) or dn(0) :TYPE_ENUM_LL_QEI_DIRECTION 
N */
N#define LL_QEI_TG(n)                                (((n)&0x1) << 5)
N/*! timer pre-scale :TYPE_ENUM_LL_QEI_TMR_PRESCALE 
N */
N#define LL_QEI_TCKPS(n)                             (((n)&0x3) << 3)
N/*! PULSE_RST_CNT enable  .
N */
N#define LL_QEI_PULSE_RST_CNT_EN                     (1UL << 2)
N/*! timer clock source :TYPE_ENUM_LL_QEI_TMR_CLK_SEL 
N */
N#define LL_QEI_TQCS(n)                              (((n)&0x1) << 1)
N/*! direct up or dn source :TYPE_ENUM_LL_QEI_UD_SRC_SEL 
N */
N#define LL_QEI_UDSRC(n)                             (((n)&0x1) << 0)
N
N
N/***** QEIO *****/
N/*! index value .
N */
N#define LL_QEI_IDX_VAL                              (1UL << 8)
N/*! pos dir state output enable 
N */
N#define LL_QEI_PSD_OUT_EN                           (1UL << 4)
N/*! qei source A B swap  enable
N */
N#define LL_QEI_SWAP_A_B_EN                          (1UL << 3)
N/*! index SRC reverse enable .
N */
N#define LL_QEI_IDX_INV_EN                           (1UL << 2)
N/*! QEB SRC reverse enable .
N */
N#define LL_QEI_QEB_INV_EN                           (1UL << 1)
N/*! QEA SRC reverse enable .
N */
N#define LL_QEI_QEA_INV_EN                           (1UL << 0)
N
N
N/***** DFLTCON *****/
N/*! digital filter enable 
N */
N#define LL_QEI_DFLT_EN                              (1UL << 7)
N/*! digital filter clock sel : TYPE_ENUM_LL_QEI_DFLT_PRESCALE 
N */
N#define LL_QEI_DFLT_CLK(n)                          (((n)&0x3) << 4)
N
N
N/***** QEIFLAG *****/
N/*! dir change flag 
N */
N#define LL_QEI_UPDN_INV_FLAG                        (1UL << 10)
N/*! SPEED_CNT error flag 
N */
N#define LL_QEI_SPEED_CNT_ERR                        (1UL << 9)
N/*! SPEED_CNT overflow flag 
N */
N#define LL_QEI_SPEED_CNT_OV                         (1UL << 8)
N/*! timer error flag 
N */
N#define LL_QEI_SPEED_TMR_ERR                        (1UL << 7)
N/*! timer overflow flag 
N */
N#define LL_QEI_SPEED_TMR_OV                         (1UL << 6)
N/*! timer gate failing flag 
N */
N#define LL_QEI_TG_FAILING                           (1UL << 5)
N/*! poscnt==maxcnt flag 
N */
N#define LL_QEI_POS_EQ_MAX                           (1UL << 4)
N/*! COUNTER error flag 
N */
N#define LL_QEI_CNT_ERR                              (1UL << 3)
N/*! IDX_RST_CNT  flag 
N */
N#define LL_QEI_IDX_RST_CNT                          (1UL << 2)
N/*! poscnt==maxcnt _RST_CNT flag 
N */
N#define LL_QEI_POS_EQ_MAX_RST_CNT                   (1UL << 1)
N/*! phase error flag 
N */
N#define LL_QEI_PHASE_ERR                            (1UL << 0)
N
N
N/***** QEICLR *****/
N/*! dir change flag clear 
N */
N#define LL_QEI_UPDN_INV_FLAG_CLR                    (1UL << 10)
N/*! SPEED_CNT error flag clear 
N */
N#define LL_QEI_SPEED_CNT_ERR_CLR                    (1UL << 9)
N/*! SPEED_CNT overflow flag clear 
N */
N#define LL_QEI_SPEED_CNT_OV_CLR                     (1UL << 8)
N/*! timer  error flag clear 
N */
N#define LL_QEI_SPEED_TMR_ERR_CLR                    (1UL << 7)
N/*! timer overflow flag clear 
N */
N#define LL_QEI_SPEED_TMR_OV_CLR                     (1UL << 6)
N/*! timer gate failing flag clear 
N */
N#define LL_QEI_TG_FAILING_CLR                       (1UL << 5)
N/*! poscnt==maxcnt flag clear 
N */
N#define LL_QEI_POS_EQ_MAX_CLR                       (1UL << 4)
N/*! COUNTER error flag clear  
N */
N#define LL_QEI_CNT_ERR_CLR                          (1UL << 3)
N/*! IDX_RST_CNT  flag clear 
N */
N#define LL_QEI_IDX_RST_CNT_CLR                      (1UL << 2)
N/*! poscnt==maxcnt _RST_CNT flag clear 
N */
N#define LL_QEI_POS_EQ_MAX_RST_CNT_CLR               (1UL << 1)
N/*! phase error flag clear 
N */
N#define LL_QEI_PHASE_ERR_CLR                        (1UL << 0)
N
N
N/***** QEIE *****/
N/*! dir change flag interrupt 
N */
N#define LL_QEI_UPDN_INV_FLAG_INT_EN                 (1UL << 10)
N/*! SPEED_CNT error flag interrupt 
N */
N#define LL_QEI_SPEED_CNT_ERR_INT_EN                 (1UL << 9)
N/*! SPEED_CNT overflow flag interrupt 
N */
N#define LL_QEI_SPEED_CNT_OV_INT_EN                  (1UL << 8)
N/*! timer  error flag interrupt 
N */
N#define LL_QEI_SPEED_TMR_ERR_INT_EN                 (1UL << 7)
N/*! timer overflow flag interrupt 
N */
N#define LL_QEI_SPEED_TMR_OV_INT_EN                  (1UL << 6)
N/*! timer gate failing flag interrupt 
N */
N#define LL_QEI_TG_FAILING_INT_EN                    (1UL << 5)
N/*! poscnt==maxcnt flag interrupt 
N */
N#define LL_QEI_POS_EQ_MAX_INT_EN                    (1UL << 4)
N/*! COUNTER error flag interrupt 
N */
N#define LL_QEI_CNT_ERR_INT_EN                       (1UL << 3)
N/*! IDX_RST_CNT  flag interrupt 
N */
N#define LL_QEI_IDX_RST_CNT_INT_EN                   (1UL << 2)
N/*! poscnt==maxcnt _RST_CNT flag interrupt 
N */
N#define LL_QEI_POS_EQ_MAX_RST_CNT_INT_EN            (1UL << 1)
N/*! phase error flag interrupt 
N */
N#define LL_QEI_PHASE_ERR_INT_EN                     (1UL << 0)
N
N
N/***** POSCNT *****/
N/***** MAXCNT *****/
N/***** QEI_TIMER_PERIOD *****/
N/***** QEI_TIMER_CNT *****/
N/***** QEI_TIMER_CNT_LATCH *****/
N/***** QEI_ROTATE_PERIOD *****/
N/***** QEI_ROTATE_CNT *****/
N/***** QEI_TIMER_ROTATE_LATCH *****/
N/***** POSCNT_LATCH *****/
N
N/**
N  * @}
N  */
N
N/** @defgroup QEI_LL_Exported_Constants QEI LL Exported Constants
N  * @ingroup  QEI_LL_Driver
N  * @brief    QEI LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N/**
N  * @brief QEI speed calculate mode enum
N  */
Ntypedef enum {
N    /*! M MODE 
N     */
N    LL_QEI_ROTATE_SPEED_MODE_M = 0,
N    /*! T MODE 
N     */
N    LL_QEI_ROTATE_SPEED_MODE_T = 1,
N} TYPE_ENUM_LL_QEI_ROTATE_SPEED_MODE;
N
N/**
N  * @brief QEI phase select enum
N  */
Ntypedef enum {
N    /*! QEA 
N     */
N    LL_QEI_PHASE_QEA = 0,
N    /*! QEB 
N     */
N    LL_QEI_PHASE_QEB = 1,
N} TYPE_ENUM_LL_QEI_PHASE_SEL;
N
N/**
N  * @brief QEI counter direction enum
N  */
Ntypedef enum {                      
N    /*! DIRECTION_UP 
N     */
N    LL_QEI_DIRECTION_UP   = 1,
N    /*! DIRECTION_DOWN 
N     */
N    LL_QEI_DIRECTION_DOWN = 0,
N} TYPE_ENUM_LL_QEI_DIRECTION;
N
N/**
N  * @brief QEI work mode enum
N  */
Ntypedef enum {
N    /*! mode none 
N     */
N    LL_QEI_MODE_DISABLE                      = 0,
N    /*! mode timer 
N     */
N//    LL_QEI_MODE_TMR  = 1,
N    /*! mode QE X2 , pos counter reset when 1'st index and match count 
N     */
N    LL_QEI_MODE_QEX2_RST_BY_1STIDX_AND_MATCH = 2,
N    /*! mode QE X4 , pos counter reset when 1'st index and match count 
N     */
N    LL_QEI_MODE_QEX4_RST_BY_1STIDX_AND_MATCH = 3,
N    /*! mode QE X2 , pos counter reset when index  
N     */
N    LL_QEI_MODE_QEX2_RST_BY_IDX              = 4,
N    /*! mode QE X2 , pos counter reset when match count 
N     */
N    LL_QEI_MODE_QEX2_RST_BY_MATCH            = 5,
N    /*! mode QE X4 , pos counter reset when index
N     */
N    LL_QEI_MODE_QEX4_RST_BY_IDX              = 6,
N    /*! mode QE X4 , pos counter reset when match count 
N     */
N    LL_QEI_MODE_QEX4_RST_BY_MATCH            = 7,
N
N} TYPE_ENUM_LL_QEI_MODE;
N    
N/**
N  * @brief QEI timer prescale enum
N  */
Ntypedef enum {
N    /*! timer pre-scale : 1:1 
N     */
N    LL_QEI_TMR_PRESCALE_0   = 0,
N    /*! timer pre-scale : 1:8
N     */
N    LL_QEI_TMR_PRESCALE_8   = 1,
N    /*! timer pre-scale : 1:64 
N     */
N    LL_QEI_TMR_PRESCALE_64  = 2,
N    /*! timer pre-scale : 1:256 
N     */
N    LL_QEI_TMR_PRESCALE_256 = 3,
N
N} TYPE_ENUM_LL_QEI_TMR_PRESCALE;
N
N/**
N  * @brief QEI timer clock enum
N  */
Ntypedef enum {
N    /*! LL_QEI_TMR_CLK_SEL QEA 
N     */
N    LL_QEI_TMR_CLK_QEA      = 1,
N    /*! LL_QEI_TMR_CLK_SEL internal clock 
N     */
N    LL_QEI_TMR_CLK_INTERNAL = 0,
N} TYPE_ENUM_LL_QEI_TMR_CLK_SEL;
N
N/**
N  * @brief QEI up&down source enum
N  */
Ntypedef enum {
N    /*! LL_QEI_UD_SRC QEB 
N     */
N    LL_QEI_UD_SRC_QEB    = 1,
N    /*! LL_QEI_UD_SRC internal reg 
N     */
N    LL_QEI_UD_SRC_UD_REG = 0,
N} TYPE_ENUM_LL_QEI_UD_SRC_SEL;
N
N/**
N  * @brief QEI digital filter prescale enum
N  */
Ntypedef enum {
N    /*! QEA/QEB/INDX pre-scale : 1:1 
N     */
N    LL_QEI_DFLT_PRESCALE_0   = 0,
N    /*! QEA/QEB/INDX pre-scale : 1:2 
N     */
N    LL_QEI_DFLT_PRESCALE_2   = 1,
N    /*! QEA/QEB/INDX pre-scale : 1:4 
N     */
N    LL_QEI_DFLT_PRESCALE_4   = 2,
N    /*! QEA/QEB/INDX pre-scale : 1:16 
N     */
N    LL_QEI_DFLT_PRESCALE_16  = 3,
N    /*! QEA/QEB/INDX pre-scale : 1:32 
N     */
N    LL_QEI_DFLT_PRESCALE_32  = 4,
N    /*! QEA/QEB/INDX pre-scale : 1:64 
N     */
N    LL_QEI_DFLT_PRESCALE_64  = 5,
N    /*! QEA/QEB/INDX pre-scale : 1:128 
N     */
N    LL_QEI_DFLT_PRESCALE_128 = 6,
N    /*! QEA/QEB/INDX pre-scale : 1:256 
N     */
N    LL_QEI_DFLT_PRESCALE_256 = 7,
N
N} TYPE_ENUM_LL_QEI_DFLT_PRESCALE;
N
N/**
N  * @brief QEI polarity enum
N  */
Ntypedef enum {
N    /*! LL_QEI_POLE invert 
N     */
N    LL_QEI_POLE_INV    = 1,
N    /*! LL_QEI_POLE_NORMAL  
N     */
N    LL_QEI_POLE_NORMAL = 0,
N} TYPE_ENUM_LL_QEI_POLE_SEL;
N
N/**
N  * @brief QEI index match value enum
N  */
Ntypedef enum {
N    /*! LL_QEI index match value config by IMV reg
N     */
N    LL_QEI_IMV_REG      = 1,
N    /*! LL_QEI index match value config by hardware
N     */
N    LL_QEI_IMV_HARDWARE = 0,
N} TYPE_ENUM_LL_QEI_IMV_SEL;
N
N
N/***** LL API AND DRIVER API *****/
N
N
N
N/**
N  * @}
N  */
N
N/** @defgroup QEI_LL_Exported_Struct QEI LL Exported Struct
N  * @ingroup  QEI_LL_Driver
N  * @brief    QEI LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the QEI registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_qei_init. Function, you can configure the QEI module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief configuration structure for low layer QEI interrupt
N  */ 
Ntypedef struct __ll_qei_irq_cfg {
N    /*! Interrupt enable control.
N     *  @note false represents disable interrupt, true represents enable interrupt.
N     */
N    /*! dir change flag interrupt
N     */
N    u16 updn_inv_intr_en               : 1,
N    /*! SPEED_CNT error flag interrupt
N     */
N        speed_cnt_err_intr_en          : 1,
N    /*! SPEED_CNT overflow flag interrupt
N     */
N        speed_cnt_ov_intr_en           : 1,
N    /*! timer  error flag interrupt
N     */
N        speed_tmr_err_intr_en          : 1,
N    /*! timer overflow flag interrupt
N     */
N        speed_tmr_ov_intr_en           : 1,
N    /*! timer gate failing flag interrupt
N     */
N        speed_tmr_gate_failing_intr_en : 1,
N    /*! poscnt==maxcnt flag interrupt
N     */
N        speed_pos_eq_max_intr_en       : 1,
N    /*! COUNTER error flag interrupt
N     */
N        speed_pos_cnt_err_intr_en      : 1,
N    /*! IDX_RST_CNT  flag interrupt
N     */
N        speed_idx_rst_cnt_intr_en      : 1,
N    /*! poscnt==maxcnt _RST_CNT flag interrupt
N     */
N        speed_max_eq_rst_cnt_intr_en   : 1,
N    /*! phase error flag interrupt
N     */
N        speed_phase_err_intr_en        : 1,
N    /*! reserved
N     */
N        reserverd                      : 6;
N    /*! digital filter enable
N     */
N} TYPE_LL_QEI_IRQ_CFG;
N
N/**
N  * @brief configuration structure for low layer QEI module struct
N  */ 
Ntypedef struct __ll_qei_cfg {
N    /*! qei mode, timer mode is not support in current sdk
N     */    
N    TYPE_ENUM_LL_QEI_MODE               mode;
N    /*! qei phase select, valid when QEIx2 mode
N     */    
N    TYPE_ENUM_LL_QEI_PHASE_SEL          phase;
N    /*! digital filter enable
N     */
N    bool                                dflt_en;
N    /*! digital filter pre-scale
N     */
N    TYPE_ENUM_LL_QEI_DFLT_PRESCALE      dflt_pre_scale;
N    /*! max count = 4/2(mode) * no_lines_encoder
N     */
N    u16                                 max_count;
N    /*! QEA Pole select
N     */
N    TYPE_ENUM_LL_QEI_POLE_SEL           qea_pole;
N    /*! QEB Pole select
N     */
N    TYPE_ENUM_LL_QEI_POLE_SEL           qeb_pole;
N    /*! INDEX Pole select
N     */
N    TYPE_ENUM_LL_QEI_POLE_SEL           idx_pole;
N    /*! swap QEA & QEB
N     */
N    bool                                qea_qeb_swap_en;
N    /*! updn direction output to IO enable
N     */
N    bool                                updn_dir_to_io_en;
N    /*! INDEX Match Value select, when index pulsed && (qea == imv_qea) && (qeb == imv_qeb), the 
N     *  pos counter will be reset( reg mode )
N     */
N    TYPE_ENUM_LL_QEI_IMV_SEL            imv_sel;
N    /*! INDEX Match Value reg : 0/1
N     */
N    u8                                  imv_qea;
N    /*! INDEX Match Value reg : 0/1
N     */
N    u8                                  imv_qeb;
N    /*! speed calculate enable
N     */
N    bool                                speed_calc_en;
N    /*! speed calculate mode 
N     */
N    TYPE_ENUM_LL_QEI_ROTATE_SPEED_MODE  speed_calc_mode;
N    /*! speed calculate M-mode set : time, related to speed_calc_mode
N     */
N    u32                                 speed_calc_time;
N    /*! speed calculate T-mode set : counter, related to speed_calc_mode
N     */
N    u32                                 speed_calc_counter;
N} TYPE_LL_QEI_CFG;
N
N/**
N  * @brief QEI low layer Initialization structure
N  */
Ntypedef struct __ll_qei_init {
N    u8 reserved;
N} TYPE_LL_QEI_INIT;
N
N
N/**
N  * @}
N  */
N
N/** @defgroup QEI_LL_Interrupt QEI LL Interrupt Handle function
N  * @brief   QEI LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the QEI  
N    Interrupt Handle function.
N
N    how to use?
N
N    The QEI interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the QEI in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup QEI_LL_Inti_Cfg QEI LL Initialization And Configuration
N  * @brief    QEI LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the QEI data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  Low layer QEI module initialization
N  * @param  p_qei : The structure pointer of the QEI is selected.
N  * @param  p_init: Module configuration structure pointer(TYPE_LL_QEI_INIT)
N  * @retval None
N  */
Nvoid ll_qei_init(QEI_TypeDef *p_qei, TYPE_LL_QEI_INIT *p_init);
N
N/**
N  * @brief  Low layer QEI module detele initialization
N  * @param  p_qei: The structure pointer of the QEI is selected.
N  * @retval None
N  */
Nvoid ll_qei_deinit(QEI_TypeDef *p_qei);
N
N/**
N  * @brief  Low layer QEI module configuration
N  * @param  p_qei: The structure pointer of the QEI is selected.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_QEI_IRQ_CFG)
N  * @retval None
N  */
Nvoid ll_qei_irq_config(QEI_TypeDef *p_qei, TYPE_LL_QEI_IRQ_CFG *p_cfg);
N
N/**
N  * @brief  Low layer QEI module configuration
N  * @param  p_qei: The structure pointer of the QEI is selected.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_QEI_CFG)
N  * @retval None
N  */
Nvoid ll_qei_config(QEI_TypeDef *p_qei, TYPE_LL_QEI_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup QEI_LL_Data_Transfers QEI LL Data transfers functions
N  * @brief    QEI LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the QEI data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  QEI module start function
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval None
N  */
Nvoid ll_qei_start(QEI_TypeDef *p_qei);
N
N/**
N  * @brief  QEI module stop function
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval None
N  */
Nvoid ll_qei_stop(QEI_TypeDef *p_qei);
N
N/**
N  * @brief  QEI get Motor Mechanical Angle function
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval angle [0, 1] for [0, 360] theta
N  */
Nfloat32_t ll_qei_get_mech_angle(QEI_TypeDef *p_qei);
N
N/**
N  * @brief  QEI get Motor Mechanical Angle function
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval angle [0, 32768] for [0, 360] theta
N  */
Ns16 ll_qei_get_mech_angle_q15(QEI_TypeDef *p_qei);
N
N/**
N  * @brief QEI get Motor speed calc result function
N  * @param p_qei   : Select the initialized QEI group pointer
N  * @param pos_cnt : qea/qeb counters
N  * @param time_cnt: apb1_clk counters
N  * @retval true : ok, false : fail
N  */
Nbool ll_qei_get_speed_result(QEI_TypeDef *p_qei, u32 *pos_cnt, u32 *time_cnt);
N
N/**
N  * @brief  ll_qei_updn_inv_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_updn_inv_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_updn_inv_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_UPDN_INV_FLAG_INT_EN;
X    p_qei->QEIE |= (1UL << 10);
N}
N
N/**
N  * @brief  ll_qei_updn_inv_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_updn_inv_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_updn_inv_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_UPDN_INV_FLAG_INT_EN;
X    p_qei->QEIE &= ~(1UL << 10);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_UPDN_INV_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_UPDN_INV_INTERRUPT_ENABLE(p_qei)       ((p_qei)->QEIE & LL_QEI_UPDN_INV_FLAG_INT_EN)
N
N/**
N  * @brief  QEI get direction inverting pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_UPDN_INV_PENDING(p_qei)                  ((p_qei)->QEIFLAG & LL_QEI_UPDN_INV_FLAG)
N
N/**
N  * @brief  QEI clear direction inverting pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_updn_inv_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_updn_inv_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_UPDN_INV_FLAG_CLR;
X    p_qei->QEICLR = (1UL << 10);
N}
N
N/**
N  * @brief  ll_qei_speed_cnt_err_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_speed_cnt_err_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_speed_cnt_err_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_SPEED_CNT_ERR_INT_EN;
X    p_qei->QEIE |= (1UL << 9);
N}
N
N/**
N  * @brief  ll_qei_speed_cnt_err_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_speed_cnt_err_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_speed_cnt_err_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_SPEED_CNT_ERR_INT_EN;
X    p_qei->QEIE &= ~(1UL << 9);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_SPEED_CNT_ERR_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_SPEED_CNT_ERR_INTERRUPT_ENABLE(p_qei)  ((p_qei)->QEIE & LL_QEI_SPEED_CNT_ERR_INT_EN)
N
N/**
N  * @brief  QEI SPEED_CNT error pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_SPEED_CNT_ERR_PENDING(p_qei)             ((p_qei)->QEIFLAG & LL_QEI_SPEED_CNT_ERR)
N
N/**
N  * @brief  QEI clear SPEED_CNT error pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_speed_cnt_err_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_speed_cnt_err_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_SPEED_CNT_ERR_CLR;
X    p_qei->QEICLR = (1UL << 9);
N}
N
N/**
N  * @brief  ll_qei_speed_cnt_ov_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_speed_cnt_ov_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_speed_cnt_ov_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_SPEED_CNT_OV_INT_EN;
X    p_qei->QEIE |= (1UL << 8);
N}
N
N/**
N  * @brief  ll_qei_speed_cnt_ov_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_speed_cnt_ov_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_speed_cnt_ov_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_SPEED_CNT_OV_INT_EN;
X    p_qei->QEIE &= ~(1UL << 8);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_SPEED_CNT_OV_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_SPEED_CNT_OV_INTERRUPT_ENABLE(p_qei)   ((p_qei)->QEIE & LL_QEI_SPEED_CNT_OV_INT_EN)
N
N/**
N  * @brief  QEI SPEED_CNT overflow pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_SPEED_CNT_OV_PENDING(p_qei)              ((p_qei)->QEIFLAG & LL_QEI_SPEED_CNT_OV)
N
N/**
N  * @brief  QEI clear SPEED_CNT overflow pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_speed_cnt_ov_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_speed_cnt_ov_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_SPEED_CNT_OV_CLR;
X    p_qei->QEICLR = (1UL << 8);
N}
N
N/**
N  * @brief  ll_qei_speed_tmr_err_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_speed_tmr_err_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_speed_tmr_err_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_SPEED_TMR_ERR_INT_EN;
X    p_qei->QEIE |= (1UL << 7);
N}
N
N/**
N  * @brief  ll_qei_speed_tmr_err_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_speed_tmr_err_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_speed_tmr_err_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_SPEED_TMR_ERR_INT_EN;
X    p_qei->QEIE &= ~(1UL << 7);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_TMR_ERR_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_TMR_ERR_INTERRUPT_ENABLE(p_qei)    ((p_qei)->QEIE & LL_QEI_SPEED_TMR_ERR_INT_EN)
N
N/**
N  * @brief  QEI timer  error pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_SPEED_GET_TMR_ERR_PENDING(p_qei)         ((p_qei)->QEIFLAG & LL_QEI_SPEED_TMR_ERR)
N
N/**
N  * @brief  QEI clear timer  error pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_speed_tmr_err_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_speed_tmr_err_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_SPEED_TMR_ERR_CLR;
X    p_qei->QEICLR = (1UL << 7);
N}
N
N/**
N  * @brief  ll_qei_speed_tmr_ov_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_speed_tmr_ov_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_speed_tmr_ov_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_SPEED_TMR_OV_INT_EN;
X    p_qei->QEIE |= (1UL << 6);
N}
N
N/**
N  * @brief  ll_qei_speed_tmr_ov_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_speed_tmr_ov_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_speed_tmr_ov_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_SPEED_TMR_OV_INT_EN;
X    p_qei->QEIE &= ~(1UL << 6);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_SPEED_TMR_OV_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_SPEED_TMR_OV_INTERRUPT_ENABLE(p_qei)   ((p_qei)->QEIE & LL_QEI_SPEED_TMR_OV_INT_EN)
N
N/**
N  * @brief  QEI timer overflow pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_SPEED_TMR_OV_PENDING(p_qei)              ((p_qei)->QEIFLAG & LL_QEI_SPEED_TMR_OV)
N
N/**
N  * @brief  QEI clear timer overflow pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_speed_tmr_ov_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_speed_tmr_ov_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_SPEED_TMR_OV_CLR;
X    p_qei->QEICLR = (1UL << 6);
N}
N
N/**
N  * @brief  ll_qei_tg_failing_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_tg_failing_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_tg_failing_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_TG_FAILING_INT_EN;
X    p_qei->QEIE |= (1UL << 5);
N}
N
N/**
N  * @brief  ll_qei_tg_failing_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_tg_failing_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_tg_failing_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_TG_FAILING_INT_EN;
X    p_qei->QEIE &= ~(1UL << 5);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_TG_FAILING_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_TG_FAILING_INTERRUPT_ENABLE(p_qei) ((p_qei)->QEIE & LL_QEI_TG_FAILING_INT_EN)
N
N/**
N  * @brief  QEI  timer gate failing pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_TG_FAILING_PENDING(p_qei)            ((p_qei)->QEIFLAG & LL_QEI_TG_FAILING)
N
N/**
N  * @brief  QEI clear timer gate failing pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_tg_failing_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_tg_failing_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_TG_FAILING_CLR;
X    p_qei->QEICLR = (1UL << 5);
N}
N
N/**
N  * @brief  ll_qei_pos_eq_max_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_pos_eq_max_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_pos_eq_max_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_POS_EQ_MAX_INT_EN;
X    p_qei->QEIE |= (1UL << 4);
N}
N
N/**
N  * @brief  ll_qei_pos_eq_max_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_pos_eq_max_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_pos_eq_max_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_POS_EQ_MAX_INT_EN;
X    p_qei->QEIE &= ~(1UL << 4);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_POS_EQ_MAX_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_POS_EQ_MAX_INTERRUPT_ENABLE(p_qei) ((p_qei)->QEIE & LL_QEI_POS_EQ_MAX_INT_EN)
N
N/**
N  * @brief  QEI  poscnt==maxcnt pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_POS_EQ_MAX_PENDING(p_qei)            ((p_qei)->QEIFLAG & LL_QEI_POS_EQ_MAX)
N
N/**
N  * @brief  QEI clear poscnt==maxcnt pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_pos_eq_max_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_pos_eq_max_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_POS_EQ_MAX_CLR;
X    p_qei->QEICLR = (1UL << 4);
N}
N
N/**
N  * @brief  ll_qei_cnt_err_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_cnt_err_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_cnt_err_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_CNT_ERR_INT_EN;
X    p_qei->QEIE |= (1UL << 3);
N}
N
N/**
N  * @brief  ll_qei_cnt_err_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_cnt_err_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_cnt_err_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_CNT_ERR_INT_EN;
X    p_qei->QEIE &= ~(1UL << 3);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_QEI_CNT_ERR_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_QEI_CNT_ERR_INTERRUPT_ENABLE(p_qei)    ((p_qei)->QEIE & LL_QEI_CNT_ERR_INT_EN)
N
N/**
N  * @brief  QEI  COUNTER error pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_QEI_CNT_ERR_PENDING(p_qei)               ((p_qei)->QEIFLAG & LL_QEI_CNT_ERR)
N
N/**
N  * @brief  QEI clear COUNTER error pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_qei_cnt_err_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_qei_cnt_err_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_CNT_ERR_CLR;
X    p_qei->QEICLR = (1UL << 3);
N}
N
N/**
N  * @brief  ll_qei_idx_rst_cnt_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_idx_rst_cnt_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_idx_rst_cnt_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_IDX_RST_CNT_INT_EN;
X    p_qei->QEIE |= (1UL << 2);
N}
N
N/**
N  * @brief  ll_qei_idx_rst_cnt_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_idx_rst_cnt_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_idx_rst_cnt_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_IDX_RST_CNT_INT_EN;
X    p_qei->QEIE &= ~(1UL << 2);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_IDX_RST_CNT_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_IDX_RST_CNT_INTERRUPT_ENABLE(p_qei)    ((p_qei)->QEIE & LL_QEI_IDX_RST_CNT_INT_EN)
N
N/**
N  * @brief  QEI  IDX_RST_CNT pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_IDX_RST_CNT_PENDING(p_qei)               ((p_qei)->QEIFLAG & LL_QEI_IDX_RST_CNT)
N
N/**
N  * @brief  QEI clear IDX_RST_CNT pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_idx_rst_cnt_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_idx_rst_cnt_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_IDX_RST_CNT_CLR;
X    p_qei->QEICLR = (1UL << 2);
N}
N
N/**
N  * @brief  ll_qei_pos_eq_max_rst_cnt_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_pos_eq_max_rst_cnt_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_pos_eq_max_rst_cnt_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_POS_EQ_MAX_RST_CNT_INT_EN;
X    p_qei->QEIE |= (1UL << 1);
N}
N
N/**
N  * @brief  ll_qei_pos_eq_max_rst_cnt_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_pos_eq_max_rst_cnt_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_pos_eq_max_rst_cnt_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_POS_EQ_MAX_RST_CNT_INT_EN;
X    p_qei->QEIE &= ~(1UL << 1);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_POS_EQ_MAX_RST_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_POS_EQ_MAX_RST_INTERRUPT_ENABLE(p_qei) ((p_qei)->QEIE & LL_QEI_POS_EQ_MAX_RST_CNT_INT_EN)
N
N/**
N  * @brief  QEI  poscnt==maxcnt _RST_CNT pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_POS_EQ_MAX_RST_CNT_PENDING(p_qei)        ((p_qei)->QEIFLAG & LL_QEI_POS_EQ_MAX_RST_CNT)
N
N/**
N  * @brief  QEI clear poscnt==maxcnt _RST_CNT pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_pos_eq_max_rst_cnt_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_pos_eq_max_rst_cnt_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_POS_EQ_MAX_RST_CNT_CLR;
X    p_qei->QEICLR = (1UL << 1);
N}
N
N/**
N  * @brief  ll_qei_phase_err_interrupt_enable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_phase_err_interrupt_enable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_phase_err_interrupt_enable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE |= LL_QEI_PHASE_ERR_INT_EN;
X    p_qei->QEIE |= (1UL << 0);
N}
N
N/**
N  * @brief  ll_qei_phase_err_interrupt_disable
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_phase_err_interrupt_disable(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_phase_err_interrupt_disable(QEI_TypeDef *p_qei) {
N    p_qei->QEIE &= ~LL_QEI_PHASE_ERR_INT_EN;
X    p_qei->QEIE &= ~(1UL << 0);
N}
N
N/**
N  * @brief  LL_QEI_CHECK_PHASE_ERR_INTERRUPT_ENABLE
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval interrupt enable
N  */
N#define LL_QEI_CHECK_PHASE_ERR_INTERRUPT_ENABLE(p_qei) ((p_qei)->QEIE & LL_QEI_PHASE_ERR_INT_EN)
N
N/**
N  * @brief  QEI  phase error pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_PHASE_ERR_PENDING(p_qei)           ((p_qei)->QEIFLAG & LL_QEI_PHASE_ERR)
N
N/**
N  * @brief  QEI clear phase error pending
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_qei_clear_phase_err_pending(QEI_TypeDef *p_qei) {
Xstatic __inline void ll_qei_clear_phase_err_pending(QEI_TypeDef *p_qei) {
N    p_qei->QEICLR = LL_QEI_PHASE_ERR_CLR;
X    p_qei->QEICLR = (1UL << 0);
N}
N
N/**
N  * @brief  QEI get idx state
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_IDX_STATE(p_qei)                   (((p_qei)->QEIO & LL_QEI_IDX_VAL))
N
N/**
N  * @brief  QEI get pos cnt
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_POS_CNT(p_qei)                     (((p_qei)->POSCNT))
N
N/**
N  * @brief  QEI get pos cnt LATCH
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_POS_CNT_LATCH(p_qei)               (((p_qei)->POSCNT_LATCH))
N
N/**
N  * @brief  QEI get MAX cnt
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_MAX_CNT(p_qei)                     (((p_qei)->MAXCNT))
N
N/**
N  * @brief  QEI get up & down direction 
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_DIR(p_qei)                         (((p_qei)->QEICON) & LL_QEI_UPDN)
N
N/**
N  * @brief  QEI get QEA value when index pulse reset pos_cnt
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_IDX_RST_QEA_POL(p_qei)             (((p_qei)->QEICON) & LL_QEI_IMV_USE_A)
N
N/**
N  * @brief  QEI get QEB value when index pulse reset pos_cnt
N  * @param  p_qei: Select the initialized QEI group pointer
N  * @retval pending value
N  */
N#define LL_QEI_GET_IDX_RST_QEB_POL(p_qei)             (((p_qei)->QEICON) & LL_QEI_IMV_USE_B)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_QEI_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 56 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_svpwm.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_svpwm.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_svpwm.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the SVPWM LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_SVPWM_H
N#define __TX_PHE_LL_SVPWM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup svpwm_interface_gr SVPWM Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup SVPWM_LL_Driver SVPWM LL Driver
N  * @ingroup  svpwm_interface_gr
N  * @brief Mainly the driver part of the SVPWM module, which includes \b SVPWM \b Register 
N  * \b Constants, \b SVPWM \b Exported \b Constants, \b SVPWM \b Exported \b Struct, \b SVPWM
N  * \b Data \b transfers \b functions, \b SVPWM \b Initialization \b and \b SVPWM \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N 
N/** @defgroup SVPWM_LL_Register_Constants SVPWM LL Register Constants
N  * @ingroup  SVPWM_LL_Driver
N  * @brief    SVPWM LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the SVPWM 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the SVPWM register, mainly for convenience. Understand the 
N    configuration of the SVPWM.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** SVPWM CON0 *****/
N/*! RW, When DATAERR_PND = 1, data error, whether to generate an interrupt.
N */
N#define LL_SVPWM_CON0_DER_INT_EN                  (1UL << 27)
N/*! RW, Svpwm counter match indication flag, whether to generate an interrupt
N */
N#define LL_SVPWM_CON0_MATCH_INT_EN                (1UL << 26)
N/*! RW, Clear svpwm counter match indicator flag.
N */
N#define LL_SVPWM_CON0_CLR_MATCH_PNG               (1UL << 25)
N/*! RW, TSvpwm counter match indicator flag. This flag is generated when the 
N *  internal svpwm counter matches the value of SVPWM_MATCHCON.
N */
N#define LL_SVPWM_CON0_MATCH_PNG                   (1UL << 24)
N/*! RW, Svpwm counter match output enable. Generates a match output pulse when 
N *  the internal svpwm counter matches the value of SVPWM_MATCHCON
N */
N#define LL_SVPWM_CON0_MATCH_EN                    (1UL << 23)
N/*! RW, The PWM output is inverted. The original output is 0, and the output is 1.
N */
N#define LL_SVPWM_CON0_PWMOUTINVT                  (1UL << 22)
N/*! RO, Svpwm working status query flag
N */
N#define LL_SVPWM_CON0_SVPWM_ON                    (1UL << 21)
N/*! RO, Data error indication flag
N */
N#define LL_SVPWM_CON0_DATAERR_PND                 (1UL << 20)
N/*! RO, Whether the input data has been loaded to indicate the flag
N */
N#define LL_SVPWM_CON0_LOADDATA_PND                (1UL << 19)
N/*! RW, Hardware protection flag. This indicator will only be valid when HWP_EN=1.
N */
N#define LL_SVPWM_CON0_HWP_PND                     (1UL << 18)
N/*! WO, Clear data error flag
N */
N#define LL_SVPWM_CON0_CLR_DERP                    (1UL << 17)
N/*! WO, Clear data load flag
N */
N#define LL_SVPWM_CON0_CLR_LDP                     (1UL << 16)
N/*! WO, Clear hardware protection flag
N */
N#define LL_SVPWM_CON0_CLR_HWP                     (1UL << 15)
N/*! WO, Software disables SVPWM function
N */
N#define LL_SVPWM_CON0_CLR_SVPWMEN                 (1UL << 14)
N/*! RW, SVPWM related control register write enable
N */
N#define LL_SVPWM_CON0_SVPWM_CFG_EN                (1UL << 13)
N/*! RW, Hardware protection time.When a hardware error occurs, the module
N *  automatically enters the hardware protection state and automatically
N *  shuts down the svpwm module (HWPRT_EN = 1 must be configured).
N *  time = FAULT_DEBC_TIME *64*Tclk.(Tclk is the module clock cycle)
N */
N#define LL_SVPWM_CON0_FAULT_DEBC_TIME(n)          (((n)&0xF) << 9)
N/*! RW, Whether to automatically turn off the SVPWM module after data error 
N *  (DATAERR_PND = 1)
N */
N#define LL_SVPWM_CON0_DERP_EN                     (1UL << 7)
N/*! RW, When hardware protection flag HWP_PND=1, whether interrupt is generated
N */
N#define LL_SVPWM_CON0_HWP_INT_EN                  (1UL << 6)
N/*! RW, When the input data usage indication flag LOADDATA_PND=1, whether an 
N *  interrupt is generated
N */
N#define LL_SVPWM_CON0_LOADDATA_INT_EN             (1UL << 5)
N/*! RW, Whether to start the hardware protection function
N */
N#define LL_SVPWM_CON0_HWPRT_EN                    (1UL << 4)
N/*! RW, Abc coordinate input data normalization factor selection
N */
N#define LL_SVPWM_CON0_NORM_FACTOR_SEL             (1UL << 3)
N/*! RW, Dead zone control enabled. After enabling, the dead time is configured 
N *  via register SVPWM_CON2 
N */
N#define LL_SVPWM_CON0_DT_EN                       (1UL << 2)
N/*! RW, Two-level, three-level SVPWM select signal
N */
N#define LL_SVPWM_CON0_LVL_SEL_THERE               (1UL << 1)
N/*! RW, Software opens SVPWM function
N */
N#define LL_SVPWM_CON0_M_EN                        (1UL << 0)
N
N
N/***** SVPEM CON1 *****/
N/*! RW, SVPWM switching time. The configuration value should be 1/2 of the actual 
N *  switching time. SW_TIME = round(1/2*Tsw/Tclk).Tsw is the actual switching cycle 
N *  time and Tclk is the SVPWM operating clock cycle. This register needs to set 
N *  SVPWM_CFG_EN=1 before writing.
N */
N#define LL_SVPWM_CON1_SW_TIME(n)                  (((n)&0xFFFF) << 0)
N
N
N/***** SVPWM CON2 *****/
N/*! RO, SVPWM dead time control time.DT_TIME = round (Tdt/Tclk), Tdt is the actual 
N *  dead time control time, and Tclk is the SVPWM duty cycle. This register needs 
N *  to be set after SVPWM_CFG_EN=1.
N */
N#define LL_SVPWM_CON2_DT_TIME(n)                  (((n)&0xFFF) << 0)
N
N
N/***** SVPWM CON3 *****/
N/*! RW, Abc coordinates input data normalization factor. When NORM_FACTOR_SEL=1, 
N *  the configuration will not take effect.NORM_FACTOR = sqrt(3)*m, m needs to be 
N *  less than 0.866, scaling method is Q14  
N */
N#define LL_SVPWM_CON3_NORM_FACTOR(n)              (((n)&0xFFFF) << 0)
N
N
N/***** SVPWM CON4 *****/
N/*! RW, Hardware error detection control signal
N */
N#define LL_SVPWM_CON4_FAULT_DECT_DIS(n)           (((n)&0xFFFF) << 0)
N
N
N/***** SVPWM CON5 *****/
N/*! RW, When HWP_SIG[n] = 1 in the hardware error judgment of the HWP_SIG signal 
N *  inside the module, it indicates that an error has occurred
N */
N#define LL_SVPWM_CON5_FAULT_INVERT(n)             (((n)&0xFFFF) << 0)
N
N
N/***** SVPWM REFA *****/
N/*! RW, Phase A input reference signal (abc coordinates)
N */
N#define LL_SVPWM_REFA(n)                          (((n)&0xFFFF) << 0)
N
N
N/***** SVPWM REFB *****/
N/*! RW, Phase B input reference signal (abc coordinates)
N */
N#define LL_SVPWM_REFB(n)                          (((n)&0xFFFF) << 0)
N
N
N/***** SVPWM REFC *****/
N/*! RW, Phase C input reference signal (abc coordinates)
N */
N#define LL_SVPWM_REFC(n)                          (((n)&0xFFFF) << 0)
N
N
N/***** SVPWM STC0 *****/
N/*! RO, The operating time of Vector B in a switching cycle
N */
N#define LL_SVPWM_STC_B(n)                         (((n)&0xFFFF) << 15)
N/*! RO, The operating time of Vector A1 in a switching cycle
N */
N#define LL_SVPWM_STC_A1(n)                        (((n)&0xFFFF) << 0)
N
N
N/***** SVPWM STC1 *****/
N/*! RO, The operating time of Vector A2 in a switching cycle
N */
N#define LL_SVPWM_STC_A2(n)                        (((n)&0xFFFF) << 15)
N/*! RO, The operating time of Vector C in a switching cycle
N */
N#define LL_SVPWM_STC_C(n)                         (((n)&0xFFFF) << 0)
N
N
N/***** SVPWM MATCH CON *****/
N/*! RW, The control register that matches the svpwm internal counter. When the 
N *  svpwm internal counter is consistent with this register, a matching pulse 
N *  signal and corresponding flag bit and interrupt are output.
N */
N#define LL_SVPWM_MATCH_CON(n)                     (((n)&0x1FFFF) << 0)
N
N
N/***** SVPWM ADC COM *****/
N/*! RW, SVPWM Triggers the ADC conversion enable signal. When the svpwm internal 
N *  counter coincides with SVPWM_MATCH_CON, a matched pulse signal is output for 
N *  triggering the ADC conversion
N */
N#define LL_SVPWM_ADC_AUTO_EN(n)                   (((n)&0x3FFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup SVPWM_LL_Exported_Constants SVPWM LL Exported Constants
N  * @ingroup  SVPWM_LL_Driver
N  * @brief    SVPWM LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N/*! RO, SVPWM Output IO Enable Key(A:0x54, B:0xA4, C:0x58)
N */ 
N#define LL_SVPWM_KEY_VALUE                        (SVPWM_KEY_C | SVPWM_KEY_B | SVPWM_KEY_A)
N
N/*! The macro defines the configuration enable of the SVPWM.
N */
N#define LL_SVPWM_REG_OPT(expression)            \
Ndo{                                             \
N    SVPWM->CON0 |= LL_SVPWM_CON0_SVPWM_CFG_EN;  \
N    expression;                                 \
N    SVPWM->CON0 &= ~LL_SVPWM_CON0_SVPWM_CFG_EN; \
N}while(0)
X#define LL_SVPWM_REG_OPT(expression)            do{                                                 SVPWM->CON0 |= LL_SVPWM_CON0_SVPWM_CFG_EN;      expression;                                     SVPWM->CON0 &= ~LL_SVPWM_CON0_SVPWM_CFG_EN; }while(0)
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for The SVPWM mode selection
N  */
Ntypedef enum {
N    /*! svpwm Two-level mode
N     */
N    LL_SVPWM_MODE_LVL_SEL_TWO = 0,
N    /*! svpwm Three-level mode
N     */
N    LL_SVPWM_MODE_LVL_SEL_THREE,
N} TYPE_ENUM_LL_SVPWM_MODE_SEL;
N
N/**
N  * @brief Enumeration constant for The SVPWM fault debc selection
N  */
Ntypedef enum {
N    /*! Set the hardware protection time and select 0.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL0 = 0,
N    /*! Set the hardware protection time and select 1.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL1,
N    /*! Set the hardware protection time and select 2.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL2,
N    /*! Set the hardware protection time and select 3.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL3,
N    /*! Set the hardware protection time and select 4.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL4,
N    /*! Set the hardware protection time and select 5.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL5,
N    /*! Set the hardware protection time and select 6.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL6,
N    /*! Set the hardware protection time and select 7.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL7,
N    /*! Set the hardware protection time and select 8.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL8,
N    /*! Set the hardware protection time and select 9.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL9,
N    /*! Set the hardware protection time and select 10.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL10,
N    /*! Set the hardware protection time and select 11.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL11,
N    /*! Set the hardware protection time and select 12.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL12,
N    /*! Set the hardware protection time and select 13.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL13,
N    /*! Set the hardware protection time and select 14.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL14,
N    /*! Set the hardware protection time and select 15.
N     */
N    LL_SVPWM_FAULT_DEBC_SEL15,
N} TYPE_ENUM_LL_SVPWM_FAULT_DEBC_SEL;
N
N/**
N  * @brief Enumeration constant for The SVPWM norm factor selection
N  */
Ntypedef enum {
N    /*! The abc coordinate input data normalization factor, choose 
N     *  to use the built-in normalization factor. 
N     */
N    LL_SVPWM_NORM_FACTOR_SEL_INTERNAL = 0,
N    /*! The abc coordinate enters the data normalization factor and 
N     *  selects the user-configured normalization factor.
N     */
N    LL_SVPWM_NORM_FACTOR_SEL_USER,
N} TYPE_ENUM_LL_SVPWM_NORM_FACTOR_SEL;
N
N/**
N  * @}
N  */
N
N/** @defgroup SVPWM_LL_Exported_Struct SVPWM LL Exported Struct
N  * @ingroup  SVPWM_LL_Driver
N  * @brief    SVPWM LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the SVPWM registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_svpwm_init. Function, you can configure the SVPWM module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief SVPWM interrupt low layer configuration structure
N  */
Ntypedef struct _ll_svpwm_irq_cfg {
N    /*! data err protect interrupt enable
N     */
N    bool dataerr_intr_en;
N    /*! adc auto trigle match interrupt enable
N     */
N    bool match_intr_en;
N    /*! hardware protect interrupt enable
N     */
N    bool hwp_intr_en;
N    /*! load data interrupt enable
N     */
N    bool load_data_intr_en;
N} TYPE_LL_SVPWM_IRQ_CFG;
N
N/**
N  * @brief SVPWM param low layer configuration structure
N  */
Ntypedef struct _ll_svpwm_cfg {
N    /*! deal timer enable
N     */
N    bool                               dead_time_en;
N    /*! hardware protect enable
N     */
N    bool                               hwp_en;
N    /*! pwm out inverted
N     */
N    bool                               pwm_out_invt_en;
N    /*! adc auto trigle match enable
N     */
N    bool                               match_en;
N    /*! data err protect enable
N     */
N    bool                               dataerr_protect_en;
N    /*! svpwm mode sel
N     */
N    TYPE_ENUM_LL_SVPWM_MODE_SEL        mode_sel;
N    /*! ABC coordinate input data normalization factor selection
N     */
N    TYPE_ENUM_LL_SVPWM_NORM_FACTOR_SEL norm_factor_sel;
N    /*! Hardware fault protection time
N     */
N    TYPE_ENUM_LL_SVPWM_FAULT_DEBC_SEL  fault_debc_sel;
N    
N    /*! SVPWM switching time. The configuration value should be 1/2 of the actual 
N     *  switching time. SW_TIME = round(1/2*Tsw/Tclk).Tsw is the actual switching cycle 
N     *  time and Tclk is the SVPWM operating clock cycle. This register needs to set 
N     *  SVPWM_CFG_EN=1 before writing.
N     */
N    u16                                period;
N    /*! SVPWM dead time control time. DT_TIME = round (Tdt/Tclk), Tdt is the actual 
N     *  dead time control time, and Tclk is the SVPWM duty cycle. This register needs 
N     *  to be set after SVPWM_CFG_EN=1, The range is between 0 and 4096.
N     */
N    u16                                dead_time;
N    /*! ABC coordinates input data normalization factor. When NORM_FACTOR_SEL=1, 
N     *  the configuration will not take effect.NORM_FACTOR = sqrt(3)*m, m needs to be 
N     *  less than 0.866, scaling method is Q14  
N     */
N    u16                                norm_factor;
N    /*! A control register that matches the svpwm internal counter. When the 
N     *  svpwm internal counter matches the register, a matching pulse signal 
N     *  and corresponding flag bits and interrupts are output. 
N     */
N    u32                                match_cnt;
N    /*! Phase A inputs the reference signal (abc coordinates). 
N     */
N    u16                                phase_a_val;
N    /*! Phase B inputs the reference signal (abc coordinates). 
N     */
N    u16                                phase_b_val;
N    /*! Phase C inputs the reference signal (abc coordinates). 
N     */
N    u16                                phase_c_val;
N    
N    union {
N        /*! hardware fault all channel disable
N         */
N        u16 hwp_fault_dis;
N        struct {
N            /*! hardware fault channel0 disable
N             */
N            u16 hwp_fault_dis0  : 1,
N            /*! hardware fault channel1 disable
N             */
N                hwp_fault_dis1  : 1,
N            /*! hardware fault channel2 disable
N             */
N                hwp_fault_dis2  : 1,
N            /*! hardware fault channel3 disable
N             */
N                hwp_fault_dis3  : 1,
N            /*! hardware fault channel4 disable
N             */
N                hwp_fault_dis4  : 1,
N            /*! hardware fault channel5 disable
N             */
N                hwp_fault_dis5  : 1,
N            /*! hardware fault channel6 disable
N             */
N                hwp_fault_dis6  : 1,
N            /*! hardware fault channel7 disable
N             */
N                hwp_fault_dis7  : 1,
N            /*! hardware fault channel8 disable
N             */
N                hwp_fault_dis8  : 1,
N            /*! hardware fault channel9 disable
N             */
N                hwp_fault_dis9  : 1,
N            /*! hardware fault channel10 disable
N             */
N                hwp_fault_dis10 : 1,
N            /*! hardware fault channel11 disable
N             */
N                hwp_fault_dis11 : 1,
N            /*! hardware fault channel12 disable
N             */
N                hwp_fault_dis12 : 1,
N            /*! hardware fault channel13 disable
N             */
N                hwp_fault_dis13 : 1,
N            /*! hardware fault channel14 disable
N             */
N                hwp_fault_dis14 : 1,
N            /*! hardware fault channel15 disable
N             */
N                hwp_fault_dis15 : 1;
N        };
N    };
N
N    union {
N        /*! hardware fault all channel invert 
N         */
N        u16 hwp_fault_invert;
N        struct {
N            /*! hardware fault channel0  invert 
N             */
N            u16 hwp_fault_invert0  : 1,
N            /*! hardware fault channel1  invert 
N             */
N                hwp_fault_invert1  : 1,
N            /*! hardware fault channel2  invert 
N             */
N                hwp_fault_invert2  : 1,
N            /*! hardware fault channel3  invert 
N             */
N                hwp_fault_invert3  : 1,
N            /*! hardware fault channel4  invert 
N             */
N                hwp_fault_invert4  : 1,
N            /*! hardware fault channel5  invert 
N             */
N                hwp_fault_invert5  : 1,
N            /*! hardware fault channel6  invert 
N             */
N                hwp_fault_invert6  : 1,
N            /*! hardware fault channel7  invert 
N             */
N                hwp_fault_invert7  : 1,
N            /*! hardware fault channel8  invert 
N             */
N                hwp_fault_invert8  : 1,
N            /*! hardware fault channel9  invert 
N             */
N                hwp_fault_invert9  : 1,
N            /*! hardware fault channel10 invert 
N             */
N                hwp_fault_invert10 : 1,
N            /*! hardware fault channel11 invert 
N             */
N                hwp_fault_invert11 : 1,
N            /*! hardware fault channel12 invert 
N             */
N                hwp_fault_invert12 : 1,
N            /*! hardware fault channel13 invert 
N             */
N                hwp_fault_invert13 : 1,
N            /*! hardware fault channel14 invert 
N             */
N                hwp_fault_invert14 : 1,
N            /*! hardware fault channel15 invert 
N             */
N                hwp_fault_invert15 : 1;
N        };
N    };
N
N    union {
N        /*! svpwm auto trigle adc all channel enable 
N         */
N        u16 adc_auto_chn;
N        struct {
N            /*! svpwm auto trigle adc channel0  enable 
N             */
N            u16 adc_auto_chn0  : 1,
N            /*! svpwm auto trigle adc channel1  enable 
N             */
N                adc_auto_chn1  : 1,
N            /*! svpwm auto trigle adc channel2  enable 
N             */
N                adc_auto_chn2  : 1,
N            /*! svpwm auto trigle adc channel3  enable 
N             */
N                adc_auto_chn3  : 1,
N            /*! svpwm auto trigle adc channel4  enable 
N             */
N                adc_auto_chn4  : 1,
N            /*! svpwm auto trigle adc channel5  enable 
N             */
N                adc_auto_chn5  : 1,
N            /*! svpwm auto trigle adc channel6  enable 
N             */
N                adc_auto_chn6  : 1,
N            /*! svpwm auto trigle adc channel7  enable 
N             */
N                adc_auto_chn7  : 1,
N            /*! svpwm auto trigle adc channel8  enable 
N             */
N                adc_auto_chn8  : 1,
N            /*! svpwm auto trigle adc channel9  enable 
N             */
N                adc_auto_chn9  : 1,
N            /*! svpwm auto trigle adc channel10 enable 
N             */
N                adc_auto_chn10 : 1,
N            /*! svpwm auto trigle adc channel11 enable 
N             */
N                adc_auto_chn11 : 1,
N            /*! svpwm auto trigle adc channel12 enable 
N             */
N                adc_auto_chn12 : 1,
N            /*! svpwm auto trigle adc channel13 enable 
N             */
N                adc_auto_chn13 : 1;
N        };
N    };
N} TYPE_LL_SVPWM_CFG;
N
N/**
N  * @brief SVPWM low layer Initialization structure
N  */
Ntypedef struct _ll_svpwm_init {
N    u8 reserved;
N} TYPE_LL_SVPWM_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup SVPWM_LL_Interrupt SVPWM LL Interrupt Handle function
N  * @brief   SVPWM LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SVPWM  
N    Interrupt Handle function.
N
N    how to use?
N
N    The SVPWM interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the SVPWM in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup SVPWM_LL_Inti_Cfg SVPWM LL Initialization And Configuration
N  * @brief    SVPWM LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SVPWM data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Low layer SVPWM module initialization
N  * @param  p_svpwm: The structure pointer of the SVPWM is selected.
N  * @param  p_init: Module configuration structure pointer(TYPE_LL_SVPWM_INIT)
N  * @retval None
N  */
Nvoid ll_svpwm_init(SVPWM_TypeDef *p_svpwm, TYPE_LL_SVPWM_INIT *p_init);
N
N/**
N  * @brief  Low layer SVPWM module detele initialization
N  * @param  p_svpwm: The structure pointer of the SVPWM is selected.
N  * @retval None
N  */
Nvoid ll_svpwm_deinit(SVPWM_TypeDef *p_svpwm);
N
N/**
N  * @brief  Low layer SVPWM module interrupt configuration
N  * @param  p_svpwm: The structure pointer of the SVPWM is selected.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_SVPWM_IRQ_CFG)
N  * @retval None
N  */
Nvoid ll_svpwm_irq_config(SVPWM_TypeDef *p_svpwm, TYPE_LL_SVPWM_IRQ_CFG *p_cfg);
N
N/**
N  * @brief  Low layer SVPWM module configuration
N  * @param  p_svpwm: The structure pointer of the SVPWM is selected.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_SVPWM_DMA_CFG)
N  * @retval None
N  */
Nvoid ll_svpwm_config(SVPWM_TypeDef *p_svpwm, TYPE_LL_SVPWM_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup SVPWM_LL_Data_Transfers SVPWM LL Data transfers functions
N  * @brief    SVPWM LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the SVPWM data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  SVPWM module start function
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
Nvoid ll_svpwm_start(SVPWM_TypeDef *p_svpwm);
N
N/**
N  * @brief  SVPWM module stop function
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
Nvoid ll_svpwm_stop(SVPWM_TypeDef *p_svpwm);
N
N/**
N  * @brief  SVPWM module get pending
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval pending
N  */
N#define LL_SVPWM_GET_PENDING(p_svpwm)                             ((p_svpwm)->CON0)
N
N/**
N  * @brief  SVPWM module check match interrupt enable
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval pending
N  */
N#define LL_SVPWM_CHECK_MATCH_INTERRUPT_ENABLE(p_svpwm)            ((p_svpwm)->CON0 & LL_SVPWM_CON0_MATCH_INT_EN)
N
N/**
N  * @brief  SVPWM module check data error interrupt enable
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval pending
N  */
N#define LL_SVPWM_CHECK_DATA_ERR_INTERRUPT_ENABLE(p_svpwm)         ((p_svpwm)->CON0 & LL_SVPWM_CON0_DER_INT_EN)
N
N/**
N  * @brief  SVPWM module check load data interrupt enable
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval pending
N  */
N#define LL_SVPWM_CHECK_LOAD_DATA_INTERRUPT_ENABLE(p_svpwm)        ((p_svpwm)->CON0 & LL_SVPWM_CON0_LOADDATA_INT_EN)
N
N/**
N  * @brief  SVPWM module check hardware protect interrupt enable
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval pending
N  */
N#define LL_SVPWM_CHECK_HARDWARE_PROTECT_INTERRUPT_ENABLE(p_svpwm) ((p_svpwm)->CON0 & LL_SVPWM_CON0_HWP_INT_EN)
N
N/**
N  * @brief  SVPWM get match pending
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N#define LL_SVPWM_GET_MATCH_PENDING(p_svpwm)                       ((p_svpwm)->CON0 & LL_SVPWM_CON0_MATCH_PNG)
N
N/**
N  * @brief  SVPWM get data err pending
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N#define LL_SVPWM_GET_DATA_ERR_PENDING(p_svpwm)                    ((p_svpwm)->CON0 & LL_SVPWM_CON0_DATAERR_PND)
N
N/**
N  * @brief  SVPWM get load data pending
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N#define LL_SVPWM_GET_LOAD_DATA_PENDING(p_svpwm)                   ((p_svpwm)->CON0 & LL_SVPWM_CON0_LOADDATA_PND)
N
N/**
N  * @brief  SVPWM get hardware protect pending
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N#define LL_SVPWM_GET_HARDWARE_PROTECT_PENDING(p_svpwm)            ((p_svpwm)->CON0 & LL_SVPWM_CON0_HWP_PND)
N
N/**
N  * @brief  SVPWM clear match pending
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_clear_match_pending(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_clear_match_pending(SVPWM_TypeDef *p_svpwm) {
N    p_svpwm->CON0 |= LL_SVPWM_CON0_CLR_MATCH_PNG;
X    p_svpwm->CON0 |= (1UL << 25);
N}
N
N/**
N  * @brief  SVPWM clear data err pending
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_clear_data_err_pending(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_clear_data_err_pending(SVPWM_TypeDef *p_svpwm) {
N    p_svpwm->CON0 |= LL_SVPWM_CON0_CLR_DERP;
X    p_svpwm->CON0 |= (1UL << 17);
N}
N
N/**
N  * @brief  SVPWM clear load data pending
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_clear_load_data_pending(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_clear_load_data_pending(SVPWM_TypeDef *p_svpwm) {
N    p_svpwm->CON0 |= LL_SVPWM_CON0_CLR_LDP;
X    p_svpwm->CON0 |= (1UL << 16);
N}
N
N/**
N  * @brief  SVPWM clear hardware protect pending
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_clear_hardware_protect_pending(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_clear_hardware_protect_pending(SVPWM_TypeDef *p_svpwm) {
N    p_svpwm->CON0 |= LL_SVPWM_CON0_CLR_HWP;
X    p_svpwm->CON0 |= (1UL << 15);
N}
N
N/**
N  * @brief  SVPWM wait load data pending
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_wait_load_data_pending(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_wait_load_data_pending(SVPWM_TypeDef *p_svpwm) {
N    while(!(p_svpwm->CON0 & LL_SVPWM_CON0_LOADDATA_PND));
X    while(!(p_svpwm->CON0 & (1UL << 19)));
N    p_svpwm->CON0 |= LL_SVPWM_CON0_CLR_LDP;
X    p_svpwm->CON0 |= (1UL << 16);
N}
N
N/**
N  * @brief  SVPWM set phase switch time value function
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @param  sw_val: Set the value of switch time.
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_set_switch_time_value(SVPWM_TypeDef *p_svpwm, u16 sw_val) {
Xstatic __inline void ll_svpwm_set_switch_time_value(SVPWM_TypeDef *p_svpwm, u16 sw_val) {
N    LL_SVPWM_REG_OPT(
N        p_svpwm->CON1 = LL_SVPWM_CON1_SW_TIME(sw_val);
N    );
X    do{ ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 |= (1UL << 13); p_svpwm->CON1 = (((sw_val)&0xFFFF) << 0);; ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 &= ~(1UL << 13); }while(0);
N}
N
N/**
N  * @brief  SVPWM set phase dead time time value function
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @param  dt_val: Set the value of dead time.
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_set_dead_time_value(SVPWM_TypeDef *p_svpwm, u16 dt_val) {
Xstatic __inline void ll_svpwm_set_dead_time_value(SVPWM_TypeDef *p_svpwm, u16 dt_val) {
N    LL_SVPWM_REG_OPT(
N        p_svpwm->CON2 = LL_SVPWM_CON2_DT_TIME(dt_val);
N    );
X    do{ ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 |= (1UL << 13); p_svpwm->CON2 = (((dt_val)&0xFFF) << 0);; ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 &= ~(1UL << 13); }while(0);
N}
N
N/**
N  * @brief  SVPWM set phase value function
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @param  phase_a_val: Set the value of phase A.
N  * @param  phase_b_val: Set the value of phase B.
N  * @param  phase_c_val: Set the value of phase C.
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_set_phase_value(SVPWM_TypeDef *p_svpwm, 
Xstatic __inline void ll_svpwm_set_phase_value(SVPWM_TypeDef *p_svpwm, 
N                                              u16 phase_a_val,
N                                              u16 phase_b_val,
N                                              u16 phase_c_val) {
N    p_svpwm->REFA = LL_SVPWM_REFA(phase_a_val);
X    p_svpwm->REFA = (((phase_a_val)&0xFFFF) << 0);
N    p_svpwm->REFB = LL_SVPWM_REFB(phase_b_val);
X    p_svpwm->REFB = (((phase_b_val)&0xFFFF) << 0);
N    p_svpwm->REFC = LL_SVPWM_REFC(phase_c_val);
X    p_svpwm->REFC = (((phase_c_val)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  SVPWM enable data err interrupt
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_data_err_interrupt_enable(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_data_err_interrupt_enable(SVPWM_TypeDef *p_svpwm) {
N    LL_SVPWM_REG_OPT(
N        p_svpwm->CON0 |= LL_SVPWM_CON0_DER_INT_EN;
N    );
X    do{ ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 |= (1UL << 13); p_svpwm->CON0 |= (1UL << 27);; ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 &= ~(1UL << 13); }while(0);
N}
N
N/**
N  * @brief  SVPWM disable data err interrupt
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_data_err_interrupt_disable(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_data_err_interrupt_disable(SVPWM_TypeDef *p_svpwm) {
N    LL_SVPWM_REG_OPT(
N        p_svpwm->CON0 &= ~(LL_SVPWM_CON0_DER_INT_EN);
N    );
X    do{ ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 |= (1UL << 13); p_svpwm->CON0 &= ~((1UL << 27));; ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 &= ~(1UL << 13); }while(0);
N}
N
N/**
N  * @brief  SVPWM enable match interrupt
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_match_interrupt_enable(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_match_interrupt_enable(SVPWM_TypeDef *p_svpwm) {
N    LL_SVPWM_REG_OPT(
N        p_svpwm->CON0 |= LL_SVPWM_CON0_MATCH_INT_EN;
N    );
X    do{ ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 |= (1UL << 13); p_svpwm->CON0 |= (1UL << 26);; ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 &= ~(1UL << 13); }while(0);
N}
N
N/**
N  * @brief  SVPWM disable match interrupt
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_match_interrupt_disable(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_match_interrupt_disable(SVPWM_TypeDef *p_svpwm) {
N    LL_SVPWM_REG_OPT(
N        p_svpwm->CON0 &= ~(LL_SVPWM_CON0_MATCH_INT_EN);
N    );
X    do{ ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 |= (1UL << 13); p_svpwm->CON0 &= ~((1UL << 26));; ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 &= ~(1UL << 13); }while(0);
N}
N
N/**
N  * @brief  SVPWM enable hardware protect interrupt
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_hardware_protect_interrupt_enable(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_hardware_protect_interrupt_enable(SVPWM_TypeDef *p_svpwm) {
N    LL_SVPWM_REG_OPT(
N        p_svpwm->CON0 |= LL_SVPWM_CON0_HWP_INT_EN;
N    );
X    do{ ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 |= (1UL << 13); p_svpwm->CON0 |= (1UL << 6);; ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 &= ~(1UL << 13); }while(0);
N}
N
N/**
N  * @brief  SVPWM disable hardware protect interrupt
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_hardware_protect_interrupt_disable(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_hardware_protect_interrupt_disable(SVPWM_TypeDef *p_svpwm) {
N    LL_SVPWM_REG_OPT(
N        p_svpwm->CON0 &= ~(LL_SVPWM_CON0_HWP_INT_EN);
N    );
X    do{ ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 |= (1UL << 13); p_svpwm->CON0 &= ~((1UL << 6));; ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 &= ~(1UL << 13); }while(0);
N}
N
N/**
N  * @brief  SVPWM enable load data interrupt
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_load_data_interrupt_enable(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_load_data_interrupt_enable(SVPWM_TypeDef *p_svpwm) {
N    LL_SVPWM_REG_OPT(
N        p_svpwm->CON0 |= LL_SVPWM_CON0_LOADDATA_INT_EN;
N    );
X    do{ ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 |= (1UL << 13); p_svpwm->CON0 |= (1UL << 5);; ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 &= ~(1UL << 13); }while(0);
N}
N
N/**
N  * @brief  SVPWM disable load data interrupt
N  * @param  p_svpwm: Select the initialized SVPWM group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_svpwm_load_data_interrupt_disable(SVPWM_TypeDef *p_svpwm) {
Xstatic __inline void ll_svpwm_load_data_interrupt_disable(SVPWM_TypeDef *p_svpwm) {
N    LL_SVPWM_REG_OPT(
N        p_svpwm->CON0 &= ~(LL_SVPWM_CON0_LOADDATA_INT_EN);
N    );
X    do{ ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 |= (1UL << 13); p_svpwm->CON0 &= ~((1UL << 5));; ((SVPWM_TypeDef *) ((((uint32_t)0x40000000) + 0x30000) + 0x3000))->CON0 &= ~(1UL << 13); }while(0);
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_SVPWM_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 57 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_iic.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_iic.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_iic.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.1
N  * @date    03-08-2018
N  * @brief   This file contains all the IIC LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_IIC_H
N#define __TX_PHE_LL_IIC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup iic_interface_gr IIC Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup IIC_LL_Driver IIC LL Driver
N  * @ingroup  iic_interface_gr
N  * @brief Mainly the driver part of the IIC module, which includes \b IIC \b Register 
N  * \b Constants, \b IIC \b Exported \b Constants, \b IIC \b Exported \b Struct, \b IIC
N  * \b Data \b transfers \b functions, \b IIC \b Initialization \b and \b IIC \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N 
N/** @defgroup IIC_LL_Register_Constants IIC LL Register Constants
N  * @ingroup  IIC_LL_Driver
N  * @brief    IIC LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the IIC 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the IIC register, mainly for convenience. Understand the 
N    configuration of the IIC.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** IC_CON(IIC Control Register) *****/
N/*! In slave, controls to enable DW_apb_i2c slave as persistentor non-persistent slave
N */
N#define LL_IIC_CON_SMBUS_PERSISTANT_SLV_ADDR_EN             (1UL << 19)
N/*! In slave, controls whether DW_apb_i2c should enable Address Resolution Logic in 
N *  SMBus Mode 
N */
N#define LL_IIC_CON_SMBUS_ARP_EN                             (1UL << 18)
N/*! In slave, controls DW_apb_i2c slave only receives Quick commands in SMBus Mode
N */
N#define LL_IIC_CON_SMBUS_SLAVE_QUICK_CMD_EN                 (1UL << 17)
N/*! In slave, Enables the usage of IC_OPTIONAL_SAR register
N */
N#define LL_IIC_CON_OPTION_SAR_CTRL                          (1UL << 16)
N/*! In master, bus clear feature enable/disable
N */
N#define LL_IIC_CON_BUS_CLEAR_FEATURE_CTRL                   (1UL << 11)
N/*! in master, stop dectect signal if only/whether the master is active
N */
N#define LL_IIC_CON_STOP_DEC_IF_MASTER_ACTINE                (1UL << 10)
N/*! This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is 
N *  physically full to its RX_BUFFER_DEPTH 
N */
N#define LL_IIC_CON_RX_FIFO_FULL_HLD_CTRL                    (1UL << 9)
N/*! This bit controls the generation of the TX_EMPTY interrupt, as described in the 
N *  LL_IIC_IC_RAW_INTR_STAT register
N */
N#define LL_IIC_CON_TX_EMPTY_CTRL                            (1UL << 8)
N/*! In slave, stop dectect signal if only/whether the master is active
N */
N#define LL_IIC_CON_STOP_DET_IFADDRESSED                     (1UL << 7)
N/*! Enable/Disable IIC slave
N */
N#define LL_IIC_CON_IC_SLAVE_DISABLE                         (1UL << 6)
N/*! Determines whether RESTART conditions may be sent when acting as a master
N */
N#define LL_IIC_CON_IC_RESTART_EN                            (1UL << 5)
N/*! In master, support 7bit/10bit address
N */
N#define LL_IIC_CON_IC10BITADDR_MASTER                       (1UL << 4)
N/*! In slave, support 7bit/10bit address
N */
N#define LL_IIC_CON_IC10BITADDR_SLAVE                        (1UL << 3)
N/*! These bits control at which speed the DW_apb_i2c operates
N */
N#define LL_IIC_CON_SPEED(n)                                 (((n)&0x3) << 1)
N/*! This bit controls whether the DW_apb_i2c master is enabled
N */
N#define LL_IIC_CON_MASTER_MODE                              (1UL << 0)
N
N
N/***** IC_TAR(IIC Target Address Register) *****/
N/*! If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a Quick command 
N *  is to be performed by the DW_apb_i2c 
N */
N#define LL_IIC_TAR_SMBUS_QUICK_CMD                          (1UL << 16)
N/*! If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a Device-ID of
N *  a particular slave mentioned in IC_TAR[6:0] is to be performed by the DW_apb_i2c 
N *  Master
N */
N#define LL_IIC_TAR_DEVICE_ID                                (1UL << 13)
N/*! This bit controls whether the DW_apb_i2c starts its transfers in 7-or 10-bit 
N *  addressing mode when acting as a master 
N */
N#define LL_IIC_TAR_IC_10BITADDR_MASTER                      (1UL << 12)
N/*! indicates whether software performs a Device-ID, General Call or START BYTE command
N */
N#define LL_IIC_TAR_SPECIAL                                  (1UL << 11)
N/*! If bit 11 (SPECIAL) is set to 1 and bit 13 (Device-ID) is set to 0, then this bit 
N *  indicates whether a General Call or START byte command is to be performed by the 
N *  DW_apb_i2c
N */
N#define LL_IIC_TAR_GC_OR_START                              (1UL << 10)
N/*! This is the target address for any master transaction
N */
N#define LL_IIC_TAR_IC_TAR(n)                                (((n)&0x3FF) << 0)
N
N
N/***** IC_SAR(IIC Slave Address Register) *****/
N/*! The IC_SAR holds the slave address when the I2C is operating as a slave
N */
N#define LL_IIC_SAR_IC_SAR(n)                                (((n)&0x3FF) << 0)
N
N
N/***** IC_HS_MADDR(IIC High Speed Master Mode Code Address Register) *****/
N/*! This bit field holds the value of the I2C HS mode master code
N */
N#define LL_IIC_HS_MADDR_IC_HS_MAR(n)                        (((n)&0x7) << 0)
N
N
N/***** IC_DATA_CMD(IIC Rx/Tx Data Buffer and Command Register) *****/
N/*! Indicates the first data byte received after the address phase for receive transfer
N *  in Master receiver or Slave receiver mode 
N */
N#define LL_IIC_DATA_CMD_FIRST_DATA_BYTE                     (1UL << 11)
N/*! This bit controls whether a RESTART is issued before the byte is sent or received
N */
N#define LL_IIC_DATA_CMD_RESTART                             (1UL << 10)
N/*! This bit controls whether a STOP is issued after the byte is sent or received
N */
N#define LL_IIC_DATA_CMD_STOP                                (1UL << 9)
N/*! This bit controls whether a read or a write is performed
N */
N#define LL_IIC_DATA_CMD_CMD                                 (1UL << 8)
N/*! This register contains the data to be transmitted or received on the I2C bus
N */
N#define LL_IIC_DATA_CMD_DAT(n)                              (((n)&0xFF) << 0)
N
N
N/***** IC_SS_SCL_HCNT(Standard Speed I2C Clock SCL High Count Register) *****/
N/*! This register must be set before any I2C bus transaction can take place to ensure 
N *  proper I/O timing, This register sets the SCL clock high-period count for standard 
N *  speed
N */
N#define LL_IIC_IC_SS_SCL_HCNT(n)                            (((n)&0xFFFF) << 0)
N
N
N/***** IC_SS_SCL_LCNT(Standard Speed I2C Clock SCL Low Count Register) *****/
N/*! This register must be set before any I2C bus transaction can take place to ensure 
N *  proper I/O timing. This register sets the SCL clock low period count for standard 
N *  speed
N */
N#define LL_IIC_IC_SS_SCL_LCNT(n)                            (((n)&0xFFFF) << 0)
N
N
N/***** IC_FS_SCL_HCNT(Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register) *****/
N/*! This register must be set before any I2C bus transaction can take place to ensure 
N *  proper I/O timing. This reg sets the SCL clock high-period count for fast mode or 
N *  fast mode plus
N */
N#define LL_IIC_IC_FS_SCL_HCNT(n)                            (((n)&0xFFFF) << 0)
N
N
N/***** IC_FS_SCL_LCNT(Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register) *****/
N/*! This register must be set before any I2C bus transaction can take place to ensure 
N *  proper I/O timing. This reg sets the SCL clock low period count for fast mode or 
N *  fast mode plus
N */
N#define LL_IIC_IC_FS_SCL_LCNT(n)                            (((n)&0xFFFF) << 0)
N
N
N/***** IC_HS_SCL_HCNT(High Speed I2C Clock SCL High Count Register) *****/
N/*! This register must be set before any I2C bus transaction can take place to ensure 
N *  proper I/O timing. This register sets the SCL clock high period count for high speed
N */ 
N#define LL_IIC_IC_HS_SCL_HCNT(n)                            (((n)&0xFFFF) << 0)
N
N
N/***** IC_HS_SCL_LCNT(High Speed I2C Clock SCL Low Count Register) *****/
N/*! This register must be set before any I2C bus transaction can take place toensure 
N *  proper I/O timing. This register sets the SCL clock low period count for high speed
N */
N#define LL_IIC_IC_HS_SCL_LCNT(n)                            (((n)&0xFFFF) << 0)
N
N
N/***** IC_INTR_STAT(IIC Interrupt Status Register) *****/
N/*! See IC_RAW_INTR_STAT for a detailed description of this bit.
N */
N#define LL_IIC_INTR_STAT_R_SCL_STUCK_AT_LOW                 (1UL << 14)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_MST_ON_HOLD                      (1UL << 13)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_RESTART_DET                      (1UL << 12)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_GEN_CALL                         (1UL << 11)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_START_DET                        (1UL << 10)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_STOP_DET                         (1UL << 9)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_ACTIVITY                         (1UL << 8)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_RX_DONE                          (1UL << 7)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_TX_ABRT                          (1UL << 6)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_RD_REQ                           (1UL << 5)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_TX_EMPTY                         (1UL << 4)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_TX_OVER                          (1UL << 3)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_RX_FULL                          (1UL << 2)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_RX_OVER                          (1UL << 1)
N/*! See IC_RAW_INTR_STAT on page 186 for a detailed description of this bit
N */
N#define LL_IIC_INTR_STAT_R_RX_UNDER                         (1UL << 0)
N
N
N/***** IC_INTR_MASK (IIC Interrupt Mask Register) *****/
N/*! This bit masks the R_SCL_STUCK_AT_LOW interrupt bit in the IC_INTR_STAT register 
N *  This bit is enabled only when IC_BUS_CLEAR_FEATURE = 1.
N */
N#define LL_IIC_INTR_MASK_M_SCL_STUCK_AT_LOW                 (1UL << 14)
N/*! This bit masks the R_MST_ON_HOLD interrupt bit in the IC_INTR_STAT register.
N */
N#define LL_IIC_INTR_MASK_M_MST_ON_HOLD                      (1UL << 13)
N/*! This bit masks the R_RESTART_DET interrupt status bit in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_RESTART_DET                      (1UL << 12)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_GEN_CALL                         (1UL << 11)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_START_DET                        (1UL << 10)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_STOP_DET                         (1UL << 9)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_ACTIVITY                         (1UL << 8)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_RX_DONE                          (1UL << 7)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_TX_ABRT                          (1UL << 6)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_RD_REQ                           (1UL << 5)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_TX_EMPTY                         (1UL << 4)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_TX_OVER                          (1UL << 3)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_RX_FULL                          (1UL << 2)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_RX_OVER                          (1UL << 1)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK_M_RX_UNDER                         (1UL << 0)
N/*! These bits mask their corresponding interrupt status bits in the IC_INTR_STAT register
N */
N#define LL_IIC_INTR_MASK(n)                                 (((n)&0x7FFF) << 0)
N
N
N/***** IC_RAW_INTR_STAT(IIC Raw Interrupt Status Register) *****/
N/*! Indicates whether the SCL Line is stuck at low for the IC_SCL_STUCK_LOW_TIMOUT number 
N *  of ic_clk periods. Enabled only when IC_BUS_CLEAR_FEATURE = 1
N */
N#define LL_IIC_RAW_INTR_STAT_SCL_STUCK_AT_LOW               (1UL << 14)
N/*! Indicates whether a master is holding the bus and the Tx FIFO is empty. Enabled only 
N *  when I2C_DYNAMIC_TAR_UPDATE = 1 and IC_EMPTYFIFO_HOLD_MASTER_EN = 1
N */
N#define LL_IIC_RAW_INTR_STAT_MST_ON_HOLD                    (1UL << 13)
N/*! Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c 
N *  is operating in slave mode and the slave is the addressed slave.Enabled only when 
N *  IC_SLV_RESTART_DET_EN = 1
N */
N#define LL_IIC_RAW_INTR_STAT_RESTART_DET                    (1UL << 12)
N/*! Set only when a General Call address is received and it is acknowledged. It stays set 
N *  until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the 
N *  IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.
N */
N#define LL_IIC_RAW_INTR_STAT_GEN_CALL                       (1UL << 11)
N/*! Indicates whether a START or RESTART condition has occurred on the I2C interface regardless 
N *  of whether DW_apb_i2c is operating in slave or master mode
N */
N#define LL_IIC_RAW_INTR_STAT_START_DET                      (1UL << 10)
N/*! Indicates whether a STOP condition has occurred on the I2C interface regardless of whether 
N *  DW_apb_i2c is operating in slave or master mode
N */
N#define LL_IIC_RAW_INTR_STAT_STOP_DET                       (1UL << 9)
N/*! This bit captures DW_apb_i2c activity and stays set until it is cleared
N */
N#define LL_IIC_RAW_INTR_STAT_ACTIVITY                       (1UL << 8)
N/*! When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master 
N *  does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, 
N *  indicating that the transmission is done
N */
N#define LL_IIC_RAW_INTR_STAT_RX_DONE                        (1UL << 7)
N/*! This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended 
N *  actions on the contents of the transmit FIFO. This situation can occur both as an I2C master 
N *  or an I2C slave, and is referred to as a "Transmit abort"
N */
N#define LL_IIC_RAW_INTR_STAT_TX_ABRT                        (1UL << 6)
N/*! This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting 
N *  to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until 
N *  this interrupt is serviced, which means that the slave has been addressed by a remote master 
N *  that is asking for data to be transferred. The processor must respond to this interrupt and then 
N *  write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor 
N *  reads the IC_CLR_RD_REQ register.
N */
N#define LL_IIC_RAW_INTR_STAT_RD_REQ                         (1UL << 5)
N/*! The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the 
N *  IC_CON register.
N */
N#define LL_IIC_RAW_INTR_STAT_TX_EMPTY                       (1UL << 4)
N/*! Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts 
N *  to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this 
N *  bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, 
N *  this interrupt is cleared
N */
N#define LL_IIC_RAW_INTR_STAT_TX_OVER                        (1UL << 3)
N/*! Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is 
N *  automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled 
N *  (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this 
N *  bit is cleared once IC_ENABLE[0] is set to 0, regardless of the activity that continues.
N */
N#define LL_IIC_RAW_INTR_STAT_RX_FULL                        (1UL << 2)
N/*! Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received 
N *  from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO
N *  is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master 
N *  or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
N */
N#define LL_IIC_RAW_INTR_STAT_RX_OVER                        (1UL << 1)
N/*! Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD 
N *  register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave 
N *  state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
N */
N#define LL_IIC_RAW_INTR_STAT_RX_UNDER                       (1UL << 0)
N
N
N/***** IC_RX_TL(IIC Receive FIFO Threshold Register) *****/
N/*! Receive FIFO Threshold Level Controls the level of entries (or above) that triggers 
N *  the LL_IIC_RX_FULL interrupt(bit 2 in LL_IIC_IC_RAW_INTR_STAT register)
N */
N#define LL_IIC_RX_TL(n)                                     (((n)&0xFF ) << 0)
N
N
N/***** IC_TX_TL(IIC Transmit FIFO Threshold Register) *****/
N/*! Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger 
N *  the LL_IIC_TX_EMPTY interrupt(bit 4 in LL_IIC_IC_RAW_INTR_STAT register)
N */
N#define LL_IIC_TX_TL(n)                                     (((n)&0xFF) << 0)
N
N
N/***** IC_CLR_INTR(Clear Combined and Individual Interrupt Register) *****/
N/*! Read this register to clear the combined interrupt, all individual interrupts, and 
N *  the LL_IIC_IC_TX_ABRT_SOURCE register
N */
N#define LL_IIC_IC_CLR_INTR                                  (1UL << 0)
N
N
N/***** IC_CLR_RX_UNDER(Clear RX_UNDER Interrupt Register) *****/
N/*! Read this register to clear the RX_UNDER interrupt (bit 0) of the LL_IIC_IC_RAW_INTR_STAT 
N *  register
N */
N#define LL_IIC_IC_CLR_RX_UNDER                              (1UL << 0)
N
N
N/***** IC_CLR_RX_OVER(Clear RX_OVER Interrupt Register) *****/
N/*! Read this register to clear the RX_OVER interrupt (bit 1) of the LL_IIC_IC_RAW_INTR_STAT 
N *  register 
N */
N#define LL_IIC_IC_CLR_RX_OVER                               (1UL << 0)
N
N
N/***** IC_CLR_TX_OVER(Clear TX_OVER Interrupt Register) *****/
N/*! Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register 
N */
N#define LL_IIC_IC_CLR_TX_OVER                               (1UL << 0)
N
N
N/***** IC_CLR_RD_REQ(Clear RD_REQ Interrupt Register) *****/
N/*! Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register. 
N */
N#define LL_IIC_IC_CLR_RD_REQ                                (1UL << 0)
N
N
N/***** IC_CLR_TX_ABRT(Clear TX_ABRT Interrupt Register) *****/
N/*! Read this register to clear the TX_ABRT interrupt (bit 6) of the LL_IIC_IC_RAW_INTR_STAT 
N *  register, and the IC_TX_ABRT_SOURCE register.
N  */
N#define LL_IIC_IC_CLR_TX_ABRT                               (1UL << 0)
N
N
N/***** IC_CLR_RX_DONE(Clear RX_DONE Interrupt Register) *****/
N/*! Read this register to clear the RX_DONE interrupt (bit 7) of the LL_IIC_IC_RAW_INTR_STAT 
N *  register 
N */
N#define LL_IIC_IC_CLR_RX_DONE                               (1UL << 0)
N
N
N/***** IC_CLR_ACTIVITY(Clear ACTIVITY Interrupt Register) *****/
N/*! Read this register clears the ACTIVITY interrupt if the I2C is not active anymore
N */
N#define LL_IIC_IC_CLR_ACTIVITY                              (1UL << 0)
N
N
N/***** IC_CLR_STOP_DET(Clear STOP_DET Interrupt Register) *****/
N/*! Read this register to clear the STOP_DET interrupt (bit 9) of the LL_IIC_IC_RAW_INTR_STAT 
N *  register
N */
N#define LL_IIC_IC_CLR_STOP_DET                              (1UL << 0)
N
N
N/***** IC_CLR_START_DET(Clear START_DET Interrupt Register) *****/
N/*! Read this register to clear the START_DET interrupt (bit 10) of the LL_IIC_IC_RAW_INTR_STAT 
N *  register
N */
N#define LL_IIC_IC_CLR_START_DET                             (1UL << 0)
N
N
N/***** IC_CLR_GEN_CALL(Clear GEN_CALL Interrupt Register) *****/
N/*! Read this register to clear the GEN_CALL interrupt (bit 11) of LL_IIC_IC_RAW_INTR_STAT 
N *  register
N */
N#define LL_IIC_IC_CLR_GEN_CALL                              (1UL << 0)
N
N
N/***** IC_ENABLE(IIC Enable Register) *****/
N/*! The SMBUS_ALERT_CTRL register bit is used to control assertion of SMBALERT signal
N */
N#define LL_IIC_ENABLE_SMBUS_ALERT_EN                        (1UL << 18)
N/*! The LL_IIC_SMBUS_SUSPEND_EN register bit is used to control assertion and deassertion of 
N *  SMBSUS signal
N */
N#define LL_IIC_ENABLE_SMBUS_SUSPEND_EN                      (1UL << 17)
N/*! This bit is used in SMBus Host mode to initiate the SMBus Master Clock Reset
N */
N#define LL_IIC_ENABLE_SMBUS_CLK_RESET                       (1UL << 16)
N/*! If SDA is stuck at low indicated through the TX_ABORT interrupt (IC_TX_ABRT_SOURCE[17]), 
N *  this bit is used as a control knob to initiate the SDA Recovery Mechanism (that is, send 
N *  at most 9 SCL clocks and STOP to release the SDA line) and then this bit gets auto clear
N */
N#define LL_IIC_ENABLE_SDA_STUCK_RECOVERY_ENABLE             (1UL << 3)
N/*! In Master mode: 1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to 
N *  transmit; 0: The transmission of data starts on I2C bus automatically, as soon as the 
N *  first data is available in the Tx FIFO
N */
N#define LL_IIC_ENABLE_TX_CMD_BLOCK                          (1UL << 2)
N/*! When set, the controller initiates the transfer abort
N */
N#define LL_IIC_ENABLE_ABORT                                 (1UL << 1)
N/*! Controls whether the DW_apb_i2c is enabled
N */
N#define LL_IIC_ENABLE                                       (1UL << 0)
N
N
N/***** IC_STATUS(IIC Status Register, RO) *****/
N/*! This bit indicates whether the status of the input signal is ic_smbus_alert_in_n. 
N *  This signal is asserted when the SMBus Alert signal is asserted by the SMBus Device
N */
N#define LL_IIC_STATUS_SMBUS_ALERT_STATUS                    (1UL << 20)
N/*! This bit indicates whether the status of the input signal is ic_smbus_sus_in_n. 
N *  This signal is asserted when the SMBus Suspend signal is asserted by the SMBus Host
N */
N#define LL_IIC_STATUS_SMBUS_SUSPEND_STATUS                  (1UL << 19)
N/*! This bit indicates whether the SMBus Slave address (ic_sar[6:0]) is Resolved by ARP Master
N */
N#define LL_IIC_STATUS_SMBUS_SLAVE_ADDR_RESOLVED             (1UL << 18)
N/*! This bit indicates whether the SMBus Slave address (ic_sar[6:0]) is valid or not
N */ 
N#define LL_IIC_STATUS_SMBUS_SLAVE_ADDR_VALID                (1UL << 17)
N/*! This bit indicates the R/W bit of the Quick command received. This bit will be cleared 
N *  after the user has read this bit
N */
N#define LL_IIC_STATUS_SMBUS_QUICK_CMD_BIT                   (1UL << 16)
N/*! This bit indicates that an SDA stuck at low is not recovered after the recovery mechanism.
N *  This bit is enabled only when LL_IIC_IC_BUS_CLEAR_FEATURE = 1
N */
N#define LL_IIC_STATUS_SDA_STUCK_NOT_RECOVERED               (1UL << 11)
N/*! This bit indicates the BUS Hold in Slave mode due to the Rx FIFO being Full and an 
N *  additional byte being received (this kind of Bus hold is applicable if 
N *  LL_IIC_IC_RX_FULL_HLD_BUS_EN is set to 1)
N */
N#define LL_IIC_STATUS_SLV_HOLD_RX_FIFO_FULL                 (1UL << 10)
N/*! This bit indicates the BUS Hold in Slave mode for the Read request when the Tx FIFO is 
N *  empty. The Bus is in hold until the Tx FIFO has data to Transmit for the read request.
N */
N#define LL_IIC_STATUS_SLV_HOLD_TX_FIFO_EMPTY                (1UL << 9)
N/*! This bit indicates the BUS Hold in Master mode due to Rx FIFO is Full and additional byte 
N *  has been received(This kind of Bus hold is applicable if LL_IIC_IC_RX_FULL_HLD_BUS_EN is 
N *  set to 1)
N */
N#define LL_IIC_STATUS_MST_HOLD_RX_FIFO_FULL                 (1UL << 8)
N/*! This bit indicates the BUS hold when the master holds the bus because of the Tx FIFO being 
N *  empty, and the the previous transferred command does not have the Stop bit set. 
N *  (This kind of Bus hold is applicable if LL_IIC_IC_EMPTYFIFO_HOLD_MASTER_EN is set to 1)
N */
N#define LL_IIC_STATUS_MST_HOLD_TX_FIFO_EMPTY                (1UL << 7)
N/*! Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE 
N *  state, this bit is set
N */
N#define LL_IIC_STATUS_SLV_ACTIVITY                          (1UL << 6)
N/*! Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE 
N *  state, this bit is set
N */
N#define LL_IIC_STATUS_MST_ACTIVITY                          (1UL << 5)
N/*! Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. 
N *  When the receive FIFO contains one or more empty location, this bit is cleared
N */
N#define LL_IIC_STATUS_RFF                                   (1UL << 4)
N/*! Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; 
N *  it is cleared when the receive FIFO is empty
N */
N#define LL_IIC_STATUS_RFNE                                  (1UL << 3)
N/*! Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. 
N *  When it contains one or more valid entries, this bit is cleared. This bit field does not 
N *  request an interrupt
N */
N#define LL_IIC_STATUS_TFE                                   (1UL << 2)
N/*! Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, 
N *  and is cleared when the FIFO is full
N */
N#define LL_IIC_STATUS_TFNF                                  (1UL << 1)
N/*! I2C Activity Status
N */
N#define LL_IIC_STATUS_ACTIVITY                              (1UL << 0)
N
N
N/***** IC_DMA_CR(IIC DMA Control Register, RW) *****/
N/*! This bit enables/disables the transmit FIFO DMA channel.
N */
N#define LL_IIC_DMA_CR_TDMAE                                 (1UL << 1)
N/*! This bit enables/disables the receive FIFO DMA channel. 
N */
N#define LL_IIC_DMA_CR_RDMAE                                 (1UL << 0)
N
N
N/***** IC_DMA_TDLR(IIC DMA Transmit Data Level Register) *****/
N/*! Transmit Data Level. This bit field controls the level at which a DMA request is made by the 
N *  transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated 
N *  when the number of valid data entries in the transmit FIFO is equal to or below this field value,
N *  and TDMAE = 1
N */
N#define LL_IIC_DMA_TDLR(n)                                  (((n)&0xFF) << 0)
N
N
N/***** IC_DMA_RDLR(IIC DMA Receive Data Level Register) *****/
N/*! Receive Data Level. This bit field controls the level at which a DMA request is made by the 
N *  receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number 
N *  of valid data entries in the receive FIFO is equal to or more than this field value + 1, and 
N *  RDMAE = 1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries
N *  are present in the receive FIFO.
N */
N#define LL_IIC_DMA_RDLR(n)                                  (((n)&0xFF) << 0)
N
N
N/***** IC_SDA_SETUP(IIC SDA Setup Register) *****/
N/*! SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 
N *  10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a 
N *  minimum value of 2 
N */
N#define LL_IIC_SDA_SETUP(n)                                 (((n)&0xFF) << 0)
N
N
N/***** IC_ACK_GENERAL_CALL(IIC ACK General Call Register) *****/
N/*! ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when 
N *  it receives a General Call. When set to 0, the DW_apb_i2c does not generate General Call interrupts 
N */
N#define LL_IIC_ACK_GEN_CALL                                 (1UL << 0)
N
N
N/***** IC_ENABLE_STATUS(IIC Enable Status Register) *****/
N/*! Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with 
N *  at least one data byte received from an I2C transfer due to setting IC_ENABLE[0] from 1 to 0 
N */
N#define LL_IIC_SLV_RX_DATA_LOST                             (1UL << 2)
N/*! Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave 
N *  operation has been aborted due to setting bit 0 of the IC_ENABLE register from 1 to 0.  
N */
N#define LL_IIC_SLV_DISABLED_WHILE_BUSY                      (1UL << 1)
N/*! ic_en Status. This bit always reflects the value driven on the output port ic_en. 
N */
N#define LL_IIC_IC_EN                                        (1UL << 0)
N
N
N/***** IC_FS_SPKLEN(IIC SS and FS Spike Suppression Limit Register) *****/
N/*! This register must be set before any I2C bus transaction can take place to ensure stable operation. 
N *  This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA 
N *  lines that are filtered out by the spike suppression logic; 
N */
N#define LL_IIC_IC_FS_SPKLEN(n)                              (((n)&0xFF) << 0)
N
N
N/***** IC_HS_SPKLEN(IIC HS Spike Suppression Limit Register) *****/
N/*! This register must be set before any I2C bus transaction can take place to ensure stable operation.
N *  This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA 
N *  lines that are filtered out by the spike suppression logic;  
N */
N#define LL_IIC_IC_HS_SPKLEN(n)                              (((n)&0xFF) << 0)
N
N
N/***** IC_CLR_RESTART_DET(IIC Clear RESTART_DET Interrupt Register) *****/
N/*!  Read this register to clear the RESTART_DET interrupt (bit 12) of the IC_RAW_INTR_STAT register.  
N */
N#define LL_IIC_CLR_RESTART_DET                              (1UL << 0)
N
N
N/***** IC_COMP_PARAM_1(IIC Component Parameter Register 1) *****/
N/*! The value of this register is derived from the IC_TX_BUFFER_DEPTH coreConsultant parameter.
N */
N#define LL_IIC_TX_BUFFER_DEPTH(n)                           (((n)&0xFF) << 16)
N/*! The value of this register is derived from the IC_RX_BUFFER_DEPTH coreConsultant parameter 
N*/
N#define LL_IIC_RX_BUFFER_DEPTH(n)                           (((n)&0xFF) << 8)
N/*! The value of this register is derived from the IC_ADD_ENCODED_PARAMS coreConsultant parameter. 
N */
N#define LL_IIC_ADD_ENCODED_PARAMS                           (1UL << 7)
N/*! The value of this register is derived from the IC_HAS_DMA coreConsultant parameter. 
N */
N#define LL_IIC_HAS_DMA                                      (1UL << 6)
N/*! The value of this register is derived from the IC_INTR_IO coreConsultant parameter. 
N */
N#define LL_IIC_INTR_IO                                      (1UL << 5)
N
N/*! The value of this register is derived from the IC_HC_COUNT_VALUES coreConsultant parameter.  
N */
N#define LL_IIC_HC_COUNT_VALUES                              (1UL << 4)
N
N/*! The value of this register is derived from the IC_MAX_SPEED_MODE coreConsultant parameter. 
N */
N#define LL_IIC_MAX_SPEED_MODE(n)                            (((n)&0x3) << 2)
N
N/*! The value of this register is derived from the APB_DATA_WIDTH coreConsultant parameter 
N */
N#define LL_IIC_APB_DATA_WIDTH(n)                            (((n)&0x3) << 0)
N
N
N/***** IC_COMP_VERSION(IIC Component Version Register) *****/
N/*! Specific values for this register are described in the Releases Table in the AMBA 2 release 
N *  notes 
N */
N#define LL_IIC_IC_COMP_VERSION(n)                           (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IC_COMP_TYPE(IIC Component Type Register) *****/
N/*! Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant 
N *  and is derived from the two ASCII letters "DW" followed by a 16-bit unsigned number
N */
N#define LL_IIC_ IC_COMP_TYPE(n)                             (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IC_SCL_STUCK_AT_LOW_TIMEOUT(IIC SCL Stuck at Low Timeout) *****/
N/*! DW_apb_i2c generates the interrupt to indicate SCL stuck at low if it detects the SCL stuck 
N *  at low for the IC_SCL_STUCK_LOW_TIMEOUT in units of ic_clk period 
N */
N#define LL_IIC_IC_SCL_STUCK_LOW_TIMEOUT(n)                  (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IC_SDA_STUCK_AT_LOW_TIMEOUT(IIC SDA Stuck at Low Timeout) *****/
N/*! DW_apb_i2c initiates the recovery of SDA line through enabling the SDA_STUCK_RECOVERY_EN 
N *  (IC_ENABLE[3]) register bit, if it detects the SDA stuck at low for the IC_SDA_STUCK_LOW_TIMEOUT 
N *  in units of ic_clk period.  
N */
N#define LL_IIC_IC_SDA_STUCK_LOW_TIMEOUT(n)                  (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IC_CLR_SCL_STUCK_DET(IIC Clear SCL Stuck at Low Detect Interrupt Register) *****/
N/*! Read this register to clear the SCL_STUCK_DET interrupt (bit 14) of the IC_RAW_INTR_STAT register 
N */
N#define LL_IIC_CLR_SCL_STUCK                                (1UL << 0)
N
N
N/***** IC_DEVICE_ID(IIC Device ID) *****/
N/*! Contains the Device-ID of the component assigned through the configuration parameter IC_DEVICE_ID_VALUE 
N */
N#define LL_IIC_DEVICE_ID(n)                                 (((n)&0xFFFFFF) << 0)
N
N
N/***** IC_UFM_SCL_HCNT(IIC Ultra-Fast mode IIC Clock High Count Register) *****/
N/*! This register must be set before any I2C bus transaction can take place to ensure proper I/O timing.
N *  This register sets the SCL clock high-period count for Ultra-Fast speed 
N */
N#define LL_IIC_IC_UFM_SCL_HCNT(n)                           (((n)&0xFFFF) << 0)
N
N
N/***** IC_UFM_SCL_LCNT(IIC Ultra-Fast mode IIC Clock Low Count Register) *****/
N/*! This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. 
N *  This register sets the SCL clock low-period count for Ultra-Fast speed. 
N */
N#define LL_IIC_IC_UFM_SCL_LCNT(n)                           (((n)&0xFFFF) << 0)
N
N
N/***** IC_UFM_SPKLEN(IIC Ultra-Fast mode Spike suppression Register) *****/
N/*! This register must be set before any I2C bus transaction can occur to ensure stable operation. 
N *  This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA 
N *  lines that are filtered out by the spike suppression logic. 
N */
N#define LL_IIC_IC_UFM_SPKLEN(n)                             (((n)&0xFF) << 0)
N
N
N/***** IC_UFM_TBUF_CNT(IIC Ultra-Fast mode TBuf Idle Count Register) *****/
N/*! This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. 
N *  This register sets the tBuf Idle time count for Ultra-Fast speed.
N */
N#define LL_IIC_IC_UFM_TBUF_CNT(n)                           (((n)&0xFFFF) << 0)
N
N
N/***** IC_SMBUS_CLOCK_LOW_SEXT(IIC SMBUS Slave Clock Extend Timeout Register) *****/
N/*! This field is used to detect the Slave Clock Extend timeout (tLOW:SEXT) in master mode extended by 
N *  the slave device in one message from the initial START to the STOP. 
N */
N#define LL_IIC_SMBUS_CLK_LOW_SEXT_TIMEOUT(n)                (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IC_SMBUS_CLOCK_LOW_MEXT(IIC SMBUS Master extend clock Timeout Register) *****/
N/*! This field is used to detect the Master extend SMBus clock (SCL) timeout defined from START-to-ACK, 
N *  ACK-to-ACK, or ACK-to-STOP in Master mode. 
N */
N#define LL_IIC_SMBUS_CLK_LOW_MEXT_TIMEOUT(n)                (((n)&0xFFFFFFFF) << 0)
N
N
N/***** IC_SMBUS_THIGH_MAX_IDLE_COUNT (IIC SMBus Thigh MAX Bus-Idle count Register) *****/
N/*! This field is used to set the required Bus-Idle time period used when a master has been dynamically
N *  added to the bus and may not have detected a state transition on the SMBCLK or SMBDAT lines.
N */
N#define LL_IIC_SMBUS_THIGH_MAX_BUS_IDLE_CNT(n)              (((n)&0xFFFF) << 0)
N
N
N/***** IC_SMBUS_INTR_STAT(IIC I2C SMBUS Interrupt Status Register) *****/
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit. 
N */
N#define LL_IIC_R_SMBUS_ALERT_DET                            (1UL << 10) 
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit 
N */
N#define LL_IIC_R_SMBUS_SUSPEND_DET                          (1UL << 9)
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit 
N */
N#define LL_IIC_R_SLV_RX_PEC_NACK                            (1UL << 8)
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit 
N */
N#define LL_IIC_R_ARP_ASSGN_ADDR_CMD_DET                     (1UL << 7)
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit 
N */
N#define LL_IIC_R_ARP_GET_UDID_CMD_DET                       (1UL << 6)
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit 
N */
N#define LL_IIC_R_ARP_RST_CMD_DET                            (1UL << 5)
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit 
N */
N#define LL_IIC_R_ARP_PREPARE_CMD_DET                        (1UL << 4)
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit 
N */
N#define LL_IIC_R_HOST_NOTIFY_MST_DET                        (1UL << 3)
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit 
N */
N#define LL_IIC_R_QUICK_CMD_DET                              (1UL << 2)
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit 
N */
N#define LL_IIC_R_MST_CLOCK_EXTND_TIMEOUT                    (1UL << 1)
N/*! See IC_SMBUS_INTR_RAW_STATUS for a detailed description of this bit 
N */
N#define LL_IIC_R_SLV_CLOCK_EXTND_TIMEOUT                    (1UL << 0)
N
N
N/***** IC_SMBUS_INTR_MASK(IIC Interrupt Mask Register) *****/
N/*! This bit masks the R_SMBUS_ALERT_DET interrupt bit in the IC_SMBUS_INTR_STAT register. This bit 
N *  is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_SMBUS_ALERT_DET                            (1UL << 10)
N/*! This bit masks the R_SMBUS_SUSPEND_DET interrupt bit in the IC_SMBUS_INTR_STAT register. This bit 
N *  is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_SMBUS_SUSPEND_DET                          (1UL << 9)
N/*! This bit masks the R_SLV_RX_PEC_NACK interrupt bit in the IC_SMBUS_INTR_STAT register. This bit 
N *  is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_SLV_RX_PEC_NACK                            (1UL << 8)
N/*! This bit masks the R_ARP_ASSGN_ADDR_CMD_DET interrupt bit in the IC_SMBUS_INTR_STAT register. 
N *  This bit is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_ARP_ASSGN_ADDR_CMD_DET                     (1UL << 7)
N/*! This bit masks the R_ARP_GET_UDID_CMD_DET interrupt bit in the IC_SMBUS_INTR_STAT register. This bit 
N *  is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_ARP_GET_UDID_CMD_DET                       (1UL << 6)
N/*! This bit masks the R_ARP_RST_CMD_DET interrupt bit in the IC_SMBUS_INTR_STAT register. This bit 
N *  is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_ARP_RST_CMD_DET                            (1UL << 5)
N/*! This bit masks the R_ARP_PREPARE_CMD_DET interrupt bit in the IC_SMBUS_INTR_STAT register. This bit 
N *  is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_ARP_PREPARE_CMD_DET                        (1UL << 4)
N/*! This bit masks the R_HOST_NOTIFY_MST_DET interrupt bit in the IC_SMBUS_INTR_STAT register. This bit 
N *  is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_HOST_NOTIFY_MST_DET                        (1UL << 3)
N/*! This bit masks the R_QUICK_CMD_DET interrupt bit in the IC_SMBUS_INTR_STAT register. This bit 
N *  is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_QUICK_CMD_DET                              (1UL << 2)
N/*! This bit masks the R_MST_CLOCK_EXTND_TIMEOUT interrupt bit in the IC_SMBUS_INTR_STAT register. 
N *  This bit is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_MST_CLOCK_EXTND_TIMEOUT                    (1UL << 1)
N/*! This bit masks the R_SLV_CLOCK_EXTND_TIMEOUT interrupt bit in the IC_SMBUS_INTR_STAT register.
N *  This bit is enabled only when IC_SMBUS_SUSPEND_ALERT=1.
N */
N#define LL_IIC_M_SLV_CLOCK_EXTND_TIMEOUT                    (1UL << 0)
N
N
N/***** IC_SMBUS_INTR_RAW_STATUS(IIC SMBUS Raw Interrupt Status Register) *****/
N/*! Indicates whether a SMBALERT (ic_smbalert_in_n) signal is driven low by the slave 
N */
N#define LL_IIC_SMBUS_ALERT_DET                              (1UL << 10)
N/*! Indicates whether a SMBSUS (ic_smbsus_in_n) signal is driven low by the Host 
N */
N#define LL_IIC_SMBUS_SUSPEND_DET                            (1UL << 9)
N/*! Indicates whether a Slave generates a NACK for the PEC Byte of the ARP command from the slave 
N */
N#define LL_IIC_SLV_RX_PEC_NACK                              (1UL << 8)
N/*! Indicates whether an Assign Address ARP command has been received 
N */
N#define LL_IIC_ARP_ASSGN_ADDR_CMD_DET                       (1UL << 7)
N/*! Indicates whether a General or directed Get UDID ARP command has been received. 
N */
N#define LL_IIC_ARP_GET_UDID_CMD_DET                         (1UL << 6)
N/*! Indicates whether a General or Directed Reset ARP command has been received.
N */
N#define LL_IIC_ARP_RST_CMD_DET                              (1UL << 5)
N/*! Indicates whether a Prepare to ARP command has been received.
N */
N#define LL_IIC_ARP_PREPARE_CMD_DET                          (1UL << 4)
N/*! Indicates whether a Host Notify command has been received. 
N */
N#define LL_IIC_HOST_NTFY_MST_DET                            (1UL << 3)
N/*! Indicates whether a Quick command has been received on the SMBus interface regardless of whether 
N *  DW_apb_i2c is operating in slave or master mode. This bit is enabled only when IC_SMBUS=1 is set 
N *  to 1 
N */
N#define LL_IIC_QUICK_CMD_DET                                (1UL << 2)
N/*! Indicates whether the Master device transaction (START-to-ACK, ACK-to-ACK, or ACK-to-STOP) from 
N *  START to STOP exceeds IC_SMBUS_CLOCK_LOW_MEXT time in each byte of message.
N */
N#define LL_IIC_MST_CLOCK_EXTND_TIMEOUT                      (1UL << 1)
N/*! Indicates whether the transaction from Slave (that is, from START to STOP) exceeds 
N *  IC_SMBUS_CLOCK_LOW_SEXT time.
N */
N#define LL_IIC_SLV_CLOCK_EXTND_TIMEOUT                      (1UL << 0)
N
N
N/***** IC_CLR_SMBUS_INTR(IIC Clear SMBUS Interrupt Register) *****/
N/*! Write this register to clear the SMBUS_ALERT_DET interrupt (bit 10) of the IC_SMBUS_RAW_INTR_STAT 
N *  register
N */
N#define LL_IIC_CLR_SMBUS_ALERT_DET                          (1UL << 10)
N/*! Write this register to clear the R_SMBUS_SUSPEND_DET interrupt (bit 9) of the IC_SMBUS_RAW_INTR_STAT 
N *  register
N */
N#define LL_IIC_CLR_SMBUS_SUSPEND_DET                        (1UL << 9)
N/*! Write this register to clear the SLV_RX_PEC_NACK interrupt (bit 8) of the IC_SMBUS_RAW_INTR_STAT 
N *  register.
N */
N#define LL_IIC_CLR_SLV_RX_PEC_NACK                          (1UL << 8)
N/*! Write this register to clear the ARP_ASSGN_ADDR_CMD_DET interrupt (bit 7) of the IC_SMBUS_RAW_INTR_STAT 
N *  register.
N */
N#define LL_IIC_CLR_ARP_ASSGN_ADDR_CMD_DET                   (1UL << 7)
N/*! Write this register to clear the ARP_GET_UDID_CMD_DET interrupt (bit 6) of the IC_SMBUS_RAW_INTR_STAT 
N *  register.
N */
N#define LL_IIC_CLR_ARP_GET_UDID_CMD_DET                     (1UL << 6)
N/*! Write this register to clear the ARP_RST_CMD_DET interrupt (bit 5) of the IC_SMBUS_RAW_INTR_STAT 
N *  register.
N */
N#define LL_IIC_CLR_ARP_RST_CMD_DET                          (1UL << 5)
N/*! Write this register to clear the ARP_PREPARE_CMD_DET interrupt (bit 4) of the IC_SMBUS_RAW_INTR_STAT 
N *  register
N */
N#define LL_IIC_CLR_ARP_PREPARE_CMD_DET                      (1UL << 4)
N/*! Write this register to clear the HOST_NOTIFY_MST_DET interrupt (bit 3) of the IC_SMBUS_RAW_INTR_STAT 
N *  register.
N */
N#define LL_IIC_CLR_HOST_NTFY_MST_DET                        (1UL << 3)
N/*! Write this register to clear the QUICK_CMD_DET interrupt (bit 2) of the IC_SMBUS_RAW_INTR_STAT 
N *  register.
N */
N#define LL_IIC_CLR_QUICK_CMD_DET                            (1UL << 2)
N/*! Write this register to clear the MST_CLOCK_EXTND_TIMEOUT interrupt (bit 1) of the IC_SMBUS_RAW_INTR_STAT 
N *  register.
N */
N#define LL_IIC_CLR_MST_CLOCK_EXTND_TIMEOUT                  (1UL << 1)
N/*! Write this register to clear the SLV_CLOCK_EXTND_TIMEOUT interrupt (bit 0) of the IC_SMBUS_RAW_INTR_STAT
N *  register.
N */
N#define LL_IIC_CLR_SLV_CLOCK_EXTND_TIMEOUT                  (1UL << 0)
N
N
N/***** IC_OPTIONAL_SAR(IIC Optional Slave Address Register) *****/
N/*! Optional Slave address for DW_apb_i2c when operating as a slave in SMBus Mode.  
N */
N#define LL_IIC_IC_OPTIONAL_SAR(n)                           (((n)&0x7F) << 0)
N
N
N/***** IC_SMBUS_UDID_LSB(IIC SMBUS ARP UDID LSB Register) *****/
N/*! This field is used to store the LSB 32 bit value of slave unique device identifier used in Address 
N *  Resolution Protocol 
N */
N#define LL_IIC_IC_SMBUS_ARP_UDID_LSB(n)                     (((n)&0xFFFFFFFF) << 0)
N
N
N/**
N  * @}
N  */
N
N/** @defgroup IIC_LL_Exported_Constants IIC LL Exported Constants
N  * @ingroup  IIC_LL_Driver
N  * @brief    IIC LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for low layer IIC type of timer IO map
N  */
Ntypedef enum {
N    /*! Select the pin of the IIC io map0
N     */
N    LL_IIC_IO_MAP0       = 0x01,
N    /*! Select the pin of the IIC Smbus io map0
N     */
N    LL_IIC_IO_SMBUS_MAP0 = 0x02,
N    /*! Select the pin of the IIC Smbus io map1
N     */
N    LL_IIC_IO_SMBUS_MAP1 = 0x04,
N}TYPE_ENUM_LL_IIC_IO_MAP;
N
N/**
N  * @brief Enumeration constant for IIC speed selection
N  */
Ntypedef enum {
N    /*! 1: standard mode (0 to 100 Kb/s)
N     */
N    LL_IIC_SPEED_STANDARD_MODE = 1, 
N    /*! 2: fast mode (= 400 Kb/s) or fast mode plus (= 1000 Kb/s)
N     */
N    LL_IIC_SPEED_MODE,
N    /*! 3: high speed mode (= 3.4 Mb/s)
N     */
N    LL_IIC_SPEED_HIGH_MODE,
N} TYPE_ENUM_LL_IIC_SPEED_SEL;
N
N/**
N  * @brief Enumeration constant for IIC mode selection
N  */
Ntypedef enum {
N    /*! IIC selects the master mode.
N     */
N    LL_IIC_MODE_MASTER = 0,
N    /*! IIC selects the slave mode.
N     */
N    LL_IIC_MODE_SLAVE,
N} TYPE_ENUM_LL_IIC_MODE_SEL;
N
N/**
N  * @brief Enumeration constant for IIC address bit selection
N  */
Ntypedef enum {
N    /*! The IIC communication address selects the 7-bit mode.
N     */
N    LL_IIC_ADDR_7BIT = 0,
N    /*! The IIC communication address selects the 10-bit mode.
N     */
N    LL_IIC_ADDR_10BIT,
N} TYPE_ENUM_LL_IIC_ADDR_SEL;
N
N/**
N  * @}
N  */
N
N/** @defgroup IIC_LL_Exported_Struct IIC LL Exported Struct
N  * @ingroup  IIC_LL_Driver
N  * @brief    IIC LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the IIC registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_iic_init. Function, you can configure the IIC module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief IIC module interrupt low layer configuration structure
N  */
Ntypedef struct _ll_iic_irq_cfg {
N    /*! rx buffer overflow down interrupt
N     */
N    bool rx_under_intr_en;
N    /*! rx buffer overflow up interrupt
N     */
N    bool rx_over_intr_en;
N    /*! rx buffer full interrupt
N     */
N    bool rx_full_intr_en;
N    /*! tx buffer overflow interrupt
N     */
N    bool tx_over_intr_en;
N    /*! tx buffer empty interrupt
N     */
N    bool tx_empty_intr_en;
N    /*! read request interrupt
N     */
N    bool read_req_intr_en;
N    /*! tx abrt interrupt
N     */
N    bool tx_abrt_intr_en;
N    /*! rx done interrupt
N     */
N    bool rx_done_intr_en;
N    /*! DW_apb_i2c activity interrupt
N     */
N    bool activity_intr_en;
N    /*! stop condition detect interrupt
N     */
N    bool stop_det_intr_en;
N    /*! start condition detect interrupt
N     */
N    bool start_det_intr_en;
N    /*! General Call address interrupt
N     */
N    bool gen_call_intr_en;
N    /*! RESTART condition has occurred interrupt
N     */
N    bool restart_det_intr_en;
N    /*! Indicates whether a master is holding the bus and the Tx FIFO is empty interrupt
N     */
N    bool master_on_hold_intr_en;
N    /*! Indicates whether the SCL Line is stuck at low for the 
N     *  IC_SCL_STUCK_LOW_TIMOUT number of ic_clk periods interrupt
N     */
N    bool scl_stuck_at_low_intr_en;
N} TYPE_LL_IIC_IRQ_CFG;
N
N/**
N  * @brief IIC low layer configuration structure
N  */
Ntypedef struct _ll_iic_cfg {
N    /***** IC_CON *****/
N    /*! Controls whether the DW_apb_i2c master is enabled
N     */
N    TYPE_ENUM_LL_IIC_MODE_SEL  mode_sel;
N    /*! Configure the baud rate of iic.
N     */
N    u32                        baudrate;
N    /*! Controls whether responds to 7- or 10-bit addresses as slave/master
N     */
N    TYPE_ENUM_LL_IIC_ADDR_SEL  addr_sel;
N    /*! Determines whether RESTART conditions may be sent as a master
N     */
N    bool                       restart_en;
N    /*! Issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1
N     */
N    bool                       stop_det_if_addr_en;
N    /*! Controls the generation of the TX_EMPTY interrupt
N     */
N    bool                       tx_empty_ctrl;
N    /*! controls whether DW_apb_i2c should hold the buS when the Rx FIFO is 
N     *  physically full to its RX_BUFFER_DEPTH
N     */
N    bool                       rx_fifo_full_hld_ctrl;
N    /*! Issues the STOP_DET interrupt only when the master is active
N     */
N    bool                       stop_det_if_master_active;
N    /*! Bus Clear Feature is enabled as mater
N     */
N    bool                       bus_clear_feature_ctrl;
N    /*! Enables the usage of IC_OPTIONAL_SAR register
N     */
N    bool                       optional_sar_ctrl;
N
N    /***** IC_TAR *****/
N    /*! This is the target address for any master transaction
N     */
N    u16                        target_addr;
N                                     
N    /***** IC_SAR *****/
N    /*! The IC_SAR holds the slave address when the I2C is operating as a slave
N     */
N    u16                        slave_addr;
N
N    
N    /***** IC_DMA_TDLR *****/
N    /*! Transmit Data Level. This bit field controls the level at which a DMA 
N     *  request is made by the transmit logic. It is equal to the watermark level; 
N     *  that is, the dma_tx_req signal is generated when the number of valid 
N     *  data entries in the transmit FIFO is equal to or below this field value, 
N     *  and TDMAE = 1
N     */
N    u8                         dma_tx_threshold_level;
N    
N    /***** IC_DMA_RDLR *****/
N    /*! Receive Data Level. This bit field controls the level at which a DMA request 
N     *  is made by the receive logic. The watermark level = DMARDL+1; that is, 
N     *  dma_rx_req is generated when the number of valid data entries in the 
N     *  receive FIFO is equal to or more than this field value + 1, and RDMAE = 1. 
N     *  For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or 
N     *  more data entries are present in the receive FIFO. 
N     */
N    u8                         dma_rx_threshold_level;
N    
N    /***** IC_SS_SCL_CNT *****/
N    /*! Standard Speed I2C Clock SCL High Count.
N     *  This register must be set before any I2C bus transaction can take place to 
N     *  ensure proper I/O timing. This register sets the SCL clock high-period count 
N     *  for standard speed. For more information, refer to "C_CLK Frequency 
N     *  Configuration" on page 79.
N     *  High-level time in a single cycle of the IIC clk signal: (1/SYS_CLK)*ss_scl_hcnt
N     */
N    u16                        ss_scl_hcnt;
N    /*! Standard Speed I2C Clock SCL Low Count.
N     *  Low-level time in a single cycle of the IIC clk signal: (1/SYS_CLK)*ss_scl_lcnt
N     */
N    u16                        ss_scl_lcnt;
N
N    /***** IC_RX_TL TX_TL *****/
N    /*! I2C Receive FIFO Threshold.
N     *  The IIC DMA TX path starts from the threshold value given to the DMAC. The default 
N     *  value is 0, indicating that every 1 byte of data in the RX FIFO will be sent to 
N     *  notify the DMAC to acquire.
N     */
N    u8                         rx_threshold_level;
N    /*! I2C Transmit FIFO Threshold
N     *  The IIC DMA TX path starts from the threshold value given to the DMAC. The default 
N     *  value is 0, indicating that every 1 byte of data in the TX FIFO will be sent to 
N     *  notify the DMAC to acquire.
N     */
N    u8                         tx_threshold_level;
N    /*! IO map selection for IIC.
N     *  @note The correspondence table of IO_MAP is as follows:
N     * 
N     *               LL_IIC_IO_MAP0    LL_IIC_IO_SMBUS_MAP0    LL_IIC_IO_SMBUS_MAP1  
N     * 
N     *                                 iic_scl(PMBUS_CLK)/     iic_scl(PMBUS_CLK)/   
N     *   io name    iic_scl/iic_sda    iic_sda(PMBUS_DATA)/    iic_sda(PMBUS_DATA)/  
N     *                                         PMBUS_CTRL/             PMBUS_CTRL/   
N     *                                         PMBUS_ALERT             PMBUS_ALERT   
N     * 
N     *     IIC0         PA6/PA7           PA6/PA7/P4/PA5        PB8/PB9/PB10/PB11    
N     * 
N     *     IIC1         PA8/PA9           PD0/PD1/PD2/PD3                            
N     * 
N     */
N    TYPE_ENUM_LL_IIC_IO_MAP    io_map;
N} TYPE_LL_IIC_CFG;
N
N/**
N  * @brief IIC low layer Initialization structure
N  */
Ntypedef struct _ll_iic_init {
N    u8 reserved;
N} TYPE_LL_IIC_INIT;
N/**
N  * @}
N  */
N
N/** @defgroup IIC_LL_Interrupt IIC LL Interrupt Handle function
N  * @brief   IIC LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the IIC  
N    Interrupt Handle function.
N
N    how to use?
N
N    The IIC interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the IIC in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup IIC_LL_Inti_Cfg IIC LL Initialization And Configuration
N  * @brief    IIC LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the IIC data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Low layer IIC module initialization
N  * @param  p_iic: The structure pointer of the IIC group (IIC0, IIC1) is selected.
N  * @param  p_init: Module configuration structure pointer(TYPE_LL_IIC_INIT)
N  * @retval None
N  */
Nvoid ll_iic_init(IIC_TypeDef *p_iic, TYPE_LL_IIC_INIT *p_init);
N
N/**
N  * @brief  Low layer IIC module detele initialization
N  * @param  p_iic: The structure pointer of the IIC group (IIC0, IIC1) is selected.
N  * @retval None
N  */
Nvoid ll_iic_deinit(IIC_TypeDef *p_iic);
N
N/**
N  * @brief  Low layer IIC module interrupt configuration
N  * @param  p_iic: The structure pointer of the IIC group (IIC0, IIC1) is selected.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_IIC_IRQ_CFG)
N  * @retval None
N  */
Nvoid ll_iic_irq_config(IIC_TypeDef *p_iic, TYPE_LL_IIC_IRQ_CFG *p_cfg);
N
N/**
N  * @brief  Low layer IIC module configuration
N  * @param  p_iic: The structure pointer of the IIC group (IIC0, IIC1) is selected.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_IIC_DMA_CFG)
N  * @retval None
N  */
Nvoid ll_iic_config(IIC_TypeDef *p_iic, TYPE_LL_IIC_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup IIC_LL_Data_Transfers IIC LL Data transfers functions
N  * @brief    IIC LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the IIC data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  IIC module start function
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
Nvoid ll_iic_start(IIC_TypeDef *p_iic);
N
N/**
N  * @brief  IIC module DMA start function
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
Nvoid ll_iic_dma_start(IIC_TypeDef *p_iic);
N
N/**
N  * @brief  IIC module stop function
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
Nvoid ll_iic_stop(IIC_TypeDef *p_iic);
N
N/**
N  * @brief  IIC module DMA stop function
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
Nvoid ll_iic_dma_stop(IIC_TypeDef *p_iic);
N
N/**
N  * @brief  Timing of IIC, send start signal + address value(8 bit).
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @param  addr : the addr of IIC slave where you want to read, 
N  *                The address value is 2byte.
N  * @retval None
N  */
N#define LL_IIC_TIMING_RESTART_ADDRESS_8(p_iic, addr)                       \
Ndo {                                                                       \
N    p_iic->DATA_CMD = LL_IIC_DATA_CMD_RESTART | LL_IIC_DATA_CMD_DAT(addr); \
N} while(0)
X#define LL_IIC_TIMING_RESTART_ADDRESS_8(p_iic, addr)                       do {                                                                           p_iic->DATA_CMD = LL_IIC_DATA_CMD_RESTART | LL_IIC_DATA_CMD_DAT(addr); } while(0)
N
N/**
N  * @brief  Timing of IIC, send start signal + address value(16 bit).
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @param  addr : the addr of IIC slave where you want to read, 
N  *                The address value is 2byte.
N  * @retval None
N  */
N#define LL_IIC_TIMING_RESTART_ADDRESS_16(p_iic, addr)                           \
Ndo {                                                                            \
N    p_iic->DATA_CMD = LL_IIC_DATA_CMD_RESTART | LL_IIC_DATA_CMD_DAT(addr >> 8); \
N    p_iic->DATA_CMD = LL_IIC_DATA_CMD_DAT(addr);                                \
N} while(0)
X#define LL_IIC_TIMING_RESTART_ADDRESS_16(p_iic, addr)                           do {                                                                                p_iic->DATA_CMD = LL_IIC_DATA_CMD_RESTART | LL_IIC_DATA_CMD_DAT(addr >> 8);     p_iic->DATA_CMD = LL_IIC_DATA_CMD_DAT(addr);                                } while(0)
N
N/**
N  * @brief  Timing of IIC, send start signal + address value(8*n bit).
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @param  addr : the addr of IIC slave where you want to read, 
N  *                The address format is (low address in addr[0]).
N  * @param  len  : the addr length of IIC slave where you want to read, 
N  *                The address format is (low address in addr[0]).
N  * @retval None
N  */
N#define LL_IIC_TIMING_RESTART_ADDRESS(p_iic, addr, len)                          \
Ndo {                                                                             \
N    u8 *p_addr_buf = addr;                                                       \
N    p_iic->DATA_CMD = LL_IIC_DATA_CMD_RESTART | LL_IIC_DATA_CMD_DAT(p_addr_buf); \
N    p_addr_buf++;                                                                \
N    len--;                                                                       \
N    while(len > 0) {                                                             \
N        p_iic->DATA_CMD = LL_IIC_DATA_CMD_DAT(p_addr_buf);                       \
N        p_buf++;                                                                 \
N        len--;                                                                   \
N    }                                                                            \
N} while(0)
X#define LL_IIC_TIMING_RESTART_ADDRESS(p_iic, addr, len)                          do {                                                                                 u8 *p_addr_buf = addr;                                                           p_iic->DATA_CMD = LL_IIC_DATA_CMD_RESTART | LL_IIC_DATA_CMD_DAT(p_addr_buf);     p_addr_buf++;                                                                    len--;                                                                           while(len > 0) {                                                                     p_iic->DATA_CMD = LL_IIC_DATA_CMD_DAT(p_addr_buf);                               p_buf++;                                                                         len--;                                                                       }                                                                            } while(0)
N
N/**
N  * @brief  Timing of IIC, send start signal + read signal + stop signal.
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_TIMING_RESTART_READ_STOP(p_iic)  \
Ndo {                                            \
N    p_iic->DATA_CMD = LL_IIC_DATA_CMD_RESTART | \
N                      LL_IIC_DATA_CMD_STOP    | \
N                      LL_IIC_DATA_CMD_CMD;      \
N} while(0)
X#define LL_IIC_TIMING_RESTART_READ_STOP(p_iic)  do {                                                p_iic->DATA_CMD = LL_IIC_DATA_CMD_RESTART |                       LL_IIC_DATA_CMD_STOP    |                       LL_IIC_DATA_CMD_CMD;      } while(0)
N
N/**
N  * @brief  Timing of IIC, send start signal + read signal.
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_TIMING_RESTART_READ(p_iic)       \
Ndo {                                            \
N    p_iic->DATA_CMD = LL_IIC_DATA_CMD_RESTART | \
N                      LL_IIC_DATA_CMD_CMD;      \
N} while(0)
X#define LL_IIC_TIMING_RESTART_READ(p_iic)       do {                                                p_iic->DATA_CMD = LL_IIC_DATA_CMD_RESTART |                       LL_IIC_DATA_CMD_CMD;      } while(0)
N
N/**
N  * @brief  Timing of IIC, send read signal.
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_TIMING_READ(p_iic)          \
Ndo {                                       \
N    p_iic->DATA_CMD = LL_IIC_DATA_CMD_CMD; \
N} while(0)
X#define LL_IIC_TIMING_READ(p_iic)          do {                                           p_iic->DATA_CMD = LL_IIC_DATA_CMD_CMD; } while(0)
N
N/**
N  * @brief  Timing of IIC, send read signal + stop signal.
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_TIMING_READ_STOP(p_iic)       \
Ndo {                                         \
N    p_iic->DATA_CMD = LL_IIC_DATA_CMD_STOP | \
N                      LL_IIC_DATA_CMD_CMD;   \
N} while(0)
X#define LL_IIC_TIMING_READ_STOP(p_iic)       do {                                             p_iic->DATA_CMD = LL_IIC_DATA_CMD_STOP |                       LL_IIC_DATA_CMD_CMD;   } while(0)
N
N/**
N  * @brief  Timing of IIC, send write signal.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @param  data : data value.
N  * @retval None
N  */
N#define LL_IIC_TIMING_WRITE(p_iic, data) \
Ndo {                                     \
N    p_iic->DATA_CMD = data;              \
N} while(0)
X#define LL_IIC_TIMING_WRITE(p_iic, data) do {                                         p_iic->DATA_CMD = data;              } while(0)
N
N/**
N  * @brief  Timing of IIC, get read data.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @param  data : read data value.
N  * @retval None
N  */
N#define LL_IIC_TIMING_GET_READ_DATA(p_iic, data) \
Ndo {                                             \
N    data = (u8)p_iic->DATA_CMD;                  \
N} while(0)
X#define LL_IIC_TIMING_GET_READ_DATA(p_iic, data) do {                                                 data = (u8)p_iic->DATA_CMD;                  } while(0)
N
N/**
N  * @brief  Timing of IIC, send write signal + stop signal.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @param  data : data value.
N  * @retval None
N  */
N#define LL_IIC_TIMING_WRITE_STOP(p_iic, data)      \
Ndo {                                               \
N    p_iic->DATA_CMD = data | LL_IIC_DATA_CMD_STOP; \
N} while(0)
X#define LL_IIC_TIMING_WRITE_STOP(p_iic, data)      do {                                                   p_iic->DATA_CMD = data | LL_IIC_DATA_CMD_STOP; } while(0)
N
N/**
N  * @brief  IIC get interrupt pending
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_GET_INTERRPT_PENDING(p_iic)                      ((p_iic)->INTR_STAT)
N
N/**
N  * @brief  IIC check recevied under interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_RX_UNDER_INTERRUPT_ENABLE(p_iic)           ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_RX_UNDER)
N
N/**
N  * @brief  IIC check rx buffer overflow up interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_RX_OVER_INTERRUPT_ENABLE(p_iic)            ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_RX_OVER)
N
N/**
N  * @brief  IIC check rx buffer full interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_RX_FULL_INTERRUPT_ENABLE(p_iic)            ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_RX_FULL)
N
N/**
N  * @brief  IIC check tx buffer overflow interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_TX_OVER_INTERRUPT_ENABLE(p_iic)            ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_TX_OVER)
N
N/**
N  * @brief  IIC check tx buffer empty interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_TX_EMPTY_INTERRUPT_ENABLE(p_iic)           ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_TX_EMPTY)
N
N/**
N  * @brief  IIC check read request interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_READ_REQ_INTERRUPT_ENABLE(p_iic)           ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_RD_REQ)
N
N/**
N  * @brief  IIC check tx abrt interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_TX_ABRT_INTERRUPT_ENABLE(p_iic)            ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_TX_ABRT)
N
N/**
N  * @brief  IIC check rx done interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_RX_DONE_INTERRUPT_ENABLE(p_iic)            ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_RX_DONE)
N
N/**
N  * @brief  IIC check DW_apb_i2c activity interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_ACTIVITY_INTERRUPT_ENABLE(p_iic)           ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_ACTIVITY)
N
N/**
N  * @brief  IIC check stop condition detect interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_STOP_DET_INTERRUPT_ENABLE(p_iic)           ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_STOP_DET)
N
N/**
N  * @brief  IIC check start condition detect interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_START_DET_INTERRUPT_ENABLE(p_iic)          ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_START_DET)
N
N/**
N  * @brief  IIC check General Call address interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_GEN_CALL_INTERRUPT_ENABLE(p_iic)           ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_GEN_CALL)
N
N/**
N  * @brief  IIC check RESTART condition interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_RESTART_DET_INTERRUPT_ENABLE(p_iic)        ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_RESTART_DET)
N
N/**
N  * @brief  IIC check master on hold interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_MST_ON_HOLD_INTERRUPT_ENABLE(p_iic)        ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_MST_ON_HOLD)
N
N/**
N  * @brief  IIC check SCL Line is stuck at low interrupt enable
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval None
N  */
N#define LL_IIC_CHECK_SCL_STUCK_AT_LOW_INTERRUPT_ENABLE(p_iic)   ((p_iic)->INTR_MASK & LL_IIC_INTR_MASK_M_SCL_STUCK_AT_LOW)
N
N/**
N  * @brief  Low layer get IIC Activity Status.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_ACTIVITY(p_iic)                       ((p_iic)->STATUS & LL_IIC_STATUS_ACTIVITY)
N
N/**
N  * @brief  Low layer get Transmit FIFO Not Full status. Set when the transmit FIFO contains 
N  *         one or more empty locations, and is cleared when the FIFO is full
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_TX_FIFO_NO_FULL(p_iic)                ((p_iic)->STATUS & LL_IIC_STATUS_TFNF)
N
N/**
N  * @brief  Low layer get IIC Transmit FIFO Completely Empty status. When the transmit FIFO is 
N  *         completely empty, this bit is set. When it contains one or more valid entries, 
N  *         this bit is cleared. This bit field does not request an interrupt.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_TX_FIFO_EMPTY(p_iic)                  ((p_iic)->STATUS & LL_IIC_STATUS_TFE)
N
N/**
N  * @brief  Low layer get IIC Receive FIFO Not Empty status. This bit is set when the receive 
N  *         FIFO contains one or more entries; it is cleared when the receive FIFO is empty. 
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_RX_FIFO_NO_EMPTY(p_iic)               ((p_iic)->STATUS & LL_IIC_STATUS_RFNE)
N
N/**
N  * @brief  Low layer get IIC Receive FIFO Completely Full status. When the receive FIFO is 
N  *         completely full, this bit is set. When the receive FIFO contains one or more 
N  *         empty location, this bit is cleared.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_RX_FIFO_FULL(p_iic)                   ((p_iic)->STATUS & LL_IIC_STATUS_RFF)
N
N/**
N  * @brief  Low layer get IIC Master FSM Activity Status. When the Master Finite State Machine 
N  *         (FSM) is not in the IDLE state, this bit is set.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_MST_ACTIVITY(p_iic)                   ((p_iic)->STATUS & LL_IIC_STATUS_MST_ACTIVITY)
N
N/**
N  * @brief  Low layer get IIC Slave FSM Activity Status. When the Slave Finite State Machine 
N  *         (FSM) is not in the IDLE state, this bit is set
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_SLV_ACTIVITY(p_iic)                   ((p_iic)->STATUS & LL_IIC_STATUS_SLV_ACTIVITY)
N
N/**
N  * @brief  Low layer get IIC master hold tx fifo empty Status.This bit indicates the BUS hold 
N  *         when the master holds the bus because of the Tx FIFO being empty, and the the 
N  *         previous transferred command does not have the Stop bit set. 
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_MST_HOLD_TX_FIFO_EMPTY(p_iic)         ((p_iic)->STATUS & LL_IIC_STATUS_MST_HOLD_TX_FIFO_EMPTY)
N
N/**
N  * @brief  Low layer get IIC master hold rx fifo full Status.This bit indicates the BUS Hold 
N  *         in Master mode due to Rx FIFO is Full and additional byte has been received 
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_MST_HOLD_RX_FIFO_FULL(p_iic)          ((p_iic)->STATUS & LL_IIC_STATUS_MST_HOLD_RX_FIFO_FULL)
N
N/**
N  * @brief  Low layer get IIC slave hold tx fifo_empty Status.This bit indicates the BUS Hold 
N  *         in Slave mode for the Read request when the Tx FIFO is empty. The Bus is in hold 
N  *         until the Tx FIFO has data to Transmit for the read request.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_SLV_HOLD_TX_FIFO_EMPTY(p_iic)         ((p_iic)->STATUS & LL_IIC_STATUS_SLV_HOLD_TX_FIFO_EMPTY)
N
N/**
N  * @brief  Low layer get IIC slave hold rx fifo full Status.This bit indicates the BUS Hold 
N  *         in Slave mode due to the Rx FIFO being Full and an additional byte being received.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_SLV_HOLD_RX_FIFO_FULL(p_iic)          ((p_iic)->STATUS & LL_IIC_STATUS_SLV_HOLD_RX_FIFO_FULL)
N
N/**
N  * @brief  Low layer get IIC sda stuck no recovered Status.This bit indicates that an SDA stuck 
N  *         at low is not recovered after the recovery mechanism.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_SDA_STUCK_NOT_RECOVERED(p_iic)        ((p_iic)->STATUS & LL_IIC_STATUS_SDA_STUCK_NOT_RECOVERED)
N
N/**
N  * @brief  Low layer get IIC smbus quick command bit Status.This bit indicates the R/W bit of 
N  *         the Quick command received. This bit will be cleared after the user has read this bit.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_SMBUS_QUICK_CMD_BIT(p_iic)            ((p_iic)->STATUS & LL_IIC_STATUS_SMBUS_QUICK_CMD_BIT)
N
N/**
N  * @brief  Low layer get IIC smbus slave address valid Status.This bit indicates whether the 
N  *         SMBus Slave address (ic_sar[6:0]) is valid or not.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_SMBUS_SLAVE_ADDR_VALID(p_iic)         ((p_iic)->STATUS & LL_IIC_STATUS_SMBUS_SLAVE_ADDR_VALID)
N
N/**
N  * @brief  Low layer get IIC smbus slave address resolved Status.This bit indicates whether 
N  *         the SMBus Slave address (ic_sar[6:0]) is Resolved by ARP Master.
N
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_SMBUS_SLAVE_ADDR_RESOLVED(p_iic)      ((p_iic)->STATUS & LL_IIC_STATUS_SMBUS_SLAVE_ADDR_RESOLVED)
N
N/**
N  * @brief  Low layer get IIC smbus suspend Status.This bit indicates whether the status of 
N  *         the input signal is ic_smbus_sus_in_n. This signal is asserted when the SMBus 
N  *         Suspend signal is asserted by the SMBus Host.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_SMBUS_SUSPEND_STATUS(p_iic)           ((p_iic)->STATUS & LL_IIC_STATUS_SMBUS_SUSPEND_STATUS)
N 
N/**
N  * @brief  Low layer get IIC smbus alert Status.This bit indicates whether the status of the 
N  *         input signal is ic_smbus_alert_in_n. This signal is asserted when the SMBus Alert 
N  *         signal is asserted by the SMBus Device.
N  * @param  p_iic: Select the initialized IIC group pointer.
N  * @retval pending value
N  */
N#define LL_IIC_GET_STATUS_SMBUS_ALERT_STATUS(p_iic)             ((p_iic)->STATUS & LL_IIC_STATUS_SMBUS_ALERT_STATUS)
N
N/**
N  * @brief  IIC module get recevied under pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RX_UNDER_PENDING(p_iic)                      ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_RX_UNDER)
N
N/**
N  * @brief  IIC module get rx buffer overflow up pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RX_OVER_PENDING(p_iic)                       ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_RX_OVER)
N
N/**
N  * @brief  IIC module get rx buffer full pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RX_FULL_PENDING(p_iic)                       ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_RX_FULL)
N
N/**
N  * @brief  IIC module get tx buffer overflow pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_TX_OVER_PENDING(p_iic)                       ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_TX_OVER)
N
N/**
N  * @brief  IIC module get tx buffer empty pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_TX_EMPTY_PENDING(p_iic)                      ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_TX_EMPTY)
N
N/**
N  * @brief  IIC module get read request pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_READ_REQ_PENDING(p_iic)                      ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_RD_REQ)
N
N/**
N  * @brief  IIC module get tx abrt pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_TX_ABRT_PENDING(p_iic)                       ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_TX_ABRT)
N
N/**
N  * @brief  IIC module get rx done pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RX_DONE_PENDING(p_iic)                       ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_RX_DONE)
N
N/**
N  * @brief  IIC module get DW_apb_i2c activity pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_ACTIVITY_PENDING(p_iic)                      ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_ACTIVITY)
N
N/**
N  * @brief  IIC module get stop condition detect pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_STOP_DET_PENDING(p_iic)                      ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_STOP_DET)
N
N/**
N  * @brief  IIC module start condition detect pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_START_DET_PENDING(p_iic)                     ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_START_DET)
N
N/**
N  * @brief  IIC module get General Call address pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_GEN_CALL_PENDING(p_iic)                      ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_GEN_CALL)
N
N/**
N  * @brief  IIC module get master on hold pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_MST_ON_HOLD_PENDING(p_iic)                   ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_MST_ON_HOLD)
N
N/**
N  * @brief  IIC module get RESTART condition pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RESTART_DET_PENDING(p_iic)                   ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_RESTART_DET)
N
N/**
N  * @brief  IIC module get SCL Line is stuck at low pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_SCL_STUCK_AT_LOW_PENDING(p_iic)              ((p_iic)->INTR_STAT & LL_IIC_INTR_STAT_R_SCL_STUCK_AT_LOW)
N
N/**
N  * @brief  IIC module get recevied under pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_RX_UNDER_PENDING(p_iic)                  ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_RX_UNDER)
N
N/**
N  * @brief  IIC module get rx buffer overflow up pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_RX_OVER_PENDING(p_iic)                   ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_RX_OVER)
N
N/**
N  * @brief  IIC module get rx buffer full pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_RX_FULL_PENDING(p_iic)                   ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_RX_FULL)
N
N/**
N  * @brief  IIC module get tx buffer overflow pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_TX_OVER_PENDING(p_iic)                   ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_TX_OVER)
N
N/**
N  * @brief  IIC module get tx buffer empty pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_TX_EMPTY_PENDING(p_iic)                  ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_TX_EMPTY)
N
N/**
N  * @brief  IIC module get read request pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_READ_REQ_PENDING(p_iic)                  ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_RD_REQ)
N
N/**
N  * @brief  IIC module get tx abrt pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_TX_ABRT_PENDING(p_iic)                   ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_TX_ABRT)
N
N/**
N  * @brief  IIC module get rx done pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_RX_DONE_PENDING(p_iic)                   ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_RX_DONE)
N
N/**
N  * @brief  IIC module get DW_apb_i2c activity pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_ACTIVITY_PENDING(p_iic)                  ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_ACTIVITY)
N
N/**
N  * @brief  IIC module get stop condition detect pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_STOP_DET_PENDING(p_iic)                  ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_STOP_DET)
N
N/**
N  * @brief  IIC module get start condition detect pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_START_DET_PENDING(p_iic)                 ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_START_DET)
N
N/**
N  * @brief  IIC module get General Call address pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_GEN_CALL_PENDING(p_iic)                  ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_GEN_CALL)
N
N/**
N  * @brief  IIC module get RESTART condition pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_RESTART_DET_PENDING(p_iic)               ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_RESTART_DET)
N
N/**
N  * @brief  IIC module get master on hold pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_MST_ON_HOLD_PENDING(p_iic)               ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_MST_ON_HOLD)
N
N/**
N  * @brief  IIC module get SCL Line is stuck at low pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N#define LL_IIC_GET_RAW_SCL_STUCK_AT_LOW_PENDING(p_iic)          ((p_iic)->RAW_INTR_STAT & LL_IIC_RAW_INTR_STAT_SCL_STUCK_AT_LOW)
N
N/**
N  * @brief  IIC module clear recevied under pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_rx_under_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_rx_under_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_RX_UNDER = p_iic->CLR_RX_UNDER;
N}
N
N/**
N  * @brief  IIC module clear rx buffer overflow up pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_rx_over_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_rx_over_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_RX_OVER = p_iic->CLR_RX_OVER;
N}
N
N/**
N  * @brief  IIC module clear rx buffer full pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_rx_full_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_rx_full_pending(IIC_TypeDef *p_iic) {
N    /* Note: RX_FULL does not have a separate CLR register. It can only be 
N     * masked or read from the data in the RX buffer. Only the RX FIFO buffer 
N     * does not reach full, and the pending will not rise again.
N     */
N}
N
N/**
N  * @brief  IIC module clear tx buffer overflow pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_tx_over_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_tx_over_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_TX_OVER = p_iic->CLR_TX_OVER;
N}
N
N/**
N  * @brief  IIC module clear tx buffer empty pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_tx_empty_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_tx_empty_pending(IIC_TypeDef *p_iic) {
N    /* Note: TX empty does not have a separate CLR register. It can only be 
N     * masked or read from the TX buffer. Only the TX FIFO Buffer is not empty. 
N     * This pending will not be up again.
N     */
N}
N
N/**
N  * @brief  IIC module clear read request pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_read_req_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_read_req_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_RD_REQ = p_iic->CLR_RD_REQ;
N}
N
N/**
N  * @brief  IIC module clear tx abrt pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_tx_abrt_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_tx_abrt_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_TX_ABRT = p_iic->CLR_TX_ABRT;
N}
N
N/**
N  * @brief  IIC module clear rx done pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_rx_done_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_rx_done_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_RX_DONE = p_iic->CLR_RX_DONE;
N}
N
N/**
N  * @brief  IIC module clear DW_apb_i2c activity pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_activity_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_activity_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_ACTIVITY = p_iic->CLR_ACTIVITY;
N}
N
N/**
N  * @brief  IIC module clear stop condition detect pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_stop_det_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_stop_det_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_STOP_DET = p_iic->CLR_STOP_DET;
N}
N
N/**
N  * @brief  IIC module clear start condition detect pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_start_det_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_start_det_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_START_DET = p_iic->CLR_START_DET;
N}
N
N/**
N  * @brief  IIC module clear General Call address pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_gen_call_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_gen_call_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_GEN_CALL = p_iic->CLR_GEN_CALL;
N}
N
N/**
N  * @brief  IIC module clear RESTART condition pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_restart_det_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_restart_det_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_RESTART_DET = p_iic->CLR_RESTART_DET;
N}
N
N/**
N  * @brief  IIC module clear master on hold pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_master_on_hold_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_master_on_hold_pending(IIC_TypeDef *p_iic) {
N    /* Note: MASTER_ON_HOLD does not have a separate CLR register. It can 
N     * only be masked or read from the TX buffer. Only the TX FIFO Buffer 
N     * is not empty. This pending will not be up again. 
N     */
N}
N
N/**
N  * @brief  IIC module clear SCL Line is stuck at low pending
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_clear_stuck_at_low_pending(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_clear_stuck_at_low_pending(IIC_TypeDef *p_iic) {
N    p_iic->CLR_SCL_STUCK_DET = p_iic->CLR_SCL_STUCK_DET;
N}
N
N/**
N  * @brief  IIC module enable recevied under interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_rx_under_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_rx_under_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_RX_UNDER;
X    p_iic->INTR_MASK |= (1UL << 0);
N}
N
N/**
N  * @brief  IIC module disable recevied under interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_rx_under_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_rx_under_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_RX_UNDER);
X    p_iic->INTR_MASK &= ~((1UL << 0));
N}
N
N/**
N  * @brief  IIC module enable rx buffer overflow up interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_rx_over_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_rx_over_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_RX_OVER;
X    p_iic->INTR_MASK |= (1UL << 1);
N}
N
N/**
N  * @brief  IIC module disable rx buffer overflow up interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_rx_over_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_rx_over_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_RX_OVER);
X    p_iic->INTR_MASK &= ~((1UL << 1));
N}
N
N/**
N  * @brief  IIC module enable rx buffer full interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_rx_full_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_rx_full_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_RX_FULL;
X    p_iic->INTR_MASK |= (1UL << 2);
N}
N
N/**
N  * @brief  IIC module disable rx buffer full interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_rx_full_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_rx_full_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_RX_FULL);
X    p_iic->INTR_MASK &= ~((1UL << 2));
N}
N
N/**
N  * @brief  IIC module enable tx buffer overflow interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_tx_over_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_tx_over_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_TX_OVER;
X    p_iic->INTR_MASK |= (1UL << 3);
N}
N
N/**
N  * @brief  IIC module disable tx buffer overflow interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_tx_over_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_tx_over_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_TX_OVER);
X    p_iic->INTR_MASK &= ~((1UL << 3));
N}
N
N/**
N  * @brief  IIC module enable tx buffer empty interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_tx_empty_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_tx_empty_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_TX_EMPTY;
X    p_iic->INTR_MASK |= (1UL << 4);
N}
N
N/**
N  * @brief  IIC module disable tx buffer empty interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_tx_empty_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_tx_empty_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_TX_EMPTY);
X    p_iic->INTR_MASK &= ~((1UL << 4));
N}
N
N/**
N  * @brief  IIC module enable read request interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_read_req_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_read_req_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_RD_REQ;
X    p_iic->INTR_MASK |= (1UL << 5);
N}
N
N/**
N  * @brief  IIC module disable read request interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_read_req_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_read_req_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_RD_REQ);
X    p_iic->INTR_MASK &= ~((1UL << 5));
N}
N
N/**
N  * @brief  IIC module enable tx abrt interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_tx_abrt_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_tx_abrt_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_TX_ABRT;
X    p_iic->INTR_MASK |= (1UL << 6);
N}
N
N/**
N  * @brief  IIC module disable tx abrt interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_tx_abrt_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_tx_abrt_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_TX_ABRT);
X    p_iic->INTR_MASK &= ~((1UL << 6));
N}
N
N/**
N  * @brief  IIC module enable rx done interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_rx_done_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_rx_done_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_RX_DONE;
X    p_iic->INTR_MASK |= (1UL << 7);
N}
N
N/**
N  * @brief  IIC module disable rx done interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_rx_done_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_rx_done_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_RX_DONE);
X    p_iic->INTR_MASK &= ~((1UL << 7));
N}
N
N/**
N  * @brief  IIC module enable DW_apb_i2c activity interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_activity_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_activity_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_ACTIVITY;
X    p_iic->INTR_MASK |= (1UL << 8);
N}
N
N/**
N  * @brief  IIC module disable DW_apb_i2c activity interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_activity_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_activity_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_ACTIVITY);
X    p_iic->INTR_MASK &= ~((1UL << 8));
N}
N
N/**
N  * @brief  IIC module enable stop condition detect interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_stop_det_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_stop_det_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_STOP_DET;
X    p_iic->INTR_MASK |= (1UL << 9);
N}
N
N/**
N  * @brief  IIC module disable stop condition detect interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_stop_det_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_stop_det_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_STOP_DET);
X    p_iic->INTR_MASK &= ~((1UL << 9));
N}
N
N/**
N  * @brief  IIC module enable start condition detect interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_start_det_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_start_det_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_START_DET;
X    p_iic->INTR_MASK |= (1UL << 10);
N}
N
N/**
N  * @brief  IIC module disable start condition detect interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_start_det_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_start_det_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_START_DET);
X    p_iic->INTR_MASK &= ~((1UL << 10));
N}
N
N/**
N  * @brief  IIC module enable General Call address interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_gen_call_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_gen_call_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_GEN_CALL;
X    p_iic->INTR_MASK |= (1UL << 11);
N}
N
N/**
N  * @brief  IIC module disable General Call address interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_gen_call_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_gen_call_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_GEN_CALL);
X    p_iic->INTR_MASK &= ~((1UL << 11));
N}
N
N/**
N  * @brief  IIC module enable RESTART condition interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_restart_det_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_restart_det_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_RESTART_DET;
X    p_iic->INTR_MASK |= (1UL << 12);
N}
N
N/**
N  * @brief  IIC module disable RESTART condition interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_restart_det_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_restart_det_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_RESTART_DET);
X    p_iic->INTR_MASK &= ~((1UL << 12));
N}
N
N/**
N  * @brief  IIC module enable master on hold interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_master_on_hold_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_master_on_hold_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_MST_ON_HOLD;
X    p_iic->INTR_MASK |= (1UL << 13);
N}
N
N/**
N  * @brief  IIC module disable master on hold interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_master_on_hold_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_master_on_hold_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_MST_ON_HOLD);
X    p_iic->INTR_MASK &= ~((1UL << 13));
N}
N
N/**
N  * @brief  IIC module enable SCL Line is stuck at low interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_scl_stuck_at_low_interrupt_enable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_scl_stuck_at_low_interrupt_enable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK |= LL_IIC_INTR_MASK_M_SCL_STUCK_AT_LOW;
X    p_iic->INTR_MASK |= (1UL << 14);
N}
N
N/**
N  * @brief  IIC module disable SCL Line is stuck at low interrupt
N  * @param  p_iic: Select the initialized IIC group pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_scl_stuck_at_low_interrupt_disable(IIC_TypeDef *p_iic) {
Xstatic __inline void ll_iic_scl_stuck_at_low_interrupt_disable(IIC_TypeDef *p_iic) {
N    p_iic->INTR_MASK &= ~(LL_IIC_INTR_MASK_M_SCL_STUCK_AT_LOW);
X    p_iic->INTR_MASK &= ~((1UL << 14));
N}
N
N/**
N  * @brief  Set the target address of iic in host mode.
N  * @param  p_iic      : Select the initialized IIC group pointer
N  * @param  target_addr: The destination address value of iic.
N  * @retval None
N  */
N__STATIC_INLINE void ll_iic_set_target_addr(IIC_TypeDef *p_iic, u16 target_addr) {
Xstatic __inline void ll_iic_set_target_addr(IIC_TypeDef *p_iic, u16 target_addr) {
N    p_iic->TAR &= ~(LL_IIC_TAR_IC_TAR(0x3FF));
X    p_iic->TAR &= ~((((0x3FF)&0x3FF) << 0));
N    p_iic->TAR |= LL_IIC_TAR_IC_TAR(target_addr);
X    p_iic->TAR |= (((target_addr)&0x3FF) << 0);
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_IIC_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 58 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_evsys.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_evsys.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_evsys.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the EVSYS LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_EVSYS_H
N#define __TX_PHE_LL_EVSYS_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup evsys_interface_gr EVSYS Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup EVSYS_LL_Driver EVSYS LL Driver
N  * @ingroup  evsys_interface_gr
N  * @brief Mainly the driver part of the EVSYS module, which includes \b EVSYS \b Register 
N  * \b Constants, \b EVSYS \b Exported \b Constants, \b EVSYS \b Exported \b Struct, \b EVSYS
N  * \b Data \b transfers \b functions, \b EVSYS \b Initialization \b and \b EVSYS \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N 
N/** @defgroup EVSYS_LL_Register_Constants EVSYS LL Register Constants
N  * @ingroup  EVSYS_LL_Driver
N  * @brief    EVSYS LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the EVSYS 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the EVSYS register, mainly for convenience. Understand the 
N    configuration of the EVSYS.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** CH_ENA *****/
N/*! evsys channel enable
N */
N#define LL_EVSYS_CHN_ENABLE(n)                    (((n)&0xFFFF) << 0)
N
N
N/***** CH_INT_ENA *****/
N/*! evsys channel interrupt enable
N */
N#define LL_EVSYS_CHN_INTR_ENABLE(n)               (((n)&0xFFFF) << 0)
N
N
N/***** CPU_KST *****/
N/*! evsys channel kick start
N */
N#define LL_EVSYS_CHN_KICK_START_L(n)              (((n)&0xFFFF) << 0)
N/*! evsys channel kick start
N */
N#define LL_EVSYS_CHN_KICK_START_H(n)              (((n)&0xFFFF) << 16)
N
N
N/***** CH_PND_CLR *****/
N/*! evsys channel cpu clear pending
N */
N#define LL_EVSYS_CHN_PND_CLR(n)                   (((n)&0xFFFF) << 0)
N
N
N/***** CH_CPU_PND *****/
N/*! evsys channel cpu pending
N */
N#define LL_EVSYS_CHN_CPU_PND(n)                   (((n)&0xFFFF) << 0)
N
N
N/***** CH_HW_PND *****/
N/*! evsys channel hardware pending
N */
N#define LL_EVSYS_CHN_HW_PND(n)                    (((n)&0xFFFF) << 0)
N
N
N/***** CH_MODE *****/
N/*! evsys channel mode select
N */
N#define LL_EVSYS_CHN_MODE(n)                      (((n)&0xFFFF) << 0)
N
N
N/***** SRC_CH_CON0 *****/
N/*! evsys source channel num select(low chn: 0~31)
N */
N#define LL_EVSYS_SRC_CHN_NUM0(n)                  (((n)&0xFFFFFFFF) << 0)
N
N
N/***** SRC_CH_CON1 *****/
N/*! evsys source channel counter set
N */
N#define LL_EVSYS_SRC_CHN_CNT(n)                   (((n)&0xFFFF) << 16)
N/*! evsys source channel num select(high chn: 32~43)
N */
N#define LL_EVSYS_SRC_CHN_NUM1(n)                  (((n)&0x7FF) << 0)
N
N
N/***** DST_CH_CON0 *****/
N/*! evsys destination channel enable
N */
N#define LL_EVSYS_DST_CHN_ENABLE(n)                (((n)&0xFFFFFFFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup EVSYS_LL_Exported_Constants EVSYS LL Exported Constants
N  * @ingroup  EVSYS_LL_Driver
N  * @brief    EVSYS LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for The EVSYS source event selection
N  */
Ntypedef enum {
N    /*! EVSYS source channel trigger signal selection(IIR0     ): 0
N     */
N    LL_EVSYS_SRC_EVENT_IIR0 = 0,
N    /*! EVSYS source channel trigger signal selection(IIR1     ): 1
N     */
N    LL_EVSYS_SRC_EVENT_IIR1,
N    /*! EVSYS source channel trigger signal selection(IIR2     ): 2
N     */
N    LL_EVSYS_SRC_EVENT_IIR2,
N    /*! EVSYS source channel trigger signal selection(FIR0     ): 3
N     */
N    LL_EVSYS_SRC_EVENT_FIR0,
N    /*! EVSYS source channel trigger signal selection(FIR1     ): 4
N     */
N    LL_EVSYS_SRC_EVENT_FIR1,
N    /*! EVSYS source channel trigger signal selection(FIR2     ): 5
N     */
N    LL_EVSYS_SRC_EVENT_FIR2,
N    /*! EVSYS source channel trigger signal selection(ARCTAN0  ): 6
N     */
N    LL_EVSYS_SRC_EVENT_ARCTAN0,
N    /*! EVSYS source channel trigger signal selection(ARCTAN1  ): 7
N     */
N    LL_EVSYS_SRC_EVENT_ARCTAN1,
N    /*! EVSYS source channel trigger signal selection(ARCTAN2  ): 8
N     */
N    LL_EVSYS_SRC_EVENT_ARCTAN2,
N    /*! EVSYS source channel trigger signal selection(DFTTRANS0): 9
N     */
N    LL_EVSYS_SRC_EVENT_DFTTRANS0,
N    /*! EVSYS source channel trigger signal selection(DFTTRANS1): 10
N     */
N    LL_EVSYS_SRC_EVENT_DFTTRANS1,
N    /*! EVSYS source channel trigger signal selection(DFTTRANS2): 11
N     */
N    LL_EVSYS_SRC_EVENT_DFTTRANS2,
N    /*! EVSYS source channel trigger signal selection(FFT0     ): 12
N     */
N    LL_EVSYS_SRC_EVENT_FFT0,
N    /*! EVSYS source channel trigger signal selection(FFT1     ): 13
N     */
N    LL_EVSYS_SRC_EVENT_FFT1,
N    /*! EVSYS source channel trigger signal selection(FFT2     ): 14
N     */
N    LL_EVSYS_SRC_EVENT_FFT2,
N    /*! EVSYS source channel trigger signal selection(FFT0_DMA ): 15
N     */
N    LL_EVSYS_SRC_EVENT_FFT0_DMA,
N    /*! EVSYS source channel trigger signal selection(FFT1_DMA ): 16
N     */
N    LL_EVSYS_SRC_EVENT_FFT1_DMA,
N    /*! EVSYS source channel trigger signal selection(FFT2_DMA ): 17
N     */
N    LL_EVSYS_SRC_EVENT_FFT2_DMA,
N    /*! EVSYS source channel trigger signal selection(MATRIX0  ): 18
N     */
N    LL_EVSYS_SRC_EVENT_MATRIX0,
N    /*! EVSYS source channel trigger signal selection(MATRIX1  ): 19
N     */
N    LL_EVSYS_SRC_EVENT_MATRIX1,
N    /*! EVSYS source channel trigger signal selection(MATRIX2  ): 20
N     */
N    LL_EVSYS_SRC_EVENT_MATRIX2,
N    /*! EVSYS source channel trigger signal selection(MATRIX3  ): 21
N     */
N    LL_EVSYS_SRC_EVENT_MATRIX3,
N    /*! EVSYS source channel trigger signal selection(RMS0     ): 22
N     */
N    LL_EVSYS_SRC_EVENT_RMS0,
N    /*! EVSYS source channel trigger signal selection(RMS1     ): 23
N     */
N    LL_EVSYS_SRC_EVENT_RMS1,
N    /*! EVSYS source channel trigger signal selection(RMS2     ): 24
N     */
N    LL_EVSYS_SRC_EVENT_RMS2,
N    /*! EVSYS source channel trigger signal selection(SINCOS0  ): 25
N     */
N    LL_EVSYS_SRC_EVENT_SINCOS0,
N    /*! EVSYS source channel trigger signal selection(SINCOS1  ): 26
N     */
N    LL_EVSYS_SRC_EVENT_SINCOS1,
N    /*! EVSYS source channel trigger signal selection(DATA_DMA ): 27
N     */
N    LL_EVSYS_SRC_EVENT_DATA_DMA,
N    /*! EVSYS source channel trigger signal selection(HCC      ): 28
N     */
N    LL_EVSYS_SRC_EVENT_HCC,
N    /*! EVSYS source channel trigger signal selection(SARADC0  ): 29
N     */
N    LL_EVSYS_SRC_EVENT_SARADC0,
N    /*! EVSYS source channel trigger signal selection(SARADC1  ): 30
N     */
N    LL_EVSYS_SRC_EVENT_SARADC1,
N    /*! EVSYS source channel trigger signal selection(SARADC2  ): 31
N     */
N    LL_EVSYS_SRC_EVENT_SARADC2,
N    /*! EVSYS source channel trigger signal selection(SARADC3  ): 32
N     */
N    LL_EVSYS_SRC_EVENT_SARADC3,
N    /*! EVSYS source channel trigger signal selection(SARADC4  ): 33
N     */
N    LL_EVSYS_SRC_EVENT_SARADC4,
N    /*! EVSYS source channel trigger signal selection(SARADC5  ): 34
N     */
N    LL_EVSYS_SRC_EVENT_SARADC5,
N    /*! EVSYS source channel trigger signal selection(SARADC6  ): 35
N     */
N    LL_EVSYS_SRC_EVENT_SARADC6,
N    /*! EVSYS source channel trigger signal selection(SARADC7  ): 36
N     */
N    LL_EVSYS_SRC_EVENT_SARADC7,
N    /*! EVSYS source channel trigger signal selection(SARADC8  ): 37
N     */
N    LL_EVSYS_SRC_EVENT_SARADC8,
N    /*! EVSYS source channel trigger signal selection(SARADC9  ): 38
N     */
N    LL_EVSYS_SRC_EVENT_SARADC9,
N    /*! EVSYS source channel trigger signal selection(SARADC10 ): 39
N     */
N    LL_EVSYS_SRC_EVENT_SARADC10,
N    /*! EVSYS source channel trigger signal selection(SARADC11 ): 40
N     */
N    LL_EVSYS_SRC_EVENT_SARADC11,
N    /*! EVSYS source channel trigger signal selection(SARADC12 ): 41
N     */
N    LL_EVSYS_SRC_EVENT_SARADC12,
N    /*! EVSYS source channel trigger signal selection(SARADC13 ): 42
N     */
N    LL_EVSYS_SRC_EVENT_SARADC13,
N    /*! EVSYS source channel trigger signal selection(idle     ): 65
N     */
N    LL_EVSYS_SRC_EVEVT_IDLE = 65,
N    /*! EVSYS source channel trigger signal selection(CPU kick ): 66
N     */
N    LL_EVSYS_SRC_EVEVT_CPU  = 66,
N} TYPE_ENUM_LL_EVSYS_SRC_EVENT_SEL;
N
N/**
N  * @brief Enumeration constant for The EVSYS destination event selection
N  */
Ntypedef enum {
N    /*! EVSYS destination channel trigger signal selection(IIR0     ): 0
N     */
N    LL_EVSYS_DST_EVENT_IIR0 = 0,
N    /*! EVSYS destination channel trigger signal selection(IIR1     ): 1
N     */
N    LL_EVSYS_DST_EVENT_IIR1,
N    /*! EVSYS destination channel trigger signal selection(IIR2     ): 2
N     */
N    LL_EVSYS_DST_EVENT_IIR2,
N    /*! EVSYS destination channel trigger signal selection(FIR0     ): 3
N     */
N    LL_EVSYS_DST_EVENT_FIR0,
N    /*! EVSYS destination channel trigger signal selection(FIR1     ): 4
N     */
N    LL_EVSYS_DST_EVENT_FIR1,
N    /*! EVSYS destination channel trigger signal selection(FIR2     ): 5
N     */
N    LL_EVSYS_DST_EVENT_FIR2,
N    /*! EVSYS destination channel trigger signal selection(ARCTAN0  ): 6
N     */
N    LL_EVSYS_DST_EVENT_ARCTAN0,
N    /*! EVSYS destination channel trigger signal selection(ARCTAN1  ): 7
N     */
N    LL_EVSYS_DST_EVENT_ARCTAN1,
N    /*! EVSYS destination channel trigger signal selection(ARCTAN2  ): 8
N     */
N    LL_EVSYS_DST_EVENT_ARCTAN2,
N    /*! EVSYS destination channel trigger signal selection(DFTTRANS0): 9
N     */
N    LL_EVSYS_DST_EVENT_DFTTRANS0,
N    /*! EVSYS destination channel trigger signal selection(DFTTRANS1): 10
N     */
N    LL_EVSYS_DST_EVENT_DFTTRANS1,
N    /*! EVSYS destination channel trigger signal selection(DFTTRANS2): 11
N     */
N    LL_EVSYS_DST_EVENT_DFTTRANS2,
N    /*! EVSYS destination channel trigger signal selection(FFT0     ): 12
N     */
N    LL_EVSYS_DST_EVENT_FFT0,
N    /*! EVSYS destination channel trigger signal selection(FFT1     ): 13
N     */
N    LL_EVSYS_DST_EVENT_FFT1,
N    /*! EVSYS destination channel trigger signal selection(FFT2     ): 14
N     */
N    LL_EVSYS_DST_EVENT_FFT2,
N    /*! EVSYS destination channel trigger signal selection(FFT0_DMA ): 15
N     */
N    LL_EVSYS_DST_EVENT_FFT0_DMA,
N    /*! EVSYS destination channel trigger signal selection(FFT1_DMA ): 16
N     */
N    LL_EVSYS_DST_EVENT_FFT1_DMA,
N    /*! EVSYS destination channel trigger signal selection(FFT2_DMA ): 17
N     */
N    LL_EVSYS_DST_EVENT_FFT2_DMA,
N    /*! EVSYS destination channel trigger signal selection(MATRIX0  ): 18
N     */
N    LL_EVSYS_DST_EVENT_MATRIX0,
N    /*! EVSYS destination channel trigger signal selection(MATRIX1  ): 19
N     */
N    LL_EVSYS_DST_EVENT_MATRIX1,
N    /*! EVSYS destination channel trigger signal selection(MATRIX2  ): 20
N     */
N    LL_EVSYS_DST_EVENT_MATRIX2,
N    /*! EVSYS destination channel trigger signal selection(MATRIX3  ): 21
N     */
N    LL_EVSYS_DST_EVENT_MATRIX3,
N    /*! EVSYS destination channel trigger signal selection(RMS0     ): 22
N     */
N    LL_EVSYS_DST_EVENT_RMS0,
N    /*! EVSYS destination channel trigger signal selection(RMS1     ): 23
N     */
N    LL_EVSYS_DST_EVENT_RMS1,
N    /*! EVSYS destination channel trigger signal selection(RMS2     ): 24
N     */
N    LL_EVSYS_DST_EVENT_RMS2,
N    /*! EVSYS destination channel trigger signal selection(SINCOS0  ): 25
N     */
N    LL_EVSYS_DST_EVENT_SINCOS0,
N    /*! EVSYS destination channel trigger signal selection(SINCOS1  ): 26
N     */
N    LL_EVSYS_DST_EVENT_SINCOS1,
N    /*! EVSYS destination channel trigger signal selection(DATA_DMA ): 27
N     */
N    LL_EVSYS_DST_EVENT_DATA_DMA,
N    /*! EVSYS destination channel trigger signal selection(HCC      ): 28
N     */
N    LL_EVSYS_DST_EVENT_HCC,
N    /*! EVSYS destination channel trigger signal selection(idle     ): 65
N     */
N    LL_EVSYS_DST_EVENT_IDLE = 65,
N} TYPE_ENUM_LL_EVSYS_DST_EVENT_SEL;
N
N/**
N  * @brief Enumeration constant for The EVSYS channel selection
N  */
Ntypedef enum {
N    /*! EVSYS channel select: 0
N     */
N    LL_EVSYS_CHN_NUM0 = 0,
N    /*! EVSYS channel select: 1
N     */
N    LL_EVSYS_CHN_NUM1,
N    /*! EVSYS channel select: 2
N     */
N    LL_EVSYS_CHN_NUM2,
N    /*! EVSYS channel select: 3
N     */
N    LL_EVSYS_CHN_NUM3,
N    /*! EVSYS channel select: 4
N     */
N    LL_EVSYS_CHN_NUM4,
N    /*! EVSYS channel select: 5
N     */
N    LL_EVSYS_CHN_NUM5,
N    /*! EVSYS channel select: 6
N     */
N    LL_EVSYS_CHN_NUM6,
N    /*! EVSYS channel select: 7
N     */
N    LL_EVSYS_CHN_NUM7,
N    /*! EVSYS channel select: 8
N     */
N    LL_EVSYS_CHN_NUM8,
N    /*! EVSYS channel select: 9
N     */
N    LL_EVSYS_CHN_NUM9,
N    /*! EVSYS channel select: 10
N     */
N    LL_EVSYS_CHN_NUM10,
N    /*! EVSYS channel select: 11
N     */
N    LL_EVSYS_CHN_NUM11,
N    /*! EVSYS channel select: 12
N     */
N    LL_EVSYS_CHN_NUM12,
N    /*! EVSYS channel select: 13
N     */
N    LL_EVSYS_CHN_NUM13,
N    /*! EVSYS channel select: 14
N     */
N    LL_EVSYS_CHN_NUM14,
N    /*! EVSYS channel select: 15
N     */
N    LL_EVSYS_CHN_NUM15,
N} TYPE_ENUM_LL_EVSYS_CHN;
N
N/**
N  * @}
N  */
N
N/** @defgroup EVSYS_LL_Exported_Struct EVSYS LL Exported Struct
N  * @ingroup  EVSYS_LL_Driver
N  * @brief    EVSYS LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the EVSYS registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_evsys_init. Function, you can configure the EVSYS module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief EVSYS low layer configuration structure
N  */
Ntypedef struct _ll_evsys_cfg {
N    /*! evsys channel num
N     *  Please refer to the enumeration TYPE_ENUM_LL_EVSYS_CHN for details.
N     */
N    TYPE_ENUM_LL_EVSYS_CHN           chn;
N    /*! source channel
N     *  Please refer to the enumeration TYPE_ENUM_LL_EVSYS_EVENT_SEL for details.
N     */
N    TYPE_ENUM_LL_EVSYS_SRC_EVENT_SEL src_chn;
N    /*! destination channel
N     *  Please refer to the enumeration TYPE_ENUM_LL_EVSYS_EVENT_SEL for details.
N     */
N    TYPE_ENUM_LL_EVSYS_DST_EVENT_SEL dst_chn;
N    /*! the source data is triggered once after count calculations
N     */
N    u16                              src_kick_cnt;
N} TYPE_LL_EVSYS_CFG;
N
N/**
N  * @brief EVSYS low layer Initialization structure
N  */
Ntypedef struct _ll_evsys_init {
N    u8 reserved;
N} TYPE_LL_EVSYS_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup EVSYS_LL_Interrupt EVSYS LL Interrupt Handle function
N  * @brief   EVSYS LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the EVSYS  
N    Interrupt Handle function.
N
N    how to use?
N
N    The EVSYS interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the EVSYS in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup EVSYS_LL_Inti_Cfg EVSYS LL Initialization And Configuration
N  * @brief    EVSYS LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the EVSYS data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Low layer EVSYS module initialization
N  * @param  p_evsys: The register structure pointer of the EVSYS.
N  * @param  p_init : Module configuration structure pointer(TYPE_LL_EVSYS_INIT)
N  * @retval None
N  */
Nvoid ll_evsys_init(EVSYS_TypeDef *p_evsys, TYPE_LL_EVSYS_INIT *p_init);
N
N/**
N  * @brief  Low layer EVSYS module detele initialization
N  * @param  p_evsys: The register structure pointer of the EVSYS.
N  * @retval None
N  */
Nvoid ll_evsys_deinit(EVSYS_TypeDef *p_evsys);
N
N/**
N  * @brief  Low layer EVSYS module configuration
N  * @param  p_evsys: The register structure pointer of the EVSYS.
N  * @param  p_cfg  : Module configuration structure pointer(TYPE_LL_EVSYS_CFG)
N  * @retval None
N  */
Nvoid ll_evsys_config(EVSYS_TypeDef *p_evsys, TYPE_LL_EVSYS_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup EVSYS_LL_Data_Transfers EVSYS LL Data transfers functions
N  * @brief    EVSYS LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the EVSYS data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  EVSYS module start function
N  * @param  p_evsys : The register structure pointer of the EVSYS.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.
N  * @retval None
N  */
Nvoid ll_evsys_start(EVSYS_TypeDef *p_evsys, u16 chn_bits);
N
N/**
N  * @brief  EVSYS module stop function
N  * @param  p_evsys : The register structure pointer of the EVSYS.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.
N  * @retval None
N  */
Nvoid ll_evsys_stop(EVSYS_TypeDef *p_evsys, u16 chn_bits);
N
N/**
N  * @brief  EVSYS module get cpu pending function
N  * @param  p_evsys : The register structure pointer of the EVSYS.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.
N  * @retval pending value
N  */
N#define LL_EVSYS_GET_CPU_PENDING(p_evsys, chn_bits)         ((p_evsys)->CH_CPU_PND & LL_EVSYS_CHN_CPU_PND(chn_bits))
N
N/**
N  * @brief  EVSYS module get hardware pending function
N  * @param  p_evsys : The register structure pointer of the EVSYS.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.
N  * @retval pending value
N  */
N#define LL_EVSYS_GET_HARDWARE_PENDING(p_evsys, chn_bits)    ((p_evsys)->CH_HW_PND & LL_EVSYS_CHN_HW_PND(chn_bits))
N
N/**
N  * @brief  EVSYS module clear hardware and CPU pending function
N  * @param  p_evsys : The register structure pointer of the EVSYS.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.
N  * @retval pending value
N  */
N__STATIC_INLINE void ll_evsys_clear_pending(EVSYS_TypeDef *p_evsys, u16 chn_bits) {
Xstatic __inline void ll_evsys_clear_pending(EVSYS_TypeDef *p_evsys, u16 chn_bits) {
N    p_evsys->CH_PND_CLR |= LL_EVSYS_CHN_PND_CLR(chn_bits);
X    p_evsys->CH_PND_CLR |= (((chn_bits)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  EVSYS module wait CPU pending function
N  * @param  p_evsys : The register structure pointer of the EVSYS.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.
N  * @retval pending value
N  */
N__STATIC_INLINE void ll_evsys_wait_cpu_pending(EVSYS_TypeDef *p_evsys, u16 chn_bits) {
Xstatic __inline void ll_evsys_wait_cpu_pending(EVSYS_TypeDef *p_evsys, u16 chn_bits) {
N    while(chn_bits != (p_evsys->CH_CPU_PND & LL_EVSYS_CHN_CPU_PND(chn_bits)));
X    while(chn_bits != (p_evsys->CH_CPU_PND & (((chn_bits)&0xFFFF) << 0)));
N    p_evsys->CH_PND_CLR |= LL_EVSYS_CHN_PND_CLR(chn_bits);
X    p_evsys->CH_PND_CLR |= (((chn_bits)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  EVSYS module wait hardware pending function
N  * @param  p_evsys : The register structure pointer of the EVSYS.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.
N  * @retval pending value
N  */
N__STATIC_INLINE void ll_evsys_wait_hardware_pending(EVSYS_TypeDef *p_evsys, u16 chn_bits) {
Xstatic __inline void ll_evsys_wait_hardware_pending(EVSYS_TypeDef *p_evsys, u16 chn_bits) {
N    while(chn_bits != (p_evsys->CH_HW_PND & LL_EVSYS_CHN_HW_PND(chn_bits)));
X    while(chn_bits != (p_evsys->CH_HW_PND & (((chn_bits)&0xFFFF) << 0)));
N    p_evsys->CH_PND_CLR |= LL_EVSYS_CHN_PND_CLR(chn_bits);
X    p_evsys->CH_PND_CLR |= (((chn_bits)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  EVSYS module interrupt enable function
N  * @param  p_evsys : The register structure pointer of the EVSYS.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_evsys_interrupt_enable(EVSYS_TypeDef *p_evsys, u16 chn_bits) {
Xstatic __inline void ll_evsys_interrupt_enable(EVSYS_TypeDef *p_evsys, u16 chn_bits) {
N    p_evsys->CH_INT_ENA |= LL_EVSYS_CHN_INTR_ENABLE(chn_bits);
X    p_evsys->CH_INT_ENA |= (((chn_bits)&0xFFFF) << 0);
N}
N
N/**
N  * @brief  EVSYS module interrupt disable function
N  * @param  p_evsys : The register structure pointer of the EVSYS.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.
N  * @retval None
N  */
N__STATIC_INLINE void ll_evsys_interrupt_disable(EVSYS_TypeDef *p_evsys, u16 chn_bits) {
Xstatic __inline void ll_evsys_interrupt_disable(EVSYS_TypeDef *p_evsys, u16 chn_bits) {
N    p_evsys->CH_INT_ENA &= ~(LL_EVSYS_CHN_INTR_ENABLE(chn_bits));
X    p_evsys->CH_INT_ENA &= ~((((chn_bits)&0xFFFF) << 0));
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_EVSYS_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 59 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_can.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_can.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_can.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   This file contains all the CAN LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_CAN_H
N#define __TX_PHE_LL_CAN_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup can_interface_gr CAN Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup CAN_LL_Driver CAN LL Driver
N  * @ingroup  can_interface_gr
N  * @brief Mainly the driver part of the CAN module, which includes \b CAN \b Register 
N  * \b Constants, \b CAN \b Exported \b Constants, \b CAN \b Exported \b Struct, \b CAN
N  * \b Data \b transfers \b functions, \b CAN \b Initialization \b and \b CAN \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N 
N/** @defgroup CAN_LL_Register_Constants CAN LL Register Constants
N  * @ingroup  CAN_LL_Driver
N  * @brief    CAN LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the CAN 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the CAN register, mainly for convenience. Understand the 
N    configuration of the CAN.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** CFG_STAT *****/
N/*! RESET request bit  
N *  1 - The host controller performs a local reset of CAN-CTRL.  
N *  0 - no local reset of CAN-CTRL  
N *  The node configuration (BITTIME_x, x_PRESC, acceptance code and mask) can only
N *  be modified if RESET=1 
N */
N#define LL_CAN_CFG_STA_RESET                      (1UL << 7)
N/*! Loop Back Mode, External  
N *  0 - Disabled  
N *  1 - Enabled  
N *  LBME should not be enabled while a transmission is active. 
N */
N#define LL_CAN_CFG_STA_LBME                       (1UL << 6)
N/*! Loop Back Mode, Internal  
N *  0 - Disabled  
N *  1 - Enabled  
N *  LBMI should not be enabled while a transmission is active. 
N */
N#define LL_CAN_CFG_STA_LBMI                       (1UL << 5)
N/*! Transmission Primary Single Shot mode for PTB  
N *  0 - Disabled  
N *  1 - Enabled  
N */
N#define LL_CAN_CFG_STA_TPSS                       (1UL << 4)
N/*! Transmission Secondary Single Shot mode for STB  
N *  0 - Disabled  
N *  1 - Enabled  
N */
N#define LL_CAN_CFG_STA_TSSS                       (1UL << 3)
N/*! Reception ACTIVE (Receive Status bit)  
N *  1 - The controller is presently receiving data or a remote frame.  
N *  0 - No receive activity.   
N */
N#define LL_CAN_CFG_STA_ARCTIVE                    (1UL << 2)
N/*! Transmission ACTIVE (Transmit Status bit)  
N *  1 - The controller is presently transmitting data or a remote frame.  
N *  0 - No transmit activity.  
N */
N#define LL_CAN_CFG_STA_TACTIVE                    (1UL << 1)
N/*! Bus Off (Bus Status bit)  
N *  1 - The controller status is " bus off "  
N *  0 - The controller status is " bus on "  
N *  See detailed description in chap. 3.6.1
N */
N#define LL_CAN_CFG_STA_BUSOFF                     (1UL << 0)
N
N
N/***** TCMD *****/
N/*! Transmit Buffer Select  
N *  Selects the transmit buffer to be loaded with a message. Use the TBUF 
N *  registers for  access. TBSEL needs to be stable all the time the TBUF 
N *  registers are written and when TSNEXT is set.  
N *  0 - PTB (high-priority buffer)  
N *  1 - STB (FIFO like)  
N */
N#define LL_CAN_TCMD_TBSEL                         (1UL << 7)
N/*! Listen Only Mode  
N *  0 - Disabled  
N *  1 - Enabled  
N *  LOM should not be enabled while a transmission is active. No transmission 
N *  can be started if LOM is enabled. 
N */
N#define LL_CAN_TCMD_LOM                           (1UL << 6)
N/*! Transceiver Standby Mode  
N *  0 - Disabled  
N *  1 - Enabled  
N *  This register bit is connected to the output signal stby which can be used 
N *  to control a standby mode of a transceiver.
N *  STBY cannot be set to 1 if TPE=1, TSONE=1 or TSALL=1. 
N */
N#define LL_CAN_TCMD_STBY                          (1UL << 5)
N/*! Transmit Primary Enable  
N *  1 - Transmission enable of the message of the high-priority PTB  
N *  0 - No transmission for the PTB  
N *  If TPE is set, the message from the PTB will be transmitted at the next possible 
N *  transmit position. A started transmission from the STB will be completed before, 
N *  but pending new messages are delayed until the PTB message has been transmitted. 
N */
N#define LL_CAN_TCMD_TPE                           (1UL << 4)
N/*! Transmit Primary Abort  
N *  1-  Aborts a transmission from TPB which has been requested by TPE=1 but not
N *      started yet.
N *      (The data bytes of the message remain in the PTB.)  
N *  0-  no abort  
N *  The bit has to be set by the host controller and will be reset by CAN-CTRL. 
N *  Setting TPA automatically de-asserts TPE. 
N */
N#define LL_CAN_TCMD_TPA                           (1UL << 3)
N/*! Transmit Secondary ONE frame  
N *  1-  Transmission enable of the oldest message in the STB.
N *      The message format is stored in the IDE buffer which belongs to this message.
N *      The controller starts the transmission as soon as the bus becomes vacant and
N *      no request of the PTB (bit TPE) is pending.  
N *  0-  No transmission for the STB.  
N *  TSONE stays set until the message has been transmitted successfully or it is aborted 
N *  using TSA. Only the host controller can set TSONE 
N */
N#define LL_CAN_TCMD_TSONE                         (1UL << 2)
N/*! Transmit Secondary ALL frames  
N *  1-  Transmission enable of all messages in the STB.
N *      The message format is stored in the appropriate IDE buffers.
N *      The controller starts the transmission as soon as the bus becomes vacant and
N *      no request of the PTB (bit TPE) is pending.  
N *  0-  No transmission for the STB.  
N *  TSALL stays set until all messages have been transmitted successfully or they are aborted 
N *  using TSA. Only the host controller can set TSALL 
N */
N#define LL_CAN_TCMD_TSALL                         (1UL << 1)
N/*! Transmit Secondary Abort  
N *  1-  Aborts a transmission from STB which has been requested but not started yet.
N *      For a TSONE transmission, only one frame is aborted while for a TSALL
N *      Transmission, all frames are aborted 
N *      One or all message slots will be released which updates TSSTAT. Because of
N *      the FIFO-like behavior of the STB all aborted messages are lost because they
N *      are not accessible any more.  
N *  0-  no abort  
N *  The bit has to be set by the host controller and will be reset by CAN-CTRL. Setting TSA, 
N *  automatically de-asserts TSONE or TSALL respectively
N */
N#define LL_CAN_TCMD_TSA                           (1UL << 0)
N
N
N/***** TCTRL *****/
N/*! CAN FD ISO mode  
N *  0 - Bosch CAN FD (non-ISO) mode  
N *  1 - ISO CAN FD mode  
N *  This bit is only writeable if RESET=1.
N *  ISO CAN FD mode has a different CRC initialization value and an additional stuff bit count. 
N *  Both modes are incompatible and must not be mixed in one CAN network.
N *  This bit has no impact to CAN 2.0B. 
N */
N#define LL_CAN_TCTRL_FD_ISO                       (1UL << 7)
N/*! Transmit buffer Secondary NEXT  
N *  0 - no action  
N *  1 - STB slot filled, select next FIFO slot.  
N *  After all frame bytes are written to the TBUF registers, the host controller has to set 
N *  TSNEXT to signal that this slot has been filled. Then the CAN-CTRL core connects the TBUF 
N *  registers to the next FIFO slot. Once a slot is marked as filled a transmission can be 
N *  started using TSONE or TSALL 
N */
N#define LL_CAN_TCTRL_TSNEXT                       (1UL << 6)
N/*! Transmission Secondary STATus bits Number of filled message buffers (0 ~ 16). 
N */
N#define LL_CAN_TCTRL_TSSTAT(n)                    (((n)&0x1F) << 0)
N
N
N/***** RCTRL *****/
N/*! Receive buffer OVerflow  
N *  1-  Overflow. At least one message is lost.  
N *  0-  No Overflow.  
N *  ROV is cleared by setting RREL=1. 
N */
N#define LL_CAN_RCTRL_ROV                          (1UL << 5)
N/*! Receive buffer RELease  
N *  The host controller acknowledges the emptying of the actual RB slot. Afterwards the 
N *  CAN-CTRL core points to the next RB slot. RSTAT gets updated.  
N *  1-  Release: The host has emptied the RB.  
N *  0-  No release  
N */
N#define LL_CAN_RCTRL_RREL                         (1UL << 4)
N/*! Receive buffer status  
N *  00 - empty  
N *  01 - > empty and < almost full (AFWL)  
N *  10 - >= almost full (programmable threshold by AFWL) but not full and no overflow  
N *  11 - full (stays set in case of overflow for overflow signaling see ROV)  
N */
N#define LL_CAN_RCTRL_RSTAT(n)                     (((n)&0x3) << 0)
N
N
N/***** RTIE *****/
N/*! Receive Interrupt Enable  
N *  0-  Disabled  
N *  1-  Enabled  
N */
N#define LL_CAN_RTIE_RIE                           (1UL << 7)
N/*! RB Overrun Interrupt Enable  
N *  0-  Disabled  
N *  1-  Enabled
N */
N#define LL_CAN_RTIE_ROIE                          (1UL << 6)
N/*! RB Full Interrupt Enable  
N *  0-  Disabled  
N *  1-  Enabled  
N */
N#define LL_CAN_RTIE_RFIE                          (1UL << 5)
N/*! RB Almost Full Interrupt Enable  
N *  0-  Disabled  
N *  1-  Enabled  
N */
N#define LL_CAN_RTIE_RAFIE                         (1UL << 4)
N/*! Transmission Primary Interrupt Enable  
N *  0-  Disabled  
N *  1-  Enabled  
N */
N#define LL_CAN_RTIE_TPIE                          (1UL << 3)
N/*! Transmission Secondary Interrupt Enable  
N *  0-  Disabled  
N *  1-  Enabled  
N */
N#define LL_CAN_RTIE_TSIE                          (1UL << 2)
N/*! Error Interrupt Enable  
N *  0-  Disabled
N *  1-  Enabled  
N */
N#define LL_CAN_RTIE_EIE                           (1UL << 1)
N/*! Transmit Secondary buffer Full Flag  
N *  1 - The STB is filled with the maximal count of messages.  
N *  0 - The STB is not filled with the maximal count of messages  
N */
N#define LL_CAN_RTIE_TSFF                          (1UL << 0)
N
N
N/***** RTIF *****/
N/*! Receive Interrupt Flag  
N *  1 - Data or a remote frame has been received and is available in the receive buffer.  
N *  0 - No frame has been received  
N */
N#define LL_CAN_RTIF_RIF                           (1UL << 7)
N/*! RB Overrun Interrupt Flag  
N *  1 - At least one received message has been overwritten in the RB.  
N *  0 - No RB overwritten.  
N *  In case of an overrun both ROIF and RFIF will be set.
N */
N#define LL_CAN_RTIF_ROIF                          (1UL << 6)
N/*! RB Full Interrupt Flag  
N *  1 - All RBs are full. If no RB will be released until the next valid message is received,
N *      the oldest message will be lost.  
N *  0 - The RB FIFO is not full   
N */
N#define LL_CAN_RTIF_RFIF                          (1UL << 5)
N/*! RB Almost Full Interrupt Flag  
N *  1 - number of filled RB slots >= AFWL_i  
N *  0 - number of filled RB slots < AFWL_i  
N*/
N#define LL_CAN_RTIF_RAFIF                         (1UL << 4)
N/*! Transmission Primary Interrupt Flag  
N *  1 - The requested transmission of the PTB has been successfully completed.  
N *  0 - No transmission of the PTB has been completed.  
N */
N#define LL_CAN_RTIF_TPIF                          (1UL << 3)
N/*! Transmission Secondary Interrupt Flag  
N *  1 - The requested transmission of the STB has been successfully completed.  
N *  0 - No transmission of the STB has been completed successfully  
N */
N#define LL_CAN_RTIF_TSIF                          (1UL << 2)
N/*! Error Interrupt Flag  
N *  1 - The border of the error warning limit has been crossed in either direction,
N *      or the BUSOFF bit has been changed in either direction.  
N *  0 - There has been no change  
N */
N#define LL_CAN_RTIF_EIF                           (1UL << 1)
N/*! Abort Interrupt Flag  
N *  1 - After setting TPA or TSA the appropriated message(s) have been aborted.
N *      It is recommended to not set both TPA and TSA simultaneously because both
N *      source AIF.  
N *  0 - No abort has been executed.  
N *  The AIF does not have an associated enable register.
N *  See also chap. 3.6.6 for further information 
N */
N#define LL_CAN_RTIF_AIF                           (1UL << 0)
N
N
N/***** ERRINT *****/
N/*! Error WARNing limit reached  
N *  1 - One of the error counters RECNT or TECNT is equal or bigger than EWL  
N *  0 - The values in both counters are less than EWL.  
N */
N#define LL_CAN_ERRINT_EWARN                       (1UL << 7)
N/*! Error Passive mode active  
N *  0 - not active (node is error active)  
N *  1 - active (node is error passive)  
N */
N#define LL_CAN_ERRINT_EPASS                       (1UL << 6)
N/*! Error Passive Interrupt Enable
N */
N#define LL_CAN_ERRINT_EPIE                        (1UL << 5)
N/*! Error Passive Interrupt Flag. EPIF will be activated if the error status changes 
N *  from error active to error passive or vice versa and if this interrupt is enabled 
N */
N#define LL_CAN_ERRINT_EPIF                        (1UL << 4)
N/*! Arbitration Lost Interrupt Enable
N */
N#define LL_CAN_ERRINT_ALIE                        (1UL << 3)
N/*! Arbitration Lost Interrupt Flag
N */
N#define LL_CAN_ERRINT_ALIF                        (1UL << 2)
N/*! Bus Error Interrupt Enable
N */
N#define LL_CAN_ERRINT_BEIE                        (1UL << 1)
N/*! Bus Error Interrupt Flag
N */
N#define LL_CAN_ERRINT_BEIF                        (1UL << 0)
N
N
N/***** BITTIME_0 *****/
N/*! Synchronization Jump Width (fast speed)  
N *  The Synchronization Jump Width T_sjw = (SJW + 1) * TQ is the maximum time for 
N *  shortening or lengthening the Bit Time for resynchronization, where TQ is a time 
N *  quanta 
N */
N#define LL_CAN_BITTIME_0_F_SJW(n)                 (((n)&0x3) << 6)
N/*! Bit Timing Segment 1 (slow speed)  
N *  The sample point will be set to T_seg_1 = (Seg_1 + 2) * TQ after start of bit time.
N *  Seg_1=0 is meaningless and automatically treated as 1. 
N */
N#define LL_CAN_BITTIME_0_S_SEG_1(n)               (((n)&0x3F) << 0)
N
N
N/***** BITTIME_1 *****/
N/*! Bit Timing Segment 2 (fast speed)  
N *  Time T_seg_2 = (Seg_2 + 1) * TQ after the sample point. Seg_2=0 is meaningless and
N *  automatically treated as 1 
N */
N#define LL_CAN_BITTIME_1_F_SEG_2(n)               (((n)&0x7) << 5)
N/*! Bit Timing Segment 2 (slow speed)  
N *  Time T_seg_2 = (Seg_2 + 1) * TQ after the sample point. Seg_2=0 is meaningless and
N *  automatically treated as 1 
N */
N#define LL_CAN_BITTIME_1_S_SEG_2(n)               (((n)&0x1F) << 0)
N
N
N/***** BITTIME_2 *****/
N/*! Bit Timing Segment 1 (fast speed)  
N *  The sample point will be set to T_seg_1 = (Seg_1 + 2) * TQ after start of bit time.
N *  Seg_1=0 is meaningless and automatically treated as 1. 
N */
N#define LL_CAN_BITTIME_2_F_SEG_1(n)               (((n)&0xF) << 4)
N/*! Synchronization Jump Width (slow speed)  
N *  The Synchronization Jump Width T_sjw = (SJW + 1) * TQ is the maximum time for 
N *  shortening or lengthening the Bit Time for resynchronization, where TQ is a time 
N *  quanta. 
N */
N#define LL_CAN_BITTIME_2_S_SJW(n)                 (((n)&0xF) << 0)
N
N
N/***** S_PRESC  *****/
N/*! Prescaler (slow and fast speed)  
N *  The prescaler divides the system clock to get the time quanta clock tq_clk.
N *  Valid range PRESC=[0x01, 0xff] results in divider values 2 to 256.
N *  PRESC=0 is forbidden and automatically treated as 1. (Necessary because the bit timing 
N *  logic of this core requires it.) 
N */
N#define LL_CAN_S_PRESC(n)                         (((n)&0xFF) << 0)
N
N
N/***** F_PRESC *****/
N/*! Prescaler (slow and fast speed)  
N *  The prescaler divides the system clock to get the time quanta clock tq_clk.
N *  Valid range PRESC=[0x01, 0xff] results in divider values 2 to 256.
N *  PRESC=0 is forbidden and automatically treated as 1. (Necessary because the bit timing 
N *  logic of this core requires it.) 
N */
N#define LL_CAN_F_PRESC(n)                         (((n)&0xFF) << 0)
N
N
N/***** TDC *****/
N/*! Transmitter Delay Compensation ENable  
N *  TDC will be activated during the data phase of a CAN FD frame if BRS is active if TDCEN=1.
N *  For more details about TDC see chap. 4.5 
N */
N#define LL_CAN_TDC_TDCEN                          (1UL << 7)
N/*! Secondary Sample Point OFFset  
N *  The transmitter delay plus SSPOFF defines the time of the secondary sample point for TDC.
N *  SSPOFF is given as a number of TQ. 
N */
N#define LL_CAN_TDC_SSPOFF(n)                      (((n)&0x1F) << 0)
N
N
N/***** LIMIT *****/
N/*! receive buffer Almost Full Warning Limit
N */
N#define LL_CAN_LIMIT_AFWL(n)                      (((n)&0xF) << 4)
N/*! Programmable Error Warning Limit = (EWL+1)*8. Possible Limit values: 8, 16, ... 128.
N *  The value of EWL controls EIF.
N *  EWL needs to be transferred using CDC from host to CAN clock domain. During transfer 
N *  EWL register bits are write-locked for the host for a few clocks until CDC is complete 
N */
N#define LL_CAN_LIMIT_EWL(n)                       (((n)&0xF) << 0)
N
N
N/***** EALCAP *****/
N/*! Kind Of ERror (Error code)  
N *  000 - no error  
N *  001 - BIT ERROR  
N *  010 - FORM ERROR  
N *  011 - STUFF ERROR  
N *  100 - ACKNOWLEDGEMENT ERROR  
N *  101 - CRC ERROR  
N *  110 - OTHER ERROR
N *        (dominant bits after own error flag, received active Error Flag too long,
N *        dominant bit during Passive-Error-Flag after ACK error)
N *  111 - not used  
N *  KOER is reset after a successful transmission or reception of a frame 
N */
N#define LL_CAN_EALCAP_KOER(n)                     (((n)&0x7) << 5)
N/*! Arbitration Lost Capture (bit position in the frame where the arbitration has been lost)
N */
N#define LL_CAN_EALCAP_ALC(n)                      (((n)&0x1F) << 0)
N
N
N/***** RECNT *****/
N/*! Receive Error CouNT (number of errors during reception)  
N *  RECNT is incremented and decremented as defined in the CAN specification.
N *  RECNT does not overflow. RECNT signals 0xff = 255 as maximum value. See chap. 3.6.1 
N *  for more details about RECNT and the " bus off " state 
N */
N#define LL_CAN_RECNT(n)                           (((n)&0xFF) << 0)
N
N
N/***** TECNT *****/
N/*! Receive Error CouNT (number of errors during reception)  
N *  RECNT is incremented and decremented as defined in the CAN specification.
N *  RECNT does not overflow. RECNT signals 0xff = 255 as maximum value. See chap. 3.6.1 
N *  for more details about RECNT and the " bus off " state 
N */
N#define LL_CAN_TECNT(n)                           (((n)&0xFF) << 0)
N
N
N/***** ACFCTRL *****/
N/*! SELect acceptance MASK  
N *  0 - Registers ACF_x point to acceptance code  
N *  1 - Registers ACF_x point to acceptance mask  
N *  ACFADR selects one specific acceptance filter. (See Figure 3-4.) 
N */
N#define LL_CAN_ACFCTRL_SELMASK                    (1UL << 5)
N/*! acceptance filter address  
N *  ACFADR points to a specific acceptance filter. The selected filter is accessible using the 
N *  registers ACF_x. Bit SELMASK selects between acceptance code and mask for the 
N *  selected acceptance filter. (See Figure 3-4.)
N *  A value of ACFADR>NR_OF_ACF-1 is meaningless and automatically treated as value 
N *  NR_OF_ACF-1. (See chap. 0 and Figure 3-4 for details about NR_OF_ACF.) 
N */
N#define LL_CAN_ACFCTRL_ACFADR(n)                  (((n)&0xF) << 0)
N
N
N/***** ACODE_X *****/
N/*! Acceptance CODE  
N *  1 - ACC bit value to compare with ID bit of the received message  
N *  0 - ACC bit value to compare with ID bit of the received message  
N *  ACODE_x(10:0) will be used for extended frames.  
N *  ACODE_x(28:0) will be used for extended frames.  
N *  Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.
N *  See chap. 3.6.2 for further details 
N */
N#define LL_CAN_ACODE_X(n)                         (((n)&0x1FFFFFFF) << 0)
N
N
N/***** AMASK_X *****/
N/*! Acceptance MASK  
N *  1 - acceptance check for these bits of receive identifier disabled  
N *  0 - acceptance check for these bits of receive identifier enable  
N *  AMASK_x(10:0) will be used for extended frames.  
N *  AMASK_x(28:0) will be used for extended frames.  
N *  Disabled bits result in accepting the message. Therefore the default configuration after 
N *  reset for filter 0 accepts all messages.
N *  Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.
N *  See chap. 3.6.2 for further details 
N */
N#define LL_CAN_AMASK_X(n)                         (((n)&0x1FFFFFFF) << 0)
N
N
N/***** ACF_3 *****/
N/*! Acceptance mask IDE bit check enable  
N *  1 - acceptance filter accepts either standard or extended as defined by AIDE  
N *  0 - acceptance filter accepts both standard or extended frames  
N *  Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.
N */
N#define LL_CAN_ACF_3_AIDEE                        (1UL << 1)
N/*! Acceptance mask IDE bit value  
N *  If AIDEE=1 then:  
N *  1 - acceptance filter accepts only extended frames  
N *  0 - acceptance filter accepts only standard frames  
N *  Only filter 0 is affected by the power-on reset. All other filters stay uninitialized 
N */
N#define LL_CAN_ACF_3_AIDE                         (1UL << 0)
N
N
N/***** ACF_EN_0 *****/
N/*! Acceptance filter Enable  
N *  1 - acceptance filter enabled  
N *  0 - acceptance filter disable  
N *  Each acceptance filter (AMASK / ACODE) can be individually enabled or disabled. Only 
N *  filter number 0 is enabled by default after hardware reset.
N *  Disabled filters reject a message. Only enabled filters can accept a message if the 
N *  appropriate AMASK / ACODE configuration matches.
N *  To accept all messages one filter x has to be enabled by setting AE_x=1, 
N *  AMASK_x=0xff and ACODE_x=0x00. This is the default configuration after hardware 
N *  reset for filter x=0 while all other filters are disabled 
N */
N#define LL_CAN_ACF_EN_0(n)                        (((n)&0xFF) << 0)
N
N
N/***** ACF_EN_1 *****/
N/*! Acceptance filter Enable  
N *  1 - acceptance filter enabled  
N *  0 - acceptance filter disable  
N *  Each acceptance filter (AMASK / ACODE) can be individually enabled or disabled.
N *  Disabled filters reject a message. Only enabled filters can accept a message if the 
N *  appropriate AMASK / ACODE configuration matches 
N */
N#define LL_CAN_ACF_EN_1(n)                        (((n)&0xFF) << 0)
N
N
N/***** VER_0 *****/
N/*! Version of CAN-CTRL, given as decimal value. VER_1 holds the major version and 
N *  VER_0 the minor version.  
N *  Example: version 5x16N00S00 is represented by VER_1=5 and VER_0=16. 
N */
N#define LL_CAN_VER_0(n)                           (((n)&0xFFFF) << 0)
N
N
N/***** VER_1 *****/
N/*! Version of CAN-CTRL, given as decimal value. VER_1 holds the major version and 
N *  VER_0 the minor version.  
N *  Example: version 5x16N00S00 is represented by VER_1=5 and VER_0=16. 
N */
N#define LL_CAN_VER_1(n)                           (((n)&0xFFFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup CAN_LL_Exported_Constants CAN LL Exported Constants
N  * @ingroup  CAN_LL_Driver
N  * @brief    CAN LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N/*! The address of can is 11 bits. 
N */
N#define LL_CAN_BUF_ID_11BITS(n)                   (((n)&0x7FF) << 0)
N/*! The address of can is 29 bits. 
N */
N#define LL_CAN_BUF_ID_29BITS(n)                   (((n)&0x1FFFFFFF) << 0)
N
N/*! The macro defines the configuration enable of the CAN.
N */
N#define LL_CAN_REG_OPT(expression)        \
Ndo{                                       \
N    CAN->CFGSTA |= LL_CAN_CFG_STA_RESET;  \
N    expression;                           \
N    CAN->CFGSTA &= ~LL_CAN_CFG_STA_RESET; \
N}while(0)
X#define LL_CAN_REG_OPT(expression)        do{                                           CAN->CFGSTA |= LL_CAN_CFG_STA_RESET;      expression;                               CAN->CFGSTA &= ~LL_CAN_CFG_STA_RESET; }while(0)
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N
N/**
N  * @brief Enumeration constant for CAN address filter channel selection.
N  */
Ntypedef enum {
N    /*! CAN address filter channel select: channel 0. 
N     */
N    LL_CAN_ADDR_FILT_CHN_0 = 0,
N    /*! CAN address filter channel select: channel 1. 
N     */
N    LL_CAN_ADDR_FILT_CHN_1,
N    /*! CAN address filter channel select: channel 2. 
N     */
N    LL_CAN_ADDR_FILT_CHN_2,
N    /*! CAN address filter channel select: channel 3. 
N     */
N    LL_CAN_ADDR_FILT_CHN_3,
N    /*! CAN address filter channel select: channel 4. 
N     */
N    LL_CAN_ADDR_FILT_CHN_4,
N    /*! CAN address filter channel select: channel 5. 
N     */
N    LL_CAN_ADDR_FILT_CHN_5,
N    /*! CAN address filter channel select: channel 6. 
N     */
N    LL_CAN_ADDR_FILT_CHN_6,
N    /*! CAN address filter channel select: channel 7. 
N     */
N    LL_CAN_ADDR_FILT_CHN_7,
N    /*! CAN address filter channel select: channel 8. 
N     */
N    LL_CAN_ADDR_FILT_CHN_8,
N    /*! CAN address filter channel select: channel 9. 
N     */
N    LL_CAN_ADDR_FILT_CHN_9,
N    /*! CAN address filter channel select: channel 10. 
N     */
N    LL_CAN_ADDR_FILT_CHN_10,
N    /*! CAN address filter channel select: channel 11. 
N     */
N    LL_CAN_ADDR_FILT_CHN_11,
N    /*! CAN address filter channel select: channel 12. 
N     */
N    LL_CAN_ADDR_FILT_CHN_12,
N    /*! CAN address filter channel select: channel 13. 
N     */
N    LL_CAN_ADDR_FILT_CHN_13,
N    /*! CAN address filter channel select: channel 14. 
N     */
N    LL_CAN_ADDR_FILT_CHN_14,
N    /*! CAN address filter channel select: channel 15. 
N     */
N    LL_CAN_ADDR_FILT_CHN_15,
N} TYPE_ENUM_LL_CAN_ADDR_FILT_CHN;
N
N/**
N  * @brief Enumeration constant for CAN receive almost full warnning selection.
N  */
Ntypedef enum {
N    /*! CAN receive almost full warnning select: 0 Byte, the default is 1. 
N     */
N    LL_CAN_RX_AFWL_SEL_0 = 0,
N    /*! CAN receive almost full warnning select: 1 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_1,
N    /*! CAN receive almost full warnning select: 2 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_2,
N    /*! CAN receive almost full warnning select: 3 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_3,
N    /*! CAN receive almost full warnning select: 4 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_4,
N    /*! CAN receive almost full warnning select: 5 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_5,
N    /*! CAN receive almost full warnning select: 6 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_6,
N    /*! CAN receive almost full warnning select: 7 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_7,
N    /*! CAN receive almost full warnning select: 8 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_8,
N    /*! CAN receive almost full warnning select: 9 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_9,
N    /*! CAN receive almost full warnning select: 10 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_10,
N    /*! CAN receive almost full warnning select: 11 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_11,
N    /*! CAN receive almost full warnning select: 12 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_12,
N    /*! CAN receive almost full warnning select: 13 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_13,
N    /*! CAN receive almost full warnning select: 14 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_14,
N    /*! CAN receive almost full warnning select: 15 Byte. 
N     */
N    LL_CAN_RX_AFWL_SEL_15,
N} TYPE_ENUM_LL_CAN_RX_AFWL_SEL;
N
N/**
N  * @brief Enumeration constant for CAN program error warnning selection.
N  */
Ntypedef enum {
N    /*! CAN program error warnning select: Count up to 8 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_8 = 0,
N    /*! CAN program error warnning select: Count up to 16 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_16,
N    /*! CAN program error warnning select: Count up to 24 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_24,
N    /*! CAN program error warnning select: Count up to 32 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_32,
N    /*! CAN program error warnning select: Count up to 40 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_40,
N    /*! CAN program error warnning select: Count up to 48 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_48,
N    /*! CAN program error warnning select: Count up to 56 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_56,
N    /*! CAN program error warnning select: Count up to 64 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_64,
N    /*! CAN program error warnning select: Count up to 72 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_72,
N    /*! CAN program error warnning select: Count up to 80 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_80,
N    /*! CAN program error warnning select: Count up to 88 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_88,
N    /*! CAN program error warnning select: Count up to 96 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_96,
N    /*! CAN program error warnning select: Count up to 104 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_104,
N    /*! CAN program error warnning select: Count up to 112 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_112,
N    /*! CAN program error warnning select: Count up to 120 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_120,
N    /*! CAN program error warnning select: Count up to 128 bytes. 
N     */
N    LL_CAN_PROG_ERRWL_SEL_128,
N} TYPE_ENUM_LL_CAN_PROG_ERRWL_SEL;
N
N/**
N  * @}
N  */
N
N/** @defgroup CAN_LL_Exported_Struct CAN LL Exported Struct
N  * @ingroup  CAN_LL_Driver
N  * @brief    CAN LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the CAN registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_can_init. Function, you can configure the CAN module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief CAN interrupt low layer configuration structure
N  */
Ntypedef struct __ll_can_irq_cfg {
N    /*! Receive interrupt enable 
N     */
N    bool rx_intr_en;
N    /*! Receive buffer overrun interrupt enable 
N     */
N    bool rx_buf_overrun_intr_en;
N    /*! Receive buffer full interrupt enable 
N     */
N    bool rx_buf_full_intr_en;
N    /*! Receive buffer Almost Full Interrupt Enable 
N     */
N    bool rx_buf_almost_full_intr_en;
N    /*! Transmission primary interrupt enable 
N     */
N    bool tx_primary_intr_en;
N    /*! Transmission secondary interrupt enable 
N     */
N    bool tx_secondary_intr_en;
N    /*! Error interrupt enable 
N     */
N    bool err_intr_en;
N    /*! Error passive interrupt enable 
N     */
N    bool err_passive_intr_en;
N    /*! Arbitration lost interrupt enable 
N     */
N    bool arbitration_lost_intr_en;
N    /*! Bus error interrupt enable 
N     */
N    bool bus_err_intr_en;
N} TYPE_LL_CAN_IRQ_CFG;
N
N/**
N  * @brief CAN buffer format low layer configuration structure
N  */
Ntypedef struct __ll_can_rx_buf_format {  
N    /*! Standard/Extended iDentifier value 
N     */
N    u32 id                  : 29,
N    /*! Reserved bit. 
N     */
N        reserved1           : 2,
N    /*! Error State Indicator. This is a read-only status bit for RBUF and is not available 
N     *  in TBUF. The protocol machine automatically embeds the correct value of ESI into 
N     *  transmitted frames. ESI is only included in CAN FD frames and does not exist in CAN 
N     *  2.0 frames. 
N     */
N        err_state_indicator : 1;
N    /*! The Data Length Code (DLC) in RBUF and TBUF defines the length of the payload(the 
N     *  number of payload bytes in a frame). 
N     */
N    u32 data_len_code     : 4,
N    /*! Bit Rate Switch
N     *  0: nominal / slow bit rate for the complete frame.
N     *  1: switch to data / fast bit rate for the data payload and the CRC
N     *  Only CAN FD frames can switch the bitrate. Therefore BRS is forced to 0 if EDL=0 
N     */
N        bit_rate_switch   : 1,
N    /*! Extended Data Length
N     *  0: CAN 2.0 frame (up to 8 bytes payload)
N     *  1: CAN FD frame (up to 64 bytes payload) 
N     */
N        extended_data_len : 1,
N    /*! Remote Transmission Request
N     *  0: data frame
N     *  1: remote frame 
N     *  Only CAN 2.0 frames can be remote frames. There is no remote frame for CAN FD. 
N     *  Therefore RTR is forced to 0 if EDL=1 in the TBUF.
N     */
N        remote_tx_req     : 1,
N    /*! IDentifier Extension
N     *  0: Standard Format: ID(10:0)
N     *  1: Extended Format: ID(28:0)
N     */
N        id_extension      : 1,
N    /*! Reserved bit. 
N     */
N        reserved2         : 24;
N} TYPE_LL_CAN_RX_BUF_FORMAT;
N
N/**
N  * @brief CAN buffer format low layer configuration structure
N  */
Ntypedef struct __ll_can_tx_buf_format {  
N    /*! Standard/Extended iDentifier value 
N     */
N    u32 id                : 29,
N    /*! Reserved bit. 
N     */
N        reserved1         : 3;
N    
N    /*! The Data Length Code (DLC) in RBUF and TBUF defines the length of the payload(the 
N     *  number of payload bytes in a frame). 
N     */
N    u32 data_len_code     : 4,
N    /*! Bit Rate Switch  
N     *  0: nominal / slow bit rate for the complete frame.  
N     *  1: switch to data / fast bit rate for the data payload and the CRC  
N     *  Only CAN FD frames can switch the bitrate. Therefore BRS is forced to 0 if EDL=0 
N     */
N        bit_rate_switch   : 1,
N    /*! Extended Data Length  
N     *  0: CAN 2.0 frame (up to 8 bytes payload)  
N     *  1: CAN FD frame (up to 64 bytes payload)  
N     */
N        extended_data_len : 1,
N    /*! Remote Transmission Request  
N     *  0: data frame  
N     *  1: remote frame  
N     *  Only CAN 2.0 frames can be remote frames. There is no remote frame for CAN FD. 
N     *  Therefore RTR is forced to 0 if EDL=1 in the TBUF.
N     */
N        remote_tx_req     : 1,
N    /*! IDentifier Extension  
N     *  0: Standard Format: ID(10:0)  
N     *  1: Extended Format: ID(28:0)  
N     */
N        id_extension      : 1,
N    /*! Reserved bit. 
N     */
N        reserved2         : 24;
N} TYPE_LL_CAN_TX_BUF_FORMAT;
N
N/**
N  * @brief CAN address filter low layer configuration structure
N  */
Ntypedef struct __ll_can_addr_filt_cfg {
N    /*! can address filter channel select
N     */
N    TYPE_ENUM_LL_CAN_ADDR_FILT_CHN chn;
N    /*! channel enable bit
N     */
N    bool                           enable;
N    /*! Acceptance CODE value  
N     *  acceptance bit value to compare with ID bit of the received message.
N     */
N    u32                            acode_val;
N    /*! Acceptance CODE value  
N     *  acceptance check for these bits of receive identifier disabled.
N     */
N    u32                            amask_val;
N} TYPE_LL_CAN_ADDR_FILT_CFG;
N
N/**
N  * @brief CAN low layer configuration structure
N  */
Ntypedef struct __ll_can_cfg {
N    /*! Configure the baud rate of CAN.
N     */
N    u8                              baudrate;
N    /*! Can receive the buffer almost full count condition selection.
N     */
N    TYPE_ENUM_LL_CAN_RX_AFWL_SEL    rx_almost_full_limit_sel;
N    /*! Can send buffer, there is an error number warning selection.
N     */
N    TYPE_ENUM_LL_CAN_PROG_ERRWL_SEL program_err_limit_sel;
N} TYPE_LL_CAN_CFG;
N
N/**
N  * @brief CAN low layer Initialization structure
N  */
Ntypedef struct __ll_can_init {
N    u8 reserved;
N} TYPE_LL_CAN_INIT;
N
N/**
N  * @}
N  */
N
N/** @defgroup CAN_LL_Interrupt CAN LL Interrupt Handle function
N  * @brief   CAN LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the CAN  
N    Interrupt Handle function.
N
N    how to use?
N
N    The CAN interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the CAN in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup CAN_LL_Inti_Cfg CAN LL Initialization And Configuration
N  * @brief    CAN LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the CAN data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief  Low layer CAN module initialization
N  * @param  p_can : The register structure pointer of the CAN.
N  * @param  p_init: Module configuration structure pointer(TYPE_LL_CAN_INIT)
N  * @retval None
N  */
Nvoid ll_can_init(CAN_TypeDef *p_can, TYPE_LL_CAN_INIT *p_init);
N
N/**
N  * @brief  Low layer CAN module detele initialization
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
Nvoid ll_can_deinit(CAN_TypeDef *p_can);
N
N/**
N  * @brief  Low layer CAN module interrupt configuration
N  * @param  p_can: The register structure pointer of the CAN.
N  * @param  p_cfg: Module interrupt configuration structure pointer
N  *                (TYPE_LL_CAN_IRQ_CFG)
N  * @retval None
N  */
Nvoid ll_can_irq_config(CAN_TypeDef *p_can, TYPE_LL_CAN_IRQ_CFG *p_cfg) ;
N
N/**
N  * @brief  Low layer CAN module address filter configuration
N  * @param  p_can: The register structure pointer of the CAN.
N  * @param  p_cfg: Module address filter configuration structure pointer
N  *                (TYPE_LL_CAN_ADDR_FILT_CFG)
N  * @retval None
N  */
Nvoid ll_can_address_filter_config(CAN_TypeDef *p_can, TYPE_LL_CAN_ADDR_FILT_CFG *p_cfg);
N
N/**
N  * @brief  Low layer CAN module configuration
N  * @param  p_can: The register structure pointer of the CAN.
N  * @param  p_cfg: Module configuration structure pointer(TYPE_LL_CAN_CFG)
N  * @retval None
N  */
Nvoid ll_can_config(CAN_TypeDef *p_can, TYPE_LL_CAN_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup CAN_LL_Data_Transfers CAN LL Data transfers functions
N  * @brief    CAN LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the CAN data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  CAN module start function
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
Nvoid ll_can_start(CAN_TypeDef *p_can);
N
N/**
N  * @brief  CAN module stop function
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
Nvoid ll_can_stop(CAN_TypeDef *p_can);
N
N/**
N  * @brief  CAN sends the function of the standard Primary Transmit Buffer.
N  * @param  p_can       : The register structure pointer of the CAN.
N  * @param  p_buf_format: The frame header format in which can can send data.
N  * @param  p_data      : The header address pointer for sending data.
N  * @retval None
N  * @note   The format of each frame of p_data must be aligned in 4 bytes.
N  */
Nvoid ll_can_send_standard_PTB(CAN_TypeDef               *p_can, 
N                              TYPE_LL_CAN_TX_BUF_FORMAT *p_buf_format, 
N                              u32                       *p_data);
N
N/**
N  * @brief  CAN sends a package of standard Secondary Transmit Buffer functions.
N  * @param  p_can       : The register structure pointer of the CAN.
N  * @param  p_buf_format: The frame header format in which can can send data.
N  * @param  p_data      : The header address pointer for sending data.
N  * @retval None
N  * @note   The format of each frame of p_data must be aligned in 4 bytes.
N  */
Nvoid ll_can_send_standard_STB(CAN_TypeDef               *p_can, 
N                              TYPE_LL_CAN_TX_BUF_FORMAT *p_buf_format, 
N                              u32                       *p_data);
N
N/**
N  * @brief  CAN sends a multi-package standard Secondary Transmit Buffer function.
N  * @param  p_can       : The register structure pointer of the CAN.
N  * @param  p_buf_format: The frame header format in which can can send data.
N  * @param  p_data      : The header address pointer for sending data.
N  * @param  send_cnt    : The number of CAN packets.
N  * @retval None
N  * @note   The format of each frame of p_data must be aligned in 4 bytes.
N  */
Nvoid ll_can_send_standard_STB_most(CAN_TypeDef               *p_can, 
N                                   TYPE_LL_CAN_TX_BUF_FORMAT *p_buf_format, 
N                                   u32                       *p_data, 
N                                   u32                        send_cnt);
N
N/**
N  * @brief  Low layer CAN get Receive buffer status
N  * @param  p_can  : The register structure pointer of the CAN.
N  * @param  sta_val: Receive buffer status value:
N  *                   00 - empty  
N  *                   01 - > empty and < almost full (AFWL)  
N  *                   10 - >= almost full (programmable threshold by AFWL) but not full and no overflow  
N  *                   11 - full (stays set in case of overflow for overflow signaling see ROV)  
N  * @retval status value
N  */
N#define LL_CAN_GET_RX_BUFF_STATUS(p_can, sta_val)                 ((p_can)->RCTRL & LL_CAN_RCTRL_RSTAT(sta_val))
N
N/**
N  * @brief  Low layer CAN get RTIF register value
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval register value
N  */
N#define LL_CAN_GET_RTIF_PENDING(p_can)                            ((p_can)->RTIF)
N
N/**
N  * @brief  Low layer CAN get ERRINT register value
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval register value
N  */
N#define LL_CAN_GET_ERRINT_PENDING(p_can)                          ((p_can)->ERRINT)
N
N/**
N  * @brief  Low layer CAN check Receive interrupt enable
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval result
N  */
N#define LL_CAN_CHECK_RECEIVE_INTERRUPT_ENABLE(p_can)              ((p_can)->RTIE & LL_CAN_RTIE_RIE)
N
N/**
N  * @brief  Low layer CAN check Receive buffer over run interrupt enable
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval result
N  */
N#define LL_CAN_CHECK_RECEIVE_OVERRUN_INTERRUPT_ENABLE(p_can)      ((p_can)->RTIE & LL_CAN_RTIE_ROIE)
N
N/**
N  * @brief  Low layer CAN check Receive buffer full interrupt enable
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval result
N  */
N#define LL_CAN_CHECK_RECEIVE_BUFF_FULL_INTERRUPT_ENABLE(p_can)    ((p_can)->RTIE & LL_CAN_RTIE_RFIE)
N
N/**
N  * @brief  Low layer CAN check Receive buffer almost full interrupt enable
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval result
N  */
N#define LL_CAN_CHECK_RECEIVE_ALMOST_FULL_INTERRUPT_ENABLE(p_can)  ((p_can)->RTIE & LL_CAN_RTIE_RAFIE)
N
N/**
N  * @brief  Low layer CAN check Transmission Primary interrupt enable
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval result
N  */
N#define LL_CAN_CHECK_TRANS_PRIMARY_INTERRUPT_ENABLE(p_can)        ((p_can)->RTIE & LL_CAN_RTIE_TPIE)
N
N/**
N  * @brief  Low layer CAN check Transmission Secondary interrupt enable
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval result
N  */
N#define LL_CAN_CHECK_TRANS_SECONDARY_INTERRUPT_ENABLE(p_can)      ((p_can)->RTIE & LL_CAN_RTIE_TSIE)
N
N/**
N  * @brief  Low layer CAN check error interrupt enable
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval result
N  */
N#define LL_CAN_CHECK_ERR_INTERRUPT_ENABLE(p_can)                  ((p_can)->RTIE & LL_CAN_RTIE_EIE)
N
N/**
N  * @brief  Low layer CAN check abort interrupt enable
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval result
N  */
N#define LL_CAN_CHECK_ERR_PASSIVE_INTERRUPT_ENABLE(p_can)          ((p_can)->ERRINT & LL_CAN_ERRINT_EPIE)
N
N/**
N  * @brief  Low layer CAN check error passive interrupt enable
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval result
N  */
N#define LL_CAN_CHECK_ARBITRATION_LOST_INTERRUPT_ENABLE(p_can)     ((p_can)->ERRINT & LL_CAN_ERRINT_ALIE)
N
N/**
N  * @brief  Low layer CAN check Arbitration Lost interrupt enable
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval result
N  */
N#define LL_CAN_CHECK_BUS_ERR_INTERRUPT_ENABLE(p_can)              ((p_can)->ERRINT & LL_CAN_ERRINT_BEIE)
N
N/**
N  * @brief  Low layer CAN get Receive Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_RECEIVE_PENDING(p_can)                         ((p_can)->RTIF & LL_CAN_RTIF_RIF)
N
N/**
N  * @brief  Low layer CAN get Receive buffer Overrun Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_RECEIVE_OVERRUN_PENDING(p_can)                 ((p_can)->RTIF & LL_CAN_RTIF_ROIF)
N
N/**
N  * @brief  Low layer CAN get Receive buffer Full Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_RECEIVE_FULL_PENDING(p_can)                    ((p_can)->RTIF & LL_CAN_RTIF_RFIF)
N
N/**
N  * @brief  Low layer CAN get Receive buffer Almost Full Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_RECEIVE_ALMOST_FULL_PENDING(p_can)             ((p_can)->RTIF & LL_CAN_RTIF_RAFIF)
N
N/**
N  * @brief  Low layer CAN get Transmission Primary Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_TRANS_PRIMARY_PENDING(p_can)                   ((p_can)->RTIF & LL_CAN_RTIF_TPIF)
N
N/**
N  * @brief  Low layer CAN get Transmission Secondary Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_TRANS_SECONDARY_PENDING(p_can)                 ((p_can)->RTIF & LL_CAN_RTIF_TSIF)
N
N/**
N  * @brief  Low layer CAN get Error Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_ERR_PENDING(p_can)                             ((p_can)->RTIF & LL_CAN_RTIF_EIF)
N
N/**
N  * @brief  Low layer CAN get Abort Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_ABORT_PENDING(p_can)                           ((p_can)->RTIF & LL_CAN_RTIF_AIF)
N
N/**
N  * @brief  Low layer CAN get Error Passive Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_ERR_PASSIVE_PENDING(p_can)                     ((p_can)->ERRINT & LL_CAN_ERRINT_EPIF)
N
N/**
N  * @brief  Low layer CAN get Arbitration Lost Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_ARBITRATION_PENDING(p_can)                     ((p_can)->ERRINT & LL_CAN_ERRINT_ALIF)
N
N/**
N  * @brief  Low layer CAN get Bus Error Interrupt Flag
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N#define LL_CAN_GET_BUS_ERR_PENDING(p_can)                         ((p_can)->ERRINT & LL_CAN_ERRINT_BEIF)
N
N/**
N  * @brief  Low layer CAN clear receive buffer
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_clear_receive_buffer(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_clear_receive_buffer(CAN_TypeDef *p_can) {
N    p_can->RCTRL |= LL_CAN_RCTRL_RREL;
X    p_can->RCTRL |= (1UL << 4);
N}
N
N/**
N  * @brief  Low layer CAN enable receive interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_receive_interrupt_enable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_receive_interrupt_enable(CAN_TypeDef *p_can) {
N    p_can->RTIE |= LL_CAN_RTIE_RIE;
X    p_can->RTIE |= (1UL << 7);
N}
N
N/**
N  * @brief  Low layer CAN disable receive interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_receive_interrupt_disable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_receive_interrupt_disable(CAN_TypeDef *p_can) {
N    p_can->RTIE &= ~(LL_CAN_RTIE_RIE);
X    p_can->RTIE &= ~((1UL << 7));
N}
N
N/**
N  * @brief  Low layer CAN enable receive buffer Overrun Interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_receive_buf_overrun_interrupt_enable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_receive_buf_overrun_interrupt_enable(CAN_TypeDef *p_can) {
N    p_can->RTIE |= LL_CAN_RTIE_ROIE;
X    p_can->RTIE |= (1UL << 6);
N}
N
N/**
N  * @brief  Low layer CAN disable receive buffer Overrun Interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_receive_buf_overrun_interrupt_disable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_receive_buf_overrun_interrupt_disable(CAN_TypeDef *p_can) {
N    p_can->RTIE &= ~(LL_CAN_RTIE_ROIE);
X    p_can->RTIE &= ~((1UL << 6));
N}
N
N/**
N  * @brief  Low layer CAN enable receive buffer full interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_receive_buf_full_interrupt_enable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_receive_buf_full_interrupt_enable(CAN_TypeDef *p_can) {
N    p_can->RTIE |= LL_CAN_RTIE_RFIE;
X    p_can->RTIE |= (1UL << 5);
N}
N
N/**
N  * @brief  Low layer CAN disable receive buffer full interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_receive_buf_full_interrupt_disable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_receive_buf_full_interrupt_disable(CAN_TypeDef *p_can) {
N    p_can->RTIE &= ~(LL_CAN_RTIE_RFIE);
X    p_can->RTIE &= ~((1UL << 5));
N}
N
N/**
N  * @brief  Low layer CAN enable receive buffer almost full interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_receive_buf_almost_full_interrupt_enable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_receive_buf_almost_full_interrupt_enable(CAN_TypeDef *p_can) {
N    p_can->RTIE |= LL_CAN_RTIE_RAFIE;
X    p_can->RTIE |= (1UL << 4);
N}
N
N/**
N  * @brief  Low layer CAN disable receive buffer almost full interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_receive_buf_almost_full_interrupt_disable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_receive_buf_almost_full_interrupt_disable(CAN_TypeDef *p_can) {
N    p_can->RTIE &= ~(LL_CAN_RTIE_RAFIE);
X    p_can->RTIE &= ~((1UL << 4));
N}
N
N/**
N  * @brief  Low layer CAN enable transmission primary interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_transmission_primary_interrupt_enable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_transmission_primary_interrupt_enable(CAN_TypeDef *p_can) {
N    p_can->RTIE |= LL_CAN_RTIE_TPIE;
X    p_can->RTIE |= (1UL << 3);
N}
N
N/**
N  * @brief  Low layer CAN disable transmission primary interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_transmission_primary_interrupt_disable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_transmission_primary_interrupt_disable(CAN_TypeDef *p_can) {
N    p_can->RTIE &= ~(LL_CAN_RTIE_TPIE);
X    p_can->RTIE &= ~((1UL << 3));
N}
N
N/**
N  * @brief  Low layer CAN enable transmission secondary interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_transmission_secondary_interrupt_enable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_transmission_secondary_interrupt_enable(CAN_TypeDef *p_can) {
N    p_can->RTIE |= LL_CAN_RTIE_TSIE;
X    p_can->RTIE |= (1UL << 2);
N}
N
N/**
N  * @brief  Low layer CAN disable transmission secondary interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_transmission_secondary_interrupt_disable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_transmission_secondary_interrupt_disable(CAN_TypeDef *p_can) {
N    p_can->RTIE &= ~(LL_CAN_RTIE_TSIE);
X    p_can->RTIE &= ~((1UL << 2));
N}
N
N/**
N  * @brief  Low layer CAN enable error interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_error_interrupt_enable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_error_interrupt_enable(CAN_TypeDef *p_can) {
N    p_can->RTIE |= LL_CAN_RTIE_EIE;
X    p_can->RTIE |= (1UL << 1);
N}
N
N/**
N  * @brief  Low layer CAN disable error interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_error_interrupt_disable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_error_interrupt_disable(CAN_TypeDef *p_can) {
N    p_can->RTIE &= ~(LL_CAN_RTIE_EIE);
X    p_can->RTIE &= ~((1UL << 1));
N}
N
N/**
N  * @brief  Low layer CAN enable error passive interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_error_passive_interrupt_enable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_error_passive_interrupt_enable(CAN_TypeDef *p_can) {
N    p_can->ERRINT |= LL_CAN_ERRINT_EPIE;
X    p_can->ERRINT |= (1UL << 5);
N}
N
N/**
N  * @brief  Low layer CAN disable error passive interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_error_passive_interrupt_disable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_error_passive_interrupt_disable(CAN_TypeDef *p_can) {
N    p_can->ERRINT &= ~(LL_CAN_ERRINT_EPIE);
X    p_can->ERRINT &= ~((1UL << 5));
N}
N
N/**
N  * @brief  Low layer CAN enable arbitration lost interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_arbitration_lost_interrupt_enable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_arbitration_lost_interrupt_enable(CAN_TypeDef *p_can) {
N    p_can->ERRINT |= LL_CAN_ERRINT_ALIE;
X    p_can->ERRINT |= (1UL << 3);
N}
N
N/**
N  * @brief  Low layer CAN disable arbitration lost interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_arbitration_lost_interrupt_disable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_arbitration_lost_interrupt_disable(CAN_TypeDef *p_can) {
N    p_can->ERRINT &= ~(LL_CAN_ERRINT_ALIE);
X    p_can->ERRINT &= ~((1UL << 3));
N}
N
N/**
N  * @brief  Low layer CAN enable bus error interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_bus_error_interrupt_enable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_bus_error_interrupt_enable(CAN_TypeDef *p_can) {
N    p_can->ERRINT |= LL_CAN_ERRINT_BEIE;
X    p_can->ERRINT |= (1UL << 1);
N}
N
N/**
N  * @brief  Low layer CAN disable bus error interrupt
N  * @param  p_can: The register structure pointer of the CAN.
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_bus_error_interrupt_disable(CAN_TypeDef *p_can) {
Xstatic __inline void ll_can_bus_error_interrupt_disable(CAN_TypeDef *p_can) {
N    p_can->ERRINT &= ~(LL_CAN_ERRINT_BEIE);
X    p_can->ERRINT &= ~((1UL << 1));
N}
N
N/**
N  * @brief  Low layer CAN set slow speed mode bit time param
N  * @param  p_can      : The register structure pointer of the CAN.
N  * @param  s_seg_1_val: The value of bit timing segment 1 (slow speed).
N  *                      Actual TQ value = s_seg_1_val + 2;
N  * @param  s_seg_2_val: The value of bit timing segment 2 (slow speed).
N  *                      Actual TQ value = s_seg_2_val + 1;
N  * @param  s_sjw_val  : The value of synchronization jump width (slow speed).
N  *                      Actual TQ value = s_sjw_val + 1;
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_set_slow_bit_time(CAN_TypeDef *p_can, 
Xstatic __inline void ll_can_set_slow_bit_time(CAN_TypeDef *p_can, 
N                                              u8 s_seg_1_val, 
N                                              u8 s_seg_2_val,
N                                              u8 s_sjw_val) {
N    TX_ASSERT(s_seg_1_val < 64);
X    ((s_seg_1_val < 64) ? (void)0U : tx_assert_false((uint8_t *)"..\\..\\..\\..\\Libraries\\Driver\\include\\LL\\tx_phe_ll_can.h", 1534));
N    TX_ASSERT(s_seg_2_val < 32);
X    ((s_seg_2_val < 32) ? (void)0U : tx_assert_false((uint8_t *)"..\\..\\..\\..\\Libraries\\Driver\\include\\LL\\tx_phe_ll_can.h", 1535));
N    TX_ASSERT(s_sjw_val < 16);
X    ((s_sjw_val < 16) ? (void)0U : tx_assert_false((uint8_t *)"..\\..\\..\\..\\Libraries\\Driver\\include\\LL\\tx_phe_ll_can.h", 1536));
N
N    LL_CAN_REG_OPT(
N        p_can->BITTIME0 = (p_can->BITTIME0 & LL_CAN_BITTIME_0_F_SJW(0x3)) |
N                          LL_CAN_BITTIME_0_S_SEG_1(s_seg_1_val);
N
N        p_can->BITTIME1 = (p_can->BITTIME1 & LL_CAN_BITTIME_1_F_SEG_2(0x7)) |
N                          LL_CAN_BITTIME_1_S_SEG_2(s_seg_2_val);
N
N        p_can->BITTIME2 = (p_can->BITTIME2 & LL_CAN_BITTIME_2_F_SEG_1(0xF)) |
N                          LL_CAN_BITTIME_2_S_SJW(s_sjw_val);
N    );
X    do{ ((CAN_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x9000))->CFGSTA |= (1UL << 7); p_can->BITTIME0 = (p_can->BITTIME0 & (((0x3)&0x3) << 6)) | (((s_seg_1_val)&0x3F) << 0); p_can->BITTIME1 = (p_can->BITTIME1 & (((0x7)&0x7) << 5)) | (((s_seg_2_val)&0x1F) << 0); p_can->BITTIME2 = (p_can->BITTIME2 & (((0xF)&0xF) << 4)) | (((s_sjw_val)&0xF) << 0);; ((CAN_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x9000))->CFGSTA &= ~(1UL << 7); }while(0);
N}
N
N#if 0
S///**
S//  * @brief  Low layer CAN set fast speed mode bit time param
S//  * @param  p_can      : The register structure pointer of the CAN.
S//  * @param  f_seg_1_val: The value of bit timing segment 1 (fast speed).
S//  *                      Actual TQ value = f_seg_1_val + 2;
S//  * @param  f_seg_2_val: The value of bit timing segment 2 (fast speed).
S//  *                      Actual TQ value = f_seg_2_val + 1;
S//  * @param  f_sjw_val  : The value of synchronization jump width (fast speed).
S//  *                      Actual TQ value = f_seg_2_val + 1;
S//  * @retval None
S//  */
S//__STATIC_INLINE void ll_can_set_fast_bit_time(CAN_TypeDef *p_can, 
S//                                              u8 f_seg_1_val, 
S//                                              u8 f_seg_2_val,
S//                                              u8 f_sjw_val) {
S//    TX_ASSERT(f_seg_1_val < 16);
S//    TX_ASSERT(f_seg_2_val < 8);
S//    TX_ASSERT(f_sjw_val < 4);
S
S//    LL_CAN_REG_OPT(
S//        p_can->BITTIME0 = (p_can->BITTIME0 & LL_CAN_BITTIME_0_S_SEG_1(0x3F)) |
S//                          LL_CAN_BITTIME_0_F_SJW(f_seg_1_val);
S
S//        p_can->BITTIME1 = (p_can->BITTIME1 & LL_CAN_BITTIME_1_S_SEG_2(0x1F)) |
S//                          LL_CAN_BITTIME_1_F_SEG_2(f_seg_2_val);
S
S//        p_can->BITTIME2 = (p_can->BITTIME2 & LL_CAN_BITTIME_2_S_SJW(0xF)) |
S//                          LL_CAN_BITTIME_2_F_SEG_1(f_sjw_val);
S//    );
S//}
N#endif 
N/**
N  * @brief  Low layer CAN set slow speed mode baudrate
N  * @param  p_can     : The register structure pointer of the CAN.
N  * @param  s_baudrate: The value of baudrate(slow speed).
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_set_slow_baudrate(CAN_TypeDef *p_can, u8 s_baudrate) {
Xstatic __inline void ll_can_set_slow_baudrate(CAN_TypeDef *p_can, u8 s_baudrate) {
N    LL_CAN_REG_OPT(
N        p_can->S_PRESC = LL_CAN_S_PRESC(s_baudrate);
N    );
X    do{ ((CAN_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x9000))->CFGSTA |= (1UL << 7); p_can->S_PRESC = (((s_baudrate)&0xFF) << 0);; ((CAN_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x9000))->CFGSTA &= ~(1UL << 7); }while(0);
N}
N
N#if 0
S///**
S//  * @brief  Low layer CAN set fast speed mode baudrate
S//  * @param  p_can     : The register structure pointer of the CAN.
S//  * @param  s_baudrate: The value of baudrate(fast speed).
S//  * @retval None
S//  */
S//__STATIC_INLINE void ll_can_set_fast_baudrate(CAN_TypeDef *p_can, u8 f_baudrate) {
S//    LL_CAN_REG_OPT(
S//        p_can->F_PRESC = LL_CAN_F_PRESC(f_baudrate);
S//    );
S//}
N#endif
N
N/**
N  * @brief  Low layer CAN enable receive address filter 
N  * @param  p_can   : The register structure pointer of the CAN.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.  
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_rx_addr_filt_enable(CAN_TypeDef *p_can, u16 chn_bits) {
Xstatic __inline void ll_can_rx_addr_filt_enable(CAN_TypeDef *p_can, u16 chn_bits) {
N    p_can->ACF_EN_0 |= LL_CAN_ACF_EN_0(chn_bits);
X    p_can->ACF_EN_0 |= (((chn_bits)&0xFF) << 0);
N    p_can->ACF_EN_1 |= LL_CAN_ACF_EN_1(chn_bits >> 8);
X    p_can->ACF_EN_1 |= (((chn_bits >> 8)&0xFF) << 0);
N}
N
N/**
N  * @brief  Low layer CAN disable receive address filter 
N  * @param  p_can   : The register structure pointer of the CAN.
N  * @param  chn_bits: Set the value of chn to be shifted, you can call the BIT() 
N  *                   function to assign values.  
N  * @retval None
N  */
N__STATIC_INLINE void ll_can_rx_addr_filt_disable(CAN_TypeDef *p_can, u16 chn_bits) {
Xstatic __inline void ll_can_rx_addr_filt_disable(CAN_TypeDef *p_can, u16 chn_bits) {
N    p_can->ACF_EN_0 &= ~(LL_CAN_ACF_EN_0(chn_bits));
X    p_can->ACF_EN_0 &= ~((((chn_bits)&0xFF) << 0));
N    p_can->ACF_EN_1 &= ~(LL_CAN_ACF_EN_1(chn_bits >> 8));
X    p_can->ACF_EN_1 &= ~((((chn_bits >> 8)&0xFF) << 0));
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_CAN_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 60 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_mac.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_mac.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_mac.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    08-10-2018
N  * @brief   This file contains all the MAC LL firmware functions.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_MAC_H
N#define __TX_PHE_LL_MAC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "tx_phe.h"
N#include "typedef.h"
N     
N/** @addtogroup TX_PHE_StdPeriph_Driver TX_PHE Driver
N  * @{
N  */
N     
N/** @addtogroup mac_interface_gr MAC Driver
N  * @ingroup  TX_PHE_StdPeriph_Driver
N  * @{
N  */ 
N
N/** @addtogroup MAC_LL_Driver MAC LL Driver
N  * @ingroup  mac_interface_gr
N  * @brief Mainly the driver part of the MAC module, which includes \b MAC \b Register 
N  * \b Constants, \b MAC \b Exported \b Constants, \b MAC \b Exported \b Struct, \b MAC
N  * \b Data \b transfers \b functions, \b MAC \b Initialization \b and \b MAC \b Configuration 
N  * \b And \b Interrupt \b Handle \b function.
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup MAC_LL_Register_Constants MAC LL Register Constants
N  * @ingroup  MAC_LL_Driver
N  * @brief    MAC LL register constant table definition
N  *
N  *
N@verbatim   
N  ===============================================================================
N                                Register Constants
N  ===============================================================================  
N  
N    Register Constants mainly encapsulates each bit in each group in the MAC 
N    register. In the process of configuration, the macro definition can be directly 
N    called to configure the MAC register, mainly for convenience. Understand the 
N    configuration of the MAC.
N    
N@endverbatim
N  *
N  * @{
N  */
N
N/***** CSR0(The bus mode register) *****/
N/*! Transmit automatic polling interval setting.
N */
N#define LL_MAC_CSR0_TAP_SET(n)                      (((n)&0x07) << 17)
N#define LL_MAC_CSR0_TAP_MASK                        (0x07UL << 17)
N/*! Specifies the maximum number of words that can be transferred within one
N *  DMA transaction.
N *  @note PBL cannot be 0, the recommended setting is 16
N */
N#define LL_MAC_CSR0_PBL_SET(n)                      (((n)&0x3F) << 8)
N/*! Specifies the number of 128-bit words between two consecutive unchained
N *  descriptors.
N */
N#define LL_MAC_CSR0_DSL_SET(n)                      (((n)&0x1F) << 2)
N/*! Software reset.
N */
N#define LL_MAC_CSR0_SWR_EN                          (1UL << 0)
N
N
N/***** CSR5(The status register) *****/
N/*! Transmit process state.
N */
N#define LL_MAC_CSR5_TS_GET(n)                       (((n) >> 20) & 0x07)
N/*! Receive process state .
N */
N#define LL_MAC_CSR5_RS_GET(n)                       (((n) >> 17) & 0x07)
N/*! Normal interrupt summary.
N */
N#define LL_MAC_CSR5_NIS_PENDING                     (1UL << 16)
N/*! Abnormal interrupt summary.
N */
N#define LL_MAC_CSR5_AIS_PENDING                     (1UL << 15)
N/*! Early receive interrupt.
N */
N#define LL_MAC_CSR5_ERI_PENDING                     (1UL << 14)
N/*! General-purpose timer expiration.
N */
N#define LL_MAC_CSR5_GTI_PENDING                     (1UL << 11)
N/*! Early transmit interrupt.
N */
N#define LL_MAC_CSR5_ETI_PENDING                     (1UL << 10)
N/*! Receive process stopped.
N */
N#define LL_MAC_CSR5_RPS_PENDING                     (1UL << 8)
N/*! Receive buffer unavailable.
N */
N#define LL_MAC_CSR5_RU_PENDING                      (1UL << 7)
N/*! Receive interrupt.
N */
N#define LL_MAC_CSR5_RI_PENDING                      (1UL << 6)
N/*! Transmit underflow.
N */
N#define LL_MAC_CSR5_UNF_PENDING                     (1UL << 5)
N/*! Transmit buffer unavailable.
N */
N#define LL_MAC_CSR5_TU_PENDING                      (1UL << 2)
N/*! Transmit process stopped.
N */
N#define LL_MAC_CSR5_TPS_PENDING                     (1UL << 1)
N/*! Transmit interrupt.
N */
N#define LL_MAC_CSR5_TI_PENDING                      (1UL << 0)
N
N
N/***** CSR6(The operation mode register) *****/
N/*! Receive all.
N */
N#define LL_MAC_CSR6_RA_EN                           (1UL << 30)
N/*! mask output of mac module.
N */
N#define LL_MAC_CSR6_MASK_EN                         (1UL << 29)
N/*! Write 1 to reset txfifo & tx buffer addr, auto clear.
N */
N#define LL_MAC_CSR6_CPU_RST_TX                      (1UL << 28)
N/*! Write 1 to reset rxfifo & rx buffer addr, auto clear.
N */
N#define LL_MAC_CSR6_CPU_RST_RX                      (1UL << 27)
N/*! auto reset txfifo & tx buffer addr, if chained frame finished and the
N *  next frame is not chained.
N */
N#define LL_MAC_CSR6_TCH_RST_EN                      (1UL << 26)
N/*! auto reset rxfifo & rx buffer addr, if chained frame finished and the
N *  next frame is not chained.
N */
N#define LL_MAC_CSR6_RCH_RST_EN                      (1UL << 25)
N/*! auto reset rxfifo & rx buffer addr, if receive buffer unavailable.
N */
N#define LL_MAC_CSR6_RU_RST_EN                       (1UL << 24)
N/*! auto disable RX if receive buffer unavailable.
N */
N#define LL_MAC_CSR6_RU_DIS_EN                       (1UL << 23)
N/*! Transmit threshold mode.
N */
N#define LL_MAC_CSR6_TTM_EN                          (1UL << 22)
N/*! When set, the transmission starts after a full packet is written into
N *  the transmit FIFO, regardless of the current FIFO threshold level.
N */
N#define LL_MAC_CSR6_SF_EN                           (1UL << 21)
N/*! rx address scatter mode(use RXDES2).
N */
N#define LL_MAC_CSR6_RXADR_UP_EN                     (1UL << 19)
N/*! tx address scatter mode(use TXDES2).
N */
N#define LL_MAC_CSR6_TXADR_UP_EN                     (1UL << 18)
N/*! Ethernet Speed Selection.
N */
N#define LL_MAC_CSR6_SPEED_SET(n)                    (((n)&0x03) << 16)
N#define LL_MAC_CSR6_SPEED_MASK                      (0x03UL << 16)
N/*! Threshold control bits.
N */
N#define LL_MAC_CSR6_TR_SET(n)                       (((n)&0x03) << 14)
N/*! Start/stop transmit command.
N */
N#define LL_MAC_CSR6_ST_EN                           (1UL << 13)
N/*! Full duplex mode.
N */
N#define LL_MAC_CSR6_FD                              (1UL << 9)
N/*! Pass all multicast.
N */
N#define LL_MAC_CSR6_PM_EN                           (1UL << 7)
N/*! Promiscuous mode.
N */
N#define LL_MAC_CSR6_PR_EN                           (1UL << 6)
N/*! Inverse filtering.
N */
N#define LL_MAC_CSR6_IF                              (1UL << 4)
N/*! Pass bad frames.
N */
N#define LL_MAC_CSR6_PB_EN                           (1UL << 3)
N/*! Hash only filtering mode.
N */
N#define LL_MAC_CSR6_HO                              (1UL << 2)
N/*! Start/stop receive command.
N */
N#define LL_MAC_CSR6_SR_EN                           (1UL << 1)
N/*! Hash/perfect receive filtering mode.
N */
N#define LL_MAC_CSR6_HP                              (1UL << 0)
N
N
N/***** CSR7(The interrupt enable register) *****/
N/*! Normal interrupt summary enable.
N */
N#define LL_MAC_CSR7_NIE_EN                          (1UL << 16)
N/*! Abnormal interrupt summary enable.
N */
N#define LL_MAC_CSR7_AIE_EN                          (1UL << 15)
N/*! Early receive interrupt enable.
N */
N#define LL_MAC_CSR7_ERE_EN                          (1UL << 14)
N/*! General-purpose timer overflow enable.
N */
N#define LL_MAC_CSR7_GTE_EN                          (1UL << 11)
N/*! Early transmit interrupt enable.
N */
N#define LL_MAC_CSR7_ETE_EN                          (1UL << 10)
N/*! Receive stopped enable.
N */
N#define LL_MAC_CSR7_RSE_EN                          (1UL << 8)
N/*! Receive buffer unavailable enable.
N */
N#define LL_MAC_CSR7_RUE_EN                          (1UL << 7)
N/*! Receive interrupt enable.
N */
N#define LL_MAC_CSR7_RIE_EN                          (1UL << 6)
N/*! Underflow interrupt enable.
N */
N#define LL_MAC_CSR7_UNE_EN                          (1UL << 5)
N/*! Transmit buffer unavailable enable.
N */
N#define LL_MAC_CSR7_TUE_EN                          (1UL << 2)
N/*! Transmit stopped enable.
N */
N#define LL_MAC_CSR7_TSE_EN                          (1UL << 1)
N/*! Transmit interrupt enable.
N */
N#define LL_MAC_CSR7_TIE_EN                          (1UL << 0)
N
N
N/***** CSR8(The missed frames counter register) *****/
N/*! Missed frame overflow.
N */
N#define LL_MAC_CSR8_MFO_PENDING                     (1UL << 16)
N/*! Missed frame counter.
N */
N#define LL_MAC_CSR8_MFC(n)                          (((n)&0xFFFF) >> 0)
N
N
N/***** CSR9(The serial ROM/Software MII Serial Management register) *****/
N/*! MII management data in signal.
N */
N#define LL_MAC_CSR9_MDI_GET(n)                      (((n) >> 19) & 0x01)
N/*! MII management interface mode.
N */
N#define LL_MAC_CSR9_MII_SET(n)                      (((n)&0x01) << 18)
N/*! MII management write data.
N */
N#define LL_MAC_CSR9_MDO_SET(n)                      (((n)&0x01) << 17)
N/*! MII management clock.
N */
N#define LL_MAC_CSR9_MDC_SET(n)                      (((n)&0x01) << 16)
N/*! Serial ROM data output.
N */
N#define LL_MAC_CSR9_SDO_SET(n)                      (((n)&0x01) << 3)
N/*! Serial ROM data input.
N */
N#define LL_MAC_CSR9_SDI_GET(n)                      (((n) >> 2) & 0x01)
N/*! Serial ROM clock.
N */
N#define LL_MAC_CSR9_SCLK_SET(n)                     (((n)&0x01) << 1)
N/*! Serial ROM chip select.
N */
N#define LL_MAC_CSR9_SCS_SET(n)                      (((n)&0x01) << 0)
N
N
N/***** CSR10(The MII serial management register) *****/
N/*! START/BUSY.
N */
N#define LL_MAC_CSR10_SB                             (1UL << 31)
N/*! clock divider settings.
N */
N#define LL_MAC_CSR10_CLKDIV_SET(n)                  (((n)&0x07) << 28)
N/*! MIISM operation code.
N */
N#define LL_MAC_CSR10_OPCODE_SET(n)                  (((n)&0x03) << 26)
N/*! Physical layer address for current transfer.
N */
N#define LL_MAC_CSR10_PHYADD_SET(n)                  (((n)&0x1F) << 21)
N/*! Register address for the current transfer.
N */
N#define LL_MAC_CSR10_REGADD_SET(n)                  (((n)&0x1F) << 16)
N/*! Register data.
N */
N#define LL_MAC_CSR10_DATA(n)                        (((n)&0xFFFF) << 0)
N
N
N/***** CSR11(Timer and interrupt mitigation control) *****/
N/*! Controls the time units for the transmit and receive timers.
N */
N#define LL_MAC_CSR11_CS_SET(n)                      (((n)&0x01) << 31)
N/*! Controls the time that must elapse between the end of a transmit
N *  operation and issuing the transmit interrupt.
N */
N#define LL_MAC_CSR11_TT_SET(n)                      (((n)&0x0F) << 27)
N/*! Controls the number of the frames transmitted before issuing the
N *  transmit interrupt.
N */
N#define LL_MAC_CSR11_NTP_SET(n)                     (((n)&0x07) << 24)
N/*! Controls the time that must elapse between the end of a receive
N *  operation and issuing the receive interrupt.
N */
N#define LL_MAC_CSR11_RT_SET(n)                      (((n)&0x0F) << 20)
N/*! Controls the number of the received frames before issuing the receive
N *  interrupt.
N */
N#define LL_MAC_CSR11_NRP_SET(n)                     (((n)&0x07) << 17)
N/*! Continuous mode.
N */
N#define LL_MAC_CSR11_CON_EN                         (1UL << 16)
N/*! Contains the number of iterations of the general-purpose timer.
N */
N#define LL_MAC_CSR11_TIM_SET(n)                     (((n)&0xFFFF) << 0)
N
N/**
N  * @}
N  */
N
N/** @defgroup MAC_LL_Exported_Constants MAC LL Exported Constants
N  * @ingroup  MAC_LL_Driver
N  * @brief    MAC LL external constant definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Constants
N  ===============================================================================  
N  
N    Exported Constants mainly restricts the partial configuration of the abstraction 
N    layer by using the form of enumeration to facilitate the use and understanding of 
N    the module configuration. For the specific enumeration meaning, please refer to 
N    the annotation of each module.
N
N@endverbatim
N  *
N  * @{
N  */
N  
N/***** DRIVER API *****/
N
N
N
N/***** LL API *****/
N
N
N  
N/***** LL API AND DRIVER API *****/
N/**
N  * @brief Transmit automatic polling intervals
N  */
Ntypedef enum {
N/*  Time interval                           10Mbps          100Mbps             */
N    LL_MAC_TAP_DISABLE          = 0,    /*    -                -                */
N    LL_MAC_TAP_128_PERIOD       = 4,    /*  51.2us          5.12us              */
N    LL_MAC_TAP_256_PERIOD       = 5,    /*  102.4us         10.24us             */
N    LL_MAC_TAP_512_PERIOD       = 6,    /*  204.8us         20.48us             */
N    LL_MAC_TAP_1024_PERIOD      = 7,    /*  409.6us         40.96us             */
N    LL_MAC_TAP_2048_PERIOD      = 1,    /*  819.2us         81.92us             */
N    LL_MAC_TAP_4096_PERIOD      = 2,    /*  1.638ms         163.8us             */
N    LL_MAC_TAP_8192_PERIOD      = 3,    /*  3.276ms         327.6us             */
N} TYPE_ENUM_LL_MAC_TAP_SEL;
N
N/**
N  * @brief Programmable burst length for data buffer access
N  * @note  PBL cannot be 0, GMAC_PBL_16 is recommended.
N  */
Ntypedef enum {
N    LL_MAC_PBL_0                = 0,
N    LL_MAC_PBL_1                = 1,
N    LL_MAC_PBL_2                = 2,
N    LL_MAC_PBL_4                = 4,
N    LL_MAC_PBL_8                = 8,
N    LL_MAC_PBL_16               = 16,
N    LL_MAC_PBL_32               = 32,
N} TYPE_ENUM_LL_MAC_PBL_SEL;
N
N/**
N  * @brief MAC Transmit process state
N  */
Ntypedef enum {
N    /*! stop
N    */
N    LL_MAC_TX_STOP              = 0,
N    /*! fetching tx descriptor
N    */
N    LL_MAC_TX_FETCHING          = 1,
N    /*! waiting for end of transmission
N    */
N    LL_MAC_TX_WAITING_END       = 2,
N    /*! data buf from host to FIFO
N    */
N    LL_MAC_TX_TO_FIFO           = 3,
N    /*! setup packet processing
N    */
N    LL_MAC_TX_SETUP_PROCESSING  = 5,
N    /*! FIFO underflow/unavailable descriptor
N    */
N    LL_MAC_TX_SUSPENDED         = 6,
N    /*! closing transmit descriptor
N    */
N    LL_MAC_TX_CLOSING           = 7,
N} TYPE_ENUM_LL_MAC_TX_STATE;
N
N/**
N  * @brief MAC Receive process state
N  */
Ntypedef enum {
N    /*! stop
N    */
N    LL_MAC_RX_STOP              = 0, 
N    /*! fetching rx descriptor
N    */
N    LL_MAC_RX_FETCHING          = 1,
N    /*! waiting for the end of receive packet
N    */
N    LL_MAC_RX_WAITING_END       = 2,
N    /*! waiting for receive packet
N    */
N    LL_MAC_RX_WAITING_RECEIVE   = 3,
N    /*! unavailable receive buffer
N    */
N    LL_MAC_RX_SUSPENDED         = 4,
N    /*! closing receive descriptor
N    */
N    LL_MAC_RX_CLOSING           = 5,
N    /*! transferring data from FIFO to host memory
N    */
N    LL_MAC_RX_TO_MEMORY         = 7,
N} TYPE_ENUM_LL_MAC_RX_STATE;
N
N/**
N  * @brief MAC Ethernet speed selection
N  */
Ntypedef enum {
N    LL_MAC_ETHERNET_100M        = 0,
N    LL_MAC_ETHERNET_1G          = 1,
N    LL_MAC_ETHERNET_10M         = 2,
N} TYPE_ENUM_LL_MAC_SPEED_SEL;
N
N/**
N  * @brief MAC Software MII management interface mode
N  */
Ntypedef enum {
N    LL_MAC_MII_WRITE            = 0,
N    LL_MAC_MII_READ             = 1,
N} TYPE_ENUM_LL_MAC_MII_SEL;
N
N/**
N  * @brief MAC MII serial management clock divider setting
N  */
Ntypedef enum {
N    LL_MAC_CLK_DIV_8            = 0,
N    LL_MAC_CLK_DIV_16           = 1,
N    LL_MAC_CLK_DIV_32           = 2,
N    LL_MAC_CLK_DIV_64           = 3,
N    LL_MAC_CLK_DIV_128          = 4,
N    LL_MAC_CLK_DIV_256          = 5,
N    LL_MAC_CLK_DIV_512          = 6,
N    LL_MAC_CLK_DIV_1024         = 7,
N} TYPE_ENUM_LL_MAC_CLKDIV_SEL;
N
N/**
N  * @brief MAC MIISM operation code
N  */
Ntypedef enum {
N    LL_MAC_DISABLE_CLK          = 0,
N    LL_MAC_REG_WRITE            = 1,
N    LL_MAC_REG_READ             = 2,
N    LL_MAC_CLK_DIVIDER_SET      = 3,
N} TYPE_ENUM_LL_MAC_OPCODE;
N
N/**
N  * @brief the time units for the transmit and receive timers
N  */
Ntypedef enum {
N/*  time unit                               10Mbps      100Mbps                 */
N    LL_MAC_128_MII_PERIOD       = 1,    /*  51.2us      5.12us                  */
N    LL_MAC_2048_MII_PERIOD      = 0,    /*  819.2us     81.92us                 */
N} TYPE_ENUM_LL_MAC_CS_SEL;
N
N/**
N  * @brief MAC filter type selection
N  */
Ntypedef enum {
N    /*! Setup frame buffer is interpreted as a set of 16 48-bit physical
N     *  addresses.
N     * @note Whitelist mode
N     */
N    LL_MAC_PERFECT_FILTER = 0,
N    /*! Setup frame buffer contains 512-bit hash table plus a single 48-bit
N     *  physical address.
N     * @note Whitelist mode. The hash table is only valid for multicast
N     *       addresses.
N     */
N    LL_MAC_HASH_FILTER,
N    /*! Setup frame buffer is interpreted as a set of 16 48-bit physical
N     *  addresses.
N     * @note Blacklist mode
N     */
N    LL_MAC_INVERSE_FILTER,
N    /*! Setup frame buffer is interpreted as a 512-bit hash table.
N     * @note Whitelist mode. The hash table is only valid for multicast
N     *       addresses.
N     */
N    LL_MAC_HASH_ONLY_FILTER,
N} TYPE_ENUM_LL_MAC_FILTER;
N
N/**
N  * @brief frame tx/rx status
N  */
Ntypedef enum {
N    /*! frame transfer completed
N     */
N    LL_MAC_FRAME_COMPLETE = 0,
N    /*! frame transmission error
N     */
N    LL_MAC_FRAME_ERR,
N    /*! frame waiting for transmission completed
N     */
N    LL_MAC_FRAME_WAITTING_COMPLETE,
N} TYPE_ENUM_LL_MAC_FRAME_STATUS;
N
N/**
N  * @}
N  */
N
N/** @defgroup MAC_LL_Exported_Struct MAC LL Exported Struct
N  * @ingroup  MAC_LL_Driver
N  * @brief    MAC LL external configuration structure definition
N  *
N@verbatim   
N  ===============================================================================
N                                Exported Struct
N  ===============================================================================  
N
N    Exported Struct mainly extracts the MAC registers from the API, and abstracts 
N    the structure. As long as it implements the low coupling between the registers 
N    and the registers, the user only needs to configure the structure of the abstraction 
N    layer and call hal_mac_init. Function, you can configure the MAC module without 
N    involving the configuration of the collective register.
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief MAC configuration structure
N  */
Ntypedef struct __ll_mac_init {
N    /*! RX descriptor start address
N     * @note rx_descriptor_start_addr are aligned in 8 bytes and can only be
N     *       located in SRAM0/SRAM10/SRAM1.  
N     *       Statement example:  
N     *        static u8 buf[1024] __attribute__((aligned(8),section("SRAM0")));
N     */
N    u32  rx_descriptor_start_addr;
N    /*! TX descriptor start address
N     * @note tx_descriptor_start_addr are aligned in 8 bytes and can only be
N     *       located in SRAM0/SRAM10/SRAM1.  
N     *       Statement example:  
N     *        static u8 buf[1024] __attribute__((aligned(8),section("SRAM0")));
N     */
N    u32  tx_descriptor_start_addr;
N    /* GMAC rx receive mode */
N    /*! receive all frame
N     */
N    bool promiscuous_en;
N    /*! receive all multicast frame
N     */
N    bool pass_all_multicast_en;
N    /*! When set, the gmac transfers all frames into the data buffers,
N     *  regardless of the receive errors
N     */
N    bool pass_bad_frame_en;
N} TYPE_LL_MAC_INIT;
N
N/**
N  * @brief MAC interrupt configuration structure
N  */
Ntypedef struct __ll_mac_irq_cfg {
N    /*! General-purpose timer overflow enable ?
N     */
N    bool timer_overflow_intr_en;
N    
N    /* rx */
N    /*! Early receive interrupt enable ?
N     */      
N    bool rx_early_intr_en;
N    /*! Receive buffer unavailable enable ?
N     */
N    bool rx_buf_unavailable_intr_en;
N    /*! Receive interrupt enable ?
N     */
N    bool rx_intr_en;
N    /*! Receive stopped enable ?
N     */
N    bool rx_stop_intr_en;
N    
N    /* tx */
N    /*! Early transmit interrupt enable ?
N     */
N    bool tx_early_intr_en;
N    /*! Transmit buffer unavailable enable ?
N    */
N    bool tx_buf_unavilable_intr_en;
N    /*! Underflow interrupt enable ?
N     */
N    bool tx_underflow_intr_en;
N    /*! Transmit interrupt enable ?
N     */
N    bool tx_intr_en;
N    /*! Transmit stopped enable ?
N     */
N    bool tx_stop_intr_en;
N} TYPE_LL_MAC_IRQ_CFG;
N
N/**
N  * @brief GMAC descriptor generic structure
N  */
Ntypedef struct __ll_mac_descriptor {
N    u32 reg0;
N    u32 reg1;
N    u32 reg2;
N    u32 reg3;
N} TYPE_LL_MAC_DESCRIPTOR;
N
N/**
N  * @brief GMAC RX descriptor structure
N  */
Ntypedef struct __ll_mac_rx_descriptor {
N    /*! This bit is reset for the frames with the legal length. When set,
N     *  indicates that the frame was truncated due to the receive FIFO
N     *  overflow.
N     */
N    u32 zero                : 1,
N    /*! This bit is valid only when the last_descriptor is set.
N     *  Additionally, the CE is not valid when the received frame is a
N     *  runt frame.
N     */
N        crc_err             : 1,
N    /*! This bit is valid only when the last_descriptor is set.
N     */
N        dribbling_bit       : 1,
N    /*! This bit is valid only when the last_descriptor is set.
N     */
N        mii_err             : 1,
N        reserved0           : 1,
N    /*! When set, indicates that the frame has the length field greater
N     *  then 1500 (Ethernet type frame). When cleared, indicates the
N     *  802.3 type frame.  
N     *  This bit is valid only when the last_descriptor is set.
N     *  Additionally, the FT is invalid for the runt frames of a length
N     *  shorter then 14 bytes.
N     */
N        frame_type          : 1,
N    /*! This bit is valid only when the last_descriptor is set.
N     */
N        collision_seen      : 1,
N    /*! This bit is valid only when the last_descriptor is set.
N     */
N        frame_too_long      : 1,
N        last_descriptor     : 1,
N        first_descriptor    : 1,
N    /*! This bit is valid only when the last_descriptor is set.
N     */
N        multicast_frame     : 1,
N    /*! This bit is valid only when the last_descriptor is set.
N     */
N        runt_frame          : 1,
N        reserved1           : 2,
N    /*! This bit is valid only when the last_descriptor is set.
N     */
N        descriptor_err      : 1,
N    /*! This bit is valid only when the last_descriptor is set.
N     */
N        err_summary         : 1,
N    /*! This bit is valid only when the last_descriptor is set and
N     *  descriptor_err is cleared.
N     */
N        frame_len           : 14,
N    /*! This bit is valid only for the last descriptor of the frame,
N     *  when the CSR6.30 (receive all) bit is set, and the frame is at
N     *  least 64 bytes long.
N     */
N        filtering_fail      : 1,
N        own                 : 1;
N    /*! Indicates the size, in bytes, of memory space used by the first
N     *  data buffer. This number must be a multiple of 4.
N     */
N    u32 buf_1_size          : 11,
N    /*! Useless, please set to 0.
N     */
N        buf_2_size          : 11,
N        reserved2           : 2,
N    /*! When set, indicates that the second buffer's address points to
N     *  the next descriptor and not to the data buffer.
N     * @note Note that the end_of_ring takes precedence over the
N     *       second_addr_chained.
N     */
N        second_addr_chained : 1,
N    /*! When set, indicates that this is the last descriptor in the
N     *  receive descriptor ring.
N     */
N        end_of_ring         : 2;
N    /*! Indicates the length, in bytes, of memory allocated for the
N     *  first receive buffer. This number must be 64 byte aligned.
N     *  @note rx_buf_addr_1 are aligned in 4 bytes and can only be located
N     *        in SRAM3.  
N     *        Statement example:  
N     *         static u8 buf[1024] __attribute__((aligned(4),section("SRAM3")));
N     */
N    u32 rx_buf_addr_1;
N    union {
N        /*no use
N         */
N        u32 rx_buf_addr_2;
N        /*! A pointer to the next rx descriptor.
N         */
N        struct __ll_mac_rx_descriptor *p_next;
N    };
N} TYPE_LL_MAC_RX_DESCRIPTOR;
N
N/**
N  * @brief GMAC TX descriptor structure type
N  */
Ntypedef struct __ll_mac_tx_descriptor {
N    /*! When set, indicates that the frame was deferred befor
N     *  transmission. Deferring occurs if the carrier is detected when
N     *  the transmission is ready to start.  
N     *  This bit is valid only when last_descriptor is set.
N     */
N    u32 deferred            : 1,
N    /*! This bit is valid only when last_descriptor is set.
N     */
N        underflow_err       : 1,
N        reserved0           : 1,
N    /*! This value is not valid when excessive_collisions is set. This
N     *  bit is valid only when last_descriptor is set.
N     */
N        collision_cnt       : 4,
N        reserved1           : 1,
N    /*! This bit is valid only when last_descriptor is set.
N     */
N        excessive_collision : 1,
N    /*! This bit is not valid when underflow_err is set. This bit is
N     *  valid only when last_descriptor is set.
N     */
N        late_collision      : 1,
N    /*! This bit is valid only when last_descriptor is set.
N     */
N        no_carrier          : 1,
N    /*! This bit is valid only when last_descriptor is set.
N     */
N        loss_of_carrier     : 1,
N        reserved2           : 3,
N    /*! This bit is valid only when last_descriptor is set.
N     */
N        err_summary         : 1,
N        reserved3           : 15,
N        own                 : 1;
N    /*! Indicates the size, in bytes, of memory space used by the first
N     *  data buffer. 
N     */
N    u32 buf_1_size          : 11,
N    /*! Useless, please set to 0.
N     */
N        buf_2_size          : 11,
N    /*! This bit is valid only for the setup frames.
N     */
N        filtering_type_0    : 1,
N    /*! When set, automatic byte padding is disabled.
N     */
N        disable_padding     : 1,
N    /*! When set, indicates that the second descriptor's address points
N     *  to the next descriptor and not to the data buffer.  
N     *  This bit is valid only when end_of_ring is 0.
N     */
N        second_addr_chained : 1,
N    /*! When set, indicates the last descriptor in the descriptors ring.
N     */
N        end_of_ring         : 1,
N        crc_disable         : 1,
N    /*! When set, indicates that this is a setup frame descriptor.
N     */
N        setup_packet        : 1,
N    /*! This bit is valid only for the setup frames.
N     */
N        filtering_type_1    : 1,
N        first_descriptor    : 1,
N        last_descriptor     : 1,
N    /*! Interrupt on completion.  
N     *  Setting this flag instructs the GMAC to set CSR5.0 (transmit
N     *  interrupt) immediately after processing a current frame.  
N     *  This bit is valid when last_descriptor is set, or for a setup
N     *  packet.
N     */
N        int_on_completion   : 1;
N    /*! Contains the address of the first data buffer. For the setup
N     *  frame this address must be 64 byte aligned. In all other cases
N     *  there are no restrictions on buffer alignment.
N     *  @note tx_buf_addr_1 are aligned in 4 bytes and can only be located
N     *        in SRAM2.  
N     *        Statement example:  
N     *         static u8 buf[1024] __attribute__((aligned(4),section("SRAM2")));
N     */
N    u32 tx_buf_addr_1;
N    union {
N        /*no use
N         */
N        u32 tx_buf_addr_2;
N        /*! A pointer to the next tx descriptor.
N         */
N        struct __ll_mac_tx_descriptor *p_next;
N    };
N} TYPE_LL_MAC_TX_DESCRIPTOR;
N
N/**
N  * @brief GMAC Hash table setup frame buffer format
N  */
Ntypedef struct __ll_mac_setup_hash_table {
N    /*! Multicast address hash table
N     */
N    u32 hash_filter[32];
N    u32 reserved[7];
N    /* 1 mac address */
N    
N    /*! MAC address 0bit~15bit
N     */
N    u32 addr_15_00;
N    /*! MAC address 16bit~31bit
N     */
N    u32 addr_31_16;
N    /*! MAC address 32bit~47bit
N     */
N    u32 addr_47_32;
N} TYPE_LL_MAC_SETUP_HASH_TABLE;
N
N/**
N  * @brief GMAC Perfect filtering setup frame buffer format
N  */
Ntypedef struct __ll_mac_setup_perfect_filter {
N    /*! 16 MAC address
N     */
N    struct {
N        /*! MAC address 0bit~15bit
N         */
N        u32 addr_15_00;
N        /*! MAC address 16bit~31bit
N         */
N        u32 addr_31_16;
N        /*! MAC address 32bit~47bit
N         */
N        u32 addr_47_32;
N    } mac_addr[16];
N} TYPE_LL_MAC_SETUP_PERFECT_FILTER;
N
N/**
N  * @brief GMAC setup frame union type
N  */
Ntypedef union __ll_mac_setup_frame {
N    /*! perfect filter
N     */
N    TYPE_LL_MAC_SETUP_PERFECT_FILTER perfect_filter;
N    /*! hash table filter
N     */
N    TYPE_LL_MAC_SETUP_HASH_TABLE     hash_table_filter;
N} TYPE_LL_MAC_SETUP_FRAME;
N
N/**
N  * @brief GMAC setup frame control structure
N  */
Ntypedef struct __ll_mac_setup_frame_ctl {
N    /*! GMAC setup frame pointer
N     *  @note The address pointed to by the p_setup_frame are aligned in 8
N     *        bytes and can only be located in SRAM0/SRAM10/SRAM1.  
N     *        Statement example:  
N     *         static u8 buf[1024] __attribute__((aligned(8),section("SRAM0")));
N     
N     */
N    TYPE_LL_MAC_SETUP_FRAME   *p_setup_frame;
N    /*! rx address filtering mode
N     */
N    TYPE_ENUM_LL_MAC_FILTER   filter_mode;
N    /*! The descriptor used for sending, the user does not need to
N     *  configure this.
N     */
N    TYPE_LL_MAC_TX_DESCRIPTOR *p_tx_descriptor;
N} TYPE_LL_MAC_SETUP_FRAME_CTL;
N
N/**
N  * @brief GMAC tx control structure type
N  */
Ntypedef struct __ll_mac_tx_frame_ctl {
N    /*! The frame buf(excluding crc) pointer to be sent
N     */
N    void                      *frame_buf;
N    /*! Frame length to send (excluding crc)
N     */
N    u32                       frame_len;
N    /*! The descriptor used for sending, the user does not need to
N     *  configure this.
N     */
N    TYPE_LL_MAC_TX_DESCRIPTOR *p_tx_descriptor;
N} TYPE_LL_MAC_TX_FRAME_CTL;
N
N/**
N  * @brief GMAC rx control structure type
N  */
Ntypedef struct __ll_mac_rx_frame_ctl {
N    /*! Stores the buf pointer of the received frame (including crc).
N     */
N    void *frame_buf;
N    /*! Received frame (including crc) length
N     */
N    u32  frame_len;
N    /*! The status of the received frame is used for query usage, and the
N     *  user does not need to pay attention to it.
N     */
N    u32  status;
N} TYPE_LL_MAC_RX_FRAME_CTL;
N
N/**
N  * @}
N  */
N
N/** @defgroup MAC_LL_Interrupt MAC LL Interrupt Handle function
N  * @brief   MAC LL Interrupt Handle function
N  *
N@verbatim   
N  ===============================================================================
N                        Interrupt Handle function
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the MAC  
N    Interrupt Handle function.
N
N    how to use?
N
N    The MAC interrupt handler uses a callback method that reserves the interface 
N    to the user in the form of a callback function. The client needs to initialize 
N    the callback function when initializing the MAC in order for the interrupt to 
N    be processed normally. 
N   
N@endverbatim
N  *
N  * @{
N  */
N
N
N
N/**
N  * @}
N  */
N  
N/** @defgroup MAC_LL_Inti_Cfg MAC LL Initialization And Configuration
N  * @brief    MAC LL Initialization And Configuration
N  *
N@verbatim   
N  ===============================================================================
N                        Initialization And Configuration
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the MAC data 
N    Initialization and Configuration.
N    
N    how to use?
N
N@endverbatim
N  *
N  * @{
N  */
N
N/**
N  * @brief GMAC register operation
N  * @param expression: expression.
N  */
N#define LL_MAC_REG_OPT(expression) \
Ndo {                               \
N    expression;                    \
N    __ASM volatile ("nop");        \
N} while(0)
X#define LL_MAC_REG_OPT(expression) do {                                   expression;                        __ASM volatile ("nop");        } while(0)
N
N/**
N  * @brief  GMAC module initialization
N  * @param  p_gmac: GMAC module pointer
N  * @param  p_init: GMAC initialization structure pointer
N  * @retval None
N  */
Nvoid ll_mac_init(GMAC_TypeDef *p_gmac, TYPE_LL_MAC_INIT *p_init);
N
N/**
N  * @brief  GMAC module deinitialization
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
Nvoid ll_mac_deinit(GMAC_TypeDef *p_gmac);
N
N/**
N  * @brief  GMAC interrupt enable setting
N  * @param  p_gmac: GMAC module pointer
N  * @param  p_cfg : GMAC interrupt enable control structure pointer
N  * @retval None
N  */
Nvoid ll_mac_irq_config(GMAC_TypeDef *p_gmac, TYPE_LL_MAC_IRQ_CFG *p_cfg);
N
N/**
N  * @}
N  */
N  
N/** @defgroup MAC_LL_Data_Transfers MAC LL Data transfers functions
N  * @brief    MAC LL Data transfers functions 
N  *
N@verbatim   
N  ===============================================================================
N                            Data transfers functions
N  ===============================================================================  
N
N    This subsection provides a set of functions allowing to manage the MAC data 
N    transfers and receive.
N  
N@endverbatim
N  *
N  * @{
N  */
N  
N/**
N  * @brief  Enable GMAC receiving function
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
Nvoid ll_mac_start(GMAC_TypeDef *p_gmac);
N
N/**
N  * @brief  Stop the GMAC module
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
Nvoid ll_mac_stop(GMAC_TypeDef *p_gmac);
N
N/**
N  * @brief  The MII management interface sends data
N  * @param  p_gmac  : GMAC module pointer
N  * @param  phy_addr: PHY address
N  * @param  reg_addr: register address
N  * @param  data    : Data to send
N  * @retval None
N  * @note   Data format symbol IEEE802.3 clause 22
N  */
Nvoid ll_mac_mdio_write(GMAC_TypeDef *p_gmac, u8 phy_addr, u8 reg_addr, u16 data);
N
N/**
N  * @brief  The MII management interface receives data
N  * @param  p_gmac  : GMAC module pointer
N  * @param  phy_addr: PHY address
N  * @param  reg_addr: register address
N  * @retval Return the read data
N  * @note   Data format symbol IEEE802.3 clause 22
N  */
Nu16 ll_mac_mdio_read(GMAC_TypeDef *p_gmac, u8 phy_addr, u8 reg_addr);
N
N/**
N  * @brief  GMAC has received the frame?
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returns true if received, false if none.
N  */
Nbool ll_mac_has_received_frame(GMAC_TypeDef *p_gmac);
N
N/**
N  * @brief  GMAC allows to send a frame?
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning true means permission, returning false means that the
N  *         TX descriptor has run out and cannot be sent.
N  */
Nbool ll_mac_allow_send_frame(GMAC_TypeDef *p_gmac);
N
N/**
N  * @brief  GMAC sends a frame of data
N  * @param  p_gmac        : GMAC module pointer
N  * @param  p_tx_frame_ctl: tx frame structure pointer
N  * @retval None
N  */
Nvoid ll_mac_send_frame(GMAC_TypeDef *p_gmac, TYPE_LL_MAC_TX_FRAME_CTL *p_tx_frame_ctl);
N
N/**
N  * @brief  GMAC setup frame transmission
N  * @param  p_gmac           : GMAC module pointer
N  * @param  p_setup_frame_ctl: setup frame structure pointer
N  * @retval Returning true means that the setup frame is placed in the send
N  *         queue. Returning false means that the previous setup frame was
N  *         not sent.
N  * @note   Wait for a setup frame to be sent before you can continue to
N  *         send a setup frame.
N  */
Nbool ll_mac_setup_send_frame(GMAC_TypeDef *p_gmac, TYPE_LL_MAC_SETUP_FRAME_CTL *p_setup_frame_ctl);
N
N/**
N  * @brief  GMAC receives a frame of data
N  * @param  p_gmac        : GMAC module pointer
N  * @param  p_rx_frame_ctl: rx frame structure pointer
N  * @retval None
N  */
Nvoid ll_mac_receive_frame(GMAC_TypeDef *p_gmac, TYPE_LL_MAC_RX_FRAME_CTL *p_rx_frame_ctl);
N
N/**
N  * @brief  Get the status of the setup frame
N  * @param  p_setup_frame_ctl: setup frame structure pointer
N  * @retval tx frame status
N  */
NTYPE_ENUM_LL_MAC_FRAME_STATUS ll_mac_get_setup_frame_status(TYPE_LL_MAC_SETUP_FRAME_CTL *p_setup_frame_ctl);
N
N/**
N  * @brief  Get the status of the send frame
N  * @param  p_gmac        : GMAC module pointer
N  * @param  p_tx_frame_ctl: tx frame structure pointer
N  * @retval tx frame status
N  */
NTYPE_ENUM_LL_MAC_FRAME_STATUS ll_mac_get_tx_frame_status(GMAC_TypeDef *p_gmac, TYPE_LL_MAC_TX_FRAME_CTL *p_tx_frame_ctl);
N
N/**
N  * @brief  Get the status of the received frame
N  * @param  p_gmac        : GMAC module pointer
N  * @param  p_rx_frame_ctl: rx frame structure pointer
N  * @retval rx frame status
N  */
NTYPE_ENUM_LL_MAC_FRAME_STATUS ll_mac_get_rx_frame_status(GMAC_TypeDef *p_gmac, TYPE_LL_MAC_RX_FRAME_CTL *p_rx_frame_ctl);
N
N/**
N  * @brief  Check GMAC normal interrupt summary enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_NIE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_NIE_EN)
N
N/**
N  * @brief  Check GMAC abnormal interrupt summary enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_AIE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_AIE_EN)
N
N/**
N  * @brief  Check GMAC early receive interrupt enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_ERE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_ERE_EN)
N
N/**
N  * @brief  Check GMAC general-purpose timer overflow enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_GTE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_GTE_EN)
N
N/**
N  * @brief  Check GMAC early transmit interrupt enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_ETE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_ETE_EN)
N
N/**
N  * @brief  Check GMAC receive stopped enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_RSE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_RSE_EN)
N
N/**
N  * @brief  Check GMAC receive buffer unavailable enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_RUE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_RUE_EN)
N
N/**
N  * @brief  Check GMAC receive interrupt enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_RIE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_RIE_EN)
N
N/**
N  * @brief  Check GMAC underflow interrupt enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_UNE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_UNE_EN)
N
N/**
N  * @brief  Check GMAC transmit buffer unavailable enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_TUE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_TUE_EN)
N
N/**
N  * @brief  Check GMAC transmit stopped enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_TSE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_TSE_EN)
N
N/**
N  * @brief  Check GMAC transmit interrupt enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval Returning 0 means disabling, and the other values are enabling
N  */
N#define LL_MAC_CHECK_TIE_INTERRUPT_ENABLE(p_gmac)   ((p_gmac)->CSR7 & LL_MAC_CSR7_TIE_EN)
N
N/**
N  * @brief  Normal interrupt summary enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_nie_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_nie_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_NIE_EN;
X    p_gmac->CSR7 |= (1UL << 16);
N}
N
N/**
N  * @brief  Abnormal interrupt summary enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_aie_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_aie_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_AIE_EN;
X    p_gmac->CSR7 |= (1UL << 15);
N}
N
N/**
N  * @brief  Early receive interrupt enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_ere_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_ere_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_ERE_EN;
X    p_gmac->CSR7 |= (1UL << 14);
N}
N
N/**
N  * @brief  General-purpose timer overflow enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_gte_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_gte_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_GTE_EN;
X    p_gmac->CSR7 |= (1UL << 11);
N}
N
N/**
N  * @brief  Early transmit interrupt enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_ete_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_ete_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_ETE_EN;
X    p_gmac->CSR7 |= (1UL << 10);
N}
N
N/**
N  * @brief  Receive stopped enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_rse_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_rse_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_RSE_EN;
X    p_gmac->CSR7 |= (1UL << 8);
N}
N
N/**
N  * @brief  Receive buffer unavailable enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_rue_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_rue_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_RUE_EN;
X    p_gmac->CSR7 |= (1UL << 7);
N}
N
N/**
N  * @brief  Receive interrupt enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_rie_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_rie_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_RIE_EN;
X    p_gmac->CSR7 |= (1UL << 6);
N}
N
N/**
N  * @brief  Underflow interrupt enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_une_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_une_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_UNE_EN;
X    p_gmac->CSR7 |= (1UL << 5);
N}
N
N/**
N  * @brief  Transmit buffer unavailable enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_tue_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_tue_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_TUE_EN;
X    p_gmac->CSR7 |= (1UL << 2);
N}
N
N/**
N  * @brief  Transmit stopped enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_tse_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_tse_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_TSE_EN;
X    p_gmac->CSR7 |= (1UL << 1);
N}
N
N/**
N  * @brief  Transmit interrupt enable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_tie_interrupt_enable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_tie_interrupt_enable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 |= LL_MAC_CSR7_TIE_EN;
X    p_gmac->CSR7 |= (1UL << 0);
N}
N
N/**
N  * @brief  Normal interrupt summary disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_nie_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_nie_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_NIE_EN;
X    p_gmac->CSR7 &= ~(1UL << 16);
N}
N
N/**
N  * @brief  Abnormal interrupt summary disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_aie_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_aie_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_AIE_EN;
X    p_gmac->CSR7 &= ~(1UL << 15);
N}
N
N/**
N  * @brief  Early receive interrupt disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_ere_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_ere_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_ERE_EN;
X    p_gmac->CSR7 &= ~(1UL << 14);
N}
N
N/**
N  * @brief  General-purpose timer overflow disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_gte_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_gte_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_GTE_EN;
X    p_gmac->CSR7 &= ~(1UL << 11);
N}
N
N/**
N  * @brief  Early transmit interrupt disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_ete_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_ete_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_ETE_EN;
X    p_gmac->CSR7 &= ~(1UL << 10);
N}
N
N/**
N  * @brief  Receive stopped disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_rse_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_rse_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_RSE_EN;
X    p_gmac->CSR7 &= ~(1UL << 8);
N}
N
N/**
N  * @brief  Receive buffer unavailable disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_rue_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_rue_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_RUE_EN;
X    p_gmac->CSR7 &= ~(1UL << 7);
N}
N
N/**
N  * @brief  Receive interrupt disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_rie_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_rie_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_RIE_EN;
X    p_gmac->CSR7 &= ~(1UL << 6);
N}
N
N/**
N  * @brief  Underflow interrupt disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_une_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_une_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_UNE_EN;
X    p_gmac->CSR7 &= ~(1UL << 5);
N}
N
N/**
N  * @brief  Transmit buffer unavailable disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_tue_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_tue_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_TUE_EN;
X    p_gmac->CSR7 &= ~(1UL << 2);
N}
N
N/**
N  * @brief  Transmit stopped disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_tse_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_tse_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_TSE_EN;
X    p_gmac->CSR7 &= ~(1UL << 1);
N}
N
N/**
N  * @brief  Transmit interrupt disable
N  * @param  p_gmac: GMAC module pointer
N  * @retval none
N  */
N__STATIC_INLINE void ll_mac_tie_interrupt_disable(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_tie_interrupt_disable(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR7 &= ~LL_MAC_CSR7_TIE_EN;
X    p_gmac->CSR7 &= ~(1UL << 0);
N}
N
N/**
N  * @brief  Check GMAC normal interrupt summary pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC normal interrupt summary pending
N  */
N#define LL_MAC_GET_NIS_PENDING(p_gmac)              ((p_gmac)->CSR5 & LL_MAC_CSR5_NIS_PENDING)
N
N/**
N  * @brief  Check GMAC abnormal interrupt summary pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC abnormal interrupt summary pending
N  */
N#define LL_MAC_GET_AIS_PENDING(p_gmac)              ((p_gmac)->CSR5 & LL_MAC_CSR5_AIS_PENDING)
N
N/**
N  * @brief  Check GMAC early receive interrupt pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC early receive interrupt pending
N  */
N#define LL_MAC_GET_ERI_PENDING(p_gmac)              ((p_gmac)->CSR5 & LL_MAC_CSR5_ERI_PENDING)
N
N/**
N  * @brief  Check GMAC general-purpose timer expiration pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC general-purpose timer expiration pending
N  */
N#define LL_MAC_GET_GTI_PENDING(p_gmac)              ((p_gmac)->CSR5 & LL_MAC_CSR5_GTI_PENDING)
N
N/**
N  * @brief  Check GMAC early transmit interrupt pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC early transmit interrupt pending
N  */
N#define LL_MAC_GET_ETI_PENDING(p_gmac)              ((p_gmac)->CSR5 & LL_MAC_CSR5_ETI_PENDING)
N
N/**
N  * @brief  Check GMAC receive process stopped pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC receive process stopped pending
N  */
N#define LL_MAC_GET_RPS_PENDING(p_gmac)              ((p_gmac)->CSR5 & LL_MAC_CSR5_RPS_PENDING)
N
N/**
N  * @brief  Check GMAC receive buffer unavailable pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC receive buffer unavailable pending
N  */
N#define LL_MAC_GET_RU_PENDING(p_gmac)               ((p_gmac)->CSR5 & LL_MAC_CSR5_RU_PENDING)
N
N/**
N  * @brief  Check GMAC receive interrupt pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC receive interrupt pending
N  */
N#define LL_MAC_GET_RI_PENDING(p_gmac)               ((p_gmac)->CSR5 & LL_MAC_CSR5_RI_PENDING)
N
N/**
N  * @brief  Check GMAC transmit underflow pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC transmit underflow pending
N  */
N#define LL_MAC_GET_UNF_PENDING(p_gmac)              ((p_gmac)->CSR5 & LL_MAC_CSR5_UNF_PENDING)
N
N/**
N  * @brief  Check GMAC transmit buffer unavailable pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC transmit buffer unavailable pending
N  */
N#define LL_MAC_GET_TU_PENDING(p_gmac)               ((p_gmac)->CSR5 & LL_MAC_CSR5_TU_PENDING)
N
N/**
N  * @brief  Check GMAC transmit process stopped pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC transmit process stopped pending
N  */
N#define LL_MAC_GET_TPS_PENDING(p_gmac)              ((p_gmac)->CSR5 & LL_MAC_CSR5_TPS_PENDING)
N
N/**
N  * @brief  Check GMAC transmit interrupt pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval Return to GMAC transmit interrupt pending
N  */
N#define LL_MAC_GET_TI_PENDING(p_gmac)               ((p_gmac)->CSR5 & LL_MAC_CSR5_TI_PENDING)
N
N/**
N  * @brief  clear GMAC normal interrupt summary pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_nis_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_nis_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_NIS_PENDING;
X    p_gmac->CSR5 = (1UL << 16);
N}
N
N/**
N  * @brief  clear GMAC abnormal interrupt summary pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_ais_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_ais_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_AIS_PENDING;
X    p_gmac->CSR5 = (1UL << 15);
N}
N
N/**
N  * @brief  clear GMAC early receive interrupt pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_eri_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_eri_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_ERI_PENDING;
X    p_gmac->CSR5 = (1UL << 14);
N}
N
N/**
N  * @brief  clear GMAC general-purpose timer expiration pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_gti_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_gti_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_GTI_PENDING;
X    p_gmac->CSR5 = (1UL << 11);
N}
N
N/**
N  * @brief  clear GMAC early transmit interrupt pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_eti_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_eti_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_ETI_PENDING;
X    p_gmac->CSR5 = (1UL << 10);
N}
N
N/**
N  * @brief  clear GMAC receive process stopped pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_rps_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_rps_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_RPS_PENDING;
X    p_gmac->CSR5 = (1UL << 8);
N}
N
N/**
N  * @brief  clear GMAC receive buffer unavailable pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_ru_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_ru_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_RU_PENDING;
X    p_gmac->CSR5 = (1UL << 7);
N}
N
N/**
N  * @brief  clear GMAC receive interrupt pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_ri_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_ri_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_RI_PENDING;
X    p_gmac->CSR5 = (1UL << 6);
N}
N
N/**
N  * @brief  clear GMAC transmit underflow pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_unf_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_unf_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_UNF_PENDING;
X    p_gmac->CSR5 = (1UL << 5);
N}
N
N/**
N  * @brief  clear GMAC transmit buffer unavailable pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_tu_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_tu_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_TU_PENDING;
X    p_gmac->CSR5 = (1UL << 2);
N}
N
N/**
N  * @brief  clear GMAC transmit process stopped pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_tps_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_tps_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_TPS_PENDING;
X    p_gmac->CSR5 = (1UL << 1);
N}
N
N/**
N  * @brief  clear GMAC transmit interrupt pending
N  * @param  p_gmac: GMAC module pointer
N  * @retval None
N  */
N__STATIC_INLINE void ll_mac_clear_ti_pending(GMAC_TypeDef *p_gmac) {
Xstatic __inline void ll_mac_clear_ti_pending(GMAC_TypeDef *p_gmac) {
N    p_gmac->CSR5 = LL_MAC_CSR5_TI_PENDING;
X    p_gmac->CSR5 = (1UL << 0);
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif //__TX_PHE_LL_MAC_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 61 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N#include "tx_phe_ll_cc_rst.h"
N     
N//Protocol
N#include "mb.h"
L 1 "..\..\..\..\Libraries\Protocol\Modbus\include\mb.h" 1
N/* 
N * FreeModbus Libary: A portable Modbus implementation for Modbus ASCII/RTU.
N * Copyright (c) 2006 Christian Walter <wolti@sil.at>
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
N * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
N * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
N * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
N * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N * File: $Id: mb.h,v 1.17 2006/12/07 22:10:34 wolti Exp $
N */
N
N#ifndef _MB_H
N#define _MB_H
N
N#include "mbdef.h"
L 1 "..\..\..\..\Libraries\Protocol\Modbus\include\mbdef.h" 1
N/*
N * FreeModbus Libary: BARE Port
N * Copyright (C) 2006 Christian Walter <wolti@sil.at>
N *
N * This library is free software; you can redistribute it and/or
N * modify it under the terms of the GNU Lesser General Public
N * License as published by the Free Software Foundation; either
N * version 2.1 of the License, or (at your option) any later version.
N *
N * This library is distributed in the hope that it will be useful,
N * but WITHOUT ANY WARRANTY; without even the implied warranty of
N * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N * Lesser General Public License for more details.
N *
N * You should have received a copy of the GNU Lesser General Public
N * License along with this library; if not, write to the Free Software
N * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
N *
N * File: $Id: port.h,v 1.1 2006/08/22 21:35:13 wolti Exp $
N */
N
N#ifndef _PORT_H
N#define _PORT_H
N
N#include <assert.h>
L 1 "D:\Tools\KIEIL\ARM\ARMCC\Bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
N#   define __assert_h
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define __ARMCLIB_VERSION 5060037
N#   ifndef __ARM_PROMISE
N#      define __ARM_PROMISE __promise
N#   endif
N#   undef __CLIBNS
N#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N    extern _ARMABI_NORETURN void abort(void);
X    extern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
X    extern __declspec(__nothrow) __declspec(__noreturn) void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
N#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
N#   endif
N#else
S#   undef assert
S#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 0L && !0L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
N#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 26 "..\..\..\..\Libraries\Protocol\Modbus\include\mbdef.h" 2
N#include <inttypes.h>
L 1 "D:\Tools\KIEIL\ARM\ARMCC\Bin\..\include\inttypes.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Based on WG14/N843 (C9X) Committee Draft August 3, 1998 */
N
N#ifndef __inttypes_h
N#define __inttypes_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N#include <stdint.h>
N
N#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) || 201103L <= __cplusplus
X#if !0L || 0L || 201103L <= __cplusplus
N
N#ifdef __LP64__
S  #define __PRISCN64 "l" /* 'int64_t' is 'long' */
N#else
N  #define __PRISCN64 "ll" /* 'int64_t' is 'long long' */
N#endif
N#if __sizeof_ptr == 8
X#if 4 == 8
S  #define __PRISCNPTR __PRISCN64 /* 'intptr_t' is 64-bits */
N#else
N  #define __PRISCNPTR /*nothing*/ /* 'intptr_t' is 'int' */
N#endif
N
N
N    /* 7.8.1 */
N
N#define PRId8         "d"
N#define PRId16        "d"
N#define PRId32        "d"
N#define PRId64      __PRISCN64 "d"
N#define PRIdLEAST8    "d"
N#define PRIdLEAST16   "d"
N#define PRIdLEAST32   "d"
N#define PRIdLEAST64 __PRISCN64 "d"
N#define PRIdFAST8     "d"
N#define PRIdFAST16    "d"
N#define PRIdFAST32    "d"
N#define PRIdFAST64  __PRISCN64 "d"
N#define PRIdMAX      "jd"
N#define PRIdPTR     __PRISCNPTR "d"
N
N#define PRIi8         "i"
N#define PRIi16        "i"
N#define PRIi32        "i"
N#define PRIi64      __PRISCN64 "i"
N#define PRIiLEAST8    "i"
N#define PRIiLEAST16   "i"
N#define PRIiLEAST32   "i"
N#define PRIiLEAST64 __PRISCN64 "i"
N#define PRIiFAST8     "i"
N#define PRIiFAST16    "i"
N#define PRIiFAST32    "i"
N#define PRIiFAST64  __PRISCN64 "i"
N#define PRIiMAX      "ji"
N#define PRIiPTR     __PRISCNPTR "i"
N
N#define PRIo8         "o"
N#define PRIo16        "o"
N#define PRIo32        "o"
N#define PRIo64      __PRISCN64 "o"
N#define PRIoLEAST8    "o"
N#define PRIoLEAST16   "o"
N#define PRIoLEAST32   "o"
N#define PRIoLEAST64 __PRISCN64 "o"
N#define PRIoFAST8     "o"
N#define PRIoFAST16    "o"
N#define PRIoFAST32    "o"
N#define PRIoFAST64  __PRISCN64 "o"
N#define PRIoMAX      "jo"
N#define PRIoPTR     __PRISCNPTR "o"
N
N#define PRIu8         "d"
N#define PRIu16        "d"
N#define PRIu32        "u"
N#define PRIu64      __PRISCN64 "u"
N#define PRIuLEAST8    "d"
N#define PRIuLEAST16   "d"
N#define PRIuLEAST32   "u"
N#define PRIuLEAST64 __PRISCN64 "u"
N#define PRIuFAST8     "u"
N#define PRIuFAST16    "u"
N#define PRIuFAST32    "u"
N#define PRIuFAST64  __PRISCN64 "u"
N#define PRIuMAX      "ju"
N#define PRIuPTR     __PRISCNPTR "u"
N
N#define PRIx8         "x"
N#define PRIx16        "x"
N#define PRIx32        "x"
N#define PRIx64      __PRISCN64 "x"
N#define PRIxLEAST8    "x"
N#define PRIxLEAST16   "x"
N#define PRIxLEAST32   "x"
N#define PRIxLEAST64 __PRISCN64 "x"
N#define PRIxFAST8     "x"
N#define PRIxFAST16    "x"
N#define PRIxFAST32    "x"
N#define PRIxFAST64  __PRISCN64 "x"
N#define PRIxMAX      "jx"
N#define PRIxPTR     __PRISCNPTR "x"
N
N#define PRIX8         "X"
N#define PRIX16        "X"
N#define PRIX32        "X"
N#define PRIX64      __PRISCN64 "X"
N#define PRIXLEAST8    "X"
N#define PRIXLEAST16   "X"
N#define PRIXLEAST32   "X"
N#define PRIXLEAST64 __PRISCN64 "X"
N#define PRIXFAST8     "X"
N#define PRIXFAST16    "X"
N#define PRIXFAST32    "X"
N#define PRIXFAST64  __PRISCN64 "X"
N#define PRIXMAX      "jX"
N#define PRIXPTR     __PRISCNPTR "X"
N
N#define SCNd8       "hhd"
N#define SCNd16       "hd"
N#define SCNd32        "d"
N#define SCNd64      __PRISCN64 "d"
N#define SCNdLEAST8  "hhd"
N#define SCNdLEAST16  "hd"
N#define SCNdLEAST32   "d"
N#define SCNdLEAST64 __PRISCN64 "d"
N#define SCNdFAST8     "d"
N#define SCNdFAST16    "d"
N#define SCNdFAST32    "d"
N#define SCNdFAST64  __PRISCN64 "d"
N#define SCNdMAX      "jd"
N#define SCNdPTR     __PRISCNPTR "d"
N
N#define SCNi8       "hhd"
N#define SCNi16       "hi"
N#define SCNi32        "i"
N#define SCNi64      __PRISCN64 "i"
N#define SCNiLEAST8  "hhi"
N#define SCNiLEAST16  "hi"
N#define SCNiLEAST32   "i"
N#define SCNiLEAST64 __PRISCN64 "i"
N#define SCNiFAST8     "i"
N#define SCNiFAST16    "i"
N#define SCNiFAST32    "i"
N#define SCNiFAST64  __PRISCN64 "i"
N#define SCNiMAX      "ji"
N#define SCNiPTR     __PRISCNPTR "i"
N
N#define SCNo8       "hho"
N#define SCNo16       "ho"
N#define SCNo32        "o"
N#define SCNo64      __PRISCN64 "o"
N#define SCNoLEAST8  "hho"
N#define SCNoLEAST16  "ho"
N#define SCNoLEAST32   "o"
N#define SCNoLEAST64 __PRISCN64 "o"
N#define SCNoFAST8     "o"
N#define SCNoFAST16    "o"
N#define SCNoFAST32    "o"
N#define SCNoFAST64  __PRISCN64 "o"
N#define SCNoMAX      "jo"
N#define SCNoPTR     __PRISCNPTR "o"
N
N#define SCNu8       "hhu"
N#define SCNu16       "hu"
N#define SCNu32        "u"
N#define SCNu64      __PRISCN64 "u"
N#define SCNuLEAST8  "hhu"
N#define SCNuLEAST16  "hu"
N#define SCNuLEAST32   "u"
N#define SCNuLEAST64 __PRISCN64 "u"
N#define SCNuFAST8     "u"
N#define SCNuFAST16    "u"
N#define SCNuFAST32    "u"
N#define SCNuFAST64  __PRISCN64 "u"
N#define SCNuMAX      "ju"
N#define SCNuPTR     __PRISCNPTR "u"
N
N#define SCNx8       "hhx"
N#define SCNx16       "hx"
N#define SCNx32        "x"
N#define SCNx64      __PRISCN64 "x"
N#define SCNxLEAST8  "hhx"
N#define SCNxLEAST16  "hx"
N#define SCNxLEAST32   "x"
N#define SCNxLEAST64 __PRISCN64 "x"
N#define SCNxFAST8     "x"
N#define SCNxFAST16    "x"
N#define SCNxFAST32    "x"
N#define SCNxFAST64  __PRISCN64 "x"
N#define SCNxMAX      "jx"
N#define SCNxPTR     __PRISCNPTR "x"
N
N#endif /* __STDC_FORMAT_MACROS */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* see <stddef.h> */
N    #else
N      typedef unsigned short wchar_t; /* see <stddef.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* see <stddef.h> */
S    #else
S      typedef unsigned short wchar_t; /* see <stddef.h> */
S    #endif
N  #endif
N#endif
N
Ntypedef struct imaxdiv_t { intmax_t quot, rem; } imaxdiv_t;
N   /* type of the value returned by the imaxdiv function. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N_ARMABI intmax_t strtoimax(const char * __restrict /*nptr*/,
X__declspec(__nothrow) intmax_t strtoimax(const char * __restrict  ,
N                   char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    /* as for strtol */
N_ARMABI uintmax_t strtoumax(const char * __restrict /*nptr*/,
X__declspec(__nothrow) uintmax_t strtoumax(const char * __restrict  ,
N                    char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    /* as for strtoul */
N
N_ARMABI intmax_t wcstoimax(const wchar_t * __restrict /*nptr*/,
X__declspec(__nothrow) intmax_t wcstoimax(const wchar_t * __restrict  ,
N                   wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N_ARMABI uintmax_t wcstoumax(const wchar_t * __restrict /*nptr*/,
X__declspec(__nothrow) uintmax_t wcstoumax(const wchar_t * __restrict  ,
N                    wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N
Nextern _ARMABI_PURE intmax_t imaxabs(intmax_t /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) intmax_t imaxabs(intmax_t  );
N   /*
N    * computes the absolute value of an intmax_t j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
Nextern _ARMABI_PURE imaxdiv_t imaxdiv(intmax_t /*numer*/, intmax_t /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) imaxdiv_t imaxdiv(intmax_t  , intmax_t  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type imaxdiv_t, comprising both the quotient and
N    *          the remainder. the structure shall contain the following
N    *          members, in either order.
N    *          intmax_t quot; intmax_t rem;
N    */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __inttypes_h */
N
N/* end of inttypes.h */
N
L 27 "..\..\..\..\Libraries\Protocol\Modbus\include\mbdef.h" 2
N
N#define	INLINE                      inline
N#define PR_BEGIN_EXTERN_C           extern "C" {
N#define	PR_END_EXTERN_C             }
N
N#define ENTER_CRITICAL_SECTION( )   
N#define EXIT_CRITICAL_SECTION( )    
N
Ntypedef unsigned char UCHAR;
Ntypedef char CHAR;
N
Ntypedef uint16_t USHORT;
Ntypedef int16_t SHORT;
N
Ntypedef uint32_t ULONG;
Ntypedef int32_t LONG;
N
N#endif
L 35 "..\..\..\..\Libraries\Protocol\Modbus\include\mb.h" 2
N
N#ifdef __cplusplus
SPR_BEGIN_EXTERN_C
N#endif
N
N#include "mbport.h"
L 1 "..\..\..\..\Libraries\Protocol\Modbus\include\mbport.h" 1
N/* 
N * FreeModbus Libary: A portable Modbus implementation for Modbus ASCII/RTU.
N * Copyright (c) 2006 Christian Walter <wolti@sil.at>
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
N * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
N * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
N * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
N * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N * File: $Id: mbport.h,v 1.19 2010/06/06 13:54:40 wolti Exp $
N */
N
N#ifndef _MB_PORT_H
N#define _MB_PORT_H
N
N#ifdef __cplusplus
SPR_BEGIN_EXTERN_C
N#endif
N
N#include "include.h"
L 1 "..\..\..\..\User\LL\include.h" 1
N/**
N  ******************************************************************************
N  * @file    User/LL/include.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   A generic header file containing various required header files
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __INCLUDE_H__
S#define __INCLUDE_H__
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* Includes ------------------------------------------------------------------*/
S#include "config.h"
S#include "tx_phe.h"
S#include "core_cm3.h"
S#include "cmsis_compiler.h"
S//#include "cmsis_version.h"
S#include "tx_phe_system.h"
S#include "tx_phe_assert.h"
S#include "tx_phe_ll_module.h"
S#include "config.h"
S
S//#include "core_cmFunc.h"
S//#include "core_cmSimd.h"
S// math
S#include <math.h>
S
S// lib
S#include <stdlib.h>
S#include <stdio.h>
S#include <string.h>
S
S/* Private typedef -----------------------------------------------------------*/
S/* Private define ------------------------------------------------------------*/
S/* Private macro -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/* Private function prototypes -----------------------------------------------*/
S/* Private functions ---------------------------------------------------------*/
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif //__INCLUDE_H__
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 39 "..\..\..\..\Libraries\Protocol\Modbus\include\mbport.h" 2
N
N/* ----------------------- Type definitions ---------------------------------*/
N
Ntypedef enum
N{
N    EV_READY,                   /*!< Startup finished. */
N    EV_FRAME_RECEIVED,          /*!< Frame received. */
N    EV_EXECUTE,                 /*!< Execute function. */
N    EV_FRAME_SENT               /*!< Frame sent. */
N} eMBEventType;
N
N/*! \ingroup modbus
N * \brief Parity used for characters in serial mode.
N *
N * The parity which should be applied to the characters sent over the serial
N * link. Please note that this values are actually passed to the porting
N * layer and therefore not all parity modes might be available.
N */
Ntypedef enum
N{
N    MB_PAR_NONE,                /*!< No parity. */
N    MB_PAR_ODD,                 /*!< Odd parity. */
N    RESVERS,
N    MB_PAR_EVEN                 /*!< Even parity. */
N} eMBParity;
N
N/* ----------------------- Callback for the protocol stack ------------------*/
N
N/*!
N * \brief Callback function for the porting layer when a new byte is
N *   available.
N *
N * Depending upon the mode this callback function is used by the RTU or
N * ASCII transmission layers. In any case a call to xMBPortSerialGetByte()
N * must immediately return a new character.
N *
N * \return <code>TRUE</code> if a event was posted to the queue because
N *   a new byte was received. The port implementation should wake up the
N *   tasks which are currently blocked on the eventqueue.
N */
Nextern          BOOL( *pxMBFrameCBByteReceived ) ( void );
N
Nextern          BOOL( *pxMBFrameCBTransmitterEmpty ) ( void );
N
Nextern          BOOL( *pxMBPortCBTimerExpired ) ( void );
N
N/* ----------------------- TCP port functions -------------------------------*/
NBOOL            xMBTCPPortInit( USHORT usTCPPort );
N
Nvoid            vMBTCPPortClose( void );
N
Nvoid            vMBTCPPortDisable( void );
N
NBOOL            xMBTCPPortGetRequest( UCHAR **ppucMBTCPFrame, USHORT * usTCPLength );
N
NBOOL            xMBTCPPortSendResponse( const UCHAR *pucMBTCPFrame, USHORT usTCPLength );
N
N
N/* ----------------------- Supporting functions -----------------------------*/
NBOOL            xMBPortEventInit( void );
N
NBOOL            xMBPortEventPost( eMBEventType eEvent );
N
NBOOL            xMBPortEventGet(  /*@out@ */ eMBEventType * eEvent );
N
N/* ----------------------- Serial port functions ----------------------------*/
N    
N__STATIC_INLINE void weaksMBSerialEnableWarning(BOOL xRxEnable, BOOL xTxEnable) {
Xstatic __inline void weaksMBSerialEnableWarning(BOOL xRxEnable, BOOL xTxEnable) {
N    DBG_NOR("PLS rewrite the vMBPortSerialEnable() function\r\n");
X    printf("PLS rewrite the vMBPortSerialEnable() function\r\n");
N}
N
N__STATIC_INLINE BOOL weaksMBSerialInitWarning( UCHAR ucPort, ULONG ulBaudRate,
Xstatic __inline BOOL weaksMBSerialInitWarning( UCHAR ucPort, ULONG ulBaudRate,
N                                   UCHAR ucDataBits, eMBParity eParity ) {
N    DBG_NOR("PLS rewrite the xMBPortSerialInit() function\r\n");
X    printf("PLS rewrite the xMBPortSerialInit() function\r\n");
N    return false;
N}
N
N__STATIC_INLINE BOOL weaksMBSerialPutByteWarning( CHAR ucByte ) {
Xstatic __inline BOOL weaksMBSerialPutByteWarning( CHAR ucByte ) {
N    DBG_NOR("PLS rewrite the xMBPortSerialPutByte() function\r\n");
X    printf("PLS rewrite the xMBPortSerialPutByte() function\r\n");
N    return false;
N}
N
N__STATIC_INLINE BOOL weaksMBSerialGetByteWarning( CHAR * pucByte ) {
Xstatic __inline BOOL weaksMBSerialGetByteWarning( CHAR * pucByte ) {
N    DBG_NOR("PLS rewrite the xMBPortSerialGetByte() function\r\n");
X    printf("PLS rewrite the xMBPortSerialGetByte() function\r\n");
N    return false;
N}
N
Nvoid vMBPortClose( void );
N
Nvoid xMBPortSerialClose( void );
N
N/* Create an interrupt handler for the transmit buffer empty interrupt
N * (or an equivalent) for your target processor. This function should then
N * call pxMBFrameCBTransmitterEmpty( ) which tells the protocol stack that
N * a new character can be sent. The protocol stack will then call 
N * xMBPortSerialPutByte( ) to send the character.
N */
N__STATIC_INLINE void prvvUARTTxReadyISR( void ){
Xstatic __inline void prvvUARTTxReadyISR( void ){
N    pxMBFrameCBTransmitterEmpty(  );
N}
N
N/* Create an interrupt handler for the receive interrupt for your target
N * processor. This function should then call pxMBFrameCBByteReceived( ). The
N * protocol stack will then call xMBPortSerialGetByte( ) to retrieve the
N * character.
N */
N__STATIC_INLINE void prvvUARTRxISR( void ){
Xstatic __inline void prvvUARTRxISR( void ){
N    pxMBFrameCBByteReceived(  );
N}
N
N/* ----------------------- Timers functions ---------------------------------*/
N
N__STATIC_INLINE BOOL weaksMBPortTimersInitWarning( USHORT usTim1Timerout50us ) {
Xstatic __inline BOOL weaksMBPortTimersInitWarning( USHORT usTim1Timerout50us ) {
N    DBG_NOR("PLS rewrite the xMBPortTimersInit() function\r\n");
X    printf("PLS rewrite the xMBPortTimersInit() function\r\n");
N    return false;
N}
N
N__STATIC_INLINE void weaksMBPortTimersEnableWarning(void) {
Xstatic __inline void weaksMBPortTimersEnableWarning(void) {
N    DBG_NOR("PLS rewrite the vMBPortTimersEnable() function\r\n");
X    printf("PLS rewrite the vMBPortTimersEnable() function\r\n");
N}
N
N__STATIC_INLINE void weaksMBPortTimersDisableWarning(void) {
Xstatic __inline void weaksMBPortTimersDisableWarning(void) {
N    DBG_NOR("PLS rewrite the vMBPortTimersDisable() function\r\n");
X    printf("PLS rewrite the vMBPortTimersDisable() function\r\n");
N}
N
Nvoid            xMBPortTimersClose( void );
N
Nvoid            vMBPortTimersDelay( USHORT usTimeOutMS );
N
N/* Create an ISR which is called whenever the timer has expired. This function
N * must then call pxMBPortCBTimerExpired( ) to notify the protocol stack that
N * the timer has expired.
N */
N__STATIC_INLINE void prvvTIMERExpiredISR( void ){
Xstatic __inline void prvvTIMERExpiredISR( void ){
N    ( void )pxMBPortCBTimerExpired(  ); 
N}
N
N#ifdef __cplusplus
SPR_END_EXTERN_C
N#endif
N#endif
L 41 "..\..\..\..\Libraries\Protocol\Modbus\include\mb.h" 2
N#include "mbproto.h"
L 1 "..\..\..\..\Libraries\Protocol\Modbus\include\mbproto.h" 1
N/* 
N * FreeModbus Libary: A portable Modbus implementation for Modbus ASCII/RTU.
N * Copyright (c) 2006 Christian Walter <wolti@sil.at>
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
N * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
N * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
N * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
N * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N * File: $Id: mbproto.h,v 1.14 2006/12/07 22:10:34 wolti Exp $
N */
N
N#ifndef _MB_PROTO_H
N#define _MB_PROTO_H
N
N#ifdef __cplusplus
SPR_BEGIN_EXTERN_C
N#endif
N/* ----------------------- Defines ------------------------------------------*/
N#define MB_ADDRESS_BROADCAST    ( 0 )   /*! Modbus broadcast address. */
N#define MB_ADDRESS_MIN          ( 1 )   /*! Smallest possible slave address. */
N#define MB_ADDRESS_MAX          ( 247 ) /*! Biggest possible slave address. */
N#define MB_FUNC_NONE                          (  0 )
N#define MB_FUNC_READ_COILS                    (  1 )
N#define MB_FUNC_READ_DISCRETE_INPUTS          (  2 )
N#define MB_FUNC_WRITE_SINGLE_COIL             (  5 )
N#define MB_FUNC_WRITE_MULTIPLE_COILS          ( 15 )
N#define MB_FUNC_READ_HOLDING_REGISTER         (  3 )
N#define MB_FUNC_READ_INPUT_REGISTER           (  4 )
N#define MB_FUNC_WRITE_REGISTER                (  6 )
N#define MB_FUNC_WRITE_MULTIPLE_REGISTERS      ( 16 )
N#define MB_FUNC_READWRITE_MULTIPLE_REGISTERS  ( 23 )
N#define MB_FUNC_DIAG_READ_EXCEPTION           (  7 )
N#define MB_FUNC_DIAG_DIAGNOSTIC               (  8 )
N#define MB_FUNC_DIAG_GET_COM_EVENT_CNT        ( 11 )
N#define MB_FUNC_DIAG_GET_COM_EVENT_LOG        ( 12 )
N#define MB_FUNC_OTHER_REPORT_SLAVEID          ( 17 )
N#define MB_FUNC_ERROR                         ( 128 )
N/* ----------------------- Type definitions ---------------------------------*/
N    typedef enum
N{
N    MB_EX_NONE = 0x00,
N    MB_EX_ILLEGAL_FUNCTION = 0x01,
N    MB_EX_ILLEGAL_DATA_ADDRESS = 0x02,
N    MB_EX_ILLEGAL_DATA_VALUE = 0x03,
N    MB_EX_SLAVE_DEVICE_FAILURE = 0x04,
N    MB_EX_ACKNOWLEDGE = 0x05,
N    MB_EX_SLAVE_BUSY = 0x06,
N    MB_EX_MEMORY_PARITY_ERROR = 0x08,
N    MB_EX_GATEWAY_PATH_FAILED = 0x0A,
N    MB_EX_GATEWAY_TGT_FAILED = 0x0B
N} eMBException;
N
Ntypedef         eMBException( *pxMBFunctionHandler ) ( UCHAR * pucFrame, USHORT * pusLength );
N
Ntypedef struct
N{
N    UCHAR           ucFunctionCode;
N    pxMBFunctionHandler pxHandler;
N} xMBFunctionHandler;
N
N#ifdef __cplusplus
SPR_END_EXTERN_C
N#endif
N#endif
L 42 "..\..\..\..\Libraries\Protocol\Modbus\include\mb.h" 2
N#include "mbfuncuser.h"
L 1 "..\..\..\..\Libraries\Protocol\Modbus\include\mbfuncuser.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Protocol/Modbus/functions/mbfuncuser.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   Main program body header file
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MBFUNCUSER_H__
N#define __MBFUNCUSER_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "typedef.h"
N     
N/** @addtogroup Template_Project
N  * @{
N  */
N
N/** @addtogroup MBFUNCUSER
N  * @{
N  */ 
N
N     
N/** @defgroup MBFUNCUSER_Exported_Constants
N  * @{
N  */
N     
N
N/**
N  * @}
N  */
N
N
N/** @defgroup MBFUNCUSER_Exported_Functions
N  * @{
N  */
N
N/**
N  * @brief  Format conversion of modbus data response, the format is 
N  *         {command code (1 byte) + data length n (1 byte) + data (n byte)}.
N  * @param  p_respond_frame_buf: The buffer address of the Modbus response data.
N  * @param  p_respond_len: The address of the Modbus response data length.
N  * @param  mb_respond_cmd: The command code for the Modbus response.
N  * @param  p_mb_respond_data_buf: Modbus response data.
N  * @param  mb_respond_data_len: The data length of the Modbus response.
N  * @retval None
N  * @note   1.The data format in the received pucFrame is 
N  *           {command code (1 byte) + data length n (1 byte) + data (n byte)} or
N  *           {command code (1 byte) + data (n byte)}.
N  *         2.If function mb_respond_cmd_len_data_conversion() is called, the data format returned 
N  *           in pucFrame is {command code (1 byte) + data length n (1 byte) + data (n byte)}.
N  *         3.At the same time, you need to assign the variable p_respond_len to the length of the returned data.
N  */
N__STATIC_INLINE void mb_respond_cmd_len_data_conversion(UCHAR  *p_respond_frame_buf, 
Xstatic __inline void mb_respond_cmd_len_data_conversion(UCHAR  *p_respond_frame_buf, 
N                                                        USHORT *p_respond_len, 
N                                                        u8      mb_respond_cmd, 
N                                                        u8     *p_mb_respond_data_buf, 
N                                                        u16     mb_respond_data_len) {
N    /* Assign the return data. The format is 
N     * {command code (1 byte) + data length n (1 byte) + data (n byte)}.
N     */
N    *(p_respond_frame_buf+0) = mb_respond_cmd;                                  //command code
N    *(p_respond_frame_buf+1) = 0x03;                                            //data length
N    memcpy(p_respond_frame_buf+2, p_mb_respond_data_buf, mb_respond_data_len);  //data
N    
N    /* Set the total length of the returned data.
N     * length = command code (1 byte) + data length n (1 byte) + data (n byte).
N     */
N    *p_respond_len = mb_respond_data_len + 2;
N}
N
N/**
N  * @brief  Format conversion of modbus data response, the format is {command code (1 byte) + data (n byte)}.
N  * @param  p_respond_frame_buf: The buffer address of the Modbus response data.
N  * @param  p_respond_len: The address of the Modbus response data length.
N  * @param  mb_respond_cmd: The command code for the Modbus response.
N  * @param  p_mb_respond_data_buf: Modbus response data.
N  * @param  mb_respond_data_len: The data length of the Modbus response.
N  * @retval None
N  * @note   1.The data format in the received pucFrame is 
N  *           {command code (1 byte) + data length n (1 byte) + data (n byte)} or
N  *           {command code (1 byte) + data (n byte)}.
N  *         2.If function mb_respond_cmd_len_data_conversion() is called, the data format returned 
N  *           in pucFrame is {command code (1 byte) + data (n byte)}.
N  *         3.At the same time, you need to assign the variable p_respond_len to the length of the returned data.
N  */
N__STATIC_INLINE void mb_respond_cmd_data_conversion(UCHAR  *p_respond_frame_buf, 
Xstatic __inline void mb_respond_cmd_data_conversion(UCHAR  *p_respond_frame_buf, 
N                                                        USHORT *p_respond_len, 
N                                                        u8      mb_respond_cmd, 
N                                                        u8     *p_mb_respond_data_buf, 
N                                                        u16     mb_respond_data_len) {
N    /* Assign the return data. The format is 
N     * {command code (1 byte) + data (n byte)}.
N     */
N    *(p_respond_frame_buf+0) = mb_respond_cmd;                                  //command code
N    memcpy(p_respond_frame_buf+1, p_mb_respond_data_buf, mb_respond_data_len);  //data
N    
N    /* Set the total length of the returned data.
N     * length = command code (1 byte) + data (n byte).
N     */
N    *p_respond_len = mb_respond_data_len + 1;
N}
N
N
N/**
N  * @}
N  */ 
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__MBFUNCUSER_H__
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
N
L 43 "..\..\..\..\Libraries\Protocol\Modbus\include\mb.h" 2
N#include "tx_phe_ll_module.h"
L 1 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 1
N/**
N  ******************************************************************************
N  * @file    Libraries/Driver/include/LL/tx_phe_ll_module.h
N  * @author  HUGE-IC Application Team
N  * @version V1.0.0
N  * @date    01-08-2018
N  * @brief   Header file collection of various modules
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2018 HUGE-IC</center></h2>
N  *
N  *
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TX_PHE_LL_MODULE_H
S#define __TX_PHE_LL_MODULE_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* Includes ------------------------------------------------------------------*/
S#include "tx_phe.h"
S#include "tx_phe_misc.h"
S#include "tx_phe_assert.h"
S#include "tx_phe_system.h"
S#include "tx_phe_debug.h"
S     
S#include "tx_phe_ll_gpio.h"
S#include "tx_phe_ll_usart.h"
S#include "tx_phe_ll_epwm.h"
S#include "tx_phe_ll_saradc.h"
S#include "tx_phe_ll_timer.h"
S#include "tx_phe_ll_dftrans.h"
S#include "tx_phe_ll_fft.h"
S#include "tx_phe_ll_matrix.h"
S#include "tx_phe_ll_sincos.h"
S#include "tx_phe_ll_spwm.h"
S#include "tx_phe_ll_eflash.h"
S#include "tx_phe_ll_wdt.h"
S#include "tx_phe_ll_fir.h"
S#include "tx_phe_ll_rms.h"
S#include "tx_phe_ll_datadma.h"
S#include "tx_phe_ll_dmac.h"
S#include "tx_phe_ll_crc.h"
S#include "tx_phe_ll_hcc.h"
S#include "tx_phe_ll_arctan.h"
S#include "tx_phe_ll_iir.h"
S#include "tx_phe_ll_spi.h"
S#include "tx_phe_ll_fadc.h"
S#include "tx_phe_ll_qei.h"
S#include "tx_phe_ll_svpwm.h"
S#include "tx_phe_ll_iic.h"
S#include "tx_phe_ll_evsys.h"
S#include "tx_phe_ll_can.h"
S#include "tx_phe_ll_mac.h"
S#include "tx_phe_ll_cc_rst.h"
S     
S//Protocol
S#include "mb.h"
S     
S//net
S//#include "net/include/uapi/linux/errno-base.h"
S//#include "net/include/uapi/linux/ethtool.h"
S//#include "net/include/uapi/linux/mii.h"
S//#include "net/include/linux/mii.h"
S//#include "net/include/linux/phy.h"
S
S/* Private typedef -----------------------------------------------------------*/
S/* Private define ------------------------------------------------------------*/
S/* Private macro -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/* Private function prototypes -----------------------------------------------*/
S/* Private functions ---------------------------------------------------------*/
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif //__TX_PHE_LL_MODULE_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 44 "..\..\..\..\Libraries\Protocol\Modbus\include\mb.h" 2
N
N/*! \defgroup modbus Modbus
N * \code #include "mb.h" \endcode
N *
N * This module defines the interface for the application. It contains
N * the basic functions and types required to use the Modbus protocol stack.
N * A typical application will want to call eMBInit() first. If the device
N * is ready to answer network requests it must then call eMBEnable() to activate
N * the protocol stack. In the main loop the function eMBPoll() must be called
N * periodically. The time interval between pooling depends on the configured
N * Modbus timeout. If an RTOS is available a separate task should be created
N * and the task should always call the function eMBPoll().
N *
N * \code
N * // Initialize protocol stack in RTU mode for a slave with address 10 = 0x0A
N * eMBInit( MB_RTU, 0x0A, 38400, MB_PAR_EVEN );
N * // Enable the Modbus Protocol Stack.
N * eMBEnable(  );
N * for( ;; )
N * {
N *     // Call the main polling loop of the Modbus protocol stack.
N *     eMBPoll(  );
N *     ...
N * }
N * \endcode
N */
N
N/* ----------------------- Defines ------------------------------------------*/
N
N/*! \ingroup modbus
N * \brief Use the default Modbus TCP port (502)
N */
N#define MB_TCP_PORT_USE_DEFAULT 0   
N
N/* ----------------------- Type definitions ---------------------------------*/
N
N/*! \ingroup modbus
N * \brief Modbus serial transmission modes (RTU/ASCII).
N *
N * Modbus serial supports two transmission modes. Either ASCII or RTU. RTU
N * is faster but has more hardware requirements and requires a network with
N * a low jitter. ASCII is slower and more reliable on slower links (E.g. modems)
N */
N    typedef enum
N{
N    MB_RTU,                     /*!< RTU transmission mode. */
N    MB_ASCII,                   /*!< ASCII transmission mode. */
N    MB_TCP                      /*!< TCP mode. */
N} eMBMode;
N
N/*! \ingroup modbus
N * \brief If register should be written or read.
N *
N * This value is passed to the callback functions which support either
N * reading or writing register values. Writing means that the application
N * registers should be updated and reading means that the modbus protocol
N * stack needs to know the current register values.
N *
N * \see eMBRegHoldingCB( ), eMBRegCoilsCB( ), eMBRegDiscreteCB( ) and 
N *   eMBRegInputCB( ).
N */
Ntypedef enum
N{
N    MB_REG_READ,                /*!< Read register values and pass to protocol stack. */
N    MB_REG_WRITE                /*!< Update register values. */
N} eMBRegisterMode;
N
N/*! \ingroup modbus
N * \brief Errorcodes used by all function in the protocol stack.
N */
Ntypedef enum
N{
N    MB_ENOERR,                  /*!< no error. */
N    MB_ENOREG,                  /*!< illegal register address. */
N    MB_EINVAL,                  /*!< illegal argument. */
N    MB_EPORTERR,                /*!< porting layer error. */
N    MB_ENORES,                  /*!< insufficient resources. */
N    MB_EIO,                     /*!< I/O error. */
N    MB_EILLSTATE,               /*!< protocol stack in illegal state. */
N    MB_ETIMEDOUT                /*!< timeout error occurred. */
N} eMBErrorCode;
N
N
N/* ----------------------- Function prototypes ------------------------------*/
N/*! \ingroup modbus
N * \brief Initialize the Modbus protocol stack.
N *
N * This functions initializes the ASCII or RTU module and calls the
N * init functions of the porting layer to prepare the hardware. Please
N * note that the receiver is still disabled and no Modbus frames are
N * processed until eMBEnable( ) has been called.
N *
N * \param eMode If ASCII or RTU mode should be used.
N * \param ucSlaveAddress The slave address. Only frames sent to this
N *   address or to the broadcast address are processed.
N * \param ucPort The port to use. E.g. 1 for COM1 on windows. This value
N *   is platform dependent and some ports simply choose to ignore it.
N * \param ulBaudRate The baudrate. E.g. 19200. Supported baudrates depend
N *   on the porting layer.
N * \param eParity Parity used for serial transmission.
N *
N * \return If no error occurs the function returns eMBErrorCode::MB_ENOERR.
N *   The protocol is then in the disabled state and ready for activation
N *   by calling eMBEnable( ). Otherwise one of the following error codes 
N *   is returned:
N *    - eMBErrorCode::MB_EINVAL If the slave address was not valid. Valid
N *        slave addresses are in the range 1 - 247.
N *    - eMBErrorCode::MB_EPORTERR IF the porting layer returned an error.
N */
NeMBErrorCode    eMBInit( eMBMode eMode, UCHAR ucSlaveAddress,
N                         UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity );
N
N/*! \ingroup modbus
N * \brief Initialize the Modbus protocol stack for Modbus TCP.
N *
N * This function initializes the Modbus TCP Module. Please note that
N * frame processing is still disabled until eMBEnable( ) is called.
N *
N * \param usTCPPort The TCP port to listen on.
N * \return If the protocol stack has been initialized correctly the function
N *   returns eMBErrorCode::MB_ENOERR. Otherwise one of the following error
N *   codes is returned:
N *    - eMBErrorCode::MB_EINVAL If the slave address was not valid. Valid
N *        slave addresses are in the range 1 - 247.
N *    - eMBErrorCode::MB_EPORTERR IF the porting layer returned an error.
N */
NeMBErrorCode    eMBTCPInit( USHORT usTCPPort );
N
N/*! \ingroup modbus
N * \brief Release resources used by the protocol stack.
N *
N * This function disables the Modbus protocol stack and release all
N * hardware resources. It must only be called when the protocol stack 
N * is disabled. 
N *
N * \note Note all ports implement this function. A port which wants to 
N *   get an callback must define the macro MB_PORT_HAS_CLOSE to 1.
N *
N * \return If the resources where released it return eMBErrorCode::MB_ENOERR.
N *   If the protocol stack is not in the disabled state it returns
N *   eMBErrorCode::MB_EILLSTATE.
N */
NeMBErrorCode    eMBClose( void );
N
N/*! \ingroup modbus
N * \brief Enable the Modbus protocol stack.
N *
N * This function enables processing of Modbus frames. Enabling the protocol
N * stack is only possible if it is in the disabled state.
N *
N * \return If the protocol stack is now in the state enabled it returns 
N *   eMBErrorCode::MB_ENOERR. If it was not in the disabled state it 
N *   return eMBErrorCode::MB_EILLSTATE.
N */
NeMBErrorCode    eMBEnable( void );
N
N/*! \ingroup modbus
N * \brief Disable the Modbus protocol stack.
N *
N * This function disables processing of Modbus frames.
N *
N * \return If the protocol stack has been disabled it returns 
N *  eMBErrorCode::MB_ENOERR. If it was not in the enabled state it returns
N *  eMBErrorCode::MB_EILLSTATE.
N */
NeMBErrorCode    eMBDisable( void );
N
N/*! \ingroup modbus
N * \brief The main pooling loop of the Modbus protocol stack.
N *
N * This function must be called periodically. The timer interval required
N * is given by the application dependent Modbus slave timeout. Internally the
N * function calls xMBPortEventGet() and waits for an event from the receiver or
N * transmitter state machines. 
N *
N * \return If the protocol stack is not in the enabled state the function
N *   returns eMBErrorCode::MB_EILLSTATE. Otherwise it returns 
N *   eMBErrorCode::MB_ENOERR.
N */
NeMBErrorCode    eMBPoll( void );
N
N/*! \ingroup modbus
N * \brief Configure the slave id of the device.
N *
N * This function should be called when the Modbus function <em>Report Slave ID</em>
N * is enabled ( By defining MB_FUNC_OTHER_REP_SLAVEID_ENABLED in mbconfig.h ).
N *
N * \param ucSlaveID Values is returned in the <em>Slave ID</em> byte of the
N *   <em>Report Slave ID</em> response.
N * \param xIsRunning If TRUE the <em>Run Indicator Status</em> byte is set to 0xFF.
N *   otherwise the <em>Run Indicator Status</em> is 0x00.
N * \param pucAdditional Values which should be returned in the <em>Additional</em>
N *   bytes of the <em> Report Slave ID</em> response.
N * \param usAdditionalLen Length of the buffer <code>pucAdditonal</code>.
N *
N * \return If the static buffer defined by MB_FUNC_OTHER_REP_SLAVEID_BUF in
N *   mbconfig.h is to small it returns eMBErrorCode::MB_ENORES. Otherwise
N *   it returns eMBErrorCode::MB_ENOERR.
N */
NeMBErrorCode    eMBSetSlaveID( UCHAR ucSlaveID, BOOL xIsRunning,
N                               UCHAR const *pucAdditional,
N                               USHORT usAdditionalLen );
N
N/*! \ingroup modbus
N * \brief Registers a callback handler for a given function code.
N *
N * This function registers a new callback handler for a given function code.
N * The callback handler supplied is responsible for interpreting the Modbus PDU and
N * the creation of an appropriate response. In case of an error it should return
N * one of the possible Modbus exceptions which results in a Modbus exception frame
N * sent by the protocol stack. 
N *
N * \param ucFunctionCode The Modbus function code for which this handler should
N *   be registers. Valid function codes are in the range 1 to 127.
N * \param pxHandler The function handler which should be called in case
N *   such a frame is received. If \c NULL a previously registered function handler
N *   for this function code is removed.
N *
N * \return eMBErrorCode::MB_ENOERR if the handler has been installed. If no
N *   more resources are available it returns eMBErrorCode::MB_ENORES. In this
N *   case the values in mbconfig.h should be adjusted. If the argument was not
N *   valid it returns eMBErrorCode::MB_EINVAL.
N */
NeMBErrorCode    eMBRegisterCB( UCHAR ucFunctionCode, 
N                               pxMBFunctionHandler pxHandler );
N
N/* ----------------------- Callback -----------------------------------------*/
N
N/*! \defgroup modbus_registers Modbus Registers
N * \code #include "mb.h" \endcode
N * The protocol stack does not internally allocate any memory for the
N * registers. This makes the protocol stack very small and also usable on
N * low end targets. In addition the values don't have to be in the memory
N * and could for example be stored in a flash.<br>
N * Whenever the protocol stack requires a value it calls one of the callback
N * function with the register address and the number of registers to read
N * as an argument. The application should then read the actual register values
N * (for example the ADC voltage) and should store the result in the supplied
N * buffer.<br>
N * If the protocol stack wants to update a register value because a write
N * register function was received a buffer with the new register values is
N * passed to the callback function. The function should then use these values
N * to update the application register values.
N */
N
N/*! \ingroup modbus_registers
N * \brief Callback function used if the value of a <em>Input Register</em>
N *   is required by the protocol stack. The starting register address is given
N *   by \c usAddress and the last register is given by <tt>usAddress +
N *   usNRegs - 1</tt>.
N *
N * \param pucRegBuffer A buffer where the callback function should write
N *   the current value of the modbus registers to.
N * \param usAddress The starting address of the register. Input registers
N *   are in the range 1 - 65535.
N * \param usNRegs Number of registers the callback function must supply.
N *
N * \return The function must return one of the following error codes:
N *   - eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal
N *       Modbus response is sent.
N *   - eMBErrorCode::MB_ENOREG If the application can not supply values
N *       for registers within this range. In this case a 
N *       <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.
N *   - eMBErrorCode::MB_ETIMEDOUT If the requested register block is
N *       currently not available and the application dependent response
N *       timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b>
N *       exception is sent as a response.
N *   - eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case
N *       a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response.
N */
N//eMBErrorCode    eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress,
N//                               USHORT usNRegs );
N
N/*! \ingroup modbus_registers
N * \brief Callback function used if a <em>Holding Register</em> value is
N *   read or written by the protocol stack. The starting register address
N *   is given by \c usAddress and the last register is given by
N *   <tt>usAddress + usNRegs - 1</tt>.
N *
N * \param pucRegBuffer If the application registers values should be updated the
N *   buffer points to the new registers values. If the protocol stack needs
N *   to now the current values the callback function should write them into
N *   this buffer.
N * \param usAddress The starting address of the register.
N * \param usNRegs Number of registers to read or write.
N * \param eMode If eMBRegisterMode::MB_REG_WRITE the application register 
N *   values should be updated from the values in the buffer. For example
N *   this would be the case when the Modbus master has issued an 
N *   <b>WRITE SINGLE REGISTER</b> command.
N *   If the value eMBRegisterMode::MB_REG_READ the application should copy 
N *   the current values into the buffer \c pucRegBuffer.
N *
N * \return The function must return one of the following error codes:
N *   - eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal
N *       Modbus response is sent.
N *   - eMBErrorCode::MB_ENOREG If the application can not supply values
N *       for registers within this range. In this case a 
N *       <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.
N *   - eMBErrorCode::MB_ETIMEDOUT If the requested register block is
N *       currently not available and the application dependent response
N *       timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b>
N *       exception is sent as a response.
N *   - eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case
N *       a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response.
N */
N//eMBErrorCode    eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress,
N//                                 USHORT usNRegs, eMBRegisterMode eMode );
N
N/*! \ingroup modbus_registers
N * \brief Callback function used if a <em>Coil Register</em> value is
N *   read or written by the protocol stack. If you are going to use
N *   this function you might use the functions xMBUtilSetBits(  ) and
N *   xMBUtilGetBits(  ) for working with bitfields.
N *
N * \param pucRegBuffer The bits are packed in bytes where the first coil
N *   starting at address \c usAddress is stored in the LSB of the
N *   first byte in the buffer <code>pucRegBuffer</code>.
N *   If the buffer should be written by the callback function unused
N *   coil values (I.e. if not a multiple of eight coils is used) should be set
N *   to zero.
N * \param usAddress The first coil number.
N * \param usNCoils Number of coil values requested.
N * \param eMode If eMBRegisterMode::MB_REG_WRITE the application values should
N *   be updated from the values supplied in the buffer \c pucRegBuffer.
N *   If eMBRegisterMode::MB_REG_READ the application should store the current
N *   values in the buffer \c pucRegBuffer.
N *
N * \return The function must return one of the following error codes:
N *   - eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal
N *       Modbus response is sent.
N *   - eMBErrorCode::MB_ENOREG If the application does not map an coils
N *       within the requested address range. In this case a 
N *       <b>ILLEGAL DATA ADDRESS</b> is sent as a response.
N *   - eMBErrorCode::MB_ETIMEDOUT If the requested register block is
N *       currently not available and the application dependent response
N *       timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b>
N *       exception is sent as a response.
N *   - eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case
N *       a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response.
N */
N//eMBErrorCode    eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress,
N//                               USHORT usNCoils, eMBRegisterMode eMode );
N
N/*! \ingroup modbus_registers
N * \brief Callback function used if a <em>Input Discrete Register</em> value is
N *   read by the protocol stack.
N *
N * If you are going to use his function you might use the functions
N * xMBUtilSetBits(  ) and xMBUtilGetBits(  ) for working with bitfields.
N *
N * \param pucRegBuffer The buffer should be updated with the current
N *   coil values. The first discrete input starting at \c usAddress must be
N *   stored at the LSB of the first byte in the buffer. If the requested number
N *   is not a multiple of eight the remaining bits should be set to zero.
N * \param usAddress The starting address of the first discrete input.
N * \param usNDiscrete Number of discrete input values.
N * \return The function must return one of the following error codes:
N *   - eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal
N *       Modbus response is sent.
N *   - eMBErrorCode::MB_ENOREG If no such discrete inputs exists.
N *       In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent 
N *       as a response.
N *   - eMBErrorCode::MB_ETIMEDOUT If the requested register block is
N *       currently not available and the application dependent response
N *       timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b>
N *       exception is sent as a response.
N *   - eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case
N *       a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response.
N */
N//eMBErrorCode    eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress,
N//                                  USHORT usNDiscrete );
N
N#ifdef __cplusplus
SPR_END_EXTERN_C
N#endif
N#endif
L 65 "..\..\..\..\Libraries\Driver\include\LL\tx_phe_ll_module.h" 2
N     
N//net
N//#include "net/include/uapi/linux/errno-base.h"
N//#include "net/include/uapi/linux/ethtool.h"
N//#include "net/include/uapi/linux/mii.h"
N//#include "net/include/linux/mii.h"
N//#include "net/include/linux/phy.h"
N
N/* Private typedef -----------------------------------------------------------*/
N/* Private define ------------------------------------------------------------*/
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private function prototypes -----------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TX_PHE_LL_MODULE_H
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 35 "..\..\..\..\User\LL\include.h" 2
N#include "config.h"
N
N//#include "core_cmFunc.h"
N//#include "core_cmSimd.h"
N// math
N#include <math.h>
N
N// lib
N#include <stdlib.h>
L 1 "D:\Tools\KIEIL\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 44 "..\..\..\..\User\LL\include.h" 2
N#include <stdio.h>
N#include <string.h>
N
N/* Private typedef -----------------------------------------------------------*/
N/* Private define ------------------------------------------------------------*/
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private function prototypes -----------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__INCLUDE_H__
N
N/*************************** (C) COPYRIGHT 2018 HUGE-IC ***** END OF FILE *****/
L 2 "..\..\..\..\User\Hardware\hw_lcd.c" 2
N#include "hw_lcd.h"
L 1 "..\..\..\..\User\Hardware\hw_lcd.h" 1
N#ifndef __HW_LCD_H__
N#define __HW_LCD_H__
N
N#include "include.h"
N
N#define LCD_SPI_CLK         40000000U
N
N#define LCD_SPI_PORT        GPIOA
N#define LCD_SPI_PIN_CS      BIT(0)
N#define LCD_SPI_PIN_CLK     BIT(1)
N#define LCD_SPI_PIN_MOSI    BIT(2)
N#define LCD_SPI_PIN_MISO    BIT(3)
N
N#define LCD_CTL_PORT        GPIOA
N#define LCD_CTL_PIN_DC_RS   BIT(4)  // /
N#define LCD_CTL_PIN_RST     BIT(5)  // 
N#define LCD_CTL_SPI_PIN_CS  BIT(6)
N
N#define LCD_CTL_RST_H       ll_gpio_bit_set(LCD_CTL_PORT, LCD_CTL_PIN_RST)
N#define LCD_CTL_RST_L       ll_gpio_bit_reset(LCD_CTL_PORT, LCD_CTL_PIN_RST)
N
N#define LCD_CTL_DC_RS_H     ll_gpio_bit_set(LCD_CTL_PORT, LCD_CTL_PIN_DC_RS)
N#define LCD_CTL_DC_RS_L     ll_gpio_bit_reset(LCD_CTL_PORT, LCD_CTL_PIN_DC_RS)
N
N#define LCD_CTL_SPI_CS_H    ll_gpio_bit_set(LCD_CTL_PORT, LCD_CTL_SPI_PIN_CS)
N#define LCD_CTL_SPI_CS_L    ll_gpio_bit_reset(LCD_CTL_PORT, LCD_CTL_SPI_PIN_CS)
N
Nvoid HW_LCD_Init(void);
Nvoid HW_LCD_Reset(void);
Nvoid HW_LCD_SendReg(uint8_t RegVal);
Nvoid HW_LCD_SendData(uint8_t DatVal);
Nvoid HW_LCD_SendData16Bit(uint16_t DatVal);
Nvoid HW_LCD_WrReg(uint8_t Reg, uint8_t Value);
N
N#endif
L 3 "..\..\..\..\User\Hardware\hw_lcd.c" 2
N
Nstatic void LCD_IO_Init(void);
Nstatic void LCD_SPI_Init(void);
Nstatic void LCD_SPI_Write(uint8_t *Buf, uint32_t Num);
N//static void LCD_SPI_Read(uint8_t *Buf, uint32_t Num);
N
Nvoid HW_LCD_Init(void)
N{
N    // GPIO 
N    LCD_IO_Init();
N    // SPI 
N    LCD_SPI_Init();
N}
N
Nvoid HW_LCD_Reset(void)
N{
N    LCD_CTL_RST_L;
X    ll_gpio_bit_reset(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(5)));
N    delay_ms(100);
N    LCD_CTL_RST_H;
X    ll_gpio_bit_set(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(5)));
N    delay_ms(50);
N}
N
Nvoid HW_LCD_SendReg(uint8_t RegVal)
N{
N    LCD_CTL_SPI_CS_L;
X    ll_gpio_bit_reset(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(6)));
N    LCD_CTL_DC_RS_L;
X    ll_gpio_bit_reset(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(4)));
N    LCD_SPI_Write(&RegVal, 1);
N    LCD_CTL_SPI_CS_H;
X    ll_gpio_bit_set(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(6)));
N}
N
Nvoid HW_LCD_SendData(uint8_t DatVal)
N{
N    LCD_CTL_SPI_CS_L;
X    ll_gpio_bit_reset(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(6)));
N    LCD_CTL_DC_RS_H;
X    ll_gpio_bit_set(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(4)));
N    LCD_SPI_Write(&DatVal, 1);
N    LCD_CTL_SPI_CS_H;
X    ll_gpio_bit_set(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(6)));
N}
N
Nvoid HW_LCD_SendData16Bit(uint16_t DatVal)
N{
N    uint8_t data = 0;
N    LCD_CTL_SPI_CS_L;
X    ll_gpio_bit_reset(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(6)));
N    LCD_CTL_DC_RS_H;
X    ll_gpio_bit_set(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(4)));
N    data = DatVal >> 8;
N    LCD_SPI_Write(&data, 1);
N    data = DatVal & 0xFF;
N    LCD_SPI_Write(&data, 1);
N    LCD_CTL_SPI_CS_H;
X    ll_gpio_bit_set(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(6)));
N}
N
Nvoid HW_LCD_WrReg(uint8_t Reg, uint8_t Value)
N{
N    HW_LCD_SendReg(Reg);
N    HW_LCD_SendData(Value);
N}
N
Nstatic void LCD_IO_Init(void)
N{
N    ll_gpio_dir(LCD_CTL_PORT, LCD_CTL_PIN_DC_RS, LL_GPIO_PIN_OUTPUT);
X    ll_gpio_dir(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(4)), LL_GPIO_PIN_OUTPUT);
N    ll_gpio_dir(LCD_CTL_PORT, LCD_CTL_PIN_RST, LL_GPIO_PIN_OUTPUT);
X    ll_gpio_dir(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(5)), LL_GPIO_PIN_OUTPUT);
N    LCD_CTL_SPI_CS_H;
X    ll_gpio_bit_set(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(6)));
N    ll_gpio_dir(LCD_CTL_PORT, LCD_CTL_SPI_PIN_CS, LL_GPIO_PIN_OUTPUT);
X    ll_gpio_dir(((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x20000) + 0x2000)), ((uint32_t)1<<(6)), LL_GPIO_PIN_OUTPUT);
N}
N
Nstatic void LCD_SPI_Init(void)
N{
N    TYPE_LL_SPI_INIT init;
N    
N    init.clk_div_cnt   = SYS_CLK/LCD_SPI_CLK/2-1;
X    init.clk_div_cnt   = SYS_CLK/40000000U/2-1;
N    init.frame_size    = LL_SPI_8_BIT;
N    init.slave_mode_en = false;
N    init.spi_mode      = LL_SPI_MODE_0;
N    init.wire_mode     = LL_SPI_NORMAL_MODE;
N    init.io_map        = LL_SPI0_IOMAP1;
N    ll_spi_init(SPI0, &init);
X    ll_spi_init(((SPI_TypeDef *) (((uint32_t)0x40000000) + 0x6000)), &init);
N}
N
Nstatic void LCD_SPI_Write(uint8_t *Buf, uint32_t Num)
N{
N    /* Start the tx function of the spi module */
N    ll_spi_start_tx(SPI0, Num);
X    ll_spi_start_tx(((SPI_TypeDef *) (((uint32_t)0x40000000) + 0x6000)), Num);
N    
N    for(uint32_t i = 0; i < Num; i++) {
N        while(LL_SPI_GET_TX_FIFO_FULL_PENDING(SPI0));
X        while(((((SPI_TypeDef *) (((uint32_t)0x40000000) + 0x6000)))->STA & (1UL << 7)));
N        LL_SPI_WRITE_DATA(SPI0, Buf[i]);
X        ((((SPI_TypeDef *) (((uint32_t)0x40000000) + 0x6000)))->WDATA = (Buf[i]));
N    }
N    /* Waiting for transmission to complete */
N    while(LL_SPI_GET_BUSY_PENDING(SPI0));
X    while(((((SPI_TypeDef *) (((uint32_t)0x40000000) + 0x6000)))->STA & (1UL << 0)));
N    /* Disable the SPI tx function */
N    ll_spi_disable(SPI0);
X    ll_spi_disable(((SPI_TypeDef *) (((uint32_t)0x40000000) + 0x6000)));
N}
N
N//static void LCD_SPI_Read(uint8_t *Buf, uint32_t Num)
N//{
N//    /* Start the rx function of the spi module */
N//    ll_spi_start_rx(SPI0, Num);
N//    
N//    for(uint32_t i = 0; i < Num; i++) {
N//        while(LL_SPI_GET_RX_FIFO_EMPTY_PENDING(SPI0));
N//        Buf[i] = LL_SPI_READ_DATA(SPI0);
N//    }
N//    /* Waiting for transmission to complete */
N//    while(LL_SPI_GET_BUSY_PENDING(SPI0));
N//    /* Disable the SPI rx function */
N//    ll_spi_disable(SPI0);
N//}
