; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\eflash2sram\objects\mbrtu.o --asm_dir=.\Eflash2Sram\Listings\ --list_dir=.\Eflash2Sram\Listings\ --depend=.\eflash2sram\objects\mbrtu.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\..\Libraries\CMSIS\DSP\Include -I..\..\..\..\Libraries\CMSIS\Core\Include -I..\..\..\..\Libraries\Device\Phoenix\include -I..\..\..\..\Libraries\Protocol\Modbus\include -I..\..\..\..\Libraries\Protocol\Modbus\port -I..\..\..\..\Libraries\Protocol\ -I..\..\..\..\User\LL -I..\..\..\..\Libraries\Driver\include -I..\..\..\..\Libraries\Driver\include\LL -I..\..\..\..\User\Hardware -I..\..\..\..\User\ThirdDrivers -I.\RTE\_Eflash2Sram -ID:\Tools\KIEIL\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Tools\KIEIL\ARM\CMSIS\5.5.1\Device\ARM\ARMCM3\Include -D__MICROLIB -D__UVISION_VERSION=528 -D_RTE_ -DARMCM3 -DEFLASH2SRAM --omf_browse=.\eflash2sram\objects\mbrtu.crf ..\..\..\..\Libraries\Protocol\Modbus\Trans_mode\mbrtu.c]
                          THUMB

                          AREA ||i.eMBRTUInit||, CODE, READONLY, ALIGN=2

                  eMBRTUInit PROC
;;;95     eMBErrorCode
;;;96     eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;97     {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;98         eMBErrorCode    eStatus = MB_ENOERR;
00000c  f04f0800          MOV      r8,#0
;;;99         ULONG           usTimerT35_50us;
;;;100    
;;;101        ( void )ucSlaveAddress;
;;;102        ENTER_CRITICAL_SECTION(  );
;;;103    
;;;104        /* Modbus RTU uses 8 Databits. */
;;;105        if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
000010  463b              MOV      r3,r7
000012  2208              MOVS     r2,#8
000014  4621              MOV      r1,r4
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       xMBPortSerialInit
00001c  2801              CMP      r0,#1
00001e  d002              BEQ      |L1.38|
;;;106        {
;;;107            eStatus = MB_EPORTERR;
000020  f04f0803          MOV      r8,#3
000024  e00f              B        |L1.70|
                  |L1.38|
;;;108        }
;;;109        else
;;;110        {
;;;111            /* If baudrate > 19200 then we should use the fixed timer values
;;;112             * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
;;;113             */
;;;114            if( ulBaudRate > 19200 )
000026  f5b44f96          CMP      r4,#0x4b00
00002a  d901              BLS      |L1.48|
;;;115            {
;;;116                usTimerT35_50us = 35;       /* 1800us. */
00002c  2523              MOVS     r5,#0x23
00002e  e003              B        |L1.56|
                  |L1.48|
;;;117            }
;;;118            else
;;;119            {
;;;120                /* The timer reload value for a character is given by:
;;;121                 *
;;;122                 * ChTimeValue = Ticks_per_1s / ( Baudrate / 11 )
;;;123                 *             = 11 * Ticks_per_1s / Baudrate
;;;124                 *             = 220000 / Baudrate
;;;125                 * The reload for t3.5 is 1.5 times this value and similary
;;;126                 * for t3.5.
;;;127                 */
;;;128                usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
000030  0060              LSLS     r0,r4,#1
000032  4906              LDR      r1,|L1.76|
000034  fbb1f5f0          UDIV     r5,r1,r0
                  |L1.56|
;;;129            }
;;;130            if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
000038  b2a8              UXTH     r0,r5
00003a  f7fffffe          BL       xMBPortTimersInit
00003e  2801              CMP      r0,#1
000040  d001              BEQ      |L1.70|
;;;131            {
;;;132                eStatus = MB_EPORTERR;
000042  f04f0803          MOV      r8,#3
                  |L1.70|
;;;133            }
;;;134        }
;;;135        EXIT_CRITICAL_SECTION(  );
;;;136    
;;;137        return eStatus;
000046  4640              MOV      r0,r8
;;;138    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;139    
                          ENDP

                  |L1.76|
                          DCD      0x00177fa0

                          AREA ||i.eMBRTUReceive||, CODE, READONLY, ALIGN=2

                  eMBRTUReceive PROC
;;;165    eMBErrorCode
;;;166    eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;167    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;168    //    BOOL            xFrameReceived = FALSE;
;;;169        eMBErrorCode    eStatus = MB_ENOERR;
00000a  2700              MOVS     r7,#0
;;;170    
;;;171        ENTER_CRITICAL_SECTION(  );
;;;172        TX_ASSERT( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );
00000c  4810              LDR      r0,|L2.80|
00000e  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
000010  28ff              CMP      r0,#0xff
000012  dc00              BGT      |L2.22|
000014  e003              B        |L2.30|
                  |L2.22|
000016  21ac              MOVS     r1,#0xac
000018  a00e              ADR      r0,|L2.84|
00001a  f7fffffe          BL       tx_assert_false
                  |L2.30|
;;;173    
;;;174        /* Length and CRC check */
;;;175        if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
00001e  480c              LDR      r0,|L2.80|
000020  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
000022  2804              CMP      r0,#4
000024  db10              BLT      |L2.72|
;;;176            && ( usMBCRC16( ( UCHAR * ) ucRTUBuf, usRcvBufferPos ) == 0 ) )
000026  480a              LDR      r0,|L2.80|
000028  8801              LDRH     r1,[r0,#0]  ; usRcvBufferPos
00002a  4819              LDR      r0,|L2.144|
00002c  f7fffffe          BL       usMBCRC16
000030  b950              CBNZ     r0,|L2.72|
;;;177        {
;;;178            /* Save the address field. All frames are passed to the upper layed
;;;179             * and the decision if a frame is used is done there.
;;;180             */
;;;181            *pucRcvAddress = ucRTUBuf[MB_SER_PDU_ADDR_OFF];
000032  4817              LDR      r0,|L2.144|
000034  7800              LDRB     r0,[r0,#0]  ; ucRTUBuf
000036  7020              STRB     r0,[r4,#0]
;;;182    
;;;183            /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
;;;184             * size of address field and CRC checksum.
;;;185             */
;;;186            *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
000038  4805              LDR      r0,|L2.80|
00003a  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
00003c  1ec0              SUBS     r0,r0,#3
00003e  8030              STRH     r0,[r6,#0]
;;;187    
;;;188            /* Return the start of the Modbus PDU to the caller. */
;;;189            *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
000040  4813              LDR      r0,|L2.144|
000042  1c40              ADDS     r0,r0,#1
000044  6028              STR      r0,[r5,#0]
000046  e000              B        |L2.74|
                  |L2.72|
;;;190    //        xFrameReceived = TRUE;
;;;191        }
;;;192        else
;;;193        {
;;;194            eStatus = MB_EIO;
000048  2705              MOVS     r7,#5
                  |L2.74|
;;;195        }
;;;196    
;;;197        EXIT_CRITICAL_SECTION(  );
;;;198        return eStatus;
00004a  4638              MOV      r0,r7
;;;199    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;200    
                          ENDP

                  |L2.80|
                          DCD      usRcvBufferPos
                  |L2.84|
000054  2e2e5c2e          DCB      "..\\..\\..\\..\\Libraries\\Protocol\\Modbus\\Trans_mode"
000058  2e5c2e2e
00005c  5c2e2e5c
000060  4c696272
000064  61726965
000068  735c5072
00006c  6f746f63
000070  6f6c5c4d
000074  6f646275
000078  735c5472
00007c  616e735f
000080  6d6f6465
000084  5c6d6272          DCB      "\\mbrtu.c",0
000088  74752e63
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L2.144|
                          DCD      ucRTUBuf

                          AREA ||i.eMBRTUSend||, CODE, READONLY, ALIGN=2

                  eMBRTUSend PROC
;;;201    eMBErrorCode
;;;202    eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;203    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;204        eMBErrorCode    eStatus = MB_ENOERR;
00000a  f04f0800          MOV      r8,#0
;;;205        USHORT          usCRC16;
;;;206    
;;;207        ENTER_CRITICAL_SECTION(  );
;;;208    
;;;209        /* Check if the receiver is still in idle state. If not we where to
;;;210         * slow with processing the received frame and the master sent another
;;;211         * frame on the network. We have to abort sending the frame.
;;;212         */
;;;213        if( eRcvState == STATE_RX_IDLE )
00000e  4819              LDR      r0,|L3.116|
000010  7800              LDRB     r0,[r0,#0]  ; eRcvState
000012  2801              CMP      r0,#1
000014  d129              BNE      |L3.106|
;;;214        {
;;;215            /* First byte before the Modbus-PDU is the slave address. */
;;;216            pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
000016  1e70              SUBS     r0,r6,#1
000018  4917              LDR      r1,|L3.120|
00001a  6008              STR      r0,[r1,#0]  ; pucSndBufferCur
;;;217            usSndBufferCount = 1;
00001c  2001              MOVS     r0,#1
00001e  4917              LDR      r1,|L3.124|
000020  8008              STRH     r0,[r1,#0]
;;;218    
;;;219            /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
;;;220            pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
000022  4815              LDR      r0,|L3.120|
000024  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
000026  7005              STRB     r5,[r0,#0]
;;;221            usSndBufferCount += usLength;
000028  4608              MOV      r0,r1
00002a  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
00002c  4438              ADD      r0,r0,r7
00002e  8008              STRH     r0,[r1,#0]
;;;222    
;;;223            /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
;;;224            usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
000030  4608              MOV      r0,r1
000032  8801              LDRH     r1,[r0,#0]  ; usSndBufferCount
000034  4810              LDR      r0,|L3.120|
000036  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
000038  f7fffffe          BL       usMBCRC16
00003c  4604              MOV      r4,r0
;;;225            ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
00003e  490f              LDR      r1,|L3.124|
000040  8808              LDRH     r0,[r1,#0]  ; usSndBufferCount
000042  1c41              ADDS     r1,r0,#1
000044  4b0d              LDR      r3,|L3.124|
000046  8019              STRH     r1,[r3,#0]
000048  490d              LDR      r1,|L3.128|
00004a  540c              STRB     r4,[r1,r0]
;;;226            ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
00004c  1222              ASRS     r2,r4,#8
00004e  4619              MOV      r1,r3
000050  8808              LDRH     r0,[r1,#0]  ; usSndBufferCount
000052  1c41              ADDS     r1,r0,#1
000054  8019              STRH     r1,[r3,#0]
000056  490a              LDR      r1,|L3.128|
000058  540a              STRB     r2,[r1,r0]
;;;227    
;;;228            /* Activate the transmitter. */
;;;229            eSndState = STATE_TX_XMIT;
00005a  2001              MOVS     r0,#1
00005c  4909              LDR      r1,|L3.132|
00005e  7008              STRB     r0,[r1,#0]
;;;230            vMBPortSerialEnable( FALSE, TRUE );
000060  2101              MOVS     r1,#1
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       vMBPortSerialEnable
000068  e001              B        |L3.110|
                  |L3.106|
;;;231        }
;;;232        else
;;;233        {
;;;234            eStatus = MB_EIO;
00006a  f04f0805          MOV      r8,#5
                  |L3.110|
;;;235        }
;;;236        EXIT_CRITICAL_SECTION(  );
;;;237        return eStatus;
00006e  4640              MOV      r0,r8
;;;238    }
000070  e8bd81f0          POP      {r4-r8,pc}
;;;239    
                          ENDP

                  |L3.116|
                          DCD      eRcvState
                  |L3.120|
                          DCD      pucSndBufferCur
                  |L3.124|
                          DCD      usSndBufferCount
                  |L3.128|
                          DCD      ucRTUBuf
                  |L3.132|
                          DCD      eSndState

                          AREA ||i.eMBRTUStart||, CODE, READONLY, ALIGN=2

                  eMBRTUStart PROC
;;;140    void
;;;141    eMBRTUStart( void )
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143        ENTER_CRITICAL_SECTION(  );
;;;144        /* Initially the receiver is in the state STATE_RX_INIT. we start
;;;145         * the timer and if no character is received within t3.5 we change
;;;146         * to STATE_RX_IDLE. This makes sure that we delay startup of the
;;;147         * modbus protocol stack until the bus is free.
;;;148         */
;;;149        eRcvState = STATE_RX_INIT;
000002  2000              MOVS     r0,#0
000004  4904              LDR      r1,|L4.24|
000006  7008              STRB     r0,[r1,#0]
;;;150        vMBPortSerialEnable( TRUE, FALSE );
000008  2100              MOVS     r1,#0
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       vMBPortSerialEnable
;;;151        vMBPortTimersEnable(  );
000010  f7fffffe          BL       vMBPortTimersEnable
;;;152    
;;;153        EXIT_CRITICAL_SECTION(  );
;;;154    }
000014  bd10              POP      {r4,pc}
;;;155    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      eRcvState

                          AREA ||i.eMBRTUStop||, CODE, READONLY, ALIGN=1

                  eMBRTUStop PROC
;;;156    void
;;;157    eMBRTUStop( void )
000000  b510              PUSH     {r4,lr}
;;;158    {
;;;159        ENTER_CRITICAL_SECTION(  );
;;;160        vMBPortSerialEnable( FALSE, FALSE );
000002  2100              MOVS     r1,#0
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       vMBPortSerialEnable
;;;161        vMBPortTimersDisable(  );
00000a  f7fffffe          BL       vMBPortTimersDisable
;;;162        EXIT_CRITICAL_SECTION(  );
;;;163    }
00000e  bd10              POP      {r4,pc}
;;;164    
                          ENDP


                          AREA ||i.vMBPortSerialEnable||, CODE, READONLY, ALIGN=2

                  weaksMBSerialEnableWarning                  ; Alternate entry point
                  vMBPortSerialEnable PROC
;;;105        
;;;106    __STATIC_INLINE void weaksMBSerialEnableWarning(BOOL xRxEnable, BOOL xTxEnable) {
;;;107        DBG_NOR("PLS rewrite the vMBPortSerialEnable() function\r\n");
;;;108    }
;;;109    
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  a002              ADR      r0,|L6.16|
000008  f7fffffe          BL       __2printf
00000c  bd70              POP      {r4-r6,pc}
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
000010  504c5320          DCB      "PLS rewrite the vMBPortSerialEnable() function\r\n",0
000014  72657772
000018  69746520
00001c  74686520
000020  764d4250
000024  6f727453
000028  65726961
00002c  6c456e61
000030  626c6528
000034  29206675
000038  6e637469
00003c  6f6e0d0a
000040  00      
000041  00                DCB      0
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.vMBPortTimersDisable||, CODE, READONLY, ALIGN=2

                  weaksMBPortTimersDisableWarning                  ; Alternate entry point
                  vMBPortTimersDisable PROC
;;;159    
;;;160    __STATIC_INLINE void weaksMBPortTimersDisableWarning(void) {
;;;161        DBG_NOR("PLS rewrite the vMBPortTimersDisable() function\r\n");
;;;162    }
;;;163    
000000  b510              PUSH     {r4,lr}
000002  a002              ADR      r0,|L7.12|
000004  f7fffffe          BL       __2printf
000008  bd10              POP      {r4,pc}
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
00000c  504c5320          DCB      "PLS rewrite the vMBPortTimersDisable() function\r\n",0
000010  72657772
000014  69746520
000018  74686520
00001c  764d4250
000020  6f727454
000024  696d6572
000028  73446973
00002c  61626c65
000030  28292066
000034  756e6374
000038  696f6e0d
00003c  0a00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.vMBPortTimersEnable||, CODE, READONLY, ALIGN=2

                  weaksMBPortTimersEnableWarning                  ; Alternate entry point
                  vMBPortTimersEnable PROC
;;;155    
;;;156    __STATIC_INLINE void weaksMBPortTimersEnableWarning(void) {
;;;157        DBG_NOR("PLS rewrite the vMBPortTimersEnable() function\r\n");
;;;158    }
;;;159    
000000  b510              PUSH     {r4,lr}
000002  a002              ADR      r0,|L8.12|
000004  f7fffffe          BL       __2printf
000008  bd10              POP      {r4,pc}
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
00000c  504c5320          DCB      "PLS rewrite the vMBPortTimersEnable() function\r\n",0
000010  72657772
000014  69746520
000018  74686520
00001c  764d4250
000020  6f727454
000024  696d6572
000028  73456e61
00002c  626c6528
000030  29206675
000034  6e637469
000038  6f6e0d0a
00003c  00      
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.xMBPortSerialGetByte||, CODE, READONLY, ALIGN=2

                  weaksMBSerialGetByteWarning                  ; Alternate entry point
                  xMBPortSerialGetByte PROC
;;;120    
;;;121    __STATIC_INLINE BOOL weaksMBSerialGetByteWarning( CHAR * pucByte ) {
;;;122        DBG_NOR("PLS rewrite the xMBPortSerialGetByte() function\r\n");
;;;123        return false;
;;;124    }
;;;125    
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  a002              ADR      r0,|L9.16|
000006  f7fffffe          BL       __2printf
00000a  2000              MOVS     r0,#0
00000c  bd10              POP      {r4,pc}
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
000010  504c5320          DCB      "PLS rewrite the xMBPortSerialGetByte() function\r\n",0
000014  72657772
000018  69746520
00001c  74686520
000020  784d4250
000024  6f727453
000028  65726961
00002c  6c476574
000030  42797465
000034  28292066
000038  756e6374
00003c  696f6e0d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.xMBPortSerialInit||, CODE, READONLY, ALIGN=2

                  weaksMBSerialInitWarning                  ; Alternate entry point
                  xMBPortSerialInit PROC
;;;109    
;;;110    __STATIC_INLINE BOOL weaksMBSerialInitWarning( UCHAR ucPort, ULONG ulBaudRate,
;;;111                                       UCHAR ucDataBits, eMBParity eParity ) {
;;;112        DBG_NOR("PLS rewrite the xMBPortSerialInit() function\r\n");
;;;113        return false;
;;;114    }
;;;115    
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  a002              ADR      r0,|L10.24|
00000e  f7fffffe          BL       __2printf
000012  2000              MOVS     r0,#0
000014  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L10.24|
000018  504c5320          DCB      "PLS rewrite the xMBPortSerialInit() function\r\n",0
00001c  72657772
000020  69746520
000024  74686520
000028  784d4250
00002c  6f727453
000030  65726961
000034  6c496e69
000038  74282920
00003c  66756e63
000040  74696f6e
000044  0d0a00  
000047  00                DCB      0

                          AREA ||i.xMBPortSerialPutByte||, CODE, READONLY, ALIGN=2

                  weaksMBSerialPutByteWarning                  ; Alternate entry point
                  xMBPortSerialPutByte PROC
;;;115    
;;;116    __STATIC_INLINE BOOL weaksMBSerialPutByteWarning( CHAR ucByte ) {
;;;117        DBG_NOR("PLS rewrite the xMBPortSerialPutByte() function\r\n");
;;;118        return false;
;;;119    }
;;;120    
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  a002              ADR      r0,|L11.16|
000006  f7fffffe          BL       __2printf
00000a  2000              MOVS     r0,#0
00000c  bd10              POP      {r4,pc}
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
000010  504c5320          DCB      "PLS rewrite the xMBPortSerialPutByte() function\r\n",0
000014  72657772
000018  69746520
00001c  74686520
000020  784d4250
000024  6f727453
000028  65726961
00002c  6c507574
000030  42797465
000034  28292066
000038  756e6374
00003c  696f6e0d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.xMBPortTimersInit||, CODE, READONLY, ALIGN=2

                  weaksMBPortTimersInitWarning                  ; Alternate entry point
                  xMBPortTimersInit PROC
;;;150    
;;;151    __STATIC_INLINE BOOL weaksMBPortTimersInitWarning( USHORT usTim1Timerout50us ) {
;;;152        DBG_NOR("PLS rewrite the xMBPortTimersInit() function\r\n");
;;;153        return false;
;;;154    }
;;;155    
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  a002              ADR      r0,|L12.16|
000006  f7fffffe          BL       __2printf
00000a  2000              MOVS     r0,#0
00000c  bd10              POP      {r4,pc}
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
000010  504c5320          DCB      "PLS rewrite the xMBPortTimersInit() function\r\n",0
000014  72657772
000018  69746520
00001c  74686520
000020  784d4250
000024  6f727454
000028  696d6572
00002c  73496e69
000030  74282920
000034  66756e63
000038  74696f6e
00003c  0d0a00  
00003f  00                DCB      0

                          AREA ||i.xMBRTUReceiveFSM||, CODE, READONLY, ALIGN=2

                  xMBRTUReceiveFSM PROC
;;;240    BOOL
;;;241    xMBRTUReceiveFSM( void )
000000  b538              PUSH     {r3-r5,lr}
;;;242    {
;;;243        BOOL            xTaskNeedSwitch = FALSE;
000002  2400              MOVS     r4,#0
;;;244        UCHAR           ucByte;
;;;245    
;;;246        TX_ASSERT( eSndState == STATE_TX_IDLE );
000004  4821              LDR      r0,|L13.140|
000006  7800              LDRB     r0,[r0,#0]  ; eSndState
000008  b900              CBNZ     r0,|L13.12|
00000a  e003              B        |L13.20|
                  |L13.12|
00000c  21f6              MOVS     r1,#0xf6
00000e  a020              ADR      r0,|L13.144|
000010  f7fffffe          BL       tx_assert_false
                  |L13.20|
;;;247    
;;;248        /* Always read the character. */
;;;249        ( void )xMBPortSerialGetByte( ( CHAR * ) & ucByte );
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       xMBPortSerialGetByte
;;;250    
;;;251        switch ( eRcvState )
00001a  482c              LDR      r0,|L13.204|
00001c  7800              LDRB     r0,[r0,#0]  ; eRcvState
00001e  b130              CBZ      r0,|L13.46|
000020  2801              CMP      r0,#1
000022  d00a              BEQ      |L13.58|
000024  2802              CMP      r0,#2
000026  d019              BEQ      |L13.92|
000028  2803              CMP      r0,#3
00002a  d12b              BNE      |L13.132|
00002c  e002              B        |L13.52|
                  |L13.46|
;;;252        {
;;;253            /* If we have received a character in the init state we have to
;;;254             * wait until the frame is finished.
;;;255             */
;;;256        case STATE_RX_INIT:
;;;257            vMBPortTimersEnable(  );
00002e  f7fffffe          BL       vMBPortTimersEnable
;;;258            break;
000032  e027              B        |L13.132|
                  |L13.52|
;;;259    
;;;260            /* In the error state we wait until all characters in the
;;;261             * damaged frame are transmitted.
;;;262             */
;;;263        case STATE_RX_ERROR:
;;;264            vMBPortTimersEnable(  );
000034  f7fffffe          BL       vMBPortTimersEnable
;;;265            break;
000038  e024              B        |L13.132|
                  |L13.58|
;;;266    
;;;267            /* In the idle state we wait for a new character. If a character
;;;268             * is received the t1.5 and t3.5 timers are started and the
;;;269             * receiver is in the state STATE_RX_RECEIVCE.
;;;270             */
;;;271        case STATE_RX_IDLE:
;;;272            usRcvBufferPos = 0;
00003a  2000              MOVS     r0,#0
00003c  4924              LDR      r1,|L13.208|
00003e  8008              STRH     r0,[r1,#0]
;;;273            ucRTUBuf[usRcvBufferPos++] = ucByte;
000040  f89d2000          LDRB     r2,[sp,#0]
000044  8808              LDRH     r0,[r1,#0]  ; usRcvBufferPos
000046  1c41              ADDS     r1,r0,#1
000048  4b21              LDR      r3,|L13.208|
00004a  8019              STRH     r1,[r3,#0]
00004c  4921              LDR      r1,|L13.212|
00004e  540a              STRB     r2,[r1,r0]
;;;274            eRcvState = STATE_RX_RCV;
000050  2002              MOVS     r0,#2
000052  491e              LDR      r1,|L13.204|
000054  7008              STRB     r0,[r1,#0]
;;;275    
;;;276            /* Enable t3.5 timers. */
;;;277            vMBPortTimersEnable(  );
000056  f7fffffe          BL       vMBPortTimersEnable
;;;278            break;
00005a  e013              B        |L13.132|
                  |L13.92|
;;;279    
;;;280            /* We are currently receiving a frame. Reset the timer after
;;;281             * every character received. If more than the maximum possible
;;;282             * number of bytes in a modbus frame is received the frame is
;;;283             * ignored.
;;;284             */
;;;285        case STATE_RX_RCV:
;;;286            if( usRcvBufferPos < MB_SER_PDU_SIZE_MAX )
00005c  481c              LDR      r0,|L13.208|
00005e  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
000060  28ff              CMP      r0,#0xff
000062  dc09              BGT      |L13.120|
;;;287            {
;;;288                ucRTUBuf[usRcvBufferPos++] = ucByte;
000064  f89d2000          LDRB     r2,[sp,#0]
000068  4919              LDR      r1,|L13.208|
00006a  8808              LDRH     r0,[r1,#0]  ; usRcvBufferPos
00006c  1c41              ADDS     r1,r0,#1
00006e  4b18              LDR      r3,|L13.208|
000070  8019              STRH     r1,[r3,#0]
000072  4918              LDR      r1,|L13.212|
000074  540a              STRB     r2,[r1,r0]
000076  e002              B        |L13.126|
                  |L13.120|
;;;289            }
;;;290            else
;;;291            {
;;;292                eRcvState = STATE_RX_ERROR;
000078  2003              MOVS     r0,#3
00007a  4914              LDR      r1,|L13.204|
00007c  7008              STRB     r0,[r1,#0]
                  |L13.126|
;;;293            }
;;;294            vMBPortTimersEnable(  );
00007e  f7fffffe          BL       vMBPortTimersEnable
;;;295            break;
000082  bf00              NOP      
                  |L13.132|
000084  bf00              NOP                            ;258
;;;296        }
;;;297        return xTaskNeedSwitch;
000086  4620              MOV      r0,r4
;;;298    }
000088  bd38              POP      {r3-r5,pc}
;;;299    
                          ENDP

00008a  0000              DCW      0x0000
                  |L13.140|
                          DCD      eSndState
                  |L13.144|
000090  2e2e5c2e          DCB      "..\\..\\..\\..\\Libraries\\Protocol\\Modbus\\Trans_mode"
000094  2e5c2e2e
000098  5c2e2e5c
00009c  4c696272
0000a0  61726965
0000a4  735c5072
0000a8  6f746f63
0000ac  6f6c5c4d
0000b0  6f646275
0000b4  735c5472
0000b8  616e735f
0000bc  6d6f6465
0000c0  5c6d6272          DCB      "\\mbrtu.c",0
0000c4  74752e63
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L13.204|
                          DCD      eRcvState
                  |L13.208|
                          DCD      usRcvBufferPos
                  |L13.212|
                          DCD      ucRTUBuf

                          AREA ||i.xMBRTUTimerT35Expired||, CODE, READONLY, ALIGN=2

                  xMBRTUTimerT35Expired PROC
;;;338    BOOL
;;;339    xMBRTUTimerT35Expired( void )
000000  b510              PUSH     {r4,lr}
;;;340    {
;;;341        BOOL            xNeedPoll = FALSE;
000002  2400              MOVS     r4,#0
;;;342    
;;;343        switch ( eRcvState )
000004  4816              LDR      r0,|L14.96|
000006  7800              LDRB     r0,[r0,#0]  ; eRcvState
000008  b120              CBZ      r0,|L14.20|
00000a  2802              CMP      r0,#2
00000c  d007              BEQ      |L14.30|
00000e  2803              CMP      r0,#3
000010  d10b              BNE      |L14.42|
000012  e009              B        |L14.40|
                  |L14.20|
;;;344        {
;;;345            /* Timer t35 expired. Startup phase is finished. */
;;;346        case STATE_RX_INIT:
;;;347            xNeedPoll = xMBPortEventPost( EV_READY );
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       xMBPortEventPost
00001a  4604              MOV      r4,r0
;;;348            break;
00001c  e017              B        |L14.78|
                  |L14.30|
;;;349    
;;;350            /* A frame was received and t35 expired. Notify the listener that
;;;351             * a new frame was received. */
;;;352        case STATE_RX_RCV:
;;;353            xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       xMBPortEventPost
000024  4604              MOV      r4,r0
;;;354            break;
000026  e012              B        |L14.78|
                  |L14.40|
;;;355    
;;;356            /* An error occured while receiving the frame. */
;;;357        case STATE_RX_ERROR:
;;;358            break;
000028  e011              B        |L14.78|
                  |L14.42|
;;;359    
;;;360            /* Function called in an illegal state. */
;;;361        default:
;;;362            TX_ASSERT( ( eRcvState == STATE_RX_INIT ) ||
00002a  480d              LDR      r0,|L14.96|
00002c  7800              LDRB     r0,[r0,#0]  ; eRcvState
00002e  b138              CBZ      r0,|L14.64|
000030  480b              LDR      r0,|L14.96|
000032  7800              LDRB     r0,[r0,#0]  ; eRcvState
000034  2802              CMP      r0,#2
000036  d003              BEQ      |L14.64|
000038  4809              LDR      r0,|L14.96|
00003a  7800              LDRB     r0,[r0,#0]  ; eRcvState
00003c  2803              CMP      r0,#3
00003e  d100              BNE      |L14.66|
                  |L14.64|
000040  e004              B        |L14.76|
                  |L14.66|
000042  f44f71b5          MOV      r1,#0x16a
000046  a007              ADR      r0,|L14.100|
000048  f7fffffe          BL       tx_assert_false
                  |L14.76|
;;;363                    ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
;;;364    				break;
00004c  bf00              NOP      
                  |L14.78|
00004e  bf00              NOP                            ;348
;;;365        }
;;;366    
;;;367        vMBPortTimersDisable(  );
000050  f7fffffe          BL       vMBPortTimersDisable
;;;368        eRcvState = STATE_RX_IDLE;
000054  2001              MOVS     r0,#1
000056  4902              LDR      r1,|L14.96|
000058  7008              STRB     r0,[r1,#0]
;;;369    
;;;370        return xNeedPoll;
00005a  4620              MOV      r0,r4
;;;371    }
00005c  bd10              POP      {r4,pc}
                          ENDP

00005e  0000              DCW      0x0000
                  |L14.96|
                          DCD      eRcvState
                  |L14.100|
000064  2e2e5c2e          DCB      "..\\..\\..\\..\\Libraries\\Protocol\\Modbus\\Trans_mode"
000068  2e5c2e2e
00006c  5c2e2e5c
000070  4c696272
000074  61726965
000078  735c5072
00007c  6f746f63
000080  6f6c5c4d
000084  6f646275
000088  735c5472
00008c  616e735f
000090  6d6f6465
000094  5c6d6272          DCB      "\\mbrtu.c",0
000098  74752e63
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.xMBRTUTransmitFSM||, CODE, READONLY, ALIGN=2

                  xMBRTUTransmitFSM PROC
;;;300    BOOL
;;;301    xMBRTUTransmitFSM( void )
000000  b510              PUSH     {r4,lr}
;;;302    {
;;;303        BOOL            xNeedPoll = FALSE;
000002  2400              MOVS     r4,#0
;;;304    
;;;305        TX_ASSERT( eRcvState == STATE_RX_IDLE );
000004  481b              LDR      r0,|L15.116|
000006  7800              LDRB     r0,[r0,#0]  ; eRcvState
000008  2801              CMP      r0,#1
00000a  d100              BNE      |L15.14|
00000c  e004              B        |L15.24|
                  |L15.14|
00000e  f2401131          MOV      r1,#0x131
000012  a019              ADR      r0,|L15.120|
000014  f7fffffe          BL       tx_assert_false
                  |L15.24|
;;;306    
;;;307        switch ( eSndState )
000018  4826              LDR      r0,|L15.180|
00001a  7800              LDRB     r0,[r0,#0]  ; eSndState
00001c  b110              CBZ      r0,|L15.36|
00001e  2801              CMP      r0,#1
000020  d124              BNE      |L15.108|
000022  e004              B        |L15.46|
                  |L15.36|
;;;308        {
;;;309            /* We should not get a transmitter event if the transmitter is in
;;;310             * idle state.  */
;;;311        case STATE_TX_IDLE:
;;;312            /* enable receiver/disable transmitter. */
;;;313            vMBPortSerialEnable( TRUE, FALSE );
000024  2100              MOVS     r1,#0
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       vMBPortSerialEnable
;;;314            break;
00002c  e01e              B        |L15.108|
                  |L15.46|
;;;315    
;;;316        case STATE_TX_XMIT:
;;;317            /* check if we are finished. */
;;;318            if( usSndBufferCount != 0 )
00002e  4822              LDR      r0,|L15.184|
000030  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
000032  b178              CBZ      r0,|L15.84|
;;;319            {
;;;320                xMBPortSerialPutByte( ( CHAR )*pucSndBufferCur );
000034  4921              LDR      r1,|L15.188|
000036  6809              LDR      r1,[r1,#0]  ; pucSndBufferCur
000038  7808              LDRB     r0,[r1,#0]
00003a  f7fffffe          BL       xMBPortSerialPutByte
;;;321                pucSndBufferCur++;  /* next byte in sendbuffer. */
00003e  481f              LDR      r0,|L15.188|
000040  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
000042  1c40              ADDS     r0,r0,#1
000044  491d              LDR      r1,|L15.188|
000046  6008              STR      r0,[r1,#0]  ; pucSndBufferCur
;;;322                usSndBufferCount--;
000048  481b              LDR      r0,|L15.184|
00004a  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
00004c  1e40              SUBS     r0,r0,#1
00004e  491a              LDR      r1,|L15.184|
000050  8008              STRH     r0,[r1,#0]
000052  e00a              B        |L15.106|
                  |L15.84|
;;;323            }
;;;324            else
;;;325            {
;;;326                xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
000054  2003              MOVS     r0,#3
000056  f7fffffe          BL       xMBPortEventPost
00005a  4604              MOV      r4,r0
;;;327                /* Disable transmitter. This prevents another transmit buffer
;;;328                 * empty interrupt. */
;;;329                vMBPortSerialEnable( TRUE, FALSE );
00005c  2100              MOVS     r1,#0
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       vMBPortSerialEnable
;;;330                eSndState = STATE_TX_IDLE;
000064  2000              MOVS     r0,#0
000066  4913              LDR      r1,|L15.180|
000068  7008              STRB     r0,[r1,#0]
                  |L15.106|
;;;331            }
;;;332            break;
00006a  bf00              NOP      
                  |L15.108|
00006c  bf00              NOP                            ;314
;;;333        }
;;;334    
;;;335        return xNeedPoll;
00006e  4620              MOV      r0,r4
;;;336    }
000070  bd10              POP      {r4,pc}
;;;337    
                          ENDP

000072  0000              DCW      0x0000
                  |L15.116|
                          DCD      eRcvState
                  |L15.120|
000078  2e2e5c2e          DCB      "..\\..\\..\\..\\Libraries\\Protocol\\Modbus\\Trans_mode"
00007c  2e5c2e2e
000080  5c2e2e5c
000084  4c696272
000088  61726965
00008c  735c5072
000090  6f746f63
000094  6f6c5c4d
000098  6f646275
00009c  735c5472
0000a0  616e735f
0000a4  6d6f6465
0000a8  5c6d6272          DCB      "\\mbrtu.c",0
0000ac  74752e63
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L15.180|
                          DCD      eSndState
                  |L15.184|
                          DCD      usSndBufferCount
                  |L15.188|
                          DCD      pucSndBufferCur

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucRTUBuf
                          %        256

                          AREA ||.data||, DATA, ALIGN=2

                  eSndState
000000  00                DCB      0x00
                  eRcvState
000001  000000            DCB      0x00,0x00,0x00
                  pucSndBufferCur
                          DCD      0x00000000
                  usSndBufferCount
000008  0000              DCB      0x00,0x00
                  usRcvBufferPos
00000a  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Libraries\\Protocol\\Modbus\\Trans_mode\\mbrtu.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_mbrtu_c_0485e010____REV16|
#line 459 "..\\..\\..\\..\\Libraries\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___7_mbrtu_c_0485e010____REV16| PROC
#line 460

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_mbrtu_c_0485e010____REVSH|
#line 474
|__asm___7_mbrtu_c_0485e010____REVSH| PROC
#line 475

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_mbrtu_c_0485e010____RRX|
#line 661
|__asm___7_mbrtu_c_0485e010____RRX| PROC
#line 662

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
